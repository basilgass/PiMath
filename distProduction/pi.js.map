{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/maths/coefficients/fraction.ts","webpack:///./src/maths/numeric.ts","webpack:///./src/maths/algebra/polynom.ts","webpack:///./src/maths/algebra/equation.ts","webpack:///./src/maths/geometry/vector.ts","webpack:///./src/maths/geometry/point.ts","webpack:///./src/maths/coefficients/nthroot.ts","webpack:///./src/maths/algebra/monom.ts","webpack:///./src/maths/geometry/line.ts","webpack:///./src/main.ts","webpack:///./src/maths/shutingyard.ts","webpack:///./src/maths/algebra/linearSystem.ts","webpack:///./src/maths/algebra/rational.ts","webpack:///./src/maths/geometry/triangle.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Fraction","denominatorOrPeriodic","parse","S","this","_numerator","_denominator","split","length","NaN","Number","isSafeInteger","undefined","toString","Math","pow","floor","denominator","isFraction","numerator","clone","F","zero","one","infinite","Infinity","invalid","opposed","add","N","D","reduce","subtract","multiply","Q","divide","invert","abs","root","sqrt","g","Numeric","gcd","amplify","k","compare","sign","lesser","than","leq","greater","geq","isEqual","isDifferent","isOpposed","isInverted","isZero","isOne","isPositive","isNegative","isNaN","isInfinity","isFinite","isSquare","areEquals","tex","replace","decimals","round","nb","primes","slice","max","maxV","push","sort","a","b","values","gcd2","percent","random","randomInt","randomBool","Polynom","polynomString","genDisplay","output","forceSign","wrapParentheses","P","_monoms","coefficient","display","inputStr","_rawString","shutingYardToReducedPolynom","test","empty","fractions","map","x","letters","Monom","literalStr","SY","Shutingyard","rpn","m1","m2","tokenParam","token","isOperation","pop","parseInt","console","log","monoms","M","_randomizeDefaults","degree","unit","factorable","allowNullMonom","numberOfMonoms","randomize","config","rndSimple","withFraction","allowZero","reorder","splice","rndFactorable","_factors","factorUnit","isPolynom","concat","isMonom","multiplyByPolynom","multiplyByFraction","multiplyByMonom","multiplyByInteger","xmultiply","euclidian","quotient","reminder","maxMP","monomByDegree","newM","divideByFraction","divideByInteger","nbF","cP1","cP2","isSameAs","isOpposedAt","j","filter","letter","Set","variables","replaceBy","resultPolynom","literal","evaluate","forEach","monom","derivative","dP","factorize","maxValue","nbFactorsFound","commonMonom","commonPolynom","getZeroes","zeroes","zeroesAsTex","A","B","C","x1","x2","toFixed","z","indexOf","frac","monomByLetter","hasLetter","getDenominators","denominators","getNumerators","numerators","lcmDenominator","lcm","gcdDenominator","lcmNumerator","gcdNumerator","L","setLetter","min","makeItComplicate","complexity","_texString","mDegree","factorizePartial","texString","mMain","mCheck","mFactor","pFactor","minify","canDivide","evalValue","V","Equation","equations","_varnothing","_real","equationString","pStr","strSign","_findSign","_formatSign","includes","signStr","_reverseSign","_sign","left","right","_left","_right","opts","allLeft","mMove","simplify","isolate","isMultiVariable","cMove","solve","_solutions","_polynom","_solveDegree1","_solveDegree2","_solveDegree3plus","isGreater","isStrictEqual","isAlsoEqual","m0","v","delta","nthDelta","realX1","realX2","sX1","sX2","aF","bF","cF","Nthroot","hasRadical","dfrac","isEquation","join","signAsTex","raw","Vector","isVector","_parseString","isPoint","_x","_y","y","reset","components","scalarProductWithVector","normal","isNormalTo","angleWith","sharp","radian","scalar","toDegree","PI","acos","norm","normSquare","scalarProduct","v1","v2","Point","origin","middleOf","P1","P2","pts","pmatrix","radical","nthroot","_coefficient","_nth","_radical","_isValid","trim","_literal","clean","randomIntSym","M1","M2","K","item","dM","areSameAs","matchAll","keys","coeffN","coeffD","parseByCoefficient","parseByPointAndVector","equ","has","elem","delete","size","_a","_b","_c","_d","_OA","_n","isParellelTo","line","slope","height","simplifyDirection","intersection","Pt","isParallel","isSame","point","hasIntersection","canonical","mxh","OA","parametric","pt","d2","fraction","window","Pi","Root","LinearSystem","Rational","Geometry","Line","Triangle","_rpn","match","expr","start","tokenMatch","tokenType","substr","expr2","outQueue","opStack","precedence","associative","tokenPos","Uniformizer","securityLoopLvl2","securityLoopLvl1","NextToken","opTop","reverse","equationStrings","_equations","_findLetters","setCoefficient","coefficients","_letters","setLetters","generate","solutions","solutionsF","_generateOneEquation","coeff","leftValue","equString","_checkIfLinerCombination","mergeEquations","eq1","eq2","factor1","factor2","eq1multiplied","eq2multiplied","E","_resolutionSteps","_solveOneLetter","str","equStr","LS","equArray","repeat","isReal","isVarnothing","c1","c2","LE","reducedEquations","_linearReduction","_A","_B","_C","isTriangle","_updateTriangle","_lines","_middles","_remarquables","_calculateRemarquableLines","getPointByName","ptName","toUpperCase","getSegment","ptName1","ptName2","barycenter","AB","AC","BC","remarquables","medianes","mediators","heights"],"mappings":"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KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,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","file":"pi.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n","import {Numeric} from \"../numeric\";\r\n\r\nexport class Fraction {\r\n    private _numerator: number;\r\n    private _denominator: number;\r\n\r\n    constructor(value?: any, denominatorOrPeriodic?: number) {\r\n        this._numerator = 1;\r\n        this._denominator = 1;\r\n\r\n        if (value !== undefined) {\r\n            this.parse(value, denominatorOrPeriodic);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    get isFraction() {\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n\r\n    get numerator(): number {\r\n        return this._numerator;\r\n    }\r\n\r\n    set numerator(value: number) {\r\n        this._numerator = value;\r\n    }\r\n\r\n    get denominator(): number {\r\n        return this._denominator;\r\n    }\r\n\r\n    set denominator(value: number) {\r\n        this._denominator = value;\r\n    }\r\n\r\n    get value(): number {\r\n        return this._numerator / this._denominator;\r\n    }\r\n\r\n    // Display getter\r\n    get tex(): string {\r\n        if (this._denominator === 1) {\r\n            return `${this._numerator}`;\r\n        } else if (this._numerator < 0) {\r\n            return `-\\\\frac{ ${-this._numerator} }{ ${this._denominator} }`;\r\n        } else {\r\n            return `\\\\frac{ ${this._numerator} }{ ${this._denominator} }`;\r\n        }\r\n    }\r\n\r\n    get display(): string {\r\n        if (this._denominator === 1) {\r\n            return `${this._numerator}`;\r\n        } else {\r\n            return `${this._numerator}/${this._denominator}`;\r\n        }\r\n    }\r\n\r\n    // Helper function to display fractions\r\n    get frac(): string {\r\n        return this.tex;\r\n    }\r\n\r\n    get dfrac(): string {\r\n        return this.tex.replace('\\\\frac', '\\\\dfrac');\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse the value to get the numerator and denominator\r\n     * @param value : number or string to parse to get the fraction\r\n     * @param denominatorOrPeriodic (optional|number) : length of the periodic part: 2.333333 => 1 or denominator value\r\n     */\r\n    parse = (value: any, denominatorOrPeriodic?: number): Fraction => {\r\n        let S: string[];\r\n\r\n        // A null value means a zero fraction.\r\n        if (value === null) {\r\n            this._numerator = 0;\r\n            this._denominator = 1;\r\n            return this;\r\n        }\r\n\r\n        switch (typeof value) {\r\n            case \"string\":\r\n                // Split the sting value in two parts: Numerator/Denominator\r\n                S = value.split('/');\r\n\r\n                if (S.length === 1) {\r\n                    // No divide sign\r\n                    return this.parse(+S[0]);\r\n                } else if (S.length === 2) {\r\n                    // One divide signe\r\n                    // We check if the denominator is zero\r\n                    if (S[1] === '0') {\r\n                        this._numerator = NaN;\r\n                        this._denominator = 1;\r\n                    } else {\r\n                        this._numerator = +S[0];\r\n                        this._denominator = +S[1];\r\n                    }\r\n                } else {\r\n                    // More than one divide sign ?\r\n                    this._numerator = NaN;\r\n                    this._denominator = 1;\r\n                }\r\n                break;\r\n            case \"number\":\r\n                if (Number.isSafeInteger(value)) {\r\n                    // The given value is an integer\r\n                    this._numerator = +value;\r\n\r\n                    if (denominatorOrPeriodic === undefined || !Number.isSafeInteger(denominatorOrPeriodic)) {\r\n                        this._denominator = 1;\r\n                    } else {\r\n                        this._denominator = +denominatorOrPeriodic;\r\n                    }\r\n                } else {\r\n                    // The given value is a float number\r\n\r\n                    // Get the number of decimals after the float sign\r\n                    let p: number = (value.toString()).split('.')[1].length;\r\n\r\n                    // Transform the float number in two integer\r\n                    if (denominatorOrPeriodic === undefined) {\r\n                        this._numerator = value * Math.pow(10, p);\r\n                        this._denominator = Math.pow(10, p);\r\n                    } else if (Number.isSafeInteger(denominatorOrPeriodic)) {\r\n                        this._numerator = value * Math.pow(10, p) - Math.floor(value * Math.pow(10, p - denominatorOrPeriodic));\r\n                        this.denominator = Math.pow(10, p) - Math.pow(10, p - denominatorOrPeriodic)\r\n                    }\r\n                }\r\n                break;\r\n            case \"object\":\r\n                if (value.isFraction) {\r\n                    this._numerator = +value.numerator;\r\n                    this._denominator = +value.denominator;\r\n                }\r\n                break;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    clone = (): Fraction => {\r\n        let F = new Fraction();\r\n        F.numerator = +this._numerator;\r\n        F.denominator = +this._denominator;\r\n        return F;\r\n    };\r\n\r\n    zero = (): Fraction => {\r\n        this._numerator = 0;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    one = (): Fraction => {\r\n        this._numerator = 1;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    infinite = (): Fraction => {\r\n        this._numerator = Infinity;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    invalid = (): Fraction => {\r\n        this._numerator = NaN;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    opposed = (): Fraction => {\r\n        this._numerator = -this._numerator;\r\n        return this;\r\n    };\r\n\r\n    add = (F: Fraction): Fraction => {\r\n        let N: number = this._numerator,\r\n            D: number = this._denominator;\r\n\r\n        this._numerator = N * F.denominator + F.numerator * D;\r\n        this._denominator = D * F.denominator;\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    subtract = (F: Fraction): Fraction => {\r\n        return this.add(F.clone().opposed());\r\n    };\r\n\r\n    multiply = (F: Fraction | number): Fraction => {\r\n        // Parse the value.\r\n        // If it's a fraction, return a clone of it\r\n        // If it's an integer, return the fraction F/1\r\n        let Q = new Fraction(F);\r\n\r\n        this._numerator = this._numerator * Q.numerator;\r\n        this._denominator = this._denominator * Q.denominator;\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    divide = (F: Fraction | number): Fraction => {\r\n        let Q = new Fraction(F);\r\n\r\n        if (Q.numerator === 0) {\r\n            return new Fraction().infinite();\r\n        }\r\n\r\n        let N: number = +this._numerator,\r\n            D: number = +this._denominator;\r\n\r\n        this._numerator = N * Q.denominator;\r\n        this._denominator = D * Q.numerator;\r\n        return this.reduce();\r\n    };\r\n\r\n    invert = (): Fraction => {\r\n        let n = +this._numerator, d = +this._denominator;\r\n        this._numerator = d;\r\n        this._denominator = n;\r\n\r\n        return this;\r\n    }\r\n    pow = (p: number): Fraction => {\r\n        if (!Number.isSafeInteger(p)) {\r\n            return this.invalid();\r\n        }\r\n        this.reduce();\r\n\r\n        if (p < 0) {\r\n            this.invert()\r\n        }\r\n\r\n        this._numerator = this._numerator ** Math.abs(p);\r\n        this._denominator = this._denominator ** Math.abs(p);\r\n        return this;\r\n    };\r\n\r\n    root = (p: number): Fraction => {\r\n        // TODO: nth - root of a fraction => this will return another type of coefficient.\r\n\r\n        // Check if they are perfect roots..\r\n        if (p === 0) {\r\n            return this;\r\n        }\r\n\r\n        // If negative, invert the fraction\r\n        if (p < 0) {\r\n            this.invert()\r\n        }\r\n\r\n        let n = Math.pow(this._numerator, Math.abs(1 / p)),\r\n            d = Math.pow(this._denominator, Math.abs(1 / p));\r\n\r\n        this._numerator = Math.pow(this._numerator, Math.abs(1 / p));\r\n        this._denominator = Math.pow(this._denominator, Math.abs(1 / p));\r\n        return this;\r\n    }\r\n\r\n    sqrt = (): Fraction => {\r\n        return this.root(2);\r\n    }\r\n\r\n    abs = (): Fraction => {\r\n        this._numerator = Math.abs(this._numerator);\r\n        this._denominator = Math.abs(this._denominator);\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations specific to fractions\r\n    // ------------------------------------------\r\n    reduce = (): Fraction => {\r\n        let g = Numeric.gcd(this._numerator, this._denominator);\r\n        this._numerator = this._numerator / g;\r\n        this._denominator = this._denominator / g;\r\n\r\n        if (this._denominator < 0) {\r\n            this._denominator = -this._denominator;\r\n            this._numerator = -this._numerator;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    amplify = (k: number): Fraction => {\r\n        if (Number.isSafeInteger(k)) {\r\n            this._numerator *= k;\r\n            this._denominator *= k;\r\n        }\r\n        return this;\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Compare the current coefficient with another coefficient\r\n     * @param F (Coefficient) The coefficient to compare\r\n     * @param sign (string| default is =): authorized values: =, <, <=, >, >= with some variations.\r\n     */\r\n    compare = (F: Fraction, sign?: string): boolean => {\r\n        if (sign === undefined) {\r\n            sign = '=';\r\n        }\r\n\r\n\r\n        switch (sign) {\r\n            case '>':\r\n                return this.value > F.value;\r\n            case \">=\" || \"=>\" || \"geq\":\r\n                return this.value >= F.value;\r\n            case \"<\":\r\n                return this.value < F.value;\r\n            case \"<=\" || \"=>\" || \"leq\":\r\n                return this.value <= F.value;\r\n            case \"=\":\r\n                // let F2: Fraction = F.clone().reduce(),\r\n                //     F1: Fraction = this.clone().reduce();\r\n                // return (F1.numerator === F2.numerator && F1.denominator === F2.denominator);\r\n                return this.value === F.value;\r\n            case \"<>\":\r\n                return this.value !== F.value;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /* Compare shortcuts */\r\n    lesser = (than: Fraction): Boolean => {\r\n        return this.compare(than, '<');\r\n    };\r\n    leq = (than: Fraction): Boolean => {\r\n        return this.compare(than, '<=');\r\n    };\r\n    greater = (than: Fraction): Boolean => {\r\n        return this.compare(than, '>');\r\n    };\r\n    geq = (than: Fraction): Boolean => {\r\n        return this.compare(than, '>=');\r\n    };\r\n    isEqual = (than: Fraction): boolean => {\r\n        return this.compare(than, '=');\r\n    }\r\n    isDifferent = (than: Fraction): boolean => {\r\n        return this.compare(than, '<>');\r\n    }\r\n    isOpposed = (p: Fraction): boolean => {\r\n        return this.isEqual(p.clone().opposed());\r\n    }\r\n    isInverted = (p: Fraction): boolean => {\r\n        return this.isEqual(new Fraction().one().divide(p.clone()));\r\n    }\r\n    isZero = (): boolean => {\r\n        return this._numerator === 0;\r\n    }\r\n    isOne = (): boolean => {\r\n        return this._numerator === 1 && this._denominator === 1;\r\n    }\r\n    isPositive = (): boolean => {\r\n        return this.sign()===1;\r\n    }\r\n    isNegative = (): boolean => {\r\n        return this.sign()===-1;\r\n    }\r\n    isNaN = (): boolean => {\r\n        return isNaN(this._numerator);\r\n    }\r\n    isInfinity = (): boolean => {\r\n        return this._numerator === Infinity;\r\n    }\r\n    isFinite = (): boolean => {\r\n        return !this.isInfinity();\r\n    }\r\n    isSquare = (): boolean => {\r\n        return Math.sqrt(this._numerator) % 1 === 0 && Math.sqrt(this._denominator) % 1 === 0\r\n    }\r\n    sign = (): number => {\r\n        return (this._numerator * this._denominator >= 0) ? 1 : -1;\r\n    };\r\n\r\n\r\n    // TODO: The rest of the functions are not used or unnecessary ?\r\n    /**\r\n     * Simple function to determine if it's a fraction\r\n     */\r\n    areEquals = (...F: Fraction[]): boolean => {\r\n        for (let i = 0; i < F.length; i++) {\r\n            if (!this.isEqual(F[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n}","export class Numeric{\r\n    static round(value:number, decimals:number=2):number {\r\n        return Number(Math.round(Number(value+'e'+decimals))+'e-'+decimals);\r\n    }\r\n\r\n    /**\r\n     * Get the list of the nth first prime numbers.\r\n     * @param nb : number of primes to choose from\r\n     */\r\n    static prime(nb?:number):number[]{\r\n        let primes:number[] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973];\r\n        if(nb === undefined){\r\n            return primes;\r\n        }else{\r\n            return primes.slice(0,Math.max(primes.length,nb));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the list of all dividers of a number.\r\n     * @param value\r\n     */\r\n    static dividers(value:number):number[]{\r\n        let D: number[];\r\n        const maxV = Math.sqrt(value);\r\n\r\n        // Initialize the list of dividers.\r\n        D = [];\r\n\r\n        for(let i=1; i<maxV; i++){\r\n            if(value%i===0){\r\n                D.push(i);\r\n                D.push(value/i);\r\n            }\r\n        }\r\n\r\n        // Order numbers.\r\n        D.sort(function(a, b){return a-b;});\r\n        return D;\r\n    }\r\n    /**\r\n     * Great Common Divisor\r\n     * @param values : number values\r\n     */\r\n    static gcd(...values:number[]):number{\r\n        // Define the gcd for two number\r\n        let gcd2 = function(a:number,b:number):number{\r\n            if(b===0){return a;}\r\n            return gcd2(b, a%b);\r\n        };\r\n\r\n        let g:number = 1,\r\n            i:number = 2;\r\n\r\n        // Nothing is given\r\n        if(values.length===0){return 1;}\r\n        // Only one number is given\r\n        if(values.length===1){\r\n            // The first number is zero\r\n            if(values[0]===0){return 1;}\r\n            // Return the number\r\n            return values[0];\r\n        }\r\n\r\n        // We have at least 2 numbers.\r\n        g = gcd2(values[0],values[1]);\r\n\r\n        // The gcd of the two first value is one ? It's already finished.\r\n        if(g===1){return 1;}\r\n\r\n        // The current gcd isn't one. Continue with all next values.\r\n        for(i=2; i<values.length; i++){\r\n            g = gcd2(g, values[i]);\r\n            // Escape if gcd is already one.\r\n            if(g===1){break;}\r\n        }\r\n\r\n        return Math.abs(g);\r\n    }\r\n\r\n    /**\r\n     * Least Common Multiple\r\n     * @param values: list of numbers\r\n     */\r\n    static lcm(...values:number[]):number{\r\n        return values.reduce(function(a,b){\r\n            return Math.abs(a * b / Numeric.gcd(a, b));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Random boolean with a percent ratio\r\n     * @param percent\r\n     */\r\n    static randomBool(percent:number=0.5):boolean{\r\n        return Math.random()<percent;\r\n    }\r\n\r\n    /**\r\n     * Random integer between two values.\r\n     * @param a (number) : From this value to the second value. If the second is ommited, this value is the max value.\r\n     * @param b (number) : To this value. If this is ommited.\r\n     */\r\n    static randomInt(a:number, b?:number):number{\r\n        if(b===undefined){return Numeric.randomInt(0,a);}\r\n\r\n        return Math.floor(Math.random() * (b - a + 1) + a);\r\n    }\r\n\r\n    /**\r\n     * Random integer between -max and max value.\r\n     * @param max (number) : determine the limits.\r\n     * @param zero (bool) : determine if zero is allowed or not.\r\n     */\r\n    static randomIntSym(max:number, zero?:boolean):number{\r\n        if(zero===false){\r\n            return Numeric.randomBool()?this.randomInt(1,max):-this.randomInt(1,max);\r\n        }else{\r\n            return Numeric.randomInt(-max, max);\r\n        }\r\n    }\r\n}","/**\r\n * Polynom module contains everything necessary to handle polynoms.\r\n * @module Polynom\r\n */\r\n\r\nimport {Monom} from './monom';\r\nimport {Shutingyard} from '../shutingyard';\r\nimport {Numeric} from '../numeric';\r\nimport {Fraction} from '../coefficients/fraction';\r\n\r\n/**\r\n * Polynom class can handle polynoms, reorder, resolve, ...\r\n */\r\nexport class Polynom {\r\n    private _rawString: string;\r\n    private _monoms: Monom[];\r\n    private _factors: Polynom[];\r\n    private _texString: string;\r\n\r\n    /**\r\n     *\r\n     * @param {string} polynomString (optional) Default polynom to parse on class creation\r\n     */\r\n    constructor(polynomString?: string) {\r\n        this._monoms = [];\r\n        this._factors = [];\r\n        if (polynomString !== undefined) {\r\n            this.parse(polynomString);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    get isPolynom() {\r\n        return true;\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get monoms() {\r\n        return this._monoms;\r\n    }\r\n\r\n    set monoms(M: Monom[]) {\r\n        this._monoms = M;\r\n    }\r\n\r\n    get factors(): Polynom[] {\r\n        return this._factors;\r\n    }\r\n\r\n    set factors(value: Polynom[]) {\r\n        this._factors = value;\r\n    }\r\n\r\n    get texString(): string {\r\n        return this._texString;\r\n    }\r\n\r\n    get length() {\r\n        // TODO: Must reduce the monoms list to remove the zero coefficient.\r\n        return this._monoms.length;\r\n    }\r\n\r\n    get display(): string {\r\n        return this.genDisplay();\r\n    }\r\n\r\n    get raw(): string {\r\n        return this._rawString\r\n    }\r\n\r\n    get tex(): string {\r\n        return this.genDisplay('tex');\r\n    }\r\n\r\n    get isMultiVariable(): boolean {\r\n        const B = false;\r\n        for (const m of this._monoms) {\r\n            if (m.variables.length > 1) {\r\n                return true;\r\n            }\r\n        }\r\n        return B;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        let V: string[] = [];\r\n\r\n        for (const m of this._monoms) {\r\n            V = V.concat(m.variables);\r\n        }\r\n\r\n        // Remove duplicates.\r\n        V = [...new Set(V)];\r\n\r\n        return V;\r\n    }\r\n\r\n    get numberOfVars(): number {\r\n        return this.variables.length;\r\n    }\r\n\r\n    private genDisplay = (output?: string, forceSign?: boolean, wrapParentheses?: boolean): string => {\r\n        let P: string = '';\r\n\r\n        for (const k of this._monoms) {\r\n            if (k.coefficient.value === 0) {\r\n                continue;\r\n            }\r\n\r\n            P += `${(k.coefficient.sign() === 1 && (P !== '' || forceSign === true)) ? '+' : ''}${(output === 'tex') ? k.tex : k.display}`;\r\n        }\r\n\r\n        if (wrapParentheses === true && this.length > 1) {\r\n            if (output === 'tex') {\r\n                P = `\\\\left( ${P} \\\\right)`;\r\n            } else {\r\n                P = `(${P})`;\r\n            }\r\n        }\r\n\r\n        if (P === '') {\r\n            P = '0';\r\n        }\r\n        return P;\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse a string to a polynom.\r\n     * @param inputStr\r\n     * @param values: as string, numbers or fractions\r\n     */\r\n    parse = (inputStr: string, ...values: any[]): Polynom => {\r\n        if (values === undefined || values.length === 0) {\r\n            // Parse the polynom using the shuting yard algorithm\r\n\r\n            // TODO: handle if the inputstr is a number.\r\n            inputStr = ''+inputStr;\r\n\r\n            this._rawString = inputStr;\r\n\r\n            return this.shutingYardToReducedPolynom(inputStr);\r\n        } else if (/^[a-z]/.test(inputStr)) {\r\n            // We assume the inputStr contains only letters.\r\n            this.empty();\r\n\r\n            let fractions = values.map(x => new Fraction(x));\r\n            // Multiple setLetter version\r\n            if (inputStr.length > 1) {\r\n                // TODO: check that the number of values given correspond to the letters (+1 eventually)\r\n                let letters = inputStr.split(''),\r\n                    i = 0;\r\n                for (let F of fractions) {\r\n                    let m = new Monom();\r\n                    m.coefficient = F.clone();\r\n                    m.literalStr = letters[i] || '';\r\n                    this.add(m);\r\n                    i++;\r\n                }\r\n            }\r\n            // Single setLetter version\r\n            else {\r\n                let n = fractions.length - 1;\r\n                for (let F of fractions) {\r\n                    let m = new Monom()\r\n                    m.coefficient = F.clone();\r\n                    m.literalStr = `${inputStr}^${n}`\r\n                    this.add(m);\r\n                    n--;\r\n                }\r\n            }\r\n            return this;\r\n        } else {\r\n            return this.zero();\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * Main parse using a shutting yard class\r\n     * @param inputStr\r\n     */\r\n    private shutingYardToReducedPolynom = (inputStr: string): Polynom => {\r\n        // Get the RPN array of the current expression\r\n        const SY: Shutingyard = new Shutingyard().parse(inputStr);\r\n        const rpn: string[] = SY.rpn;\r\n        const m: Polynom[] = [];\r\n        let m1: Polynom;\r\n        let m2: Polynom;\r\n        let tokenParam: number = null;\r\n\r\n        for (const token of rpn) {\r\n            if (SY.isOperation(token)) {\r\n                // Polynom\r\n                m2 = (m.pop()) || new Polynom().zero();\r\n\r\n                if (m.length > 0) {\r\n                    // Get the first item from the stack\r\n                    m1 = (m.pop()) || new Polynom().zero();\r\n                } else {\r\n                    // Nothing is in the stack - create an empty polynom\r\n                    m1 = new Polynom().zero();\r\n                }\r\n\r\n                if (token[0] === '^') {\r\n                    tokenParam = parseInt(token.split('^')[1]);\r\n                }\r\n\r\n                switch (token) {\r\n                    case '+':\r\n                        m1.add(m2);\r\n                        break;\r\n                    case '-':\r\n                        m1.subtract(m2);\r\n                        break;\r\n                    case '*':\r\n                        m1.multiply(m2);\r\n                        break;\r\n                    // TODO: Shuting yard to polynom divide.\r\n                    // case '/': console.log(m1.display, m2.display);m1.divide(m2); break;\r\n                    // By default, all not operation value are converted to polynom. Therefore, the pow value must be converted to an integer.\r\n                    // TODO: Shuting yard to polynom pow : case '^': m1.pow(+m2.monoms[0].coefficient.numerator); break;\r\n                    default:\r\n                        if (tokenParam !== null) {\r\n                            if (token[0] === '^') {\r\n                                m1 = m2.clone().pow(tokenParam);\r\n                            }\r\n                        } else {\r\n                            console.log('Token not recognized in shuting yard to reduce polynom: ', token);\r\n                        }\r\n                }\r\n                m.push(m1);\r\n            } else {\r\n                m.push(new Polynom().add(new Monom(token)));\r\n            }\r\n        }\r\n\r\n        this._monoms = m[0].monoms;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clone the polynom\r\n     */\r\n    clone = (): Polynom => {\r\n        const P = new Polynom();\r\n        const M: Monom[] = [];\r\n\r\n        for (const m of this._monoms) {\r\n            M.push(m.clone());\r\n        }\r\n\r\n        P.monoms = M;\r\n        return P;\r\n    };\r\n\r\n    /**\r\n     * Set the polynom to zero.\r\n     * @returns {this}\r\n     */\r\n    zero = (): Polynom => {\r\n        this._monoms = [];\r\n        this._monoms.push(new Monom().zero());\r\n        this._rawString = '0';\r\n        return this;\r\n    };\r\n\r\n    one = (): Polynom => {\r\n        this._monoms = [];\r\n        this._monoms.push(new Monom().one());\r\n        this._rawString = '1';\r\n        return this;\r\n    }\r\n\r\n    empty = (): Polynom => {\r\n        this._monoms = [];\r\n        this._rawString = '';\r\n        return this;\r\n    };\r\n\r\n    // -----------------------------------------------\r\n    // Polynom generators and randomizers\r\n    // -----------------------------------------------\r\n    private _randomizeDefaults: { [key: string]: number | string | boolean } = {\r\n        degree: 2,\r\n        unit: true,\r\n        fractions: false,\r\n        factorable: false,\r\n        letters: 'x',\r\n        allowNullMonom: false,\r\n        numberOfMonoms: false\r\n    };\r\n    get randomizeDefaults(): { [key: string]: number | string | boolean } {\r\n        return this._randomizeDefaults;\r\n    }\r\n\r\n    set randomizeDefaults(value) {\r\n        this._randomizeDefaults = value;\r\n    }\r\n\r\n    randomize = (config: { [key: string]: number | string | boolean }): Polynom => {\r\n        let P = new Polynom();\r\n\r\n        // Check the config file and use the default values.\r\n        if (config === undefined) {\r\n            config = {};\r\n        }\r\n        for (let k in this._randomizeDefaults) {\r\n            if (config[k] === undefined) {\r\n                config[k] = this._randomizeDefaults[k];\r\n            }\r\n        }\r\n\r\n        // TODO: Build a more robust randomize function\r\n\r\n        return P;\r\n    }\r\n\r\n\r\n    // TODO: Remove rndSimple and rndFactorable.\r\n    /**\r\n     * Polynom generator\r\n     * @param degree\r\n     * @param unit\r\n     * @param withFraction\r\n     * @param letters\r\n     * @param allowZero\r\n     * @param numberOfMonoms\r\n     */\r\n    rndSimple = (degree: number = 1, unit: boolean = false, withFraction: boolean = false, letters: string = 'x', allowZero: boolean = true, numberOfMonoms: number = -1): Polynom => {\r\n        // TODO: Make rndSimple polynom generator more user friendly\r\n        // If the current polynom (this) is already created, initialise it!\r\n        this.empty();\r\n\r\n        let M: Monom;\r\n        for (let i = degree; i >= 0; i--) {\r\n            M = new Monom().random(letters, i, withFraction, (i === degree) ? false : allowZero);\r\n\r\n            // We want to have the greatest degree monom coefficient to be unit.\r\n            if (unit && i === degree) {\r\n                M.coefficient = new Fraction().one();\r\n            }\r\n            this.add(M);\r\n        }\r\n\r\n        // Remove randomly the monoms to match the number of monoms.\r\n        if (numberOfMonoms > 0 && numberOfMonoms < this.length) {\r\n            this.reorder();\r\n            // Keep the greatest degree monom.\r\n            // But remove randomly the next monoms.\r\n            while (this.length > numberOfMonoms) {\r\n                this._monoms.splice(Numeric.randomInt(1, this.length - 1), 1);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    rndFactorable = (degree: number = 2, unit: boolean | number = false, letters: string = 'x'): Polynom => {\r\n        // TODO: Make rndFactorable polynom generator more user friendly\r\n        this._factors = [];\r\n        for (let i = 0; i < degree; i++) {\r\n            let factorUnit = unit === true || i >= unit,\r\n                p = new Polynom().rndSimple(1, factorUnit, false, letters);\r\n\r\n            this._factors.push(p);\r\n        }\r\n\r\n        this.empty().monoms = this._factors[0].monoms;\r\n        for (let i = 1; i < this._factors.length; i++) {\r\n            this.multiply(this._factors[i]);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    opposed = (): Polynom => {\r\n        this._monoms = this._monoms.map(m => m.opposed());\r\n        return this;\r\n    };\r\n\r\n    add = (...values: any[]): Polynom => {\r\n\r\n        for (let value of values) {\r\n            if (value.isPolynom) {\r\n                this._monoms = this._monoms.concat(value.monoms);\r\n            } else if (value.isMonom) {\r\n                this._monoms.push(value.clone());\r\n            } else if (Number.isSafeInteger(value)) {\r\n                this._monoms.push(new Monom(value.toString()));\r\n            } else {\r\n                this._monoms.push(new Monom(value));\r\n            }\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    subtract = (...values: any[]): Polynom => {\r\n\r\n        for (let value of values) {\r\n            if (value.isPolynom) {\r\n                this._monoms = this._monoms.concat(value.clone().opposed().monoms);\r\n            } else if (value.isMonom) {\r\n                this._monoms.push(value.clone().opposed());\r\n            } else if (Number.isSafeInteger(value)) {\r\n                this._monoms.push(new Monom(value.toString()).opposed());\r\n            } else {\r\n                this._monoms.push(new Monom(value).opposed());\r\n            }\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    multiply = (value: any): Polynom => {\r\n        if (value.isPolynom) {\r\n            return this.multiplyByPolynom(value);\r\n        } else if (value.isFraction) {\r\n            return this.multiplyByFraction(value);\r\n        } else if (value.isMonom) {\r\n            return this.multiplyByMonom(value);\r\n        } else if (Number.isSafeInteger(value)) {\r\n            return this.multiplyByInteger(value);\r\n        }\r\n\r\n        // Something went wrong...\r\n        return this;\r\n    }\r\n\r\n    private multiplyByPolynom = (P: Polynom): Polynom => {\r\n        const M: Monom[] = [];\r\n        for (const m1 of this._monoms) {\r\n            for (const m2 of P.monoms) {\r\n                M.push(Monom.xmultiply(m1, m2));\r\n            }\r\n        }\r\n\r\n        this._monoms = M;\r\n        return this.reduce();\r\n    };\r\n\r\n    private multiplyByFraction = (F: Fraction): Polynom => {\r\n        for (const m of this._monoms) {\r\n            m.coefficient.multiply(F);\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    private multiplyByInteger = (nb: number): Polynom => {\r\n        return this.multiplyByFraction(new Fraction(nb));\r\n    };\r\n\r\n    private multiplyByMonom = (M: Monom): Polynom => {\r\n        for (const m of this._monoms) {\r\n            m.multiply(M)\r\n        }\r\n        return this.reduce();\r\n    };\r\n\r\n    /**\r\n     * Divide the current polynom by another polynom.\r\n     * @param P\r\n     * returns {quotient: Polynom, reminder: Polynom}\r\n     */\r\n    euclidian = (P: Polynom): { quotient: Polynom, reminder: Polynom } => {\r\n        const quotient: Polynom = new Polynom().zero();\r\n        const reminder: Polynom = this.clone();\r\n        const maxMP: Monom = P.monomByDegree();\r\n        let newM: Monom;\r\n\r\n        // Make the euclidian division of the two polynoms.\r\n        while (reminder.degree() >= P.degree()) {\r\n            // Get the greatest monom divided by the max monom of the divider\r\n            newM = reminder.monomByDegree().clone().divide(maxMP);\r\n\r\n            if (newM.isZero()) {\r\n                break;\r\n            }\r\n\r\n            // Get the new quotient and reminder.\r\n            quotient.add(newM);\r\n            reminder.subtract(P.clone().multiply(newM));\r\n        }\r\n\r\n        return {quotient, reminder};\r\n    };\r\n\r\n    divide = (value: any): Polynom => {\r\n        if (value.isFraction) {\r\n            this.divideByFraction(value);\r\n        } else if (Number.isSafeInteger(value)) {\r\n            return this.divideByInteger(value);\r\n        }\r\n    }\r\n\r\n    private divideByInteger = (nb: number): Polynom => {\r\n        const nbF = new Fraction(nb);\r\n        for (const m of this._monoms) {\r\n            m.coefficient.divide(nbF);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    private divideByFraction = (F: Fraction): Polynom => {\r\n        for (const m of this._monoms) {\r\n            m.coefficient.divide(F);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    pow = (nb: number): Polynom => {\r\n        if (!Number.isSafeInteger(nb)) {\r\n            return this.zero();\r\n        }\r\n        if (nb < 0) {\r\n            return this.zero();\r\n        }\r\n        if (nb === 0) {\r\n            return new Polynom();\r\n        }\r\n\r\n        const P = this.clone();\r\n        for (let i = 1; i < nb; i++) {\r\n            this.multiply(P);\r\n        }\r\n        return this.reduce();\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Compare the current coefficient with another coefficient\r\n     * @param F (Coefficient) The coefficient to compare\r\n     * @param sign (string| default is =): authorized values: =, <, <=, >, >= with some variations.\r\n     */\r\n    compare = (P: Polynom, sign?: string): boolean => {\r\n        if (sign === undefined) {\r\n            sign = '='\r\n        }\r\n\r\n        // Create clone version to reduce them without altering the original polynoms.\r\n        const cP1 = this.clone().reduce().reorder();\r\n        const cP2 = P.clone().reduce().reorder();\r\n\r\n        switch (sign) {\r\n            case '=':\r\n                // They must have the isSame length and the isSame degree\r\n                if (cP1.length !== cP2.length || cP1.degree() !== cP2.degree()) {\r\n                    return false;\r\n                }\r\n\r\n                // Check if the coefficients are the isSame.\r\n                for (const i in cP1.monoms) {\r\n                    if (!cP1.monoms[i].isEqual(cP2.monoms[i])) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            case 'same':\r\n                // They must have the isSame length and the isSame degree\r\n                if (cP1.length !== cP2.length || cP1.degree() !== cP2.degree()) {\r\n                    return false;\r\n                }\r\n\r\n                for (const i in cP1.monoms) {\r\n                    if (!cP1.monoms[i].isSameAs(cP2.monoms[i])) {\r\n                        return false;\r\n                    }\r\n                }\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n\r\n    isZero(): boolean {\r\n        return (this._monoms.length === 1 && this._monoms[0].coefficient.isZero()) || this._monoms.length === 0;\r\n    }\r\n\r\n    isOne(): boolean {\r\n        return this._monoms.length === 1 && this._monoms[0].coefficient.isOne();\r\n    }\r\n\r\n    isEqual = (P: Polynom): boolean => {\r\n        return this.compare(P, '=');\r\n    };\r\n\r\n    isSameAs = (P: Polynom): boolean => {\r\n        return this.compare(P, 'same');\r\n    };\r\n\r\n    isOpposedAt = (P: Polynom): boolean => {\r\n        return this.compare(P.opposed(), '=');\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Misc polynoms functions\r\n    // -------------------------------------\r\n    reduce = (): Polynom => {\r\n        for (let i = 0; i < this._monoms.length; i++) {\r\n            for (let j = i + 1; j < this._monoms.length; j++) {\r\n                if (this._monoms[i].isSameAs(this.monoms[j])) {\r\n                    this._monoms[i].add(this.monoms[j]);\r\n                    this._monoms.splice(j, 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Remove all null monoms\r\n        this._monoms = this._monoms.filter((m) => {\r\n            return m.coefficient.value !== 0\r\n        });\r\n\r\n        // Reduce all monoms coefficient.\r\n        for (const m of this._monoms) {\r\n            m.coefficient.reduce();\r\n        }\r\n\r\n        if (this.length === 0) {\r\n            return new Polynom().zero();\r\n        }\r\n        return this;\r\n    };\r\n\r\n    reorder = (letter: string = 'x'): Polynom => {\r\n        // TODO: Must handle multiple setLetter reorder system\r\n        this._monoms.sort(function (a, b) {\r\n            return b.degree(letter) - a.degree(letter)\r\n        });\r\n        return this.reduce();\r\n    };\r\n\r\n    degree = (letter?: string): number => {\r\n        let d: number = 0;\r\n        for (const m of this._monoms) {\r\n            d = Math.max(m.degree(letter), d);\r\n        }\r\n        return d;\r\n    };\r\n\r\n    letters = (): string[] => {\r\n        let L:string[] = [], S = new Set();\r\n\r\n        for(let m of this._monoms){\r\n            S = new Set([...S, ...m.variables]);\r\n        }\r\n\r\n        // @ts-ignore\r\n        return [...S];\r\n    }\r\n\r\n    /**\r\n     * Replace a variable (letter) by a polynom.\r\n     * @param letter\r\n     * @param P\r\n     */\r\n    replaceBy = (letter: string, P: Polynom): Polynom => {\r\n        let pow: number;\r\n        const resultPolynom: Polynom = new Polynom().zero();\r\n\r\n        for (const m of this.monoms) {\r\n            if (m.literal[letter] === undefined || m.literal[letter] === 0) {\r\n                resultPolynom.add(m.clone());\r\n            } else {\r\n                // We have found a setLetter.\r\n                // Get the power and reset it.\r\n                pow = +m.literal[letter];\r\n                delete m.literal[letter];\r\n\r\n                resultPolynom.add(P.clone().pow(pow).multiply(m));\r\n            }\r\n        }\r\n\r\n        this._monoms = resultPolynom.reduce().reorder().monoms;\r\n        return this;\r\n    };\r\n\r\n    // Evaluate a polynom.\r\n    evaluate = (values: { [key: string]: Fraction }): Fraction => {\r\n        const r = new Fraction().zero();\r\n\r\n        this._monoms.forEach(monom => {\r\n            //console.log('Evaluate polynom: ', monom.display, values, monom.evaluate(values).display);\r\n            r.add(monom.evaluate(values));\r\n        });\r\n        return r;\r\n    };\r\n\r\n    derivative = (letter?: string): Polynom => {\r\n        let dP = new Polynom();\r\n\r\n        for (let m of this._monoms) {\r\n            dP.add(m.derivative(letter));\r\n        }\r\n\r\n        return dP;\r\n\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Polynoms factorization functions\r\n    // -------------------------------------\r\n    /**\r\n     * Factorize a polynom and store the best results in factors.\r\n     * @param maxValue Defines the greatest value to search to (default is 20).\r\n     */\r\n    factorize = (maxValue?: number): Polynom => {\r\n        // TODO: Must handle other letters than 'x'\r\n        this._factors = [];\r\n\r\n        // Duplicate the polynom\r\n        let P = this.clone(),\r\n            nbFactorsFound = 0;\r\n\r\n        // Determine if the polynom is \"negative\", eg has a max monom degree with a negative coefficient.\r\n        if (P.monomByDegree().coefficient.numerator < 0) {\r\n            this._factors.push(new Polynom('-1'));\r\n        }\r\n\r\n        // Determine if there is a 'common' monom\r\n        let M = P.commonMonom();\r\n        if (!M.isOne()) {\r\n            let commonPolynom = new Polynom()\r\n            commonPolynom.monoms = [M]\r\n            if (this._factors.length === 0) {\r\n                this._factors.push(commonPolynom);\r\n            } else {\r\n                this._factors = [];\r\n                this._factors.push(commonPolynom.opposed());\r\n            }\r\n            P = P.euclidian(commonPolynom).quotient;\r\n\r\n            nbFactorsFound = commonPolynom.degree();\r\n        }\r\n\r\n        // Main loop. Do it only if degree is equal or less than one.\r\n        if (P.degree() <= 1) {\r\n            this._factors.push(P.clone());\r\n        } else {\r\n            // Force test.\r\n            let Q = new Fraction(),\r\n                F,\r\n                degree = P.degree();\r\n\r\n            maxValue = maxValue === undefined ? 20 : maxValue;\r\n\r\n            // Test all polynom similar to ax+b\r\n            for (let a = 1; a <= maxValue; a++) {\r\n                // Skip a coefficient of 0\r\n                for (let b = -maxValue; b <= maxValue; b++) {\r\n\r\n                    Q.parse(-b, a);\r\n\r\n                    if (P.evaluate({x: Q})) {\r\n                        F = new Polynom(`${a}x+${b}`);\r\n                        while (P.evaluate({x: Q}).value === 0) {\r\n                            this._factors.push(F.clone());\r\n                            nbFactorsFound++;\r\n\r\n                            // Means it can be divided without reminders.\r\n                            P = P.euclidian(F).quotient;\r\n                        }\r\n                    }\r\n\r\n                    // Continue if the numbers of factors found equals the degree.\r\n                    if (nbFactorsFound > degree) {\r\n                        return this;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (P.degree() > 1) {\r\n                this._factors.push(P.clone());\r\n                return this;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Polynoms helpers functions\r\n    // -------------------------------------\r\n    // TODO: get zeroes for more than first degree\r\n    getZeroes = (): (Fraction | boolean)[] => {\r\n        const Z: Fraction[] = [];\r\n\r\n        switch (this.degree()) {\r\n            case 0:\r\n                if (this._monoms[0].coefficient.value === 0) {\r\n                    return [true];\r\n                } else {\r\n                    return [false];\r\n                }\r\n            case 1:\r\n                // There is only one monoms,\r\n                if (this._monoms.length === 1) {\r\n                    return [new Fraction().zero()];\r\n                } else {\r\n                    const P = this.clone().reduce().reorder();\r\n                    return [P.monoms[1].coefficient.opposed().divide(P.monoms[0].coefficient)];\r\n                }\r\n            // TODO: Determine the zeros of an equation of second degree.\r\n            //case 2:\r\n            default:\r\n                // Make sure the polynom is factorized.\r\n                if (this._factors.length === 0) {\r\n                    this.factorize()\r\n                }\r\n\r\n                let zeroes = [], zeroesAsTex = [];\r\n                for (let P of this._factors) {\r\n                    if (P.degree() > 2) {\r\n                        // TODO: Handle other polynom.\r\n\r\n                    } else if (P.degree() === 2) {\r\n                        let A = P.monomByDegree(2).coefficient,\r\n                            B = P.monomByDegree(1).coefficient,\r\n                            C = P.monomByDegree(0).coefficient,\r\n                            D = B.clone().pow(2).subtract(A.clone().multiply(C).multiply(4));\r\n\r\n                        if (D.value > 0) {\r\n                            /*console.log('Two zeroes for ', P.tex); */\r\n                            let x1 = (-(B.value) + Math.sqrt(D.value)) / (2 * A.value),\r\n                                x2 = (-(B.value) - Math.sqrt(D.value)) / (2 * A.value);\r\n\r\n                            zeroes.push(new Fraction(x1.toFixed(3)).reduce());\r\n                            zeroes.push(new Fraction(x2.toFixed(3)).reduce());\r\n                        } else if (D.value === 0) {\r\n                            /*console.log('One zero for ', P.tex); */\r\n\r\n                        } else {\r\n                            console.log('No zero for ', P.tex);\r\n                        }\r\n                    } else {\r\n                        for (let z of P.getZeroes()) {\r\n                            // Check if the zero is already in the list.\r\n                            if (z === false || z === true) {\r\n                                continue;\r\n                            }\r\n                            if (zeroesAsTex.indexOf(z.frac) === -1) {\r\n                                zeroes.push(z);\r\n                                zeroesAsTex.push(z.frac);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return zeroes;\r\n        }\r\n        return Z;\r\n    };\r\n\r\n\r\n    // TODO: analyse the next functions to determine if they are useful or not...\r\n    monomByDegree = (degree?: number, letter?: string): Monom => {\r\n        if (degree === undefined) {\r\n            // return the highest degree monom.\r\n            return this.monomByDegree(this.degree(letter));\r\n        }\r\n\r\n        // Reduce the polynom.\r\n        const M = this.clone().reduce();\r\n        for (const m of M._monoms) {\r\n            if (m.degree(letter) === degree) {\r\n                return m.clone();\r\n            }\r\n        }\r\n\r\n        // Nothing was found - return the null monom.\r\n        return new Monom().zero();\r\n    };\r\n\r\n    // Used in LinearSystem.tex\r\n    monomByLetter = (letter: string): Monom => {\r\n        const M = this.clone().reduce();\r\n        for (const m of M._monoms) {\r\n            if (m.hasLetter(letter)) {\r\n                return m.clone();\r\n            }\r\n        }\r\n\r\n        return new Monom().zero();\r\n    };\r\n\r\n\r\n    // Next functions are used for for commonMonom, which is used in the factorize method.\r\n    getDenominators = (): number[] => {\r\n        const denominators: number[] = [];\r\n        for (const m of this._monoms) {\r\n            denominators.push(m.coefficient.denominator);\r\n        }\r\n        return denominators;\r\n    };\r\n\r\n    getNumerators = (): number[] => {\r\n        const numerators: number[] = [];\r\n        for (const m of this._monoms) {\r\n            numerators.push(m.coefficient.numerator);\r\n        }\r\n        return numerators;\r\n    };\r\n\r\n    lcmDenominator = (): number => {\r\n        return Numeric.lcm(...this.getDenominators());\r\n    };\r\n\r\n    gcdDenominator = (): number => {\r\n        return Numeric.gcd(...this.getDenominators());\r\n    };\r\n\r\n    lcmNumerator = (): number => {\r\n        return Numeric.lcm(...this.getNumerators());\r\n    };\r\n\r\n    gcdNumerator = (): number => {\r\n        return Numeric.gcd(...this.getNumerators());\r\n    };\r\n\r\n    commonMonom = (): Monom => {\r\n        let M = new Monom().one(), numerator: number, denominator: number, degree = this.degree();\r\n\r\n        numerator = this.gcdNumerator();\r\n        denominator = this.gcdDenominator();\r\n\r\n        M.coefficient = new Fraction(numerator, denominator);\r\n        for (let L of this.variables) {\r\n            // Initialize the setLetter with the max degree\r\n            M.setLetter(L, degree);\r\n            for (let m of this._monoms) {\r\n                M.setLetter(L, Math.min(m.degree(L), M.degree(L)));\r\n                if (M.degree(L) === 0) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return M;\r\n    }\r\n\r\n\r\n    // TODO: The rest of the functions are not used or unnecessary ?\r\n    /**\r\n     * This will generate a not reduced tex string of the polynom.\r\n     * @param complexity : Number of iteration to increase the complexity.\r\n     */\r\n    makeItComplicate = (complexity: number = 1): Polynom => {\r\n        this._texString = '';\r\n\r\n        // The polynom must be at least of the first degree.\r\n        if (this.degree() < 1) {\r\n            return this;\r\n        }\r\n\r\n        const mDegree = Numeric.randomInt(0, this.degree() - 1);\r\n        const A = new Polynom().rndSimple(mDegree, false, complexity > 1, 'x', false, complexity > 1 ? -1 : 1);\r\n        const B = new Polynom().rndSimple(1, false, complexity > 1);\r\n        const C = this.clone().subtract(A.clone().multiply(B));\r\n\r\n        // Try to factorize a little bit the C polynom.\r\n        C.factorizePartial(true);\r\n        this._texString = `${A.genDisplay('tex', false, true)} \\\\cdot ${B.genDisplay('tex', false, true)} ${C.texString} `;\r\n\r\n        return this;\r\n    };\r\n    factorizePartial = (forceSign?: boolean): Polynom => {\r\n        this._texString = '';\r\n        // Try to find two monoms with a common coefficient.\r\n        if (this.length <= 1) {\r\n            return this;\r\n        }\r\n\r\n        let mMain: Monom,\r\n            mCheck: Monom,\r\n            mFactor: Monom,\r\n            pFactor: Polynom,\r\n            // pRemain: Polynom,\r\n            g: number, sign: string;\r\n\r\n        for (let i = 0; i < this.length; i++) {\r\n            mMain = this._monoms[i].clone();\r\n            // We factorize only if the main coefficient isn't a fraction\r\n            // if(mMain.coefficient.denominator!==1){continue;}\r\n            for (let j = i + 1; j < this.length; j++) {\r\n                mCheck = this._monoms[j].clone();\r\n                // if(mCheck.coefficient.denominator!==1){continue;}\r\n\r\n                g = Numeric.gcd(mMain.coefficient.numerator, mCheck.coefficient.numerator);\r\n                if (g !== 1) {\r\n                    // mFactor = mMain.clone().divide(mCheck); // This gets the literal part.\r\n                    // mFactor.coefficient = new Fraction(g); // Set the coefficient to the gcd.\r\n                    mFactor = Monom.lcm(mMain, mCheck);\r\n                    sign = mMain.coefficient.sign() === 1 ? '+' : '-';\r\n                    this._texString = `${forceSign === true ? sign : (sign === '+' ? '' : sign)}${mFactor.tex}`;\r\n\r\n                    pFactor = new Polynom().add(mMain.divide(mFactor)).add(mCheck.divide(mFactor));\r\n                    this._texString += pFactor.genDisplay('tex', false, true);\r\n\r\n                    this._texString += this.clone().subtract(pFactor.clone().multiply(mFactor)).genDisplay('tex', true, false);\r\n                    return this;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._texString = this.genDisplay('tex', forceSign);\r\n\r\n        return this;\r\n    };\r\n    /**\r\n     * reduce the coefficient value as if the polynom was equal to zero.\r\n     */\r\n    minify = (): Polynom => {\r\n        // First multiply by the common denominator.\r\n        this.multiply(this.lcmDenominator()).divide(this.gcdNumerator()).reduce();\r\n        return this.reduce();\r\n    };\r\n    /**\r\n     * Determine if the current polynom is divisible by P\r\n     * TODO: should work with any polynom, not only first degree polynoms and the setLetter should disappear\r\n     * @param P\r\n     * @param letter - default setLetter\r\n     */\r\n    canDivide = (P: Polynom, letter: string = 'x'): boolean => {\r\n        const d = P.degree();\r\n\r\n        const evalValue: { [key: string]: Fraction } = {};\r\n        // A zero degree polynom can always divide, except if it's the zero polynom.\r\n        if (d === 0) {\r\n            return !P.isZero;\r\n        }\r\n\r\n        // The polynom is of degree one.\r\n        if (d === 1) {\r\n            const z = P.getZeroes();\r\n            // The zero is an undefined zero.\r\n            if (z[0] === true || z[0] === false) {\r\n                return false;\r\n            }\r\n\r\n            evalValue[letter] = z[0];\r\n            return this.evaluate(evalValue).value === 0;\r\n        }\r\n\r\n        // The polynom is of degree 2 or more...\r\n        if (d > 1) {\r\n            console.log('Currently, only first degree polynom are supported');\r\n            return false;\r\n        }\r\n\r\n        return false;\r\n    };\r\n\r\n\r\n}\r\n","import {Polynom} from \"./polynom\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Nthroot} from \"../coefficients/nthroot\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Monom} from \"./monom\";\r\n\r\nexport class Equation {\r\n    private _left: Polynom;  // Left part of the equation\r\n    private _right: Polynom; // Right part of the equation\r\n    private _sign: string;   // Signe of the equation, by default =\r\n\r\n    private _polynom: Polynom;  // Used to solve the equation // TODO: remove the private value ?\r\n    private _solutions: string[];    // Array of the solutions\r\n\r\n    // Undetermined solutions.\r\n    private _varnothing: string = '\\\\varnothing';\r\n    private _real: string = '\\\\mathbb{R}';\r\n\r\n    /**\r\n     * Create an Equation using two polynoms.\r\n     * @param equation Equation string\r\n     */\r\n    constructor(...equations: any) {\r\n        // Default equation\r\n        this._left = new Polynom().zero();\r\n        this._right = new Polynom().zero();\r\n        this._sign = '=';\r\n\r\n        if (equations.length === 1) {\r\n            if (equations[0].isEquation === true) {\r\n                return equations[0].clone();\r\n            } else {\r\n                this.parse(equations[0]);\r\n            }\r\n        } else if (equations.length === 2) {\r\n            this.left = equations[0].isPolynom ? equations[0].clone() : new Polynom(equations[0]);\r\n            this.right = equations[1].isPolynom ? equations[1].clone() : new Polynom(equations[1]);\r\n        } else {\r\n            // Return default empty equation\r\n            return this;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    get isEquation() {\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    // TODO: Check the getters and setters.\r\n    get solutions(): string[] {\r\n        return this._solutions;\r\n    }\r\n\r\n    get solution(): string {\r\n        if (this._solutions.length === 1\r\n            &&\r\n            (\r\n                this._solutions[0] === this._real\r\n                || this._solutions[0] === this._varnothing\r\n                || this._solutions[0].includes('\\\\left')\r\n            )\r\n        ) {\r\n            return `S = ${this._solutions[0]}`;\r\n        }\r\n        return `S = \\\\left{ ${this._solutions.join(';')} \\\\right}`;\r\n    }\r\n\r\n    get isReal(): boolean {\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n        return this._solutions[0] === this._real;\r\n    }\r\n\r\n    get isVarnothing(): boolean {\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n        return this._solutions[0] === this._varnothing;\r\n    }\r\n\r\n    get signAsTex(): string {\r\n        if (this._sign === '>=' || this._sign === '=>' || this._sign === 'geq') {\r\n            return '\\\\geq';\r\n        }\r\n        if (this._sign === '<=' || this._sign === '=<' || this._sign === 'leq') {\r\n            return '\\\\leq';\r\n        }\r\n        return this._sign;\r\n    }\r\n\r\n    get tex(): string {\r\n        return `${this._left.tex}${this.signAsTex}${this._right.tex}`;\r\n    }\r\n\r\n    get raw(): string {\r\n        return `${this._left.raw}${this.signAsTex}${this._right.raw}`;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        return [...new Set(this._right.variables.concat(this._left.variables))];\r\n    }\r\n\r\n    get numberOfVars(): number {\r\n        return this.variables.length;\r\n    }\r\n\r\n    get left(): Polynom {\r\n        return this._left;\r\n    }\r\n\r\n    set left(value: Polynom) {\r\n        this._left = value;\r\n    }\r\n\r\n    get right(): Polynom {\r\n        return this._right;\r\n    }\r\n\r\n    set right(value: Polynom) {\r\n        this._right = value;\r\n    }\r\n\r\n    get sign(): string {\r\n        return this._sign;\r\n    }\r\n\r\n    set sign(value: string) {\r\n        // Set the sign value as formatted.\r\n        this._sign = this._formatSign(value);\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (equationString: string): Equation => {\r\n        let pStr: string[], strSign: string | false;\r\n        // Find the string separator\r\n        strSign = this._findSign(equationString);\r\n\r\n        if (strSign === false) {\r\n            console.log('The equation is not valid (no sign found)');\r\n            return;\r\n        }\r\n\r\n        // The StrSign is found\r\n        pStr = equationString.split(strSign);\r\n\r\n        return this.create(new Polynom(pStr[0]), new Polynom(pStr[1]), this._formatSign(strSign));\r\n    };\r\n\r\n    private _findSign = (equationString: string): string | false => {\r\n        let strSign: string = '';\r\n\r\n        if (equationString.includes('geq')) {\r\n            return (equationString.includes('\\\\geq')) ? '\\\\geq' : 'geq';\r\n        } else if (equationString.includes('leq')) {\r\n            return (equationString.includes('\\\\leq')) ? '\\\\leq' : 'leq';\r\n        } else if (equationString.includes('>=')) {\r\n            return '>=';\r\n        } else if (equationString.includes('=>')) {\r\n            return '=>';\r\n        } else if (equationString.includes('>')) {\r\n            return '>';\r\n        } else if (equationString.includes('<=')) {\r\n            return '<=';\r\n        } else if (equationString.includes('=<')) {\r\n            return '=<';\r\n        } else if (equationString.includes('<')) {\r\n            return '<';\r\n        } else if (equationString.includes('=')) {\r\n            return '='\r\n        }\r\n        if (strSign === '') {\r\n            console.log('Equation: parse string : sign not found');\r\n            return false;\r\n        }\r\n    };\r\n\r\n    private _formatSign = (signStr: string): string => {\r\n        if (signStr === undefined) {\r\n            return '=';\r\n        }\r\n\r\n        if (signStr.includes('geq')) {\r\n            return '>=';\r\n        } else if (signStr.includes('>=')) {\r\n            return '>=';\r\n        } else if (signStr.includes('=>')) {\r\n            return '>=';\r\n        } else if (signStr.includes('>')) {\r\n            return '>';\r\n        } else if (signStr.includes('leq')) {\r\n            return '<=';\r\n        } else if (signStr.includes('<=')) {\r\n            return '<=';\r\n        } else if (signStr.includes('=<')) {\r\n            return '<=';\r\n        } else if (signStr.includes('<')) {\r\n            return '<';\r\n        } else {\r\n            return '='\r\n        }\r\n    };\r\n\r\n    private _reverseSign = (): Equation => {\r\n        if (this._sign === '=') {\r\n            return this;\r\n        }\r\n\r\n        if (this._sign.includes('<')) {\r\n            this._sign.replace('<', '>');\r\n            return this;\r\n        }\r\n        if (this._sign.includes('>')) {\r\n            this._sign.replace('>', '<');\r\n            return this;\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    create = (left: Polynom, right: Polynom, sign?: string): Equation => {\r\n        this._left = left;\r\n        this._right = right;\r\n        this._sign = this._formatSign(sign);\r\n        return this;\r\n    };\r\n\r\n    clone = (): Equation => {\r\n        return new Equation().create(this._left.clone(), this._right.clone(), this._sign + '');\r\n    };\r\n\r\n    // -----------------------------------------------\r\n    // Equations generators and randomizers\r\n    // -----------------------------------------------\r\n    private _randomizeDefaults: { [key: string]: number | string | boolean } = {\r\n        degree: 2\r\n    };\r\n    get randomizeDefaults(): { [key: string]: number | string | boolean } {\r\n        return this._randomizeDefaults;\r\n    }\r\n\r\n    set randomizeDefaults(value) {\r\n        this._randomizeDefaults = value;\r\n    }\r\n\r\n    randomize = (opts?: {}, sign?: string): Equation => {\r\n        // TODO: Generate equations randomly, using config.\r\n        return new Equation().create(new Polynom(), new Polynom(), sign);\r\n    };\r\n\r\n\r\n    // -----------------------------------------------\r\n    // Equations operations\r\n    // -----------------------------------------------\r\n    /**\r\n     * Reorder will move all monoms containing a letter on the left, all the other on the right.\r\n     */\r\n    reorder = (allLeft?: boolean): Equation => {\r\n        // Move all monoms of degree greater than 0 to the left.\r\n        // and all zero degree monoms to the right.\r\n        this._left.subtract(this._right);\r\n        this._right.zero();\r\n\r\n        if (allLeft) {\r\n            return this;\r\n        }\r\n        let mMove: Monom;\r\n        for (let m of this._left.monoms) {\r\n            if (m.degree() === 0) {\r\n                mMove = m.clone();\r\n                this._left.subtract(mMove);\r\n                this._right.subtract(mMove);\r\n            }\r\n        }\r\n\r\n        // Reorder the left and right polynoms\r\n        this._left.reorder();\r\n        this._right.reorder();\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Multiply by the lcm denominator and divide by the gcm numerators.\r\n     */\r\n    simplify = (): Equation => {\r\n        this.multiply(Numeric.lcm(...this._left.getDenominators(),...this._right.getDenominators()));\r\n        this.divide(Numeric.gcd(...this._left.getNumerators(),...this._right.getNumerators()));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reorder the polynom to have only one letter on the left, the rest on the right.\r\n     * @param letter\r\n     */\r\n    isolate = (letter?: string): Equation | false => {\r\n        // Determine if we can isolate the variables.\r\n\r\n        // Both part of the equations must be of the first degree.\r\n        //TODO: handle equations of degree two or more ?\r\n        if (this.degree(letter) !== 1) {\r\n            return false;\r\n        }\r\n\r\n        // Modify the equation to isolate the asked variable.\r\n        // TODO: must handle equations like 3xy+5y=4 => y = 4/(3x-5)\r\n        if (this.isMultiVariable()) {\r\n            return false;\r\n        }\r\n\r\n        // Isolate the letter.\r\n        let mMove: Monom, cMove: Fraction;\r\n        // Start by moving everything to the left.\r\n        this._left.subtract(this._right);\r\n        this._right.zero();\r\n        for (let m of this._left.monoms) {\r\n            if (!m.hasLetter(letter)) {\r\n                mMove = m.clone();\r\n                this._left.add(mMove.clone().opposed());\r\n                this._right.add(mMove.clone().opposed());\r\n            }\r\n        }\r\n\r\n        // In theory, we should have only one item on the left.\r\n        if (this._left.length !== 1) {\r\n            return false;\r\n        }\r\n        cMove = this._left.monoms[0].coefficient.clone();\r\n        this._left.divide(cMove);\r\n        this._right.divide(cMove);\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Multiple an equation by a fraction value.\r\n     * @param F\r\n     */\r\n    multiply = (value: any): Equation => {\r\n\r\n        // Make sure we have a fraction.\r\n        let F: Fraction = new Fraction(value);\r\n\r\n        // Multiply each part of the equation by the fraction\r\n        this._left.multiply(F);\r\n        this._right.multiply(F);\r\n\r\n        // The sign of the inequation must be changed.\r\n        if (this._sign !== '=' && F.sign() === -1) {\r\n            this._reverseSign();\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    divide = (value: any): Equation => {\r\n        // Make sure we have a fraction.\r\n        let F: Fraction = new Fraction(value);\r\n\r\n        if(F.isZero()){\r\n            return this;\r\n        }else {\r\n            return this.multiply(F.invert());\r\n        }\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations helpers\r\n    // -----------------------------------------------\r\n\r\n    /**\r\n     * Get the degree of the equation\r\n     * @param letter\r\n     */\r\n    degree = (letter?: string): number => {\r\n        return Math.max(this._left.degree(letter), this._right.degree(letter));\r\n    };\r\n\r\n    /**\r\n     * Determine if the equation contains more than one letter/variable.\r\n     */\r\n    isMultiVariable = (): boolean => {\r\n        return this._left.isMultiVariable || this._right.isMultiVariable;\r\n    };\r\n\r\n    letters = (): string[] => {\r\n        // @ts-ignore\r\n        return [...new Set([...this._left.letters(), ...this._right.letters()])];\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations solving algorithms\r\n    // -----------------------------------------------\r\n    solve = (letter?: string) => {\r\n        // Initialise the variables:\r\n        this._solutions = [];\r\n\r\n        // TODO: this._polynom could be removed.\r\n        // TODO: consolidate solving equations (inequations vs equations)\r\n        this._polynom = this._left.clone().subtract(this._right);\r\n\r\n        switch (this._polynom.degree(letter)) {\r\n            case 0:\r\n            case 1:\r\n                this._solveDegree1(letter);\r\n                break;\r\n            case 2:\r\n                this._solveDegree2(letter);\r\n                break;\r\n            default:\r\n                this._solveDegree3plus(letter);\r\n        }\r\n    };\r\n\r\n    private isGreater = (): boolean => {\r\n        if (this._sign.indexOf('>') !== -1) {\r\n            return true;\r\n        }\r\n        if (this._sign.indexOf('geq') !== -1) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    private isStrictEqual = (): boolean => {\r\n        return this._sign === '=';\r\n    };\r\n    private isAlsoEqual = (): boolean => {\r\n        if (this._sign.indexOf('=') !== -1) {\r\n            return true;\r\n        }\r\n        if (this._sign.indexOf('geq') !== -1) {\r\n            return true;\r\n        }\r\n        if (this._sign.indexOf('leq') !== -1) {\r\n            return true;\r\n        }\r\n    };\r\n\r\n    private _solveDegree1 = (letter?: string): string[] => {\r\n        const m1 = this._polynom.monomByDegree(1, letter).coefficient,\r\n            m0 = this._polynom.monomByDegree(0, letter).coefficient,\r\n            v = m0.clone().opposed().divide(m1).display;\r\n        let s: string;\r\n\r\n        if (this.isStrictEqual()) {\r\n            if (m1.value === 0) {\r\n                // In this case, the coefficient of the x variable is zero.\r\n                if (m0.value === 0) {\r\n                    this._solutions = [this._real];\r\n                } else {\r\n                    this._solutions = [this._varnothing];\r\n                }\r\n            } else {\r\n                this._solutions = [v];\r\n            }\r\n        } else {\r\n            if (m1.value === 0) {\r\n                // In this case, the coefficient of the x variable is zero.\r\n                if (m0.value === 0 && this.isAlsoEqual()) {\r\n                    s = '\\\\mathbb{R}';\r\n                } else {\r\n                    if (m0.value > 0) {\r\n                        s = this.isGreater() ? this._real : this._varnothing;\r\n                    } else {\r\n                        s = !this.isGreater() ? this._real : this._varnothing;\r\n                    }\r\n                }\r\n            } else {\r\n                // Must handle the case if the m1 monom is negative.\r\n                if ((this.isGreater() && m1.sign() === 1) || (!this.isGreater() && m1.sign() === -1)) {\r\n                    s = `\\\\left${this.isAlsoEqual() ? '\\\\[' : '\\\\]'}${v};+\\\\infty\\\\right\\\\[`;\r\n                } else {\r\n                    s = `\\\\left\\\\]-\\\\infty;${v} \\\\right\\\\${this.isAlsoEqual() ? '\\\\]' : '\\\\['}`;\r\n                }\r\n            }\r\n            this._solutions = [s];\r\n        }\r\n\r\n        return this._solutions;\r\n    };\r\n\r\n    private _solveDegree2 = (letter?: string): string[] => {\r\n        let aF = this._polynom.monomByDegree(2, letter).coefficient,\r\n            bF = this._polynom.monomByDegree(1, letter).coefficient,\r\n            cF = this._polynom.monomByDegree(0, letter).coefficient,\r\n            delta: number, nthDelta: Nthroot,\r\n            lcm = Numeric.lcm(aF.denominator, bF.denominator, cF.denominator),\r\n            a = aF.multiply(lcm).value,\r\n            b = bF.multiply(lcm).value,\r\n            c = cF.multiply(lcm).value,\r\n            realX1: number, realX2: number,\r\n            sX1: string, sX2: string;\r\n\r\n        delta = b * b - 4 * a * c;\r\n\r\n        if (delta > 0) {\r\n            realX1 = (-b - Math.sqrt(delta)) / (2 * a);\r\n            realX2 = (-b + Math.sqrt(delta)) / (2 * a);\r\n            nthDelta = new Nthroot().parse(delta).reduce();\r\n            if (nthDelta.hasRadical()) {\r\n                // -b +- coeff\\sqrt{radical}\r\n                // -------------------------\r\n                //           2a\r\n                let gcd = Numeric.gcd(b, 2 * a, nthDelta.coefficient);\r\n                nthDelta.coefficient = nthDelta.coefficient / gcd;\r\n\r\n                // TODO: Can i delete the next line ?\r\n                // let deltaC = nthDelta.coefficient, deltaR = nthDelta.radical;\r\n                if (b !== 0) {\r\n                    if (2 * a / gcd === 1) {\r\n                        this._solutions = [\r\n                            `${-b / gcd} - ${nthDelta.tex}`,\r\n                            `${-b / gcd} + ${nthDelta.tex}`,\r\n                        ]\r\n                    } else {\r\n                        this._solutions = [\r\n                            `\\\\dfrac{${-b / gcd} - ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                            `\\\\dfrac{${-b / gcd} + ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                        ]\r\n                    }\r\n                } else {\r\n                    if (2 * a / gcd === 1) {\r\n                        this._solutions = [\r\n                            `- ${nthDelta.tex}`,\r\n                            `${nthDelta.tex}`,\r\n                        ]\r\n                    } else {\r\n                        this._solutions = [\r\n                            `\\\\dfrac{- ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                            `\\\\dfrac{${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                        ]\r\n                    }\r\n                }\r\n            } else {\r\n                // -b +- d / 2a\r\n                this._solutions = [\r\n                    new Fraction(-b - nthDelta.coefficient, 2 * a).reduce().dfrac,\r\n                    new Fraction(-b + nthDelta.coefficient, 2 * a).reduce().dfrac\r\n                ]\r\n            }\r\n        } else if (delta === 0) {\r\n            this._solutions = [new Fraction(-b, 2 * a).reduce().dfrac];\r\n        } else {\r\n            this._solutions = [this._varnothing];\r\n        }\r\n\r\n\r\n        // Handle now the inequations.\r\n        if (!this.isStrictEqual()) {\r\n            if (this._solutions.length === 2) {\r\n                sX1 = (realX1 < realX2) ? this._solutions[0] : this._solutions[1];\r\n                sX2 = (realX1 < realX2) ? this._solutions[1] : this._solutions[0];\r\n\r\n                if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                    this._solutions = [\r\n                        `\\\\left]-\\\\infty ; ${sX1}\\\\right${this.isAlsoEqual() ? ']' : '['} \\\\cup \\\\left${this.isAlsoEqual() ? '[' : ']'}${sX2};+\\\\infty\\\\right[`\r\n                    ];\r\n                } else {\r\n                    this._solutions = [\r\n                        `\\\\left${this.isAlsoEqual() ? '[' : ']'}${sX1} ; ${sX2}\\\\right${this.isAlsoEqual() ? ']' : '['}`\r\n                    ]\r\n                }\r\n            } else if (this._solutions.length === 1 && this._solutions[0] !== this._varnothing) {\r\n                if (!this.isAlsoEqual()) {\r\n                    if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                        this._solutions = [\r\n                            `\\\\left]-\\\\infty ; ${this._solutions[0]}\\\\right[ \\\\cup \\\\left]${this._solutions[0]};+\\\\infty\\\\right[`\r\n                        ];\r\n                    } else {\r\n                        this._solutions = [this._varnothing];\r\n                    }\r\n                } else {\r\n                    if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                        this._solutions = [this._real];\r\n                    } else {\r\n                        // this._solutions = [ this._solutions[0] ];\r\n                    }\r\n                }\r\n            } else {\r\n                if (this.isGreater()) {\r\n                    this._solutions = [aF.sign() === 1 ? this._real : this._varnothing];\r\n                } else {\r\n                    this._solutions = [aF.sign() === -1 ? this._real : this._varnothing];\r\n                }\r\n            }\r\n        }\r\n        return this._solutions;\r\n    };\r\n\r\n    private _solveDegree3plus = (letter?: string): string[] => {\r\n        // TODO: try to resolve equations with a degree superior than 2.\r\n        this._solutions = [letter];  // ESLint remove system :(\r\n        return this._solutions;\r\n    };\r\n\r\n}","/**\r\n * Vector module contains everything necessary to handle 2d or 3d vectors.\r\n * @module Vector\r\n */\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\nexport class Vector {\r\n    private _x: Fraction;   // 1st component\r\n    private _y: Fraction;   // 2nd component\r\n\r\n    constructor(...values: any) {\r\n        this._x = new Fraction().zero();\r\n        this._y = new Fraction().zero();\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values);\r\n        }\r\n    };\r\n\r\n    get isVector() {\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get x(): Fraction {\r\n        return this._x;\r\n    }\r\n\r\n    set x(value: Fraction) {\r\n        this._x = value;\r\n    }\r\n\r\n    get y(): Fraction {\r\n        return this._y;\r\n    }\r\n\r\n    set y(value: Fraction) {\r\n        this._y = value;\r\n    }\r\n\r\n    get normSquare(): Fraction {\r\n        return this._x.clone().pow(2).add(this._y.clone().pow(2));\r\n    }\r\n\r\n    get norm(): number {\r\n        return Math.sqrt(this.normSquare.value);\r\n    }\r\n\r\n    get tex(): string {\r\n        return `\\\\begin{pmatrix}${this._x.tex} \\\\\\\\\\ ${this._y.tex} \\\\end{pmatrix}`\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n    parse = (...values: any): Vector => {\r\n        // TODO: Must be more strict about what is given and limit to two dimensional vectors.p\r\n        // Maybe more than one value was given...\r\n        // Initialize the vector\r\n        this.zero();\r\n\r\n        if (values.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        if (values.length === 1) {\r\n            if (values[0].isVector) {\r\n                return values[0].clone()\r\n            } else {\r\n                return this._parseString(values[0])\r\n            }\r\n        }\r\n\r\n        if (values.length >= 2) {\r\n            // Two points are given - skip the third value.\r\n            if (values[0].isPoint && values[1].isPoint) {\r\n                this._x = values[1].x.clone().subtract(values[0].x)\r\n                this._y = values[1].y.clone().subtract(values[0].y)\r\n                return this;\r\n            }\r\n\r\n            // Fractions or a number are give\r\n            if (values[0].isFraction || !isNaN(values[0])) {\r\n                this._x = new Fraction(values[0])\r\n            }\r\n            if (values[1].isFraction || !isNaN(values[1])) {\r\n                this._y = new Fraction(values[1])\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    clone = (): Vector => {\r\n        let V = new Vector();\r\n\r\n        if (this._x !== null) {\r\n            V.x = this._x.clone();\r\n        }\r\n        if (this._y !== null) {\r\n            V.y = this._y.clone();\r\n        }\r\n        return V;\r\n    }\r\n\r\n    reset = (): Vector => {\r\n        this._x = null;\r\n        this._y = null;\r\n        return this;\r\n    }\r\n\r\n    zero = (): Vector => {\r\n        this.reset();\r\n        this._x = new Fraction(null);\r\n        this._y = new Fraction(null);\r\n        return this;\r\n    }\r\n\r\n    one = (): Vector => {\r\n        this._x = new Fraction();\r\n        this._y = new Fraction();\r\n        return this;\r\n    }\r\n\r\n    private _parseString = (value: string): Vector => {\r\n        // Split comma, semi colon or single space.\r\n        let components = value.split(/[,;\\s]/g);\r\n\r\n        // Validate the fraction values.\r\n        this.x = new Fraction(components[0] || null);\r\n        this.y = new Fraction(components[1] || null);\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    opposed = (): Vector => {\r\n        this._x.opposed();\r\n        this._y.opposed();\r\n        return this;\r\n    }\r\n\r\n    add = (V: Vector): Vector => {\r\n        this._x.add(V.x);\r\n        this._y.add(V.y);\r\n\r\n        return this;\r\n    }\r\n\r\n    subtract = (V: Vector): Vector => {\r\n        return this.add(V.clone().opposed());\r\n    }\r\n\r\n    scalarProductWithVector = (V: Vector): Fraction => {\r\n        // TODO: Add the scalar factor !!!!\r\n        return this._x.clone().multiply(V.x).add(this._y.clone().multiply(V.y));\r\n    }\r\n\r\n    static scalarProduct = (v1: Vector, v2: Vector): number => {\r\n        // TODO: Transform to fraction with nthroot.\r\n        return  v1.x.value * v2.x.value + v1.y.value * v2.y.value;\r\n    };\r\n\r\n    normal = (): Vector => {\r\n        let x = this.x.clone().opposed(), y = this.y.clone();\r\n        this._x = y;\r\n        this._y = x;\r\n        return this;\r\n    }\r\n\r\n    isNormalTo = (v: Vector): boolean => {\r\n        return this.scalarProductWithVector(v).isZero()\r\n    }\r\n    // ------------------------------------------\r\n    // Vector functions\r\n    // ------------------------------------------\r\n    angleWith = (V: Vector, sharp?: Boolean, radian?: Boolean): number => {\r\n        let scalar = this.scalarProductWithVector(V).value,\r\n            toDegree = radian ? 1 : 180 / Math.PI;\r\n        if (sharp) {\r\n            scalar = Math.abs(scalar);\r\n        }\r\n\r\n        return toDegree * Math.acos(scalar / (this.norm * V.norm));\r\n    }\r\n}\r\n","/**\r\n * Vector module contains everything necessary to handle 2d or 3d vectors.\r\n * @module Vector\r\n */\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\n//TODO: Ajouter une vrification si la droite existe.\r\nexport class Point {\r\n    private _x: Fraction;   // 1st component\r\n    private _y: Fraction;   // 2nd component\r\n    private _exist: Boolean;\r\n\r\n    constructor(...values: any) {\r\n        this._x = new Fraction().zero();\r\n        this._y = new Fraction().zero();\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values);\r\n        }\r\n    };\r\n\r\n    get isPoint() {\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get x(): Fraction {\r\n        return this._x;\r\n    }\r\n\r\n    set x(value: Fraction) {\r\n        this._x = value;\r\n    }\r\n\r\n    get y(): Fraction {\r\n        return this._y;\r\n    }\r\n\r\n    set y(value: Fraction) {\r\n        this._y = value;\r\n    }\r\n\r\n    get tex(): string {\r\n        let pts = [];\r\n\r\n        pts.push(this._x.tex);\r\n        pts.push(this._y.tex);\r\n\r\n        return `\\\\left(${pts.join(';')}\\\\right)`\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n    parse = (...values: any): Point => {\r\n        // Initialize the value.\r\n        this.zero();\r\n\r\n        // Nothing is given\r\n        if (values.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        // One element is given - might be already a point !\r\n        if (values.length === 1) {\r\n            if (values[0].isPoint) {\r\n                return values.clone();\r\n            }\r\n\r\n            // Value given as a dictionnary\r\n            if (values[0].x !== undefined && values[0].y !== undefined) {\r\n                this._x = new Fraction(values[0].x).reduce()\r\n                this._y = new Fraction(values[0].y).reduce()\r\n            } else {\r\n                return this.zero();\r\n            }\r\n        }\r\n        if (values.length === 2) {\r\n            this._x = new Fraction(values[0]).reduce()\r\n            this._y = new Fraction(values[1]).reduce()\r\n        }\r\n\r\n\r\n        return this;\r\n    };\r\n\r\n    clone = (): Point => {\r\n        let V = new Point();\r\n\r\n        if (this._x !== null) {\r\n            V.x = this._x.clone();\r\n        }\r\n        if (this._y !== null) {\r\n            V.y = this._y.clone();\r\n        }\r\n        return V;\r\n    }\r\n\r\n    zero = (): Point => {\r\n        this._x = new Fraction(null);\r\n        this._y = new Fraction(null);\r\n        return this;\r\n    }\r\n\r\n    origin = (): Point => {\r\n        this.zero();\r\n        return this;\r\n    }\r\n\r\n    middleOf = (P1: Point, P2: Point): Point => {\r\n        this._x = P1.x.clone().add(P2.x).divide(2);\r\n        this._y = P1.y.clone().add(P2.y).divide(2);\r\n\r\n        return this;\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n\r\n    // ------------------------------------------\r\n    // Vector functions\r\n    // ------------------------------------------\r\n\r\n    // ------------------------------------------\r\n    // Static functions\r\n    // ------------------------------------------\r\n    static pmatrix = (a: any, b: any, c?: any): string => {\r\n        if (c === undefined) {\r\n            return `\\\\begin{pmatrix} ${a.tex ? a.tex : a} \\\\\\\\ ${b.tex ? b.tex : b} \\\\end{pmatrix}`;\r\n        } else {\r\n            return `\\\\begin{pmatrix} ${a.tex ? a.tex : a} \\\\\\\\ ${b.tex ? b.tex : b} \\\\\\\\ ${c.tex ? c.tex : c} \\\\end{pmatrix}`;\r\n        }\r\n    };\r\n\r\n}\r\n","export class Nthroot {\r\n    private _radical: number;\r\n    private _nth: number;\r\n    private _coefficient: number;\r\n    private _isValid:boolean;\r\n\r\n    constructor() {\r\n        this._radical = 1;\r\n        this._coefficient = 1;\r\n        this._nth = 2;\r\n        this._isValid = true;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get radical(): number {\r\n        return this._radical;\r\n    }\r\n\r\n    set radical(value: number) {\r\n        this._radical = value;\r\n    }\r\n\r\n    get nth(): number {\r\n        return this._nth;\r\n    }\r\n\r\n    set nth(value: number) {\r\n        if (Number.isSafeInteger(value) && value >= 2) {\r\n            this._nth = value;\r\n        } else {\r\n            // Error setting the nth root.\r\n            console.log('Error setting the nth root');\r\n            this._nth = 2;\r\n        }\r\n    }\r\n\r\n    get coefficient(): number {\r\n        return this._coefficient;\r\n    }\r\n\r\n    set coefficient(value: number) {\r\n        this._coefficient = value;\r\n    }\r\n\r\n    get tex(): string {\r\n        let C: string;\r\n\r\n        if (this._coefficient === 1) {\r\n            C = '';\r\n        } else if (this._coefficient === -1) {\r\n            C = '-';\r\n        } else {\r\n            C = this._coefficient.toString();\r\n        }\r\n\r\n        if (this._radical === 1) {\r\n            return `${this._coefficient}`;\r\n        } else {\r\n            if (this._nth === 2) {\r\n                return `${C}\\\\sqrt{${this._radical}}`\r\n            } else {\r\n                return `${C}\\\\sqrt[${this._nth}]{${this._radical}}`\r\n            }\r\n        }\r\n    }\r\n\r\n    get value(): number {\r\n        return this._coefficient * Math.pow(this._radical, 1 / this._nth);\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (radical: number, nthroot?: number, coefficient?: number): Nthroot => {\r\n        this._coefficient = (coefficient === undefined) ? 1 : coefficient;\r\n        this._nth = (nthroot === undefined) ? 2 : nthroot;\r\n        this._radical = (radical === undefined) ? 1 : radical;\r\n\r\n        if(this._nth%2===0 && this._radical<0){\r\n            this._isValid = false;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    reduce = (): Nthroot => {\r\n        // Max value to test.\r\n        let V = Math.floor(Math.pow(this._radical, 1 / this._nth));\r\n        while (V > 1) {\r\n            if (this._radical % Math.pow(V, this._nth) === 0) {\r\n                // It's dividable by V^n\r\n                this._coefficient *= V;\r\n                this._radical = this._radical / Math.pow(V, this._nth);\r\n\r\n                // Redifine the new testing value (this is optimization)\r\n                V = Math.floor(Math.pow(this._radical, 1 / this._nth));\r\n                continue;\r\n            }\r\n            V--;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    multiply = (N: Nthroot): Nthroot => {\r\n        this._radical *= N.radical;\r\n        return this.reduce();\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Help functions\r\n    // ------------------------------------------\r\n    hasRadical = ():boolean => {\r\n        return !(this._radical===1 || this._radical===0 || this._isValid===false)\r\n    };\r\n}","/***\r\n * Monom class\r\n * Defined as coefficient * literal\r\n * Examples: 3x^2, 3/5x^2, ...\r\n */\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Numeric} from \"../numeric\";\r\n\r\n\r\nexport class Monom {\r\n    private _coefficient: Fraction;\r\n    private _literal: { [Key: string]: number };\r\n\r\n    /**\r\n     * Create the monom object.\r\n     * @param value (optional) string\r\n     */\r\n    constructor(value?: string) {\r\n        this.zero();\r\n\r\n        if (value !== undefined) {\r\n            // A string is given - try to parse the value.\r\n            this.parse(value);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get isMonom() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the coefficient as fraction\r\n     */\r\n    get coefficient(): Fraction {\r\n        return this._coefficient;\r\n    }\r\n\r\n    /**\r\n     * Set the coefficient value of the monom\r\n     * @param F     Fraction\r\n     */\r\n    set coefficient(F: Fraction) {\r\n        this._coefficient = F;\r\n    }\r\n\r\n    /**\r\n     * Get the literal part, as dictionary\r\n     */\r\n    get literal(): { [Key: string]: number } {\r\n        return this._literal;\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom\r\n     * @param L     Literal part as dictionary: <setLetter: exposant>\r\n     */\r\n    set literal(L: { [Key: string]: number }) {\r\n        this._literal = L;\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom from a string\r\n     * @param inputStr  String like x^2y^3\r\n     */\r\n    set literalStr(inputStr: string) {\r\n        // Match all x^n\r\n        for (const v of [...inputStr.matchAll(/([a-z])\\^([+-]?[0-9]+)/g)]) {\r\n            if (!(v[1] in this._literal)) {\r\n                this._literal[v[1]] = 0;\r\n            }\r\n            this._literal[v[1]] += +v[2];\r\n        }\r\n        for (const v of [...inputStr.matchAll(/([a-z](?!\\^))/g)]) {\r\n            // Match all single letters\r\n            if (!(v[1] in this._literal)) {\r\n                this._literal[v[1]] = 0;\r\n            }\r\n            this._literal[v[1]] += 1;\r\n        }\r\n    }\r\n\r\n    // Getter heplers.\r\n    /**\r\n     * Get the variables letters\r\n     */\r\n    get variables(): string[] {\r\n        let M = this.clone().clean();\r\n        return Object.keys(this._literal)\r\n    }\r\n\r\n    // Display getter\r\n    /**\r\n     * This display getter is to be used in the polynom display getter\r\n     */\r\n    get display(): string {\r\n        let L: string = '';\r\n        for (let letter in this._literal) {\r\n            if (this._literal[letter] !== 0) {\r\n                L += `${letter}`;\r\n                if (this._literal[letter] > 1) {\r\n                    L += `^${this._literal[letter]}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.display}`;\r\n            } else {\r\n                return '';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.display}${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Display the monom, forcing the '+' sign to appear\r\n     */\r\n    get displayWithSign(): string {\r\n        // TODO: Rename or remove this getter ?\r\n        let d: String = this.display;\r\n        return (d[0] !== '-' ? '+' : '') + d;\r\n    }\r\n\r\n    /**\r\n     * Get the tex output of the monom\r\n     */\r\n    get tex(): string {\r\n        let L: string = '';\r\n        for (let letter in this._literal) {\r\n            if (this._literal[letter] !== 0) {\r\n                L += `${letter}`;\r\n                if (this._literal[letter] > 1) {\r\n                    L += `^${this._literal[letter]}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.dfrac}`;\r\n            } else {\r\n                return '0';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.dfrac}${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // -----------------------------------------\r\n    /**\r\n     * Parse a string to a monom. The string may include fraction.\r\n     * @param inputStr\r\n     */\r\n    parse = (inputStr: string): Monom => {\r\n        // Set the literal part.\r\n        this.literalStr = inputStr;\r\n\r\n        // Get the coefficient\r\n        this._coefficient = new Fraction();\r\n\r\n        for (const v of [...inputStr.replace(/([a-z])|(\\^[+-]?[0-9]+)/g, ',').split(',')]) {\r\n            // The value is empty.\r\n            if (v.trim() === '') {\r\n                continue;\r\n            }\r\n\r\n            // Multiple the current coefficient by the new found value.\r\n            this._coefficient.multiply(new Fraction(v.trim()));\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Clone the current Monom.\r\n     */\r\n    clone = (): Monom => {\r\n        let F: Monom = new Monom();\r\n\r\n        F.coefficient = this._coefficient.clone();\r\n\r\n        // Copy the literal parts.\r\n        for (let k in this._literal) {\r\n            F.setLetter(k, this._literal[k]);\r\n        }\r\n        return F;\r\n    };\r\n\r\n    /**\r\n     * Create a zero value monom\r\n     */\r\n    zero = (): Monom => {\r\n        this._coefficient = new Fraction().zero();\r\n        this._literal = {};\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Create a one value monom\r\n     */\r\n    one = (): Monom => {\r\n        this._coefficient = new Fraction().one();\r\n        this._literal = {};\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Clean the monom by removing each letters with a power of zero.\r\n     */\r\n    clean = (): Monom => {\r\n        for (let letter in this._literal) {\r\n            if (this._literal[letter] === 0) {\r\n                delete this._literal[letter];\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Generate a random monom\r\n     * @param letters       Letters to use, as a string\r\n     * @param degree        Max degree (default 1)\r\n     * @param withFraction  Allows fraction as coefficient (default false)\r\n     * @param allowZero     Allows null monom (default false)\r\n     */\r\n    random = (letters: string = 'x', degree: number = 1, withFraction: boolean = false, allowZero: boolean = false): Monom => {\r\n        // TODO: Randomize monoms: options or make it subclass ?\r\n        this.coefficient.parse(Numeric.randomIntSym(10, allowZero), (withFraction) ? Numeric.randomInt(1, 10) : 1);\r\n\r\n        for (let L of letters.split('')) {\r\n            this.setLetter(L, (letters.length > 1) ? Numeric.randomInt(degree) : degree);\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Get the opposed\r\n     * Returns a monom.\r\n     */\r\n    opposed = (): Monom => {\r\n        this._coefficient.opposed();\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Add all similar monoms. If they aren't similar, they are simply skipped.\r\n     * @param M (Monom[]) The monoms to add.\r\n     */\r\n    add = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            if (this.isSameAs(m)) {\r\n                this._coefficient.add(m.coefficient);\r\n            } else {\r\n                console.log('Add: Is not similar: ', m.display);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Subtract multiple monoms\r\n     * @param M (Monom[]) The monoms to subtract\r\n     */\r\n    subtract = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            if (this.isSameAs(m)) {\r\n                this._coefficient.add(m.coefficient.clone().opposed());\r\n            } else {\r\n                console.log('Subtract: Is not similar: ', m.display);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Multiple multiple monoms to the current monom\r\n     * @param M (Monom[]) The monoms to multiply to.\r\n     */\r\n    multiply = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            // Multiply the coefficient.\r\n            this._coefficient.multiply(m.coefficient);\r\n            // Multiply the literal parts.\r\n            for (let letter in m.literal) {\r\n                this._literal[letter] = (this._literal[letter] === undefined) ? m.literal[letter] : this._literal[letter] + m.literal[letter];\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Divide the current monoms by multiple monoms\r\n     * @param M (Monom[])\r\n     */\r\n    divide = (...M: Monom[]): Monom => {\r\n        // Depending on the given value, choose the current item\r\n        for (let v of M) {\r\n            // Divide the coefficient\r\n            this._coefficient.divide(v.coefficient);\r\n\r\n            // Subtract the power values\r\n            for (let letter in v.literal) {\r\n                this._literal[letter] = (this._literal[letter] === undefined) ? -v.literal[letter] : this._literal[letter] - v.literal[letter];\r\n\r\n                // If the power of a particular setLetter is zero, delete it from the literal part..\r\n                if (this._literal[letter] === 0) {\r\n                    delete this._literal[letter];\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Get the pow of a monom.\r\n     * @param nb (number) : Mathematical pow\r\n     */\r\n    pow = (nb: number): Monom => {\r\n        this._coefficient.pow(nb);\r\n        for (let letter in this._literal) {\r\n            this._literal[letter] *= nb;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Get the nth-root of the monom\r\n     * @param p\r\n     */\r\n    root = (p: number): Monom => {\r\n        // TODO: determiner the nth root of a monom\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Return the square root of a monom\r\n     */\r\n    sqrt = (): Monom => {\r\n        return this.root(2);\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n    // ------------------------------------------\r\n    compare = (M: Monom, sign?: string): boolean => {\r\n        // TODO: Build the compare systems.\r\n        if (sign === undefined) {\r\n            sign = '=';\r\n        }\r\n\r\n\r\n        switch (sign) {\r\n            case '=':\r\n                // To be equal, they must be the isSame\r\n                if (!this.compare(M, 'same')) {\r\n                    return false;\r\n                }\r\n\r\n                // The litteral parts are the isSame. The coefficient must be equal\r\n                return this._coefficient.isEqual(M.coefficient);\r\n            case 'same':\r\n                // Get the list of all variables from both monoms.\r\n                let M1: string[] = this.variables,\r\n                    M2: string[] = M.variables,\r\n                    K: string[] = M1.concat(M2.filter((item) => M1.indexOf(item) < 0));\r\n\r\n                for (let key of K) {\r\n                    // The setLetter is not available in one of the monom\r\n                    if (this._literal[key] === undefined || M.literal[key] === undefined) {\r\n                        return false;\r\n                    }\r\n                    // The setLetter does not have the isSame power in each monoms.\r\n                    if (this._literal[key] !== M.literal[key]) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                // All are positive check - the monoms are the sames.\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is null\r\n     */\r\n    isZero(): boolean {\r\n        return this._coefficient.value === 0;\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is one\r\n     */\r\n    isOne(): boolean {\r\n        return this._coefficient.value === 1 && this.variables.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Determine if two monoms are equals\r\n     * @param M\r\n     */\r\n    isEqual = (M: Monom): boolean => {\r\n        return this.compare(M, '=');\r\n    };\r\n\r\n    /**\r\n     * Determine if two monoms are similar\r\n     * @param M\r\n     */\r\n    isSameAs = (M: Monom): boolean => {\r\n        return this.compare(M, 'same');\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Misc monoms functions\r\n    // -------------------------------------\r\n    /**\r\n     * Determine if a monom contains a setLetter in it's literal part\r\n     * @param letter\r\n     */\r\n    hasLetter = (letter?: string): boolean => {\r\n        return this._literal[letter === undefined ? 'x' : letter] > 0;\r\n    };\r\n\r\n    /**\r\n     * Set the power of a particular setLetter\r\n     * @param letter (string) Letter to change\r\n     * @param pow (number) Power of the setLetter (must be positive integer.\r\n     */\r\n    setLetter = (letter: string, pow: number): void => {\r\n        // If the power is not legal or is zero, remove the setLetter from the dict\r\n        if (pow <= 0 || !Number.isSafeInteger(pow)) {\r\n            if (this._literal[letter] !== undefined) {\r\n                delete this._literal[letter];\r\n            }\r\n        } else {\r\n            this._literal[letter] = pow;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Get the degree of a monom. If no setLetter is given, the result will be the global degree.\r\n     * @param letter (string) Letter to get to degree (power)\r\n     */\r\n    degree = (letter?: string): number => {\r\n        if (this.variables.length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        if (letter === undefined) {\r\n            // Not setLetter given -> we get the global monom degree (sum of all the letters).\r\n            return Object.values(this._literal).reduce((t, n) => t + n);\r\n        } else {\r\n            // A setLetter is given -> get the corresponding power.\r\n            return this._literal[letter] === undefined ? 0 : this._literal[letter];\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Evaluate a monom. Each setLetter must be assigned to a Fraction.\r\n     * @param values    Dictionary of <setLetter: Fraction>\r\n     */\r\n    evaluate = (values: { [key: string]: Fraction }): Fraction => {\r\n        let r = this.coefficient.clone();\r\n\r\n        for (let L in this._literal) {\r\n            if (values[L] === undefined) {\r\n                return new Fraction().zero();\r\n            }\r\n            r.multiply(values[L].clone().pow(this._literal[L]));\r\n        }\r\n        return r;\r\n    };\r\n\r\n    /**\r\n     * Derivative the monom\r\n     * @param letter\r\n     */\r\n    derivative = (letter?: string): Monom => {\r\n        // No setLetter given - assume it's the setLetter 'x'\r\n        if (letter === undefined) {\r\n            letter = 'x';\r\n        }\r\n        if (this.hasLetter(letter)) {\r\n            let d = +this._literal[letter],\r\n                dM = this.clone();\r\n\r\n            // Subtract one to the degree.\r\n            dM._literal[letter] -= 1;\r\n\r\n            // Multiply the coefficient by the previous degree\r\n            dM._coefficient.multiply(new Fraction('' + d));\r\n            return dM;\r\n        } else {\r\n            return new Monom().zero();\r\n        }\r\n    };\r\n\r\n    // ----------------------------------------\r\n    // Static functions\r\n    // ----------------------------------------\r\n\r\n    /**\r\n     * Get the least common multiple of monoms\r\n     * @param monoms    Array of monoms\r\n     */\r\n    static lcm = (...monoms: Monom[]): Monom => {\r\n        let M = new Monom(),\r\n            coeffN: number[] = monoms.map(value => value.coefficient.numerator),\r\n            coeffD: number[] = monoms.map(value => value.coefficient.denominator),\r\n            n = Numeric.gcd(...coeffN),\r\n            d = Numeric.lcm(...coeffD);\r\n\r\n        // Get the coefficient.\r\n        M.coefficient = new Fraction(n, d).reduce();\r\n\r\n        // Set the literal parts - go through each monoms literal parts and get only the lowest degree of each letters.\r\n        for (let m of monoms) {\r\n            // Remove the inexistant letters from the resulting monom\r\n            for (let letter in M.literal) {\r\n                if (!(letter in m.literal)) {\r\n                    M.literal[letter] = 0;\r\n                }\r\n            }\r\n            for (let letter in m.literal) {\r\n                if (M.literal[letter] === undefined && m.literal[letter] > 0) {\r\n                    M.literal[letter] = m.literal[letter];\r\n                } else {\r\n                    M.literal[letter] = Math.min(m.literal[letter], M.literal[letter]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return M;\r\n    };\r\n\r\n    /**\r\n     * Multiply two monoms and return a NEW monom.\r\n     * @param M1\r\n     * @param M2\r\n     */\r\n    static xmultiply = (...monoms: Monom[]): Monom => {\r\n        let M = new Monom().one();\r\n\r\n        for(let m of monoms){\r\n            M.multiply(m);\r\n        }\r\n\r\n        return M;\r\n    };\r\n\r\n\r\n\r\n\r\n\r\n\r\n    // TODO: The rest of the functions are not used or unnecessary ?\r\n    /**\r\n     * Determine if multiple monoms are similar\r\n     * @param M\r\n     */\r\n    areSameAs = (...M: Monom[]): boolean => {\r\n        let result: boolean = true;\r\n\r\n        // Check all monoms if they are the isSame as the \"this\" one.\r\n        for (let i = 0; i < M.length; i++) {\r\n            if (!this.isSameAs(M[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // All check passed -> all the monoms are similar.\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Determine if multiple monoms are equals\r\n     * @param M\r\n     */\r\n    areEquals = (...M: Monom[]): boolean => {\r\n        // They are not similar.\r\n        if (!this.areSameAs(...M)) {\r\n            return false;\r\n        }\r\n\r\n        // Check all coefficient. They must be equals.\r\n        for (let m of M) {\r\n            if (!this._coefficient.isEqual(m.coefficient)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // All checks passed.\r\n        return true;\r\n    };\r\n\r\n}","/**\r\n * This class works for 2d line in a plane.\r\n */\r\n\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Vector} from \"./vector\";\r\nimport {Point} from \"./point\";\r\nimport {Polynom} from \"../algebra/polynom\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Equation} from \"../algebra/equation\";\r\n\r\nexport class Line {\r\n    // A line is defined as the canonical form\r\n    // ax + by + c = 0\r\n    private _a: Fraction;\r\n    private _b: Fraction;\r\n    private _c: Fraction;\r\n    private _OA: Point;\r\n    private _d: Vector;\r\n    private _n: Vector;\r\n\r\n    constructor(...values: any) {\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values);\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get tex(): { canonical: string, mxh: string, parametric: string } {\r\n        // canonical    =>  ax + by + c = 0\r\n        // mxh          =>  y = -a/b x - c/b\r\n        // parametric   =>  (xy) = OA + k*d\r\n\r\n        let canonical = new Equation(new Polynom().parse('xy', this._a, this._b, this._c), new Polynom('0')).simplify()\r\n        // Make sur the first item is positive.\r\n        if(this._a.isNegative()){\r\n            canonical.multiply(-1);\r\n        }\r\n\r\n        return {\r\n            canonical: canonical.tex,\r\n            mxh: this.slope.isInfinity() ? 'x=' + this.OA.x.tex : 'y=' + new Polynom().parse('x', this.slope, this.height).tex,\r\n            parametric: `${Point.pmatrix('x', 'y')} = ${Point.pmatrix(this._OA.x, this._OA.y)} + k\\\\cdot ${Point.pmatrix(this._d.x, this._d.y)}`\r\n        }\r\n    }\r\n\r\n    get a(): Fraction {\r\n        return this._a;\r\n    }\r\n\r\n    set a(value: Fraction) {\r\n        this._a = value;\r\n    }\r\n\r\n    get b(): Fraction {\r\n        return this._b;\r\n    }\r\n\r\n    set b(value: Fraction) {\r\n        this._b = value;\r\n    }\r\n\r\n    get c(): Fraction {\r\n        return this._c;\r\n    }\r\n\r\n    set c(value: Fraction) {\r\n        this._c = value;\r\n    }\r\n\r\n    get OA(): Point {\r\n        return this._OA;\r\n    }\r\n\r\n    set OA(value: Point) {\r\n        this._OA = value;\r\n    }\r\n\r\n    get d(): Vector {\r\n        return this._d;\r\n    }\r\n\r\n    get n(): Vector {\r\n        return this._n;\r\n    }\r\n\r\n    set d(value: Vector) {\r\n        this._d = value;\r\n    }\r\n\r\n    get slope(): Fraction {\r\n        return this._a.clone().opposed().divide(this._b);\r\n    }\r\n\r\n    get height(): Fraction {\r\n        return this._c.clone().opposed().divide(this._b);\r\n    }\r\n\r\n// ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (...values: any): Line => {\r\n        if (values.length === 3) {\r\n            return this.parseByCoefficient(values[0], values[1], values[2]);\r\n        } else if (values.length === 2) {\r\n            if (values[0].isPoint && values[1].isVector) {\r\n                return this.parseByPointAndVector(values[0], values[1]);\r\n            } else if (values[0].isPoint && values[1].isPoint) {\r\n                return this.parseByPointAndVector(values[0], new Vector(values[0], values[1]));\r\n            }\r\n        } else if (values.length === 1){\r\n            // Maybe it's a string or an equation\r\n            let equ = new Equation(values[0]);\r\n            if(equ.isEquation){\r\n                // Check if it's a valid equation.\r\n                equ.reorder(true)\r\n\r\n                // It must contain either x, y or both.\r\n                let letters = new Set(equ.letters());\r\n\r\n                // No 'x', no 'y' in the equations\r\n                if(!(letters.has('x') || letters.has('y'))){return;}\r\n\r\n                // Another letter in the equation.\r\n                for(let elem of ['x', 'y']){\r\n                    if(letters.has(elem)){\r\n                        letters.delete(elem)}\r\n                }\r\n                if(letters.size>0){\r\n                    console.log('Extra variable in the equation.')\r\n                    return;\r\n                }\r\n\r\n                // Everything should be ok now...\r\n                return this.parseByCoefficient(equ.left.monomByLetter('x').coefficient, equ.left.monomByLetter('y').coefficient, equ.left.monomByDegree(0).coefficient)\r\n            }\r\n        }\r\n        // TODO: Add the ability to create line from a normal vector\r\n        console.log('Someting wrong happend while creating the line')\r\n        return;\r\n    }\r\n\r\n    parseByCoefficient = (a: Fraction, b: Fraction, c: Fraction): Line => {\r\n        this._a = new Fraction(a);\r\n        this._b = new Fraction(b);\r\n        this._c = new Fraction(c);\r\n\r\n        // TODO: initialize direction and reference point\r\n        this._d = new Vector(this._b.clone(), this._a.clone().opposed());\r\n        this._OA = new Point(new Fraction().zero(), this._c.clone());\r\n        this._n = this._d.clone().normal();\r\n\r\n        return this;\r\n    }\r\n\r\n    parseByPointAndVector = (P: Point, d: Vector): Line => {\r\n        // OX = OP + k*d\r\n        // x = px + kdx     * dy\r\n        // y = py + kdy     * dx\r\n        // ------------------\r\n        // dy * x = px * dy + kdxdy\r\n        // dx * y = py * dx + kdxdy\r\n        // ------------------\r\n        // dy * x - dx * y = px * dy - py * dx\r\n        // dy * x - dx * y - (px * dy - py * dx) = 0\r\n        this.parseByCoefficient(\r\n            d.y,\r\n            d.x.clone().opposed(),\r\n            P.x.clone().multiply(d.y).subtract(P.y.clone().multiply(d.x)).opposed()\r\n        )\r\n\r\n        // Choose the current values as point and direction vector instead of the automatic version.\r\n        this._OA = P.clone();\r\n        this._d = d.clone();\r\n        this._n = this._d.clone().normal();\r\n\r\n        return this;\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    isParellelTo = (line: Line): Boolean => {\r\n        // Do they have the isSame direction ?\r\n        return this.slope.isEqual(line.slope) && this.height.isDifferent(line.height);\r\n    }\r\n    isSameAs = (line: Line): Boolean => {\r\n        return this.slope.isEqual(line.slope) && this.height.isEqual(line.height);\r\n    }\r\n    simplifyDirection = (): Line => {\r\n        let lcm = Numeric.lcm(this._d.x.denominator, this._d.y.denominator),\r\n            gcd = Numeric.gcd(this._d.x.numerator, this._d.y.numerator);\r\n\r\n        this._d.x.multiply(lcm).divide(gcd);\r\n        this._d.y.multiply(lcm).divide(gcd);\r\n        return this;\r\n    }\r\n    intersection = (line: Line): { point: Point, hasIntersection: boolean, isParallel: boolean, isSame: boolean } => {\r\n        let Pt = new Point(), isParallel = false, isSame = false, hasIntersection = true;\r\n\r\n        // this         => ax+by+c = 0\r\n        // line         => dx+ey+f = 0\r\n        //\r\n        //  aex + bey + ce = 0\r\n        //  dbx + bey + bf = 0\r\n        // (ae-db)x + ce-bf = 0\r\n        //\r\n        //  adx + bdy + cd = 0\r\n        //  adx + aey + af = 0\r\n        // (bd-ae)y + (cd-af)\r\n        //\r\n        // x = (bf-ce)/(ae-db)\r\n        // y = (af-cd)/(bd-ae)\r\n\r\n\r\n        // Theres is no 'y'\r\n        if (this._b.isZero() || line.b.isZero()) {\r\n            // TODO : handle no y in the line canonical form\r\n        }\r\n\r\n        if (this.isParellelTo(line)) {\r\n            Pt.x = null;\r\n            Pt.y = null;\r\n            isParallel = true;\r\n        } else if (this.isSameAs(line)) {\r\n            Pt.x = null;\r\n            Pt.y = null;\r\n            isSame = true;\r\n        } else {\r\n            Pt.x = this._b.clone().multiply(line.c).subtract(this._c.clone().multiply(line.b))\r\n                .divide(this._a.clone().multiply(line.b).subtract(this._b.clone().multiply(line.a)));\r\n            Pt.y = this._a.clone().multiply(line.c).subtract(this._c.clone().multiply(line.a))\r\n                .divide(this._b.clone().multiply(line.a).subtract(this._a.clone().multiply(line.b)));\r\n        }\r\n\r\n        return {\r\n            point: Pt,\r\n            hasIntersection: !(isParallel || isSame),\r\n            isParallel,\r\n            isSame\r\n        };\r\n    }\r\n\r\n    distanceTo(pt: Point): { value: number, fraction: Fraction, tex: string } {\r\n        let numerator = pt.x.clone().multiply(this._a)\r\n                .add(pt.y.clone().multiply(this._b))\r\n                .add(this._c).abs(),\r\n            d2 = this._n.normSquare;\r\n\r\n        // The denominator is null - shouldn't be possible\r\n        if (d2.isZero()) {\r\n            return {\r\n                value: NaN,\r\n                tex: 'Not a line',\r\n                fraction: new Fraction().infinite()\r\n            }\r\n        }\r\n        // The denominator is a perfect square - simplify the tex result\r\n        let value = numerator.value / Math.sqrt(d2.value),\r\n            F = numerator.clone().divide(d2.clone().sqrt());\r\n\r\n        // The denominator is a perfect square.\r\n        if (d2.isSquare()) {\r\n            return {\r\n                value,\r\n                tex: F.tex,\r\n                fraction: F\r\n            }\r\n        }\r\n        // Complete answer...\r\n        return {\r\n            value,\r\n            tex: `\\\\frac{${numerator.tex}}{\\\\sqrt{${d2.tex}}}`,\r\n            fraction: F\r\n        };\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Special functions\r\n    // ------------------------------------------\r\n    canonicalAsFloatCoefficient(decimals: number): string{\r\n        if(decimals===undefined){\r\n            decimals = 2;\r\n        }\r\n\r\n        let ca = this._a.value,\r\n            cb = this._b.value,\r\n            cc= this._c.value,\r\n            canonical = '';\r\n\r\n        if(!this._a.isZero()){\r\n            if(this._a.isOne()){\r\n                canonical = 'x'\r\n            }else if(this._a.clone().opposed().isOne()){\r\n                canonical = '-x'\r\n            }else{\r\n                canonical = this._a.value.toFixed(decimals)+'x'\r\n            }\r\n        }\r\n\r\n        if(!this._b.isZero()){\r\n            if(this._b.isPositive()){canonical+='+'}\r\n            canonical += this._b.value.toFixed(decimals) + 'y'\r\n        }\r\n\r\n        if(!this._c.isZero()){\r\n            if(this._c.isPositive()){canonical+='+'}\r\n            canonical += this._c.value.toFixed(decimals)\r\n        }\r\n\r\n\r\n        return canonical + '=0';\r\n    }\r\n}","import {Fraction} from \"./maths/coefficients/fraction\";\r\nimport {Numeric} from \"./maths/numeric\";\r\nimport {Nthroot} from \"./maths/coefficients/nthroot\";\r\nimport {Monom} from \"./maths/algebra/monom\";\r\nimport {Polynom} from \"./maths/algebra/polynom\";\r\nimport {Equation} from \"./maths/algebra/equation\";\r\nimport {LinearSystem} from \"./maths/algebra/linearSystem\";\r\nimport {Rational} from \"./maths/algebra/rational\";\r\nimport {Vector} from \"./maths/geometry/vector\";\r\nimport {Line} from \"./maths/geometry/line\";\r\nimport {Point} from \"./maths/geometry/point\";\r\nimport {Triangle} from \"./maths/geometry/triangle\";\r\n\r\n// Expose as global\r\n(<any>window).Pi = {\r\n    Numeric: Numeric,\r\n    Fraction: Fraction,\r\n    Root: Nthroot,\r\n    Monom: Monom,\r\n    Polynom: Polynom,\r\n    Equation: Equation,\r\n    LinearSystem: LinearSystem,\r\n    Rational: Rational,\r\n    Geometry: {\r\n        Vector: Vector,\r\n        Point: Point,\r\n        Line: Line,\r\n        Triangle: Triangle\r\n    }\r\n};\r\n\r\nexport var Pi = {\r\n    Numeric: Numeric,\r\n    Fraction: Fraction,\r\n    Root: Nthroot,\r\n    Monom: Monom,\r\n    Polynom: Polynom,\r\n    Equation: Equation,\r\n    LinearSystem: LinearSystem,\r\n    Rational: Rational,\r\n    Geometry: {\r\n        Vector: Vector,\r\n        Point: Point,\r\n        Line: Line,\r\n        Triangle: Triangle\r\n    }\r\n};\r\n","export class Shutingyard {\r\n    private _rpn: string[] = [];\r\n\r\n    /**\r\n     * Determin if the token is a defined operation\r\n     * Defined operations: + - * / ^ sin cos tan\r\n     * @param token\r\n     */\r\n    isOperation(token: string): boolean {\r\n        if (token[0].match(/[+\\-*/^]/g)) {\r\n            return true;\r\n        }\r\n        if (token.match(/^sin|cos|tan/g)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the next token to analyse.\r\n     * @param expr (string) Expression to analyse\r\n     * @param start (number) CUrrent position in the expr string.\r\n     */\r\n    NextToken(expr: string, start: number): [string, number, string] {\r\n        let tokenMatch: string[], token: string, tokenType: string;\r\n\r\n        // Detect a fraction monoms or return empty array\r\n        tokenMatch = (expr.substr(start).match(/^[0-9/a-z^]+/g)) || [];\r\n\r\n        if (tokenMatch.length > 0) {\r\n            token = tokenMatch[0];\r\n            tokenType = 'monom';\r\n        }\r\n        // It's an operation !\r\n        else if (expr[start].match(/[+\\-*/^]/g)) {\r\n            token = expr[start];\r\n            tokenType = 'operation';\r\n        }\r\n        // It's an opening parenthese\r\n        else if (expr[start] === '(') {\r\n            token = '(';\r\n            tokenType = '(';\r\n        }\r\n        // It's a closing parenthese\r\n        else if (expr[start] === ')') {\r\n            token = ')';\r\n            tokenType = ')';\r\n        }\r\n        // It's an argument separator for a function\r\n        else if (expr[start] === ',') {\r\n            token = ',';\r\n            tokenType = 'function-argument';\r\n        }\r\n        // It's a (basic) trigonometry function\r\n        else if (expr.match(/^(sin|cos|tan)/g)) {\r\n            token = ')';\r\n            tokenType = ')';\r\n        }\r\n            // TODO: Add other functions !\r\n\r\n        // It's a monom.\r\n        else {\r\n            // TODO: Actually, negative exposant aren't supported.\r\n            // token = (expr.substr(start).match(/^[\\da-z\\^]+/g)[0])||'';\r\n            token = tokenMatch[0];\r\n            tokenType = 'monom';\r\n\r\n            if (token === '') {\r\n                token = expr[start];\r\n                tokenType = 'monom';\r\n                console.log('SHUTING YARD - NEXT TOKEN: error at ', start);\r\n            }\r\n        }\r\n\r\n\r\n        // console.log(token, start + token.length, tokenType);\r\n        return [token, start + token.length, tokenType];\r\n    }\r\n\r\n    /**\r\n     * Sanitize an expression by adding missing common operation (multiplication between parentheseses)\r\n     * @param expr\r\n     * @constructor\r\n     */\r\n    Uniformizer(expr: string): string {\r\n        let expr2;\r\n        // Replace missing multiplication between two parenthese\r\n        expr2 = expr.replace(/\\)\\(/g, ')*(');\r\n\r\n        // Replace missing multiplication between number or setLetter and parenthese.\r\n        expr2 = expr2.replace(/([\\da-z])(\\()/g, \"$1*$2\");\r\n        expr2 = expr2.replace(/(\\))([\\da-z])/g, \"$1*$2\");\r\n\r\n        // TODO: must handle trigonometric or any other function identifier\r\n        return expr2;\r\n    }\r\n\r\n    /**\r\n     * Parse an expression using the shutting yard tree algorithms\r\n     * @param expr (string) Expression to analyse\r\n     * Returns a RPN list of items.\r\n     */\r\n    parse(expr: string): Shutingyard {\r\n        let outQueue: string[] = [],\r\n            opStack: string[] = [],\r\n            precedence: { [Key: string]: number } = {\r\n                '^': 4,\r\n                '*': 3,\r\n                '/': 3,\r\n                '+': 2,\r\n                '-': 2\r\n            },\r\n            associative: { [Key: string]: string } = {\r\n                '^': 'right',\r\n                '*': 'left',\r\n                '/': 'left',\r\n                '+': 'left',\r\n                '-': 'left'\r\n            },\r\n            token: string = '',\r\n            tokenPos: number = 0,\r\n            tokenType: string = '';\r\n\r\n        expr = this.Uniformizer(expr);\r\n\r\n        let securityLoopLvl1 = 50,\r\n            securityLoopLvl2_default = 50,\r\n            securityLoopLvl2;\r\n\r\n        while (tokenPos < expr.length) {\r\n            securityLoopLvl1--;\r\n            if (securityLoopLvl1 === 0) {\r\n                console.log('SECURITY LEVEL 1 EXIT');\r\n                break;\r\n            }\r\n\r\n            // Get the next token and the corresponding new (ending) position\r\n            [token, tokenPos, tokenType] = this.NextToken(expr, tokenPos);\r\n\r\n            switch (tokenType) {\r\n                case 'monom':\r\n                    outQueue.push(token);\r\n                    break;\r\n                case 'operation':\r\n                    //If the token is an operator, o1, then:\r\n\r\n                    if (opStack.length > 0) {\r\n                        let opTop = opStack[opStack.length - 1];\r\n\r\n                        securityLoopLvl2 = +securityLoopLvl2_default;\r\n\r\n                        //while there is an operator token o2, at the top of the operator stack and\r\n                        while (opTop in associative && (\r\n                                //either o1 is left-associative and its precedence is less than or equal to that of o2,\r\n                                (associative[token] === 'left' && precedence[token] <= precedence[opTop])\r\n                                ||\r\n                                //or o1 is right associative, and has precedence less than that of o2,\r\n                                (associative[token] === 'right' && precedence[token] < precedence[opTop])\r\n                            )\r\n                            ) {\r\n\r\n                            /* Security exit ! */\r\n                            securityLoopLvl2--;\r\n                            if (securityLoopLvl2 === 0) {\r\n                                console.log('SECURITY LEVEL 2 OPERATION EXIT');\r\n                                break;\r\n                            }\r\n\r\n                            // Add the operation to the queue\r\n                            outQueue.push((opStack.pop()) || '');\r\n\r\n                            // Get the next operation on top of the Stack.\r\n                            opTop = opStack[opStack.length - 1];\r\n                        }\r\n                    }\r\n                    //at the end of iteration push o1 onto the operator stack\r\n                    opStack.push(token);\r\n                    break;\r\n                case 'trigo':\r\n                    opStack.push(token);\r\n                    break;\r\n                case 'function-argument':\r\n                    // TODO: check if the opStack exist.\r\n                    securityLoopLvl2 = +securityLoopLvl2_default;\r\n                    while (opStack[opStack.length - 1] !== '(' && opStack.length > 0) {\r\n                        securityLoopLvl2--;\r\n                        if (securityLoopLvl2 === 0) {\r\n                            console.log('SECURITY LEVEL 2 FUNCTION ARGUMENT EXIT');\r\n                            break;\r\n                        }\r\n\r\n                        outQueue.push((opStack.pop()) || '');\r\n                    }\r\n                    break;\r\n                case '(':\r\n                    opStack.push(token);\r\n                    // Add an empty value if next element is negative.\r\n                    // console.log(token, tokenPos, expr[tokenPos], expr[tokenPos+1]);\r\n                    if(expr[tokenPos]==='-') {\r\n                        outQueue.push('0');\r\n                    }\r\n                    break;\r\n                case ')':\r\n                    securityLoopLvl2 = +securityLoopLvl2_default;\r\n                    //Until the token at the top of the stack is a left parenthesis, pop operators off the stack onto the output queue.\r\n                    while (opStack[opStack.length - 1] !== '(' && opStack.length > 1 /*Maybe zero !? */) {\r\n                        securityLoopLvl2--;\r\n                        if (securityLoopLvl2 === 0) {\r\n                            console.log('SECURITY LEVEL 2 CLOSING PARENTHESE EXIT');\r\n                            break;\r\n                        }\r\n\r\n                        outQueue.push((opStack.pop()) || '');\r\n                    }\r\n\r\n                    //Pop the left parenthesis from the stack, but not onto the output queue.\r\n                    opStack.pop();\r\n                    break;\r\n                default:\r\n                    // In theory, everything should be handled.\r\n                    console.log(`SHUTING YARD: ${tokenType} : ${token} `);\r\n            }\r\n\r\n            // Output\r\n            // console.log(outQueue.concat(opStack.reverse()).join(\" \"));\r\n        }\r\n\r\n        // console.log(outQueue.concat(opStack.reverse()));\r\n        this._rpn = outQueue.concat(opStack.reverse());\r\n\r\n        return this;\r\n    }\r\n\r\n\r\n    // Getter\r\n    get rpn() {\r\n        return this._rpn;\r\n    }\r\n\r\n\r\n}\r\n","import {Fraction} from \"../coefficients/fraction\";\r\nimport {Equation} from \"./equation\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Monom} from \"./monom\";\r\nimport {Polynom} from \"./polynom\";\r\n\r\n\r\nexport class LinearSystem {\r\n    private _solutions: { [letter: string]: { value: Fraction, isReal: boolean, isVarnothing: boolean } };\r\n    private _resolutionSteps: LinearSystem[];\r\n    private _equations: Equation[];\r\n    private _letters: string[];\r\n\r\n    constructor(...equationStrings: string[]) {\r\n        this._equations = [];\r\n        this._letters = 'xy'.split('');\r\n\r\n        if(equationStrings!==undefined && equationStrings.length>0){\r\n            this.parse(...equationStrings);\r\n        }\r\n\r\n        return this;\r\n    }\r\n    get isLinerarSystem(){return true; }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get equations(): Equation[] {\r\n        return this._equations;\r\n    }\r\n\r\n    set equations(value) {\r\n        this._equations = value;\r\n    }\r\n\r\n    get letters(): string {return this._letters.join('')}\r\n\r\n    set letters(value:string){this._letters = value.split('');}\r\n\r\n    get isSolvable(): boolean {\r\n        let V = this.variables;\r\n\r\n        // TODO: in some case, it is possible to resolve systems if there isn't the isSame number of vars and equations\r\n        if (V.length !== this._equations.length) {\r\n            return false;\r\n        }\r\n\r\n        //TOOD: Must check if two equations isn't a linear combination of the others ?\r\n\r\n        return true;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        let V: string[] = [];\r\n        for (let E of this._equations) {\r\n            V = V.concat(E.variables);\r\n        }\r\n        return [...new Set(V)].sort();\r\n    }\r\n\r\n    get tex(): string {\r\n        // Build the array of values.\r\n        // Reorder\r\n        // This clone the system :!!!\r\n        //TODO: Avoid cloning this linear system\r\n        let LS = this.clone().reorder(),\r\n            letters = LS.variables,\r\n            equStr: string[],\r\n            equArray: string[] = [],\r\n            m: Monom;\r\n\r\n        // TODO: Manage tex output of linear equations\r\n        for (let equ of LS.equations) {\r\n            equStr = [];\r\n            for (let L of letters) {\r\n                m = equ.left.monomByLetter(L);\r\n\r\n                if (equStr.length === 0) {\r\n                    equStr.push(m.isZero() ? '' : m.tex);\r\n                } else {\r\n                    equStr.push(m.isZero() ? '' : ((m.coefficient.sign() === 1) ? '+' : '') + m.tex);\r\n                }\r\n            }\r\n\r\n            // Add the equal sign\r\n            equStr.push('=');\r\n\r\n            // Add the right hand part of the equation (should be only a number, because it has been reorderd)\r\n            equStr.push(equ.right.tex);\r\n\r\n            // Add to the list.\r\n            equArray.push(equStr.join('&'));\r\n        }\r\n\r\n\r\n        return `\\\\left\\\\{\\\\begin{array}{${\"r\".repeat(letters.length)}cl}${equArray.join('\\\\\\\\\\ ')}\\\\end{array}\\\\right.`;\r\n        //return `\\\\left\\\\{\\\\begin{array}{rrrcl}${this._equations.map(equ => `${equ.tex}`).join('\\\\\\\\\\ \\n')}\\\\end{array}\\\\right.`;\r\n    }\r\n\r\n    get texSolution(): string {\r\n        let tex: string[] = [];\r\n\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n\r\n        for (let letter in this._solutions) {\r\n            if (this._solutions[letter].isReal) {\r\n                console.log(`Undetermined (letter ${letter})`);\r\n                return;\r\n            }\r\n            if (this._solutions[letter].isVarnothing) {\r\n                console.log(`Undefined (letter ${letter})`);\r\n                return;\r\n            }\r\n\r\n            tex.push(this._solutions[letter].value.dfrac);\r\n        }\r\n        return `(${tex.join(';')})`;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (...equations: any[]): LinearSystem => {\r\n        this._equations = equations.map(value => new Equation(value));\r\n        this._findLetters();\r\n        return this;\r\n    };\r\n\r\n    setCoefficient = (...coefficients: string[]): LinearSystem => {\r\n        // Reset the equations list\r\n        this._equations = [];\r\n\r\n        let i = 0;\r\n        while (i < coefficients.length - this._letters.length) {\r\n            let left = new Polynom().parse(this._letters.join(''), ...coefficients.slice(i, i + this._letters.length)),\r\n                right = new Polynom(coefficients[i + this._letters.length].toString()),\r\n                equ = new Equation().create(left, right);\r\n            this._equations.push(equ.clone());\r\n\r\n            i = i + this._letters.length + 1;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    clone = (): LinearSystem => {\r\n        return new LinearSystem().parse(...this._equations.map(equ => equ.clone()));\r\n    };\r\n\r\n    setLetters = (...letters:string[]): LinearSystem => {\r\n        this._letters = letters;\r\n        return this\r\n    }\r\n    private _findLetters = (): LinearSystem => {\r\n        // Find all letters used.\r\n        let variables = new Set();\r\n\r\n        for(let equ of this._equations){\r\n            variables = new Set([...variables, ...equ.variables]);\r\n        }\r\n\r\n        // TODO: How to transform (Set of string) to string[]\r\n        // @ts-ignore\r\n        this._letters = [...variables];\r\n        return this;\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations generators and randomizers\r\n    // -----------------------------------------------\r\n    generate = (...solutions: Fraction[] | number[]): LinearSystem => {\r\n        let solutionsF: Fraction[] = [];\r\n\r\n        // Convert the numbers to fractions if necessary\r\n        for (let s of solutions) {\r\n            if (typeof s === \"number\") {\r\n                solutionsF.push(new Fraction(s.toString()));\r\n            } else {\r\n                solutionsF.push(s.clone());\r\n            }\r\n        }\r\n\r\n        // Create the equations and make sure they are not linear combined.\r\n        this._equations = [];\r\n        for (let i = 0; i < solutions.length; i++) {\r\n            this._equations.push(this._generateOneEquation(...solutionsF));\r\n        }\r\n        return this;\r\n    };\r\n    private _generateOneEquation = (...solutions: Fraction[]): Equation => {\r\n        let coeff: number[] = [], leftValue: Fraction = new Fraction().zero(),\r\n            letters: string[] = ['x', 'y', 'z', 't', 'u', 'v', 'w', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l'],\r\n            equString: string = '', equ: Equation;\r\n        for (let i = 0; i < solutions.length; i++) {\r\n            coeff.push(Numeric.randomIntSym(5));\r\n            leftValue.add(solutions[i].clone().multiply(coeff[i]));\r\n            equString += `${(coeff[i] < 0) ? coeff[i] : '+' + coeff[i]}${letters[i]}`\r\n        }\r\n\r\n        // LeftValue contains the left part oof the equation - and is then the isSame as the right part.\r\n        // It might be a Fraction.\r\n\r\n        // Must check if it's not a linear combination\r\n        equ = new Equation(`${equString}=${leftValue.display}`);\r\n        if (equ.right.monoms[0].coefficient.denominator != 1) {\r\n            equ.multiply(new Fraction(equ.right.monoms[0].coefficient.denominator, 1));\r\n        }\r\n        if (this._checkIfLinerCombination(equ)) {\r\n            return equ;\r\n        } else {\r\n            return this._generateOneEquation(...solutions);\r\n        }\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    private _linearReduction(eq1: Equation, eq2: Equation, letter: string): Equation {\r\n        // TODO: handle other signs for equations ?\r\n        // Get the monom for the particular letter.\r\n        let c1 = eq1.left.monomByDegree(1, letter).coefficient.clone(),\r\n            c2 = eq2.left.monomByDegree(1, letter).coefficient.clone().opposed();\r\n\r\n        return this.mergeEquations(eq1, eq2, c2, c1);\r\n    }\r\n\r\n    mergeEquations = (eq1: Equation, eq2: Equation, factor1: any, factor2: any):Equation => {\r\n        // Set and clone the equations.\r\n\r\n        let eq1multiplied = eq1.clone().multiply(new Fraction(factor1)),\r\n            eq2multiplied = eq2.clone().multiply(new Fraction(factor2));\r\n\r\n        // Add both equations together.\r\n        eq1multiplied.left.add(eq2multiplied.left);\r\n        eq1multiplied.right.add(eq2multiplied.right);\r\n\r\n        return eq1multiplied;\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Solvers algorithm\r\n    // ------------------------------------------\r\n    reorder = (): LinearSystem => {\r\n        for (let E of this._equations) {\r\n            E.reorder();\r\n        }\r\n        return this;\r\n    };\r\n\r\n    solve = (): LinearSystem => {\r\n        // Solve it by linear\r\n        this._solutions = {};\r\n        this._resolutionSteps = [];\r\n\r\n        // Reorder all equations.\r\n        this.reorder();\r\n\r\n        // Get all variables in the linear system\r\n        let V = this.variables.sort();\r\n\r\n        for (let letter of V) {\r\n            this._solutions[letter] = this._solveOneLetter(letter, V)\r\n        }\r\n\r\n        // TODO: LinearSystem - solve: optimization and handle undetermined and undefined systems.\r\n        return this;\r\n    };\r\n\r\n    private _checkIfLinerCombination = (equ: Equation): boolean => {\r\n\r\n        return true;\r\n    };\r\n\r\n    private _solveOneLetter(letter: string, V: string[]): { value: Fraction, isReal: boolean, isVarnothing: boolean } {\r\n        // list of equations.\r\n        let LE: Equation[] = this.clone().equations,\r\n            reducedEquations: Equation[] = [];\r\n\r\n        // Reduce the equations.\r\n        // Do it as long as there is more than one step, but no more than the number of equations.\r\n        for (let L of V) {\r\n            // remove the setLetter from all equations using linear combinations\r\n            if (L === letter) {\r\n                continue;\r\n            }\r\n\r\n            // Linear reduction.\r\n            // TODO: Search for better association\r\n            for (let i = 0; i < LE.length - 1; i++) {\r\n                reducedEquations.push(this._linearReduction(LE[i], LE[i + 1], L));\r\n            }\r\n\r\n            // Keep track of each steps.\r\n            this._resolutionSteps.push(new LinearSystem().parse(...reducedEquations));\r\n\r\n            // Set the list of equations to the new version.\r\n            LE = this._resolutionSteps[this._resolutionSteps.length - 1].clone().equations;\r\n\r\n            // Reset the stack\r\n            reducedEquations = [];\r\n        }\r\n\r\n        // Solve the equations\r\n        let E = this._resolutionSteps[this._resolutionSteps.length - 1].equations[0];\r\n        E.solve();\r\n\r\n        return {\r\n            value: new Fraction(E.solutions[0]),\r\n            isReal: E.isReal,\r\n            isVarnothing: E.isVarnothing\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Helpers\r\n    // ------------------------------------------\r\n    log = (): string => {\r\n        let str: string = '';\r\n\r\n        for (let E of this._equations) {\r\n            console.log(E.tex);\r\n            str += `${E.tex}\\\\n}`;\r\n        }\r\n\r\n        return str;\r\n    };\r\n}","/**\r\n * Polynom module contains everythin necessary to handle polynoms.\r\n * @module Polynom\r\n */\r\n\r\nimport {Polynom} from \"./polynom\";\r\n\r\n/**\r\n * Rational class can handle rational polynoms\r\n */\r\nexport class Rational {\r\n    private _rawString: string;\r\n    private _numerator: Polynom;\r\n    private _denominator: Polynom;\r\n\r\n    /**\r\n     *\r\n     * @param {string} polynomString (optional) Default polynom to parse on class creation\r\n     */\r\n    constructor(numerator?: Polynom, denominator?: Polynom) {\r\n        this._numerator = numerator?numerator.clone():new Polynom();\r\n        this._denominator = denominator?denominator.clone():new Polynom();\r\n    }\r\n\r\n\r\n\r\n\r\n    get tex(): string {\r\n        return `\\\\dfrac{ ${this._numerator.tex} }{ ${this._denominator.tex} }`;\r\n    }\r\n}","import {Point} from \"./point\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Vector} from \"./vector\";\r\nimport {Line} from \"./line\";\r\n\r\ninterface remarquableLines {\r\n    'medianes': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    },\r\n    'mediators': {\r\n        'AB': Line,\r\n        'AC': Line,\r\n        'BC': Line,\r\n        'intersection': Point\r\n    },\r\n    'heights': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    },\r\n    'bissectors': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    }\r\n}\r\n\r\nexport class Triangle {\r\n    private _A: Point;\r\n    private _B: Point;\r\n    private _C: Point;\r\n    private _lines: {\r\n        'AB': Line,\r\n        'AC': Line,\r\n        'BC': Line\r\n    };\r\n    private _middles: {\r\n        'AB': Point,\r\n        'AC': Point,\r\n        'BC': Point\r\n    };\r\n    private _remarquables: remarquableLines;\r\n\r\n\r\n    constructor(...values: any) {\r\n\r\n        if (values.length > 0) {\r\n            this.parse(...values);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setters\r\n    // ------------------------------------------\r\n    get AB(): Vector {\r\n        return this.getSegment('A', 'B');\r\n    }\r\n\r\n    get BA(): Vector {\r\n        return this.getSegment('B', 'A');\r\n    }\r\n\r\n    get BC(): Vector {\r\n        return this.getSegment('B', 'C');\r\n    }\r\n\r\n    get CB(): Vector {\r\n        return this.getSegment('C', 'B');\r\n    }\r\n\r\n    get AC(): Vector {\r\n        return this.getSegment('A', 'C');\r\n    }\r\n\r\n    get CA(): Vector {\r\n        return this.getSegment('C', 'A');\r\n    }\r\n\r\n    get isRectangle(): boolean {\r\n        if (this.AB.isNormalTo(this.BC)) {\r\n            return true;\r\n        }\r\n        if (this.AB.isNormalTo(this.AC)) {\r\n            return true;\r\n        }\r\n        if (this.BC.isNormalTo(this.AC)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    get isEquilateral(): boolean {\r\n        return this.AB.normSquare.isEqual(this.BC.normSquare) &&\r\n            this.AB.normSquare.isEqual(this.AC.normSquare);\r\n    }\r\n\r\n    get isIsocele(): boolean {\r\n        return this.AB.normSquare.isEqual(this.BC.normSquare) ||\r\n            this.AB.normSquare.isEqual(this.AC.normSquare) ||\r\n            this.BC.normSquare.isEqual(this.AC.normSquare)\r\n    }\r\n\r\n    get lines(): { 'AB': Line, 'BC': Line, 'AC': Line } {\r\n        return this._lines;\r\n    }\r\n\r\n    get remarquables(): remarquableLines {\r\n        return this._remarquables;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Parse values to a triangle. Supported formats:\r\n     * Point, Point, Point\r\n     * x1, y1, x2, y2, x3, y3\r\n     * TODO: Something else ?\r\n     * @param values\r\n     */\r\n    parse = (...values: any): Triangle => {\r\n        if (values.length === 6) {\r\n            // Check if all values are number or fractions.\r\n            let v = values.map((x: any) => new Fraction(x));\r\n            return this.parse(\r\n                new Point(v[0], v[1]),\r\n                new Point(v[2], v[3]),\r\n                new Point(v[4], v[5]),\r\n            )\r\n        } else if (values.length === 3) {\r\n            // At least, one of the value is not a point.\r\n            if (values.reduce((x: any) => x.isPoint === true).length < 3) {\r\n                return this.parse(\r\n                    new Point(values[0]),\r\n                    new Point(values[1]),\r\n                    new Point(values[2])\r\n                )\r\n            }\r\n\r\n            // We have three points.\r\n            this._A = values[0].clone();\r\n            this._B = values[1].clone();\r\n            this._C = values[2].clone();\r\n        } else if (values.length === 1) {\r\n            if (values[0].isTriangle === true) {\r\n                return values[0].clone();\r\n            }\r\n        }\r\n\r\n        this._updateTriangle();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clone the Triangle class\r\n     */\r\n    clone = (): Triangle => {\r\n        this._A = this._A.clone();\r\n        this._B = this._B.clone();\r\n        this._C = this._C.clone();\r\n\r\n        this._updateTriangle();\r\n        return this;\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Triangle operations and properties\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Generate the Line object for the three segments of the triangle\r\n     */\r\n    private _updateTriangle = () => {\r\n        this._lines = {\r\n            'AB': new Line(this._A, this._B),\r\n            'BC': new Line(this._B, this._C),\r\n            'AC': new Line(this._A, this._C)\r\n        };\r\n\r\n        this._middles = {\r\n            'AB': new Point().middleOf(this._A, this._B),\r\n            'AC': new Point().middleOf(this._A, this._C),\r\n            'BC': new Point().middleOf(this._B, this._C)\r\n        }\r\n\r\n        this._remarquables = this._calculateRemarquableLines();\r\n    }\r\n\r\n\r\n    /**\r\n     * Get the Point class for the given name\r\n     * @param ptName\r\n     */\r\n    private getPointByName = (ptName: string): Point => {\r\n        switch (ptName.toUpperCase()) {\r\n            case 'A':\r\n                return this._A;\r\n            case 'B':\r\n                return this._B;\r\n            case 'C':\r\n                return this._C;\r\n        }\r\n\r\n        // Something went wrong ! Return the first point\r\n        return this._A;\r\n    }\r\n    /**\r\n     * Get the vector for the segment given by name.\r\n     * @param ptName1\r\n     * @param ptName2\r\n     */\r\n    private getSegment = (ptName1: string, ptName2: string): Vector => {\r\n        return new Vector(\r\n            this.getPointByName(ptName1),\r\n            this.getPointByName(ptName2)\r\n        );\r\n    }\r\n\r\n    private _calculateRemarquableLines = (): remarquableLines => {\r\n\r\n        // TODO: How to handle the best the bissectors lines ?\r\n\r\n        let barycenter = new Point(\r\n            (this.AB.norm*this._C.x.value + this.AC.norm*this._B.x.value + this.BC.norm*this._A.x.value)/(this.AB.norm+this.AC.norm+this.BC.norm),\r\n            (this.AB.norm*this._C.y.value + this.AC.norm*this._B.y.value + this.BC.norm*this._A.y.value)/(this.AB.norm+this.AC.norm+this.BC.norm)\r\n        )\r\n\r\n        let remarquables: remarquableLines = {\r\n            'medianes': {\r\n                'A': new Line(this._A, this._middles.BC),\r\n                'B': new Line(this._B, this._middles.AC),\r\n                'C': new Line(this._C, this._middles.AB),\r\n                'intersection': null\r\n            },\r\n            'mediators': {\r\n                'AB': new Line(this._middles.AB, new Vector(this._A, this._B).normal()),\r\n                'AC': new Line(this._middles.AC, new Vector(this._A, this._C).normal()),\r\n                'BC': new Line(this._middles.BC, new Vector(this._B, this._C).normal()),\r\n                'intersection': null\r\n            },\r\n            'heights': {\r\n                'A': new Line(this._A, new Vector(this._B, this._C).normal()),\r\n                'B': new Line(this._B, new Vector(this._A, this._C).normal()),\r\n                'C': new Line(this._C, new Vector(this._A, this._B).normal()),\r\n                'intersection': null\r\n            },\r\n            'bissectors': {\r\n                'A': new Line(this._A, barycenter),\r\n                'B': new Line(this._B, barycenter),\r\n                'C': new Line(this._C, barycenter),\r\n                'intersection': barycenter\r\n            }\r\n        }\r\n\r\n        // As it's a triangle, we assume the lines are intersecting and aren't parallel or superposed.\r\n        remarquables.medianes.intersection = remarquables.medianes.A.intersection(remarquables.medianes.B).point;\r\n        remarquables.mediators.intersection = remarquables.mediators.AB.intersection(remarquables.mediators.BC).point;\r\n        remarquables.heights.intersection = remarquables.heights.A.intersection(remarquables.heights.B).point;\r\n        // remarquables.bissectors.intersection = remarquables.bissectors.A.intersection(remarquables.bissectors.B).point;\r\n\r\n        // Everything was calculated for the remaruqable lines.\r\n        return remarquables;\r\n    }\r\n}"],"sourceRoot":""}