{"version":3,"file":"pimath.min.js","mappings":"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M,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAA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","sources":["webpack://pimath/./src/maths/algebra/equation.ts","webpack://pimath/./src/maths/algebra/linearSystem.ts","webpack://pimath/./src/maths/algebra/logicalset.ts","webpack://pimath/./src/maths/algebra/monom.ts","webpack://pimath/./src/maths/algebra/polynom.ts","webpack://pimath/./src/maths/algebra/rational.ts","webpack://pimath/./src/maths/algebra/study.ts","webpack://pimath/./src/maths/algebra/study/rationalStudy.ts","webpack://pimath/./src/maths/coefficients/fraction.ts","webpack://pimath/./src/maths/coefficients/nthRoot.ts","webpack://pimath/./src/maths/geometry/circle.ts","webpack://pimath/./src/maths/geometry/line.ts","webpack://pimath/./src/maths/geometry/point.ts","webpack://pimath/./src/maths/geometry/triangle.ts","webpack://pimath/./src/maths/geometry/vector.ts","webpack://pimath/./src/maths/numeric.ts","webpack://pimath/./src/maths/numexp.ts","webpack://pimath/./src/maths/randomization/random.ts","webpack://pimath/./src/maths/randomization/randomCore.ts","webpack://pimath/./src/maths/randomization/rndFraction.ts","webpack://pimath/./src/maths/randomization/rndGeometryLine.ts","webpack://pimath/./src/maths/randomization/rndGeometryPoint.ts","webpack://pimath/./src/maths/randomization/rndHelpers.ts","webpack://pimath/./src/maths/randomization/rndMonom.ts","webpack://pimath/./src/maths/randomization/rndPolynom.ts","webpack://pimath/./src/maths/shutingyard.ts","webpack://pimath/webpack/bootstrap","webpack://pimath/./src/index.ts"],"sourcesContent":["import {Polynom} from \"./polynom\";\r\nimport {literalType, Monom} from \"./monom\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {NthRoot} from \"../coefficients/nthRoot\";\r\n\r\n/**\r\n * Equation is a class to manage equations...\r\n */\r\nexport interface ISolution {\r\n    tex: string,\r\n    display: string,\r\n    value: number,\r\n    exact: unknown\r\n}\r\n\r\nexport enum PARTICULAR_SOLUTION {\r\n    real=\"\\\\mathbb{R}\",\r\n    varnothing=\"\\\\varnothing\"\r\n}\r\n\r\nexport class Equation {\r\n    private _polynom: Polynom;  // Used to solve the equation // TODO: remove the private value ?\r\n\r\n    // Undetermined texSolutions.\r\n    private _varnothing: string = PARTICULAR_SOLUTION.varnothing;\r\n    private _real: string = PARTICULAR_SOLUTION.real;\r\n\r\n    /**\r\n     * Create an Equation using two polynoms.\r\n     * Markdown *support* is cool\r\n     * @param equations\r\n     */\r\n    constructor(...equations: unknown[]) {\r\n        // Default equation\r\n        this._left = new Polynom().zero();\r\n        this._right = new Polynom().zero();\r\n        this._sign = '=';\r\n\r\n        if (equations.length === 1) {\r\n            if (equations[0] instanceof Equation) {\r\n                return equations[0].clone();\r\n            } else if (typeof equations[0] === 'string') {\r\n                this.parse(equations[0]);\r\n            }\r\n        } else if (equations.length === 2) {\r\n            if (equations[0] instanceof Polynom) {\r\n                this.left = equations[0].clone()\r\n            } else if (typeof equations[0] === 'string') {\r\n                this.left = new Polynom(equations[0])\r\n            }\r\n\r\n            if (equations[1] instanceof Polynom) {\r\n                this.right = equations[1].clone()\r\n            } else if (typeof equations[1] === 'string') {\r\n                this.right = new Polynom(equations[1])\r\n            }\r\n        } else {\r\n            // Return default empty equation\r\n            return this;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _left: Polynom;  // Left part of the equation\r\n\r\n    get left(): Polynom {\r\n        return this._left;\r\n    }\r\n\r\n    set left(value: Polynom) {\r\n        this._left = value;\r\n    }\r\n\r\n    private _right: Polynom; // Right part of the equation\r\n\r\n    get right(): Polynom {\r\n        return this._right;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n\r\n    set right(value: Polynom) {\r\n        this._right = value;\r\n    }\r\n\r\n    private _sign: string;   // Signe of the equation, by default =\r\n\r\n    get sign(): string {\r\n        return this._sign;\r\n    }\r\n\r\n    set sign(value: string) {\r\n        // Set the sign value as formatted.\r\n        this._sign = this._formatSign(value);\r\n    }\r\n\r\n    private _solutions: ISolution[]\r\n\r\n    // ------------------------------------------\r\n    get solutions(): ISolution[] {\r\n        return this._solutions\r\n    }\r\n\r\n    get isEquation() {\r\n        return true;\r\n    }\r\n\r\n    get solution(): string {\r\n        if (this._solutions.length === 1\r\n            &&\r\n            (\r\n                this._solutions[0].tex === this._real\r\n                || this._solutions[0].tex === this._varnothing\r\n                || this._solutions[0].tex.includes('\\\\left')\r\n            )\r\n        ) {\r\n            return `S = ${this._solutions[0]}`;\r\n        }\r\n        return `S = \\\\left{ ${this._solutions.map(x => x.tex).join(';')} \\\\right}`;\r\n    }\r\n\r\n    get isReal(): boolean {\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n        return this._solutions[0].tex === this._real;\r\n    }\r\n\r\n    get isVarnothing(): boolean {\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n        return this._solutions[0].tex === this._varnothing;\r\n    }\r\n\r\n    get signAsTex(): string {\r\n        if (this._sign === '>=' || this._sign === '=>' || this._sign === 'geq') {\r\n            return '\\\\geq';\r\n        }\r\n        if (this._sign === '<=' || this._sign === '=<' || this._sign === 'leq') {\r\n            return '\\\\leq';\r\n        }\r\n        return this._sign;\r\n    }\r\n\r\n    get tex(): string {\r\n        return `${this._left.tex}${this.signAsTex}${this._right.tex}`;\r\n    }\r\n\r\n    get display(): string {\r\n        return `${this._left.display}${this.signAsTex}${this._right.display}`;\r\n    }\r\n\r\n    get raw(): string {\r\n        return `${this._left.raw}${this.signAsTex}${this._right.raw}`;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        return [...new Set(this._right.variables.concat(this._left.variables))];\r\n    }\r\n\r\n    get numberOfVars(): number {\r\n        return this.variables.length;\r\n    }\r\n\r\n    hasVariable = (letter: string): boolean => {\r\n        return this.variables.includes(letter)\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n\r\n    // -----------------------------------------------\r\n    private _randomizeDefaults: { [key: string]: number | string | boolean } = {\r\n        degree: 2\r\n    };\r\n\r\n    get randomizeDefaults(): { [key: string]: number | string | boolean } {\r\n        return this._randomizeDefaults;\r\n    }\r\n\r\n    set randomizeDefaults(value) {\r\n        this._randomizeDefaults = value;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    parse = (equationString: string): Equation => {\r\n        let pStr: string[], strSign: string | false;\r\n        // Find the string separator\r\n        strSign = this._findSign(equationString);\r\n\r\n        if (strSign === false) {\r\n            console.error('The equation is not valid (no sign found)');\r\n            return;\r\n        }\r\n\r\n        // The StrSign is found\r\n        pStr = equationString.split(strSign);\r\n\r\n        return this.create(new Polynom(pStr[0]), new Polynom(pStr[1]), this._formatSign(strSign));\r\n    };\r\n\r\n    create = (left: Polynom, right: Polynom, sign?: string): Equation => {\r\n        this._left = left;\r\n        this._right = right;\r\n        this._sign = this._formatSign(sign);\r\n        return this;\r\n    };\r\n\r\n    clone = (): Equation => {\r\n        return new Equation().create(this._left.clone(), this._right.clone(), this._sign + '');\r\n    };\r\n\r\n    // -----------------------------------------------\r\n    // Equations generators and randomizers\r\n\r\n    randomize = (opts?: {}, sign?: string): Equation => {\r\n        // TODO: Generate equations randomly, using config.\r\n        return new Equation().create(new Polynom(), new Polynom(), sign);\r\n    };\r\n\r\n    // -----------------------------------------------\r\n    /**\r\n     * Reorder will move all monoms containing a letter on the left, all the other on the right.\r\n     */\r\n    moveLeft = (): Equation => {\r\n        this._left = this._left.clone().subtract(this._right)\r\n        this._right.zero()\r\n        return this;\r\n    }\r\n\r\n    reorder = (allLeft?: boolean): Equation => {\r\n        // Move all monoms of degree greater than 0 to the left.\r\n        // and all zero degree monoms to the right.\r\n        this._left.subtract(this._right);\r\n        this._right.zero();\r\n        this._left.reorder()\r\n\r\n        // we eant all left (so equal zero) : it's done !\r\n        if (allLeft) return this\r\n\r\n        // Fetch all zero degree monoms.\r\n        this._left.monoms\r\n            .filter(m=>m.degree().isZero())\r\n            .forEach(m=> {\r\n                const move = m.clone()\r\n                this._left.subtract(move)\r\n                this._right.subtract(move)\r\n            })\r\n\r\n\r\n        // Reorder the left and right polynoms\r\n        this._left.reorder();\r\n        this._right.reorder();\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Multiply by the lcm denominator and divide by the gcm numerators.\r\n     */\r\n    simplify = (): Equation => {\r\n        this.multiply(Numeric.lcm(...this._left.getDenominators(), ...this._right.getDenominators()));\r\n        this.divide(Numeric.gcd(...this._left.getNumerators(), ...this._right.getNumerators()));\r\n        return this;\r\n    }\r\n\r\n\r\n    // -----------------------------------------------\r\n    // Equations operations\r\n\r\n    /**\r\n     * Reorder the polynom to have only one letter on the left, the rest on the right.\r\n     * @param letter\r\n     */\r\n    isolate = (letter?: string): Equation | false => {\r\n        // Determine if we can isolate the variables.\r\n\r\n        // Both part of the equations must be of the first degree.\r\n        //TODO: handle equations of degree two or more ?\r\n        if (!this.degree(letter).isOne()) {\r\n            return false;\r\n        }\r\n\r\n        // Modify the equation to isolate the asked variable.\r\n        // TODO: must handle equations like 3xy+5y=4 => y = 4/(3x-5)\r\n        if (this.isMultiVariable()) {\r\n            return false;\r\n        }\r\n\r\n        // Isolate the letter.\r\n        let mMove: Monom, cMove: Fraction;\r\n        // Start by moving everything to the left.\r\n        this._left.subtract(this._right);\r\n        this._right.zero();\r\n        let values = [...this._left.monoms]\r\n        for (let m of values) {\r\n            if (!m.hasLetter(letter)) {\r\n                mMove = m.clone();\r\n                this._left.subtract(mMove);\r\n                this._right.subtract(mMove);\r\n            }\r\n        }\r\n\r\n        // In theory, we should have only one item on the left.\r\n        if (this._left.length !== 1) {\r\n            return false;\r\n        }\r\n        cMove = this._left.monoms[0].coefficient.clone();\r\n        this._left.divide(cMove);\r\n        this._right.divide(cMove);\r\n        return this;\r\n    };\r\n\r\n    replaceBy = (letter: string, P: Polynom): Equation => {\r\n        this._left.replaceBy(letter, P)\r\n        this._right.replaceBy(letter, P)\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiple an equation by a fraction value.\r\n     * @param value\r\n     */\r\n    multiply = (value: unknown): Equation => {\r\n\r\n        // Make sure we have a fraction.\r\n        let F: Fraction = new Fraction(value);\r\n\r\n        // Multiply each part of the equation by the fraction\r\n        this._left.multiply(F);\r\n        this._right.multiply(F);\r\n\r\n        // The sign of the inequation must be changed.\r\n        if (this._sign !== '=' && F.sign() === -1) {\r\n            this._reverseSign();\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * divide an equation by a given value (transformed as a fraction)\r\n     *\r\n     * ```\r\n     * 8x+10=6x \\vert 2\r\n     * 4x+5=3x\r\n     * ```\r\n     *\r\n     * |>Alternatively with $3x-4$ maybe it's working ?\r\n     * $$\\frac{3x}{5}$$\r\n     *\r\n     * @param value\r\n     * @returns {Equation}\r\n     */\r\n    divide = (value: unknown): Equation => {\r\n        // Make sure we have a fraction.\r\n        let F: Fraction = new Fraction(value);\r\n\r\n        if (F.isZero()) {\r\n            return this;\r\n        } else {\r\n            return this.multiply(F.invert());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the degree of the equation\r\n     * @param letter\r\n     */\r\n    degree = (letter?: string): Fraction => {\r\n        return Fraction.max(this._left.degree(letter), this._right.degree(letter));\r\n    };\r\n\r\n    /**\r\n     * Determine if the equation contains more than one letter/variable.\r\n     */\r\n    isMultiVariable = (): boolean => {\r\n        return this._left.isMultiVariable || this._right.isMultiVariable;\r\n    };\r\n\r\n    letters = (): string[] => {\r\n        // @ts-ignore\r\n        return [...new Set([...this._left.letters(), ...this._right.letters()])];\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations helpers\r\n    // -----------------------------------------------\r\n\r\n    // -----------------------------------------------\r\n    solve = (): Equation => {\r\n        // Initialise the variables:\r\n        this._solutions = [];\r\n\r\n        // TODO: consolidate solving equations (inequations vs equations)\r\n        // TODO: work with not natural degrees ?\r\n        this._polynom = this._left.clone().subtract(this._right);\r\n\r\n        switch (this._polynom.degree().value) {\r\n            case 0:\r\n            case 1:\r\n                this._solveDegree1();\r\n                break;\r\n            case 2:\r\n                this._solveDegree2();\r\n                break;\r\n            default:\r\n                this._solveDegree3plus();\r\n        }\r\n\r\n        // cleanup the solutions.\r\n        this._solutions = Equation.makeSolutionsUnique(this._solutions)\r\n        return this;\r\n    };\r\n\r\n    static makeSolutionsUnique(solutions: ISolution[], sorted?: boolean):ISolution[] {\r\n        let solutionAsTex:string[] = [],\r\n            uniqueSolutions = solutions.filter(sol=>{\r\n                if(!solutionAsTex.includes(sol.tex)){\r\n                    solutionAsTex.push(sol.tex)\r\n                    return true\r\n                }else{\r\n                    return false\r\n                }\r\n            })\r\n\r\n        if(sorted===true){\r\n            uniqueSolutions.sort((a, b)=>a.value-b.value)\r\n        }\r\n        return uniqueSolutions\r\n    }\r\n\r\n    test = (values: literalType): Boolean => {\r\n        return this.left.evaluate(values).isEqual(this.right.evaluate(values))\r\n    }\r\n\r\n    isSameAs = (equ: Equation): Boolean => {\r\n        let p1 = equ.clone().moveLeft().left,\r\n            p2 = this.clone().moveLeft().left\r\n\r\n        // They are the same.\r\n        return p1.isEqual(p2) || p1.isOpposedAt(p2)\r\n    }\r\n    isLinearTo = (equ: Equation): Boolean => {\r\n        // Move all left.\r\n        let p1 = equ.clone().moveLeft().simplify().left,\r\n            p2 = this.clone().moveLeft().simplify().left\r\n\r\n        // They are the same.\r\n        return p1.isEqual(p2) || p1.isOpposedAt(p2)\r\n    }\r\n\r\n    private _findSign = (equationString: string): string | false => {\r\n        let strSign: string = '';\r\n\r\n        if (equationString.includes('geq')) {\r\n            return (equationString.includes('\\\\geq')) ? '\\\\geq' : 'geq';\r\n        } else if (equationString.includes('leq')) {\r\n            return (equationString.includes('\\\\leq')) ? '\\\\leq' : 'leq';\r\n        } else if (equationString.includes('>=')) {\r\n            return '>=';\r\n        } else if (equationString.includes('=>')) {\r\n            return '=>';\r\n        } else if (equationString.includes('>')) {\r\n            return '>';\r\n        } else if (equationString.includes('<=')) {\r\n            return '<=';\r\n        } else if (equationString.includes('=<')) {\r\n            return '=<';\r\n        } else if (equationString.includes('<')) {\r\n            return '<';\r\n        } else if (equationString.includes('=')) {\r\n            return '='\r\n        }\r\n        if (strSign === '') {\r\n            console.log('Equation: parse string : sign not found');\r\n            return false;\r\n        }\r\n    };\r\n\r\n    // -----------------------------------------------\r\n    // Equations solving algorithms\r\n\r\n    private _formatSign = (signStr: string): string => {\r\n        if (signStr === undefined) {\r\n            return '=';\r\n        }\r\n\r\n        if (signStr.includes('geq')) {\r\n            return '>=';\r\n        } else if (signStr.includes('>=')) {\r\n            return '>=';\r\n        } else if (signStr.includes('=>')) {\r\n            return '>=';\r\n        } else if (signStr.includes('>')) {\r\n            return '>';\r\n        } else if (signStr.includes('leq')) {\r\n            return '<=';\r\n        } else if (signStr.includes('<=')) {\r\n            return '<=';\r\n        } else if (signStr.includes('=<')) {\r\n            return '<=';\r\n        } else if (signStr.includes('<')) {\r\n            return '<';\r\n        } else {\r\n            return '='\r\n        }\r\n    };\r\n\r\n    private _reverseSign = (): Equation => {\r\n        if (this._sign === '=') {\r\n            return this;\r\n        }\r\n\r\n        if (this._sign.includes('<')) {\r\n            this._sign.replace('<', '>');\r\n            return this;\r\n        }\r\n        if (this._sign.includes('>')) {\r\n            this._sign.replace('>', '<');\r\n            return this;\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    private isGreater = (): boolean => {\r\n        if (this._sign.indexOf('>') !== -1) {\r\n            return true;\r\n        }\r\n        return this._sign.indexOf('geq') !== -1;\r\n\r\n    };\r\n\r\n    private isStrictEqual = (): boolean => {\r\n        return this._sign === '=';\r\n    };\r\n\r\n    private isAlsoEqual = (): boolean => {\r\n        if (this._sign.indexOf('=') !== -1) {\r\n            return true;\r\n        }\r\n        if (this._sign.indexOf('geq') !== -1) {\r\n            return true;\r\n        }\r\n        if (this._sign.indexOf('leq') !== -1) {\r\n            return true;\r\n        }\r\n    };\r\n\r\n    private _solveDegree1 = (letter?: string): ISolution[] => {\r\n        const m1 = this._polynom.monomByDegree(1, letter).coefficient,\r\n            m0 = this._polynom.monomByDegree(0, letter).coefficient,\r\n            v = m0.clone().opposed().divide(m1);\r\n        let s: string, d: string;\r\n\r\n        if (this.isStrictEqual()) {\r\n            if (m1.value === 0) {\r\n                // In this case, the coefficient of the x variable is zero.\r\n                if (m0.value === 0) {\r\n                    this._solutions = [{\r\n                        tex: this._real,\r\n                        display: \"RR\",\r\n                        value: NaN,\r\n                        exact: false\r\n                    }];\r\n                } else {\r\n                    this._solutions = [{\r\n                        tex: this._varnothing,\r\n                        display: \"O/\",\r\n                        value: NaN,\r\n                        exact: false\r\n                    }];\r\n                }\r\n            } else {\r\n                this._solutions = [{\r\n                    tex: v.tex,\r\n                    display: v.display,\r\n                    value: v.value,\r\n                    exact: v\r\n                }]\r\n            }\r\n        }\r\n        else {\r\n            if (m1.value === 0) {\r\n                // In this case, the coefficient of the x variable is zero.\r\n                if (m0.value === 0 && this.isAlsoEqual()) {\r\n                    s = '\\\\mathbb{R}';\r\n                    d = \"RR\"\r\n                } else {\r\n                    if (m0.value > 0) {\r\n                        s = this.isGreater() ? this._real : this._varnothing;\r\n                        s = this.isGreater() ? \"RR\" : \"O/\";\r\n                    } else {\r\n                        s = !this.isGreater() ? this._real : this._varnothing;\r\n                        s = !this.isGreater() ? \"RR\" : \"O/\";\r\n                    }\r\n                }\r\n            } else {\r\n                // Must handle the case if the m1 monom is negative.\r\n                if ((this.isGreater() && m1.sign() === 1) || (!this.isGreater() && m1.sign() === -1)) {\r\n                    s = `\\\\left${this.isAlsoEqual() ? '[' : ']'}${v.tex};+\\\\infty\\\\right[`;\r\n                    d = `${this.isAlsoEqual() ? '[' : ']'}${v.tex};+oo[`;\r\n                } else {\r\n                    s = `\\\\left]-\\\\infty;${v.tex} \\\\right${this.isAlsoEqual() ? ']' : '['}`;\r\n                    d = `]-oo;${v.tex}${this.isAlsoEqual() ? ']' : '['}`;\r\n                }\r\n            }\r\n            this._solutions = [{\r\n                tex: s,\r\n                display: d,\r\n                value: NaN,\r\n                exact: false\r\n            }];\r\n        }\r\n\r\n        return this._solutions;\r\n    };\r\n\r\n    private _solveDegree2 = (letter?: string): ISolution[] => {\r\n        let aF = this._polynom.monomByDegree(2, letter).coefficient,\r\n            bF = this._polynom.monomByDegree(1, letter).coefficient,\r\n            cF = this._polynom.monomByDegree(0, letter).coefficient,\r\n            delta: number, nthDelta: NthRoot,\r\n            lcm = Numeric.lcm(aF.denominator, bF.denominator, cF.denominator),\r\n            a = aF.multiply(lcm).value,\r\n            b = bF.multiply(lcm).value,\r\n            c = cF.multiply(lcm).value,\r\n            realX1: number, realX2: number,\r\n            sX1: string, sX2: string;\r\n\r\n        delta = b * b - 4 * a * c;\r\n\r\n        if (delta > 0) {\r\n            realX1 = (-b - Math.sqrt(delta)) / (2 * a);\r\n            realX2 = (-b + Math.sqrt(delta)) / (2 * a);\r\n\r\n            if (delta > 1.0e5) {\r\n                // The delta is too big to be parsed !\r\n                let v1 = ((-b - Math.sqrt(delta)) / (2 * a)).toFixed(5),\r\n                    v2 = ((-b + Math.sqrt(delta)) / (2 * a)).toFixed(5)\r\n\r\n                this._solutions = [\r\n                    {\r\n                        tex: v1,\r\n                        display: v1,\r\n                        value: realX1,\r\n                        exact: false\r\n                    },\r\n                    {\r\n                        tex: v2,\r\n                        display: v2,\r\n                        value: realX2,\r\n                        exact: false\r\n                    }\r\n                ]\r\n            } else {\r\n                nthDelta = new NthRoot(delta).reduce();\r\n                if (nthDelta.hasRadical()) {\r\n                    // -b +- coeff\\sqrt{radical}\r\n                    // -------------------------\r\n                    //           2a\r\n                    let gcd = Numeric.gcd(b, 2 * a, nthDelta.coefficient),\r\n                        am = a/gcd, bm = b/gcd\r\n                    nthDelta.coefficient = nthDelta.coefficient / gcd;\r\n\r\n                    if (a < 0) {\r\n                        am = -am\r\n                        bm = -bm\r\n                    }\r\n\r\n                    let tex1 = \"\", tex2 = \"\", display1 = \"\", display2 = \"\"\r\n\r\n                    tex1 = `${bm !== 0 ? ((-bm) + ' - ') : ''}${nthDelta.tex}`\r\n                    tex2 = `${bm !== 0 ? ((-bm) + ' + ') : ''}${nthDelta.tex}`\r\n                    display1 = `${bm !== 0 ? ((-bm) + ' - ') : ''}${nthDelta.display}`\r\n                    display2 = `${bm !== 0 ? ((-bm) + ' + ') : ''}${nthDelta.display}`\r\n\r\n                    if (am !== 1) {\r\n                        tex1 = `\\\\frac{ ${tex1} }{ ${2 * am} }`\r\n                        tex2 = `\\\\frac{ ${tex2} }{ ${2 * am} }`\r\n                    }\r\n\r\n                    this._solutions = [\r\n                        {\r\n                            tex: tex1,\r\n                            display: tex1,\r\n                            value: realX1,\r\n                            exact: false\r\n                        },\r\n                        {\r\n                            tex: tex2,\r\n                            display: tex2,\r\n                            value: realX2,\r\n                            exact: false\r\n                        },\r\n                    ]\r\n\r\n\r\n                    // if (b !== 0) {\r\n                    //     if (2 * a / gcd === 1) {\r\n                    //         this._solutions = [\r\n                    //             {\r\n                    //                 tex: `${-b / gcd} - ${nthDelta.tex}`,\r\n                    //                 value: realX1,\r\n                    //                 exact: false // TODO: implement exact value with nthroot\r\n                    //             },\r\n                    //             {\r\n                    //                 tex: `${-b / gcd} + ${nthDelta.tex}`,\r\n                    //                 value: realX2,\r\n                    //                 exact: false\r\n                    //             },\r\n                    //\r\n                    //         ]\r\n                    //     } else {\r\n                    //         this._solutions = [\r\n                    //             {\r\n                    //                 tex: `\\\\frac{${-b / gcd} - ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                    //                 value: realX1,\r\n                    //                 exact: false\r\n                    //             },\r\n                    //             {\r\n                    //                 tex: `\\\\frac{${-b / gcd} + ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                    //                 value: realX2,\r\n                    //                 exact: false\r\n                    //             },\r\n                    //         ]\r\n                    //     }\r\n                    // } else {\r\n                    //     if (2 * a / gcd === 1) {\r\n                    //         this._solutions = [\r\n                    //             {\r\n                    //                 tex: `- ${nthDelta.tex}`,\r\n                    //                 value: realX1,\r\n                    //                 exact: false\r\n                    //             },\r\n                    //             {\r\n                    //                 tex: `${nthDelta.tex}`,\r\n                    //                 value: realX2,\r\n                    //                 exact: false\r\n                    //             },\r\n                    //         ]\r\n                    //     } else {\r\n                    //         this._solutions = [\r\n                    //             {\r\n                    //                 tex: `\\\\frac{- ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                    //                 value: realX1,\r\n                    //                 exact: false\r\n                    //             },\r\n                    //             {\r\n                    //                 tex: `\\\\frac{${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                    //                 value: realX2,\r\n                    //                 exact: false\r\n                    //             },\r\n                    //         ]\r\n                    //     }\r\n                    // }\r\n                } else {\r\n                    // -b +- d / 2a\r\n                    const S1 = new Fraction(-b - nthDelta.coefficient, 2 * a).reduce(),\r\n                        S2 = new Fraction(-b + nthDelta.coefficient, 2 * a).reduce()\r\n                    this._solutions = [\r\n                        {\r\n                            tex: S1.frac,\r\n                            display: S1.display,\r\n                            value: realX1,\r\n                            exact: S1\r\n                        },\r\n                        {\r\n                            tex: S2.frac,\r\n                            display: S2.display,\r\n                            value: realX2,\r\n                            exact: S2\r\n                        }\r\n                    ]\r\n                }\r\n            }\r\n\r\n        } else if (delta === 0) {\r\n            const sol = new Fraction(-b, 2 * a).reduce()\r\n            this._solutions = [{\r\n                tex: sol.frac,\r\n                display: sol.display,\r\n                value: sol.value,\r\n                exact: sol\r\n            }];\r\n        } else {\r\n            this._solutions = [{\r\n                tex: this._varnothing,\r\n                display: \"O/\",\r\n                value: NaN,\r\n                exact: false\r\n            }];\r\n        }\r\n\r\n        // Handle now the inequations.\r\n        if (!this.isStrictEqual()) {\r\n            if (this._solutions.length === 2) {\r\n                sX1 = (realX1 < realX2) ? this._solutions[0].tex : this._solutions[1].tex;\r\n                sX2 = (realX1 < realX2) ? this._solutions[1].tex : this._solutions[0].tex;\r\n\r\n                if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                    this._solutions = [{\r\n                        tex: `\\\\left]-\\\\infty ; ${sX1}\\\\right${this.isAlsoEqual() ? ']' : '['} \\\\cup \\\\left${this.isAlsoEqual() ? '[' : ']'}${sX2};+\\\\infty\\\\right[`,\r\n                        display: `]-oo;${sX1}${this.isAlsoEqual() ? ']' : '['}uu${this.isAlsoEqual() ? '[' : ']'}${sX2};+oo[`,\r\n                        value: NaN,\r\n                        exact: false\r\n                    }\r\n                    ];\r\n                } else {\r\n                    this._solutions = [{\r\n                        tex: `\\\\left${this.isAlsoEqual() ? '[' : ']'}${sX1} ; ${sX2}\\\\right${this.isAlsoEqual() ? ']' : '['}`,\r\n                        display: `${this.isAlsoEqual() ? '[' : ']'}${sX1};${sX2}${this.isAlsoEqual() ? ']' : '['}`,\r\n                        value: NaN,\r\n                        exact: false\r\n                    }]\r\n                }\r\n            } else if (this._solutions.length === 1 && this._solutions[0].tex !== this._varnothing) {\r\n                if (!this.isAlsoEqual()) {\r\n                    if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                        this._solutions = [{\r\n                            tex: `\\\\left]-\\\\infty ; ${this._solutions[0].tex}\\\\right[ \\\\cup \\\\left]${this._solutions[0].tex};+\\\\infty\\\\right[`,\r\n                            display: `]-oo;${this._solutions[0].tex}[uu]${this._solutions[0].tex};+oo[`,\r\n                            value: NaN,\r\n                            exact: false\r\n                        }\r\n                        ];\r\n                    } else {\r\n                        this._solutions = [{\r\n                            tex: this._varnothing,\r\n                            display: \"O/\",\r\n                            value: NaN,\r\n                            exact: false\r\n                        }];\r\n                    }\r\n                } else {\r\n                    if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                        this._solutions = [{\r\n                            tex: this._real,\r\n                            display: \"RR\",\r\n                            value: NaN,\r\n                            exact: false\r\n                        }];\r\n                    } else {\r\n                        // this._texSolutions = [ this._texSolutions[0] ];\r\n                    }\r\n                }\r\n            } else {\r\n                if (this.isGreater()) {\r\n                    this._solutions = [{\r\n                        tex: aF.sign() === 1 ? this._real : this._varnothing,\r\n                        display: aF.sign() === 1 ? \"RR\" : \"O/\",\r\n                        value: NaN,\r\n                        exact: false\r\n                    }];\r\n                } else {\r\n                    this._solutions = [{\r\n                        tex: aF.sign() === -1 ? this._real : this._varnothing,\r\n                        display: aF.sign() === -1 ? \"RR\" : \"O/\",\r\n                        value: NaN,\r\n                        exact: false\r\n                    }];\r\n                }\r\n            }\r\n        }\r\n        return this._solutions;\r\n    };\r\n\r\n    private _solveDegree3plus = (letter?: string): ISolution[] => {\r\n        // Push everything to the left\r\n        // factorize\r\n        // solve each factors.\r\n        let equ = this.clone().moveLeft()\r\n        equ.left.factorize()\r\n\r\n        this._solutions = []\r\n\r\n        equ.left.factors.forEach(factor=>{\r\n            if(factor.degree(letter).leq(2)) {\r\n                let factorAsEquation = new Equation(factor, 0)\r\n                factorAsEquation.solve()\r\n                factorAsEquation.solutions.forEach(solution => {\r\n                    this._solutions.push(solution)\r\n                })\r\n            }else{\r\n                console.log(factor.tex, ': cannot actually get the solution of this equation')\r\n            }\r\n        })\r\n\r\n        // TODO: check equation resolution for more than degree 2\r\n        // this._solutions = [{tex: 'solve x - not yet handled', value: NaN, exact: false}];  // ESLint remove system :(\r\n        return this._solutions;\r\n    };\r\n}","import {Equation, ISolution} from \"./equation\";\r\nimport {Monom} from \"./monom\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Polynom} from \"./polynom\";\r\nimport {Numeric} from \"../numeric\";\r\n\r\n// TODO: Must check and rework\r\nexport class LinearSystem {\r\n    // Stores the original equations\r\n    private _equations: Equation[];\r\n    // Determine the letters in the linear system, usually ['x', 'y']\r\n    private _letters: string[];\r\n    // Resolution steps contains each steps\r\n    // letter : target letter\r\n    // steps: {system: current LinearSystem, operations: [*3,/5] or [[*3,*2], [,*5], [*2,]]}\r\n    private _resolutionSteps: {\r\n        [key: string]: {\r\n            equations: Equation[],\r\n            operations: (string[])[]\r\n        }[]\r\n    };\r\n    // Get the solution of the equation\r\n    private _solutions: { [letter: string]: ISolution };\r\n\r\n    constructor(...equationStrings: (string | Equation)[]) {\r\n        // TODO: allow construction to accept an array of values (like a matrix) to build the equations\r\n        this._equations = [];\r\n        this._letters = 'xyz'.split('');\r\n\r\n        if (equationStrings !== undefined && equationStrings.length > 0) {\r\n            this.parse(...equationStrings);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get equations(): Equation[] {\r\n        return this._equations;\r\n    }\r\n\r\n    set equations(value) {\r\n        this._equations = value;\r\n    }\r\n\r\n    get letters(): string {\r\n        return this._letters.join('')\r\n    }\r\n\r\n    set letters(value: string) {\r\n        this._letters = value.split('');\r\n    }\r\n\r\n    get isSolvable(): boolean {\r\n        let V = this.variables;\r\n\r\n        // TODO: in some case, it is possible to resolve systems if there isn't the isSame number of vars and equations\r\n        if (V.length !== this._equations.length) {\r\n            return false;\r\n        }\r\n\r\n        //TODO: Must check if two equations isn't a linear combination of the others ?\r\n\r\n        return true;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        return this._letters\r\n    }\r\n\r\n    get tex(): string {\r\n        // Build the array of values.\r\n        // Reorder\r\n        // This clone the system :!!!\r\n        //TODO: Avoid cloning this linear system\r\n        let LS = this.clone().reorder(),\r\n            letters = LS.variables\r\n\r\n        return this.buildTex(LS.equations)\r\n    }\r\n\r\n    get solution(): string {\r\n        let tex: string[] = [];\r\n\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n\r\n        for (let letter in this._solutions) {\r\n            if (this._solutions[letter].display === \"RR\") {\r\n                return `\\\\left\\\\{ \\\\left(${this._letters.join(';')}\\\\right) \\\\big\\\\vert ${this.equations[0].tex} \\\\right\\\\}`;\r\n            }\r\n            if (this._solutions[letter].display === \"O/\") {\r\n                return `\\\\varnothing`\r\n            }\r\n\r\n            tex.push(this._solutions[letter].tex);\r\n        }\r\n        return `\\\\left(${tex.join(';')}\\\\right)`;\r\n    }\r\n\r\n    get solutionAsDisplay(): string {\r\n        let display: string[] = [];\r\n\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n\r\n        for (let letter in this._solutions) {\r\n            if (this._solutions[letter].display === \"RR\") {\r\n                return `{(${this._letters.join(';')}) | ${this.equations[0].display} }`;\r\n            }\r\n            if (this._solutions[letter].display === \"O/\") {\r\n                return \"O/\"\r\n            }\r\n\r\n            display.push(this._solutions[letter].display);\r\n        }\r\n        return `(${display.join(';')})`;\r\n    }\r\n\r\n    buildTex = (equations: Equation[], operators?: (string[])[]): string => {\r\n        let equStr: string[],\r\n            equArray: string[] = [],\r\n            m: Monom,\r\n            letters: string[] = []\r\n\r\n        // Get the letters from the linear system\r\n        for (let equ of equations) {\r\n            letters = letters.concat(equ.letters())\r\n        }\r\n        letters = [...new Set(letters)]\r\n        letters.sort()\r\n\r\n        for (let i = 0; i < equations.length; i++) {\r\n            let equ = equations[i]\r\n\r\n            equStr = [];\r\n            for (let L of letters) {\r\n                m = equ.left.monomByLetter(L);\r\n\r\n                if (equStr.length === 0) {\r\n                    equStr.push(m.isZero() ? '' : m.tex);\r\n                } else {\r\n                    equStr.push(m.isZero() ? '' : ((m.coefficient.sign() === 1) ? '+' : '') + m.tex);\r\n                }\r\n            }\r\n\r\n            // Add the equal sign\r\n            equStr.push('=');\r\n\r\n            // Add the right hand part of the equation (should be only a number, because it has been reordered)\r\n            equStr.push(equ.right.tex);\r\n\r\n            // Add the operations if existing\r\n            if (operators !== undefined && operators[i] !== undefined) {\r\n                // add extra space at the end of the equation\r\n                equStr[equStr.length - 1] = equStr[equStr.length - 1] + ' \\\\phantom{\\\\quad}'\r\n                for (let o of operators[i]) {\r\n                    equStr.push(`\\\\ \\\\cdot\\\\ ${o.startsWith('-') ? \"\\\\left(\" + o + \"\\\\right)\" : o}`)\r\n                }\r\n            }\r\n\r\n            // Add to the list.\r\n            equArray.push(equStr.join('&'));\r\n        }\r\n\r\n        let operatorsColumns = 0\r\n        if (operators !== undefined && operators.length > 0) {\r\n            operatorsColumns = operators[0].length\r\n        }\r\n        return `\\\\left\\\\{\\\\begin{array}{${\"r\".repeat(letters.length)}cl ${\"|l\".repeat(operatorsColumns)}}${equArray.join('\\\\\\\\\\ ')}\\\\end{array}\\\\right.`;\r\n    }\r\n\r\n    stepTex = (letter: string): string => {\r\n        const steps = this._resolutionSteps[letter]\r\n\r\n        if (steps === undefined) {\r\n            return ''\r\n        }\r\n\r\n        // steps = { equations[], operations: [[],[]]\r\n        let tex: string[] = []\r\n        for (let i = 0; i < steps.length; i++) {\r\n            tex.push(this.buildTex(steps[i].equations, steps[i].operations))\r\n        }\r\n\r\n        return `\\\\begin{aligned}&${tex.join('\\\\\\\\&')}\\\\end{aligned}`\r\n\r\n    }\r\n\r\n\r\n    get resolutionSteps(): { [p: string]: { equations: Equation[]; operations: string[][] }[] } {\r\n        return this._resolutionSteps;\r\n    }\r\n\r\n// ------------------------------------------\r\n    // Creation / parsing functions\r\n\r\n    // ------------------------------------------\r\n    parse = (...equations: (string | Equation)[]): LinearSystem => {\r\n        // make the original equations\r\n        this._equations = equations.map(value => new Equation(value));\r\n        // get the letters.\r\n        this._findLetters();\r\n        return this;\r\n    };\r\n\r\n    clone = (): LinearSystem => {\r\n        return new LinearSystem().parse(...this._equations.map(equ => equ.clone()));\r\n    };\r\n\r\n    // ------------------------------------------\r\n    reorder = (): LinearSystem => {\r\n        for (let E of this._equations) {\r\n            E.reorder();\r\n        }\r\n        return this;\r\n    };\r\n\r\n\r\n    // -----------------------------------------------\r\n    // Equations solving algorithms\r\n\r\n    solve = (withResolution?: boolean): LinearSystem => {\r\n        // Solve it by linear\r\n        this._solutions = {};\r\n        this._resolutionSteps = {};\r\n\r\n        // Reorder all equations.\r\n        this.reorder();\r\n\r\n        if (withResolution === undefined) {\r\n            withResolution = false\r\n        }\r\n\r\n        for (let letter of this.variables) {\r\n            this._solutions[letter] = this._solveOneLetter(letter, withResolution)\r\n        }\r\n\r\n        // TODO: LinearSystem - solve: optimization and handle undetermined and undefined systems.\r\n        return this;\r\n    };\r\n\r\n    mergeEquations = (eq1: Equation, eq2: Equation, factor1: Fraction, factor2: Fraction): Equation => {\r\n        // Set and clone the equations.\r\n\r\n        let eq1multiplied = eq1.clone().multiply(new Fraction(factor1)),\r\n            eq2multiplied = eq2.clone().multiply(new Fraction(factor2));\r\n\r\n        // Add both equations together.\r\n        eq1multiplied.left.add(eq2multiplied.left);\r\n        eq1multiplied.right.add(eq2multiplied.right);\r\n\r\n        return eq1multiplied;\r\n    }\r\n\r\n    private _findLetters = (): LinearSystem => {\r\n        // Find all letters used.\r\n        let variables: Set<string> = new Set();\r\n\r\n        for (let equ of this._equations) {\r\n            variables = new Set([...variables, ...equ.variables]);\r\n        }\r\n\r\n        this._letters = [...variables];\r\n        this._letters.sort()\r\n        return this;\r\n    }\r\n\r\n    private _linearReduction(eq1: Equation, eq2: Equation, letter: string): { merged: Equation, factors: Fraction[] } {\r\n        // Get the monom for the particular letter.\r\n        let c1 = eq1.left.monomByDegree(1, letter).coefficient.clone(),\r\n            c2 = eq2.left.monomByDegree(1, letter).coefficient.clone().opposed();\r\n\r\n        // Reduce c1 and c2 by the gcd\r\n        const gcdN = Numeric.gcd(c1.numerator, c2.numerator),\r\n            gcdD = Numeric.gcd(c1.denominator, c2.denominator)\r\n        c1.divide(gcdN).multiply(gcdD)\r\n        c2.divide(gcdN).multiply(gcdD)\r\n\r\n        // if one value is -1, use 1 and make the other one opposed\r\n        if (c2.isNegativeOne()) {\r\n            c1.opposed()\r\n            c2.opposed()\r\n        } else if (c1.isNegativeOne()) {\r\n            c1.opposed()\r\n            c2.opposed()\r\n        }\r\n\r\n        return {\r\n            merged: this.mergeEquations(eq1, eq2, c2, c1),\r\n            factors: [c2, c1]\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Linear reduction of the equations to have only one letter\r\n     * @param letter    letter to isolate\r\n     * @private\r\n     */\r\n    private _solveOneLetter(letter: string, withResolution: boolean): ISolution {\r\n        // list of equations.\r\n        let LE: Equation[] = this.clone().equations,\r\n            reducedEquations: Equation[] = [],\r\n            lastIndex\r\n\r\n        this._resolutionSteps[letter] = []\r\n\r\n        // Reduce the equations.\r\n        // Do it as long as there is more than one step, but no more than the number of equations.\r\n        for (let L of this.variables) {\r\n            // Reset the stack\r\n            reducedEquations = [];\r\n\r\n            // remove the setLetter from all equations using linear combinations\r\n            if (L === letter) continue;\r\n\r\n            if (withResolution) {\r\n                this._resolutionSteps[letter].push({\r\n                    equations: LE.map(x => x.clone()),\r\n                    operations: [...new Array(LE.length)].map(x => [...new Array(LE.length - 1)].map(x => \"\"))\r\n                })\r\n                lastIndex = this._resolutionSteps[letter].length - 1\r\n            }\r\n\r\n            // Linear reduction.\r\n            for (let i = 0; i < LE.length - 1; i++) {\r\n                const result = this._linearReduction(LE[i], LE[i + 1], L)\r\n                reducedEquations.push(result.merged)\r\n\r\n                if (withResolution) {\r\n                    this._resolutionSteps[letter][lastIndex].operations[i][i] = result.factors[0].tex\r\n                    this._resolutionSteps[letter][lastIndex].operations[i + 1][i] = result.factors[1].tex\r\n                }\r\n            }\r\n\r\n            LE = [...reducedEquations]\r\n        }\r\n\r\n        // Solve the equations\r\n        // let E = this._resolutionSteps[this._resolutionSteps.length - 1].equations[0];\r\n        let E = LE[0];\r\n        E.solve()\r\n        const solution = E.solutions[0]\r\n\r\n        if (withResolution) {\r\n            this._resolutionSteps[letter].push({\r\n                equations: [LE[0]],\r\n                operations: [[LE[0].left.monoms[0].coefficient.tex]]\r\n            })\r\n\r\n            let P: Polynom\r\n            if (solution.exact instanceof Fraction || typeof solution.exact === \"string\") {\r\n                P = new Polynom(solution.exact)\r\n            } else {\r\n                P = new Polynom(solution.value)\r\n            }\r\n            this._resolutionSteps[letter].push({\r\n                equations: [new Equation(new Polynom(letter), P)],\r\n                operations: []\r\n            })\r\n\r\n        }\r\n        return E.solutions[0]\r\n    }\r\n\r\n}\r\n","/**\r\n * Polynom module contains everything necessary to handle polynoms.\r\n * @module Logicalset\r\n */\r\n\r\nimport {Shutingyard, ShutingyardMode} from '../shutingyard';\r\n\r\n/**\r\n * Polynom class can handle polynoms, reorder, resolve, ...\r\n */\r\n    export class Logicalset {\r\n        private _rawString: string;\r\n        private _rpn: { token: string, tokenType: string }[]\r\n\r\n        /**\r\n         *\r\n         * @param {string} value (optional) Default polynom to parse on class creation\r\n         */\r\n        constructor(value: string) {\r\n            this._rawString = value\r\n            this.parse(value)\r\n            return this;\r\n        }\r\n\r\n        get isLogicalset() {\r\n            return true;\r\n        };\r\n\r\n        private parse = (value: string): Logicalset => {\r\n            // TODO: Must format the value string to convert some items...\r\n\r\n            // Parse the updated value to the shutingyard algorithm\r\n            this._rpn = new Shutingyard(ShutingyardMode.SET).parse(value).rpn;\r\n\r\n            return this;\r\n        }\r\n\r\n        evaluate(tokenSets: { [key: string]: unknown[] }, reference?: unknown[]): unknown[] {\r\n            let varStack: (Set<unknown>)[] = []\r\n\r\n            let referenceSet: Set<unknown>\r\n            if (reference === undefined) {\r\n                referenceSet = new Set()\r\n                for (let key in tokenSets) {\r\n                    referenceSet = new Set([...referenceSet, ...tokenSets[key]])\r\n                }\r\n            } else {\r\n                referenceSet = new Set(reference)\r\n            }\r\n\r\n            for (let token of this._rpn) {\r\n                if (token.tokenType === 'variable') {\r\n                    // The variable has no token - assume it's empty.\r\n                    if (tokenSets[token.token] === undefined) {\r\n                        varStack.push(new Set())\r\n                    } else {\r\n                        varStack.push(new Set(tokenSets[token.token]));\r\n                    }\r\n\r\n                } else {\r\n                    switch (token.token) {\r\n                        case '&':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                varStack.push(new Set([...first].filter(x => second.has(x))))\r\n                            }\r\n                            break\r\n                        case '|':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n                                varStack.push(new Set([...first, ...second]))\r\n                            }\r\n                            break\r\n                        case '-':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n                                varStack.push(new Set([...first].filter(x => !second.has(x))))\r\n                            }\r\n                            break\r\n                        case '!':\r\n                            if (varStack.length >= 1) {\r\n                                let first = varStack.pop()\r\n\r\n                                varStack.push(new Set([...referenceSet].filter(x => !first.has(x))))\r\n                            }\r\n                            break\r\n                    }\r\n                }\r\n            }\r\n\r\n            return [...varStack[0]].sort();\r\n        }\r\n\r\n        vennAB(): any[] {\r\n            return this.evaluate({\r\n                    A: ['A', 'AB'],\r\n                    B: ['B', 'AB']\r\n                },\r\n                ['A', 'B', 'AB', 'E']\r\n            )\r\n        }\r\n\r\n        vennABC(): any[] {\r\n            return this.evaluate({\r\n                    A: ['A', 'AB', 'AC', 'ABC'],\r\n                    B: ['B', 'AB', 'BC', 'ABC'],\r\n                    C: ['C', 'AC', 'BC', 'ABC']\r\n                },\r\n                ['A', 'B', 'C', 'AB', 'AC', 'BC', 'E']\r\n            )\r\n        }\r\n\r\n        get rpn(): { token: string, tokenType: string }[] {\r\n            return this._rpn\r\n        }\r\n\r\n        get tex(): string {\r\n            let varStack: { token: string, tokenType: string } [] = []\r\n\r\n            for (let token of this._rpn) {\r\n                if (token.tokenType === 'variable') {\r\n                    varStack.push(token);\r\n                } else {\r\n                    switch (token.token) {\r\n                        case '&':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\cap ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                            break\r\n                        case '|':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\cup ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                            break\r\n                        case '-':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\setminus ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                            break\r\n                        case '!':\r\n                            if (varStack.length >= 1) {\r\n                                let first = varStack.pop()\r\n                                varStack.push({token: `\\\\overline{ ${first.token} }`, tokenType: 'variable'})\r\n                            }\r\n                            break\r\n                    }\r\n                }\r\n            }\r\n\r\n            return varStack[0].token\r\n        }\r\n    }","/***\r\n * Monom class\r\n */\r\nimport {Numeric} from \"../numeric\";\r\nimport {Shutingyard, ShutingyardType, Token} from \"../shutingyard\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\nexport type literalType = {\r\n    [Key: string]: Fraction\r\n}\r\n\r\nexport class Monom {\r\n    /**\r\n     * Create a Monom\r\n     * Defined as \\\\(k \\\\cdot x^{n}\\\\), where \\\\( k,n \\in \\\\mathbb{Q}\\\\).\r\n     * Examples: \\\\(3x^2\\\\) or \\\\(3/5x^2\\\\)\r\n     * @param value (optional) string The value that should be parse. Can be a Monom, a Fraction, a string or a number. If nothing is provided, it will return the trivial monom (0).\r\n     */\r\n    constructor(value?: unknown) {\r\n        this.zero();\r\n\r\n        if (value !== undefined) {\r\n            // A string is given - try to parse the value.\r\n            this.parse(value);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _coefficient: Fraction;\r\n\r\n    // ------------------------------------------\r\n    /**\r\n     * Get the coefficient \\\\(k\\\\) of the Monom \\\\(k\\\\cdot x^{n}\\\\)\r\n     * @returns {Fraction}\r\n     */\r\n    get coefficient(): Fraction {\r\n        return this._coefficient;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n\r\n    /**\r\n     * Set the coefficient \\\\(k\\\\) value of the monom\r\n     * @param {Fraction | number | string} F\r\n     */\r\n    set coefficient(F: Fraction | number | string) {\r\n        this._coefficient = new Fraction(F);\r\n    }\r\n\r\n    private _literal: literalType;\r\n\r\n    /**\r\n     * Get the literal part of \\\\(x^{n_1}y^{n_2}\\\\) as dictionary \\\\[\\\\begin{array}{ll}x&=n_1\\\\\\\\y&=n_2\\\\end{array}\\\\]\r\n     * @returns {literalType}\r\n     */\r\n    get literal(): literalType {\r\n        return this._literal;\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom. Must be a dictionary {x: Fraction, y: Fraction, ...}\r\n     * @param {literalType} L\r\n     */\r\n    set literal(L: literalType) {\r\n        this._literal = L;\r\n    }\r\n\r\n    /**\r\n     * Get the literal square roots of the Monom.\r\n     * TODO: remove this getter ? Is it used and is it correct ?\r\n     * @returns {literalType}\r\n     */\r\n    get literalSqrt(): literalType {\r\n        if (this.isLiteralSquare()) {\r\n            let L: literalType = {}\r\n            for (let key in this._literal) {\r\n                L[key] = this._literal[key].clone().sqrt()\r\n            }\r\n            return L;\r\n        } else {\r\n            return this._literal;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom from a string\r\n     * @param inputStr  String like x^2y^3\r\n     */\r\n    set literalStr(inputStr: string) {\r\n        // TODO : parse using shutingyard tree !\r\n\r\n        // Match all x^n\r\n        for (const v of [...inputStr.matchAll(/([a-z])\\^([+-]?[0-9]+)/g)]) {\r\n            // Create the default letter entry if necessary.\r\n            if (!(v[1] in this._literal)) {\r\n                this._literal[v[1]] = new Fraction().zero();\r\n            }\r\n\r\n            // Add the new value.\r\n            // TODO: actually, it adds only numeric value\r\n            this._literal[v[1]].add(+v[2]);\r\n        }\r\n\r\n        // Match all x\r\n        for (const v of [...inputStr.matchAll(/([a-z](?!\\^))/g)]) {\r\n            // Match all single letters\r\n            if (!(v[1] in this._literal)) {\r\n                this._literal[v[1]] = new Fraction().zero();\r\n            }\r\n\r\n            // Add one to the value.\r\n            this._literal[v[1]].add(1)\r\n        }\r\n    }\r\n\r\n    // Getter helpers.\r\n    /**\r\n     * Get the variables letters\r\n     */\r\n    get variables(): string[] {\r\n        let M = this.clone().clean();\r\n        return Object.keys(M.literal)\r\n    }\r\n\r\n    // Display getter\r\n    /**\r\n     * This display getter is to be used in the polynom display getter\r\n     */\r\n    get display(): string {\r\n        let L: string = '',\r\n            letters = Object.keys(this._literal).sort()\r\n        for (let letter of letters) {\r\n            if (this._literal[letter].isNotZero()) {\r\n                L += `${letter}`;\r\n                if (this._literal[letter].isNotEqual(1)) {\r\n                    L += `^(${this._literal[letter].display})`;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.display}`;\r\n            } else {\r\n                return '';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.display}${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    get dividers(): Monom[] {\r\n        // Decompose only if the coefficient is a natural number\r\n        if (!this.coefficient.isRelative()) {\r\n            return [this.clone()]\r\n        }\r\n\r\n\r\n        // Decompose only if the power values are natural numbers.\r\n        if (this.hasFractionCoefficient()) {\r\n            return [this.clone()]\r\n        }\r\n\r\n        // Security : do not do this if greater than 10000\r\n        if (this.coefficient.numerator > 1000000) {\r\n            return [this.clone()]\r\n        }\r\n\r\n        const dividers = Numeric.dividers(Math.abs(this.coefficient.numerator))\r\n\r\n        // Decompose the literals parts.\r\n        let literals: literalType[] = [];\r\n        for (let L in this.literal) {\r\n            // L is the letter.\r\n            literals = this._getLiteralDividers(literals, L)\r\n        }\r\n\r\n        const monomDividers: Monom[] = [];\r\n        if (literals.length > 0 && dividers.length > 0) {\r\n            for (let N of dividers) {\r\n                for (let L of literals) {\r\n                    let M = new Monom();\r\n                    M.coefficient = new Fraction(N)\r\n                    M.literal = L\r\n                    monomDividers.push(M)\r\n                }\r\n            }\r\n        } else if (dividers.length === 0) {\r\n            for (let L of literals) {\r\n                let M = new Monom();\r\n                M.coefficient = new Fraction().one()\r\n                M.literal = L\r\n                monomDividers.push(M)\r\n            }\r\n        } else {\r\n            for (let N of dividers) {\r\n                let M = new Monom();\r\n                M.coefficient = new Fraction(N)\r\n                monomDividers.push(M)\r\n            }\r\n        }\r\n\r\n        return monomDividers.length === 0 ? [new Monom().one()] : monomDividers;\r\n    }\r\n\r\n    /**\r\n     * Display the monom, forcing the '+' sign to appear\r\n     */\r\n    get displayWithSign(): string {\r\n        let d: String = this.display;\r\n        return (d[0] !== '-' ? '+' : '') + d;\r\n    }\r\n\r\n    get texWithSign(): string {\r\n        if (this.coefficient.isStrictlyPositive()) {\r\n            return '+' + this.tex\r\n        }\r\n\r\n        return this.tex\r\n    }\r\n\r\n    get plotFunction(): string {\r\n\r\n        let L: string = '',\r\n            letters = Object.keys(this._literal).sort()\r\n\r\n        for (let letter of letters) {\r\n            if (this._literal[letter].isNotZero()) {\r\n                L += (L === '' ? \"\" : \"*\") + `${letter}`\r\n                if (this._literal[letter].isNotEqual(1)) {\r\n                    L += `^(${this._literal[letter].display})`;\r\n                }\r\n            }\r\n        }\r\n\r\n        // No literal part\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.display}`;\r\n            } else {\r\n                return '';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.display}*${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the tex output of the monom\r\n     */\r\n    get tex(): string {\r\n        // TODO: display with square root !\r\n        let L: string = '',\r\n            letters = Object.keys(this._literal).sort()\r\n\r\n        for (let letter of letters) {\r\n            if (this._literal[letter].isNotZero()) {\r\n                L += `${letter}`;\r\n                if (this._literal[letter].isNotEqual(1)) {\r\n                    L += `^{${this._literal[letter].tfrac}}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.frac}`;\r\n            } else {\r\n                return '0';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.frac}${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the least common multiple of monoms\r\n     * @param monoms    Array of monoms\r\n     */\r\n    static lcm = (...monoms: Monom[]): Monom => {\r\n        // All the monoms must be with natural powers...\r\n        for (let m of monoms) {\r\n            if (m.hasFractionCoefficient()) {\r\n                return new Monom().zero()\r\n            }\r\n        }\r\n\r\n\r\n        let M = new Monom(),\r\n            coeffN: number[] = monoms.map(value => value.coefficient.numerator),\r\n            coeffD: number[] = monoms.map(value => value.coefficient.denominator),\r\n            n = Numeric.gcd(...coeffN),\r\n            d = Numeric.lcm(...coeffD);\r\n\r\n        // Get the coefficient.\r\n        M.coefficient = new Fraction(n, d).reduce();\r\n\r\n        // Set the literal parts - go through each monoms literal parts and get only the lowest degree of each letters.\r\n        for (let m of monoms) {\r\n            // Remove the inexistant letters from the resulting monom\r\n            for (let letter in M.literal) {\r\n                if (!(letter in m.literal)) {\r\n                    M.literal[letter].zero();\r\n                }\r\n            }\r\n            for (let letter in m.literal) {\r\n                if (M.literal[letter] === undefined && m.literal[letter].isStrictlyPositive()) {\r\n                    M.literal[letter] = m.literal[letter].clone();\r\n                } else {\r\n                    M.literal[letter] = new Fraction(Math.min(m.literal[letter].value, M.literal[letter].value))\r\n                }\r\n            }\r\n        }\r\n\r\n        return M;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n\r\n    /**\r\n     * Multiply two monoms and return a NEW monom.\r\n     * @param monoms\r\n     */\r\n    static xmultiply = (...monoms: Monom[]): Monom => {\r\n        let M = new Monom().one();\r\n\r\n        for (let m of monoms) {\r\n            M.multiply(m);\r\n        }\r\n\r\n        return M;\r\n    };\r\n\r\n    // -----------------------------------------\r\n    /**\r\n     * Parse a string to a monom. The string may include fraction.\r\n     * @param inputStr\r\n     */\r\n    parse = (inputStr: unknown): Monom => {\r\n\r\n        if (typeof inputStr === 'string') {\r\n            this._shutingYardToReducedMonom(inputStr)\r\n        } else if (typeof inputStr === 'number') {\r\n            this._coefficient = new Fraction(inputStr)\r\n            this._literal = {}\r\n        } else if (inputStr instanceof Fraction) {\r\n            this._coefficient = inputStr.clone()\r\n            this._literal = {}\r\n        } else if (inputStr instanceof Monom) {\r\n            this._coefficient = inputStr._coefficient.clone()\r\n            this._literal = this.copyLiterals(inputStr.literal)\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    addToken = (stack: Monom[], element: Token): void => {\r\n\r\n        let q1: Monom, q2: Monom, m: Monom, letter: string, pow: Fraction\r\n\r\n        if (element.tokenType === ShutingyardType.COEFFICIENT) {\r\n            stack.push(new Monom(new Fraction(element.token)))\r\n\r\n        } else if (element.tokenType === ShutingyardType.VARIABLE) {\r\n            let M = new Monom().one()\r\n            M.setLetter(element.token, 1)\r\n            stack.push(M.clone())\r\n\r\n        } else if (element.tokenType === ShutingyardType.OPERATION) {\r\n            switch (element.token) {\r\n                case '-':\r\n                    // this should only happen for negative powers or for negative coefficient.\r\n                    q2 = (stack.pop()) || new Monom().zero()\r\n                    q1 = (stack.pop()) || new Monom().zero()\r\n\r\n                    stack.push(q1.subtract(q2))\r\n\r\n                    break;\r\n                case '*':\r\n                    // Get the last element in the stack\r\n                    q2 = (stack.pop()) || new Monom().one()\r\n                    q1 = (stack.pop()) || new Monom().one()\r\n\r\n                    stack.push(q1.multiply(q2))\r\n                    break\r\n                case '/':\r\n                    // Get the last element in the stack\r\n                    q2 = (stack.pop()) || new Monom().one()\r\n                    q1 = (stack.pop()) || new Monom().one()\r\n\r\n                    stack.push(q1.divide(q2))\r\n                    break\r\n                case '^':\r\n                    // get the two last elements in the stack\r\n                    pow = (stack.pop().coefficient) || new Fraction().one()\r\n                    m = (stack.pop()) || new Monom().one()\r\n\r\n                    letter = m.variables[0]\r\n\r\n                    if (letter !== undefined) {\r\n                        m.setLetter(letter, pow)\r\n                    }\r\n\r\n                    stack.push(m)\r\n                    // this.multiply(m.clone())\r\n                    break\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current Monom.\r\n     */\r\n    clone = (): Monom => {\r\n        let F: Monom = new Monom();\r\n\r\n        F.coefficient = this._coefficient.clone();\r\n\r\n        // Copy the literal parts.\r\n        for (let k in this._literal) {\r\n            F.setLetter(k, this._literal[k].clone());\r\n        }\r\n        return F;\r\n    };\r\n\r\n    copyLiterals = (literal: literalType): literalType => {\r\n        let L: literalType = {}\r\n\r\n        for (let k in literal) {\r\n            L[k] = literal[k].clone()\r\n        }\r\n        return L\r\n    }\r\n\r\n    makeSame = (M: Monom): Monom => {\r\n        // Copy the literal parts.\r\n        for (let k in M._literal) {\r\n            this.setLetter(k, M._literal[k].clone());\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Create a zero value monom\r\n     */\r\n    zero = (): Monom => {\r\n        this._coefficient = new Fraction().zero();\r\n        this._literal = {};\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Create a one value monom\r\n     */\r\n    one = (): Monom => {\r\n        this._coefficient = new Fraction().one();\r\n        this._literal = {};\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Clean the monom by removing each letters with a power of zero.\r\n     */\r\n    clean = (): Monom => {\r\n        for (let letter in this._literal) {\r\n            if (this._literal[letter].isZero()) {\r\n                delete this._literal[letter];\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    reduce = (): Monom => {\r\n        this.clean()\r\n        this.coefficient.reduce()\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Get the opposed\r\n     * Returns a monom.\r\n     */\r\n    opposed = (): Monom => {\r\n        this._coefficient.opposed();\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Add all similar monoms. If they aren't similar, they are simply skipped.\r\n     * @param M (Monom[]) The monoms to add.\r\n     */\r\n    add = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            if (this.isSameAs(m)) {\r\n                if (this.isZero()) {\r\n                    this.makeSame(m)\r\n                }\r\n                this._coefficient.add(m.coefficient);\r\n            } else {\r\n                console.log('Add monom: ' + this.display + ' is not similar with ', m.display);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Subtract multiple monoms\r\n     * @param M (Monom[]) The monoms to subtract\r\n     */\r\n    subtract = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            if (this.isSameAs(m)) {\r\n                if (this.isZero()) {\r\n                    this.makeSame(m)\r\n                }\r\n                this._coefficient.add(m.clone().coefficient.opposed());\r\n            } else {\r\n                console.log('Subtract: Is not similar: ', m.display);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Multiple multiple monoms to the current monom\r\n     * @param M (Monom[]) The monoms to multiply to.\r\n     */\r\n    multiply = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            // Multiply the coefficient.\r\n            this._coefficient.multiply(m.coefficient);\r\n\r\n            // Multiply the literal parts.\r\n            for (let letter in m.literal) {\r\n                if (this._literal[letter] === undefined) {\r\n                    this._literal[letter] = m.literal[letter].clone()\r\n                } else {\r\n                    this._literal[letter].add(m.literal[letter])\r\n                }\r\n\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    multiplyByNumber = (F: Fraction | number): Monom => {\r\n        this._coefficient.multiply(F);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Divide the current monoms by multiple monoms\r\n     * @param M (Monom[])\r\n     */\r\n    divide = (...M: Monom[]): Monom => {\r\n        // Depending on the given value, choose the current item\r\n        for (let v of M) {\r\n            // Divide the coefficient\r\n            this._coefficient.divide(v.coefficient);\r\n\r\n            // Subtract the power values\r\n            for (let letter in v.literal) {\r\n                this._literal[letter] = (this._literal[letter] === undefined) ? v.literal[letter].clone().opposed() : this._literal[letter].subtract(v.literal[letter])\r\n\r\n                // If the power of a particular setLetter is zero, delete it from the literal part..\r\n                if (this._literal[letter].isZero()) {\r\n                    delete this._literal[letter];\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Get the pow of a monom.\r\n     * @param nb (number) : Mathematical pow\r\n     */\r\n    pow = (nb: number | Fraction): Monom => {\r\n        this._coefficient.pow(nb);\r\n        for (let letter in this._literal) {\r\n            this._literal[letter].multiply(nb)\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Get the nth-root of the monom\r\n     * @param p\r\n     */\r\n    root = (p: number): Monom => {\r\n        // TODO: determiner the nth root of a monom\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Return the square root of a monom\r\n     */\r\n    sqrt = (): Monom => {\r\n        if (this.isSquare()) {\r\n            this._coefficient.sqrt();\r\n            for (let letter in this._literal) {\r\n                this._literal[letter].clone().divide(2)\r\n            }\r\n        }\r\n        return this.root(2);\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n    // ------------------------------------------\r\n    compare = (M: Monom, sign?: string): boolean => {\r\n        // TODO: Build the compare systems.\r\n        if (sign === undefined) {\r\n            sign = '=';\r\n        }\r\n\r\n\r\n        switch (sign) {\r\n            case '=':\r\n                // To be equal, they must be the isSame\r\n                if (!this.compare(M, 'same')) {\r\n                    return false;\r\n                }\r\n\r\n                // The literal parts are the isSame. The coefficient must be equal\r\n                return this._coefficient.isEqual(M.coefficient);\r\n            case 'same':\r\n                // Get the list of all variables from both monoms.\r\n                let M1: string[] = this.variables,\r\n                    M2: string[] = M.variables,\r\n                    K: string[] = M1.concat(M2.filter((item) => M1.indexOf(item) < 0));\r\n\r\n                if (M1.length === 0 && M2.length === 0) {\r\n                    return true\r\n                }\r\n                // To compare, both must be different than zero.\r\n                if (!this.isZero() && !M.isZero()) {\r\n                    for (let key of K) {\r\n                        // The setLetter is not available in one of the monom\r\n                        if (this._literal[key] === undefined || M.literal[key] === undefined) {\r\n                            return false;\r\n                        }\r\n                        // The setLetter does not have the isSame power in each monoms.\r\n                        if (!this._literal[key].isEqual(M.literal[key])) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // All are positive check - the monoms are the sames.\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is null\r\n     */\r\n    isZero(): boolean {\r\n        return this._coefficient.value === 0;\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is one\r\n     */\r\n    isOne(): boolean {\r\n        return this._coefficient.value === 1 && this.variables.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Determine if two monoms are equals\r\n     * @param M\r\n     */\r\n    isEqual = (M: Monom): boolean => {\r\n        return this.compare(M, '=');\r\n    };\r\n\r\n    /**\r\n     * Determine if two monoms are similar\r\n     * @param M\r\n     */\r\n    isSameAs = (M: Monom): boolean => {\r\n        return this.compare(M, 'same');\r\n    };\r\n\r\n    isSquare = (): boolean => {\r\n        if (!this.coefficient.isSquare()) {\r\n            return false;\r\n        }\r\n        return this.isLiteralSquare();\r\n    }\r\n\r\n    isLiteralSquare = (): boolean => {\r\n        for (let letter in this.literal) {\r\n            // A literal square must have a natural power\r\n            if (this.literal[letter].isRational()) {\r\n                return false\r\n            }\r\n\r\n            // The natural power must be be even\r\n            if (this.literal[letter].isEven()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    hasFractionCoefficient = (): boolean => {\r\n        for (let letter in this._literal) {\r\n            if (this._literal[letter].isRational()) {\r\n                return true\r\n            }\r\n        }\r\n\r\n        return false\r\n    }\r\n    // ------------------------------------------\r\n    // Misc monoms functions\r\n    // -------------------------------------\r\n    /**\r\n     * Determine if a monom contains a setLetter in it's literal part\r\n     * @param letter\r\n     */\r\n    hasLetter = (letter?: string): boolean => {\r\n        // The letter was not found\r\n        if (this._literal[letter === undefined ? 'x' : letter] === undefined) {\r\n            return false\r\n        }\r\n\r\n        // The letter is found and is not zero !\r\n        return this._literal[letter === undefined ? 'x' : letter].isNotZero();\r\n    };\r\n\r\n    /**\r\n     * Set the power of a particular setLetter\r\n     * @param letter (string) Letter to change\r\n     * @param pow (number) Power of the setLetter (must be positive integer.\r\n     */\r\n    setLetter = (letter: string, pow: Fraction | number): void => {\r\n        if (pow instanceof Fraction) {\r\n            // Set the power of the letter to zero => remove it\r\n            if (this.hasLetter(letter) && pow.isZero()) {\r\n                delete this._literal[letter]\r\n            }\r\n\r\n            this._literal[letter] = pow.clone()\r\n        } else {\r\n            this.setLetter(letter, new Fraction(pow))\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Get the degree of a monom. If no setLetter is given, the result will be the global degree.\r\n     * @param letter (string) Letter to get to degree (power)\r\n     */\r\n    degree = (letter?: string): Fraction => {\r\n        if (this.variables.length === 0) {\r\n            return new Fraction().zero();\r\n        }\r\n        if (letter === undefined) {\r\n            // Not setLetter given -> we get the global monom degree (sum of all the letters).\r\n            return Object.values(this._literal).reduce((t, n) => t.clone().add(n));\r\n        } else {\r\n            // A setLetter is given -> get the corresponding power.\r\n            return this._literal[letter] === undefined ? new Fraction().zero() : this._literal[letter].clone();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Evaluate a monom. Each setLetter must be assigned to a Fraction.\r\n     * @param values    Dictionary of <setLetter: Fraction>\r\n     */\r\n    evaluate = (values: literalType | Fraction | number): Fraction => {\r\n        let r = this.coefficient.clone();\r\n\r\n        if (typeof values === 'number' || values instanceof Fraction) {\r\n            let tmpValues: literalType = {}\r\n            tmpValues[this.variables[0]] = new Fraction(values)\r\n            return this.evaluate(tmpValues);\r\n        }\r\n\r\n        if (typeof values === 'object') {\r\n            if (this.variables.length === 0) {\r\n                return this.coefficient\r\n            }\r\n            for (let L in this._literal) {\r\n                if (values[L] === undefined) {\r\n                    return new Fraction().zero();\r\n                }\r\n\r\n                let value = new Fraction(values[L])\r\n\r\n                r.multiply(value.pow(this._literal[L]))\r\n            }\r\n        }\r\n\r\n        return r;\r\n    };\r\n\r\n    evaluateAsNumeric = (values: { [Key: string]: number } | number): number => {\r\n        let r = this.coefficient.value\r\n\r\n        if (typeof values === 'number') {\r\n            let tmpValues: { [Key: string]: number } = {}\r\n            tmpValues[this.variables[0]] = values\r\n            return this.evaluateAsNumeric(tmpValues);\r\n        }\r\n\r\n        if (typeof values === 'object') {\r\n            if (this.variables.length === 0) {\r\n                return this.coefficient.value\r\n            }\r\n            for (let L in this._literal) {\r\n                if (values[L] === undefined) {\r\n                    return 0;\r\n                }\r\n\r\n                r *= values[L] ** (this._literal[L].value)\r\n            }\r\n        }\r\n\r\n        return r\r\n    }\r\n\r\n    /**\r\n     * Derivative the monom\r\n     * @param letter\r\n     */\r\n    derivative = (letter?: string): Monom => {\r\n        // No setLetter given - assume it's the setLetter 'x'\r\n        if (letter === undefined) {\r\n            letter = 'x';\r\n        }\r\n\r\n        if (this.hasLetter(letter)) {\r\n            let d = this._literal[letter].clone(),\r\n                dM = this.clone();\r\n\r\n            // Subtract one to the degree.\r\n            dM._literal[letter].subtract(1)\r\n\r\n            // Multiply the coefficient by the previous degree\r\n            dM._coefficient.multiply(new Fraction(d.clone()));\r\n            return dM;\r\n        } else {\r\n            return new Monom().zero();\r\n        }\r\n    };\r\n\r\n    primitive = (letter?: string): Monom => {\r\n        // TODO: derivative including the ln value => implies creating different monom system ?\r\n        if (letter === undefined) {\r\n            letter = 'x'\r\n        }\r\n\r\n        // Zero monom\r\n        let M = this.clone(), degree\r\n\r\n        if (M.hasLetter(letter)) {\r\n            degree = M.degree(letter).clone().add(1)\r\n            M.coefficient = M.coefficient.clone().divide(degree)\r\n            M.setLetter(letter, degree)\r\n        } else {\r\n            // There is no letter.\r\n\r\n            // The coefficient might be zero (=> x) or a number a (=> ax)\r\n            if (M.coefficient.isZero()) {\r\n                M.coefficient = new Fraction().one()\r\n            }\r\n            M.setLetter(letter, 1)\r\n        }\r\n\r\n        return M\r\n    }\r\n    // ----------------------------------------\r\n    // Static functions\r\n    // ----------------------------------------\r\n\r\n    // TODO: The rest of the functions are not used or unnecessary ?\r\n    /**\r\n     * Determine if multiple monoms are similar\r\n     * @param M\r\n     */\r\n    areSameAs = (...M: Monom[]): boolean => {\r\n        let result: boolean = true;\r\n\r\n        // Check all monoms if they are the isSame as the \"this\" one.\r\n        for (let i = 0; i < M.length; i++) {\r\n            if (!this.isSameAs(M[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // All check passed -> all the monoms are similar.\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Determine if multiple monoms are equals\r\n     * @param M\r\n     */\r\n    areEquals = (...M: Monom[]): boolean => {\r\n        // They are not similar.\r\n        if (!this.areSameAs(...M)) {\r\n            return false;\r\n        }\r\n\r\n        // Check all coefficient. They must be equals.\r\n        for (let m of M) {\r\n            if (!this._coefficient.isEqual(m.coefficient)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // All checks passed.\r\n        return true;\r\n    };\r\n\r\n    isDivisible = (div: Monom): boolean => {\r\n        // For all variables (letters), the current monom must have a degree higher than the divider\r\n        if (div.degree().isStrictlyPositive()) {\r\n            for (let letter of div.variables) {\r\n                if (!this.degree(letter).geq(div.degree(letter))) {\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n\r\n        // If the coefficient is rational, we suppose we don't need to check the division by the coefficient.\r\n        if (this.coefficient.isRational() || div.coefficient.isRational()) {\r\n            return true\r\n        }\r\n\r\n        return this.coefficient.clone().divide(div.coefficient).isRelative()\r\n    }\r\n\r\n    private _getLiteralDividers(arr: literalType[], letter: string): literalType[] {\r\n        let tmpList: { [key: string]: Fraction }[] = [];\r\n\r\n        // Be default, this.literal[letter] should be a rational number.\r\n        for (let d = 0; d <= this.literal[letter].value; d++) {\r\n            if (arr.length === 0) {\r\n                let litt: literalType = {}\r\n                litt[letter] = new Fraction(d)\r\n                tmpList.push(litt)\r\n            } else {\r\n                for (let item of arr) {\r\n                    let litt: literalType = {}\r\n                    for (let currentLetter in item) {\r\n                        litt[currentLetter] = item[currentLetter]\r\n                    }\r\n                    litt[letter] = new Fraction(d)\r\n                    tmpList.push(litt)\r\n                }\r\n            }\r\n        }\r\n        return tmpList;\r\n    }\r\n\r\n    private _shutingYardToReducedMonom = (inputStr: string): Monom => {\r\n        // Get the RPN array of the current expression\r\n        const SY: Shutingyard = new Shutingyard().parse(inputStr);\r\n        const rpn: { token: string, tokenType: string }[] = SY.rpn;\r\n\r\n        let stack: Monom[] = [], m, pow, letter, q1, q2\r\n\r\n        if (rpn.length === 0) {\r\n            this.zero()\r\n            return this\r\n        } else if (rpn.length === 1) {\r\n            const element = rpn[0]\r\n\r\n            this.one()\r\n            if (element.tokenType === 'coefficient') {\r\n                this.coefficient = new Fraction(element.token)\r\n            } else if (element.tokenType === 'variable') {\r\n                this.setLetter(element.token, 1)\r\n            }\r\n            return this\r\n        } else {\r\n            // Reset the monom\r\n            for (const element of rpn) {\r\n                this.addToken(stack, element)\r\n            }\r\n        }\r\n\r\n        this.one()\r\n        this.multiply(stack[0])\r\n        return this\r\n    }\r\n\r\n}\r\n","/**\r\n * Polynom module contains everything necessary to handle polynoms.*\r\n */\r\n\r\nimport {literalType, Monom} from './monom';\r\nimport {Shutingyard, ShutingyardType, Token} from '../shutingyard';\r\nimport {Numeric} from '../numeric';\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Equation, ISolution} from \"./equation\";\r\n\r\nexport type PolynomParsingType = string | Polynom | number | Fraction | Monom\r\n\r\nexport interface IEuclidian {\r\n    quotient: Polynom,\r\n    reminder: Polynom\r\n}\r\n\r\n/**\r\n * Polynom class can handle polynoms, reorder, resolve, ...\r\n * ```\r\n * let P = new Polynom('3x-4')\r\n * ```\r\n */\r\nexport class Polynom {\r\n    private _rawString: string;\r\n\r\n    /**\r\n     *\r\n     * @param {string} polynomString (optional) Default polynom to parse on class creation\r\n     * @param values\r\n     */\r\n    constructor(polynomString?: PolynomParsingType, ...values: unknown[]) {\r\n        this._monoms = [];\r\n        this._factors = [];\r\n        this.mark_as_dirty()\r\n\r\n        if (polynomString !== undefined) {\r\n            this.parse(polynomString, ...values);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    private _dirty_factors: boolean\r\n\r\n    // ------------------------------------------\r\n    get dirty_factors(): boolean {\r\n        return this._dirty_factors;\r\n    }\r\n\r\n    set dirty_factors(value: boolean) {\r\n        this._dirty_factors = value;\r\n    }\r\n\r\n    private _dirty_zeroes: boolean\r\n\r\n    get dirty_zeroes(): boolean {\r\n        return this._dirty_zeroes;\r\n    }\r\n\r\n    set dirty_zeroes(value: boolean) {\r\n        this._dirty_zeroes = value;\r\n    }\r\n\r\n    private _euclidianCache: { [Key: string]: IEuclidian }\r\n\r\n    get euclidianCache(): { [p: string]: IEuclidian } {\r\n        return this._euclidianCache;\r\n    }\r\n\r\n    set euclidianCache(value: { [p: string]: IEuclidian }) {\r\n        this._euclidianCache = value;\r\n    }\r\n\r\n    private _factors: Polynom[];\r\n\r\n    get factors(): Polynom[] {\r\n        return this.factorize()\r\n    }\r\n\r\n    set factors(value: Polynom[]) {\r\n        this.mark_as_dirty()\r\n        this._factors = value;\r\n    }\r\n\r\n    private _monoms: Monom[];\r\n\r\n    // ------------------------------------------\r\n    get monoms() {\r\n        return this._monoms;\r\n    }\r\n\r\n    set monoms(M: Monom[]) {\r\n        this._monoms = M;\r\n    }\r\n\r\n    private _texString: string;\r\n\r\n    get texString(): string {\r\n        return this._texString;\r\n    }\r\n\r\n    private _zeroes: ISolution[]\r\n\r\n    get zeroes(): ISolution[] {\r\n        return this.getZeroes()\r\n    }\r\n\r\n    get texFactors(): string {\r\n        this.factorize()\r\n\r\n        if (this.factors.length <= 1) {\r\n            return this.tex\r\n        }\r\n\r\n        // Build an array of texFactors with the number of similar items.\r\n        let factorsCount: { [Key: string]: { degree: number, factor: Polynom } } = {}\r\n        for (let f of this.factors) {\r\n            if (factorsCount[f.tex] !== undefined) {\r\n                factorsCount[f.tex].degree++\r\n            } else {\r\n                factorsCount[f.tex] = {\r\n                    degree: 1,\r\n                    factor: f\r\n                }\r\n            }\r\n        }\r\n\r\n        // First round to put the 'monom' first\r\n        let simpleFactor = new Polynom().one()\r\n\r\n        for (let item of Object.values(factorsCount).filter(item => item.factor.monoms.length === 1)) {\r\n            simpleFactor.multiply(item.factor)\r\n        }\r\n\r\n        let tex = simpleFactor.isOne() ? '' : simpleFactor.tex\r\n\r\n        // Loop through all factors that contains at least 2 monoms.\r\n        for (let item of Object.values(factorsCount).filter(item => item.factor.monoms.length > 1)) {\r\n            if (item.factor.length > 1) {\r\n                tex += `\\\\left( ${item.factor.tex} \\\\right)${item.degree > 1 ? '^{ ' + item.degree + ' }' : ''}`\r\n            }\r\n        }\r\n\r\n        return tex;\r\n    }\r\n\r\n    get displayFactors() {\r\n        this.factorize()\r\n\r\n        if (this.factors.length <= 1) {\r\n            return this.display\r\n        }\r\n\r\n        // Build an array of texFactors with the number of similar items.\r\n        let factorsCount: { [Key: string]: { degree: number, factor: Polynom } } = {}\r\n        for (let f of this.factors) {\r\n            if (factorsCount[f.display] !== undefined) {\r\n                factorsCount[f.display].degree++\r\n            } else {\r\n                factorsCount[f.display] = {\r\n                    degree: 1,\r\n                    factor: f\r\n                }\r\n            }\r\n        }\r\n\r\n        // First round to put the 'monom' first\r\n        let simpleFactor = new Polynom().one()\r\n\r\n        for (let item of Object.values(factorsCount).filter(item => item.factor.monoms.length === 1)) {\r\n            simpleFactor.multiply(item.factor)\r\n        }\r\n\r\n        let display = simpleFactor.isOne() ? '' : simpleFactor.display\r\n\r\n        // Loop through all factors that contains at least 2 monoms.\r\n        for (let item of Object.values(factorsCount).filter(item => item.factor.monoms.length > 1)) {\r\n            if (item.factor.length > 1) {\r\n                display += `(${item.factor.display})${item.degree > 1 ? '^(' + item.degree + ')' : ''}`\r\n            }\r\n        }\r\n\r\n        return display;\r\n    }\r\n\r\n    get length() {\r\n        // TODO: Must reduce the monoms list to remove the zero coefficient.\r\n        return this._monoms.length;\r\n    }\r\n\r\n    get display(): string {\r\n        return this.genDisplay();\r\n    }\r\n\r\n    get raw(): string {\r\n        return this._rawString\r\n    }\r\n\r\n    get tex(): string {\r\n        return this.genDisplay('tex');\r\n    }\r\n\r\n    get isMultiVariable(): boolean {\r\n        const B = false;\r\n        for (const m of this._monoms) {\r\n            if (m.variables.length > 1) {\r\n                return true;\r\n            }\r\n        }\r\n        return B;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        let V: string[] = [];\r\n\r\n        for (const m of this._monoms) {\r\n            V = V.concat(m.variables);\r\n        }\r\n\r\n        // Remove duplicates.\r\n        V = [...new Set(V)];\r\n        V.sort()\r\n        return V;\r\n    }\r\n\r\n    get numberOfVars(): number {\r\n        return this.variables.length;\r\n    }\r\n\r\n    get plotFunction(): string {\r\n        return this.genDisplay('tex', false, false, true)\r\n    }\r\n\r\n    mark_as_dirty = (): void => {\r\n        this.dirty_factors = true\r\n        this.dirty_zeroes = true\r\n        this.euclidianCache = {}\r\n    }\r\n\r\n    addToken = (stack: Polynom[], element: Token): void => {\r\n        switch (element.tokenType) {\r\n            case ShutingyardType.COEFFICIENT:\r\n                stack.push(new Polynom(element.token))\r\n                break\r\n\r\n            case ShutingyardType.VARIABLE:\r\n                stack.push(new Polynom().add(new Monom(element.token)))\r\n                break\r\n\r\n            case ShutingyardType.CONSTANT:\r\n                // TODO: add constant support to Polynom parsing.\r\n                console.log('Actually, not supported - will be added later !')\r\n                break\r\n\r\n            case ShutingyardType.OPERATION:\r\n                if (stack.length >= 2) {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop()\r\n\r\n                    if (element.token === '+') {\r\n                        stack.push(a.add(b))\r\n                    } else if (element.token === '-') {\r\n                        stack.push(a.subtract(b))\r\n                    } else if (element.token === '*') {\r\n                        stack.push(a.multiply(b))\r\n                    } else if (element.token === '/') {\r\n                        if (b.degree().isStrictlyPositive()) {\r\n                            console.log('divide by a polynom -> should create a rational polynom !')\r\n                        } else {\r\n                            stack.push(a.divide(b.monoms[0].coefficient))\r\n\r\n                        }\r\n                    } else if (element.token === '^') {\r\n                        if (b.degree().isStrictlyPositive()) {\r\n                            console.error('Cannot elevate a polynom with another polynom !', a.tex, b.tex)\r\n                        } else {\r\n                            if (b.monoms[0].coefficient.isRelative()) {\r\n                                // Integer power\r\n                                stack.push(a.pow(b.monoms[0].coefficient.value))\r\n                            } else {\r\n                                // Only allow power if the previous polynom is only a monom, without coefficient.\r\n                                if (a.monoms.length === 1 && a.monoms[0].coefficient.isOne()) {\r\n                                    for (let letter in a.monoms[0].literal) {\r\n                                        a.monoms[0].literal[letter].multiply(b.monoms[0].coefficient)\r\n                                    }\r\n                                    stack.push(a)\r\n                                } else {\r\n                                    console.error('Cannot have power with fraction')\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (element.token === '-') {\r\n                        stack.push(stack.pop().opposed())\r\n                    } else {\r\n                        throw \"Error parsing the polynom \" + this._rawString\r\n                    }\r\n                }\r\n                break\r\n\r\n            case ShutingyardType.MONOM:\r\n                // Should never appear.\r\n                console.error('The monom token should not appear here')\r\n                break;\r\n\r\n            case ShutingyardType.FUNCTION:\r\n                // Should never appear.\r\n                console.error('The function token should not appear here - might be introduced later.')\r\n                break;\r\n        }\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse a string to a polynom.\r\n     * @param inputStr\r\n     * @param values: as string, numbers or fractions\r\n     */\r\n    parse = (inputStr: PolynomParsingType, ...values: unknown[]): Polynom => {\r\n        // Reset the main variables.\r\n        this._monoms = []\r\n        this._factors = []\r\n        this.mark_as_dirty()\r\n\r\n        // TODO: allow to enter a liste of Fraction (a, b, c, ...) to make a polynom ax^n + bx^(n-1) + cx^(n-2) + ...\r\n        if (typeof inputStr === 'string') {\r\n            return this._parseString(inputStr, ...values)\r\n        } else if (\r\n            (typeof inputStr === 'number' || inputStr instanceof Fraction || inputStr instanceof Monom)\r\n            && (values === undefined || values.length === 0)\r\n        ) {\r\n            this._monoms.push(new Monom(inputStr))\r\n        } else if (inputStr instanceof Monom && values.length > 0) {\r\n            this._monoms.push(new Monom(inputStr))\r\n            values.forEach(m => {\r\n                this._monoms.push(new Monom(m))\r\n            })\r\n        } else if (inputStr instanceof Polynom) {\r\n            for (const m of inputStr.monoms) {\r\n                this._monoms.push(m.clone())\r\n            }\r\n        }\r\n\r\n        return this\r\n    };\r\n\r\n    /**\r\n     * Clone the polynom\r\n     */\r\n    clone = (): Polynom => {\r\n        const P = new Polynom();\r\n        const M: Monom[] = [];\r\n\r\n        for (const m of this._monoms) {\r\n            M.push(m.clone());\r\n        }\r\n\r\n        P.monoms = M;\r\n\r\n        return P;\r\n    };\r\n\r\n    /**\r\n     * Set the polynom to zero.\r\n     * @returns {this}\r\n     */\r\n    zero = (): Polynom => {\r\n        this._monoms = [];\r\n        this._monoms.push(new Monom().zero());\r\n        this._rawString = '0';\r\n        this.mark_as_dirty()\r\n        return this;\r\n    };\r\n\r\n    one = (): Polynom => {\r\n        this._monoms = [];\r\n        this._monoms.push(new Monom().one());\r\n        this._rawString = '1';\r\n        this.mark_as_dirty()\r\n        return this;\r\n    }\r\n\r\n    empty = (): Polynom => {\r\n        this._monoms = [];\r\n        this._rawString = '';\r\n        this.mark_as_dirty()\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    opposed = (): Polynom => {\r\n        this._monoms = this._monoms.map(m => m.opposed());\r\n        this.mark_as_dirty()\r\n        return this;\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n\r\n    add = (...values: unknown[]): Polynom => {\r\n        this.mark_as_dirty()\r\n\r\n        // @ts-ignore\r\n        for (let value of values) {\r\n            if (value instanceof Polynom) {\r\n                this._monoms = this._monoms.concat(value.monoms);\r\n            } else if (value instanceof Monom) {\r\n                this._monoms.push(value.clone());\r\n            } else if (Number.isSafeInteger(value)) {\r\n                this._monoms.push(new Monom(value.toString()));\r\n            } else {\r\n                this._monoms.push(new Monom(value));\r\n            }\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    subtract = (...values: unknown[]): Polynom => {\r\n        this.mark_as_dirty()\r\n\r\n        for (let value of values) {\r\n            if (value instanceof Polynom) {\r\n                this._monoms = this._monoms.concat(value.clone().opposed().monoms);\r\n            } else if (value instanceof Monom) {\r\n                this._monoms.push(value.clone().opposed());\r\n            } else if (Number.isSafeInteger(value)) {\r\n                this._monoms.push(new Monom(value.toString()).opposed());\r\n            } else {\r\n                this._monoms.push(new Monom(value).opposed());\r\n            }\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    multiply = (value: unknown): Polynom => {\r\n        this.mark_as_dirty()\r\n\r\n        if (value instanceof Polynom) {\r\n            return this.multiplyByPolynom(value)\r\n        } else if (value instanceof Fraction) {\r\n            return this.multiplyByFraction(value);\r\n        } else if (value instanceof Monom) {\r\n            return this.multiplyByMonom(value);\r\n        } else if (Number.isSafeInteger(value) && typeof value === 'number') {\r\n            return this.multiplyByInteger(value);\r\n        }\r\n\r\n        // Something went wrong...\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Divide the current polynom by another polynom.\r\n     * @param P\r\n     * returns {quotient: Polynom, reminder: Polynom}\r\n     */\r\n    euclidian = (P: Polynom): IEuclidian => {\r\n\r\n        if (this.euclidianCache[P.tex] !== undefined) {\r\n            return this.euclidianCache[P.tex]\r\n        }\r\n\r\n        const letter: string = P.variables[0];\r\n        const quotient: Polynom = new Polynom().zero();\r\n        const reminder: Polynom = this.clone().reorder(letter);\r\n\r\n        // There is no variable - means it's a number\r\n        if (P.variables.length === 0) {\r\n            let q = this.clone().divide(P)\r\n            return {\r\n                quotient: this.clone().divide(P).reduce(),\r\n                reminder: new Polynom().zero()\r\n            }\r\n        }\r\n\r\n        // Get at least a letter\r\n        const maxMP: Monom = P.monomByDegree(undefined, letter);\r\n        const degreeP: Fraction = P.degree(letter);\r\n\r\n        let newM: Monom;\r\n\r\n        // Make the euclidian division of the two polynoms.\r\n        let MaxIteration = this.degree(letter).value * 2;\r\n        while (reminder.degree(letter).geq(degreeP) && MaxIteration > 0) {\r\n            MaxIteration--\r\n\r\n            // Get the greatest monom divided by the max monom of the divider\r\n            newM = reminder.monomByDegree(undefined, letter).clone().divide(maxMP);\r\n\r\n            if (newM.isZero()) break;\r\n\r\n            // Get the new quotient and reminder.\r\n            quotient.add(newM);\r\n            reminder.subtract(P.clone().multiply(newM));\r\n\r\n            // Check if the reminder is zero.\r\n            if (newM.degree(letter).isZero()) break\r\n        }\r\n\r\n        quotient.reduce()\r\n        reminder.reduce()\r\n        return {quotient, reminder};\r\n    };\r\n\r\n    divide = (value: unknown): Polynom => {\r\n        this.mark_as_dirty()\r\n\r\n        if (value instanceof Fraction) {\r\n            return this.divideByFraction(value);\r\n        } else if (typeof value === 'number' && Number.isSafeInteger(value)) {\r\n            return this.divideByInteger(value);\r\n        } else if (value instanceof Monom) {\r\n            return this.divide(new Polynom(value))\r\n        } else if (value instanceof Polynom) {\r\n            if (value.monoms.length === 1 && value.variables.length === 0) {\r\n                return this.divideByFraction(value.monoms[0].coefficient)\r\n            } else {\r\n                let {quotient, reminder} = this.euclidian(value)\r\n                if (reminder.isZero()) {\r\n                    return quotient\r\n                } else {\r\n                    console.log(`${this.tex} is not divideable by ${value.tex}`)\r\n                    return new Polynom().zero()\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    pow = (nb: number): Polynom => {\r\n        this.mark_as_dirty()\r\n\r\n        if (!Number.isSafeInteger(nb)) {\r\n            return this.zero();\r\n        }\r\n        if (nb < 0) {\r\n            return this.zero();\r\n        }\r\n        if (nb === 0) {\r\n            return new Polynom();\r\n        }\r\n\r\n        const P = this.clone();\r\n        for (let i = 1; i < nb; i++) {\r\n            this.multiply(P);\r\n        }\r\n        return this.reduce();\r\n    };\r\n\r\n    // ------------------------------------------\r\n    /**\r\n     * Compare the current coefficient with another coefficient\r\n     * @param P\r\n     * @param sign (string| default is =): authorized values: =, <, <=, >, >= with some variations.\r\n     */\r\n    compare = (P: Polynom, sign?: string): boolean => {\r\n        if (sign === undefined) {\r\n            sign = '='\r\n        }\r\n\r\n        // Create clone version to reduce them without altering the original polynoms.\r\n        const cP1 = this.clone().reduce().reorder();\r\n        const cP2 = P.clone().reduce().reorder();\r\n\r\n        switch (sign) {\r\n            case '=':\r\n                // They must have the isSame length and the isSame degree\r\n                if (cP1.length !== cP2.length || cP1.degree().isNotEqual(cP2.degree())) {\r\n                    return false;\r\n                }\r\n\r\n                // Check if the coefficients are the isSame.\r\n                for (const i in cP1.monoms) {\r\n                    if (!cP1.monoms[i].isEqual(cP2.monoms[i])) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            case 'same':\r\n                // They must have the isSame length and the isSame degree\r\n                if (cP1.length !== cP2.length || cP1.degree() !== cP2.degree()) {\r\n                    return false;\r\n                }\r\n\r\n                for (const i in cP1.monoms) {\r\n                    if (!cP1.monoms[i].isSameAs(cP2.monoms[i])) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n\r\n    isZero(): boolean {\r\n        return (this._monoms.length === 1 && this._monoms[0].coefficient.isZero()) || this._monoms.length === 0;\r\n    }\r\n\r\n    isOne(): boolean {\r\n        return this._monoms.length === 1 && this._monoms[0].coefficient.isOne();\r\n    }\r\n\r\n    isEqual = (P: Polynom): boolean => {\r\n        return this.compare(P, '=');\r\n    };\r\n\r\n    isSameAs = (P: Polynom): boolean => {\r\n        return this.compare(P, 'same');\r\n    };\r\n\r\n    isOpposedAt = (P: Polynom): boolean => {\r\n        return this.compare(P.clone().opposed(), '=');\r\n    };\r\n\r\n    isFactorized = (polynomString: string, soft?: boolean): boolean => {\r\n        let P;\r\n\r\n        // Check if polynom is complete...\r\n        if (polynomString.split('(').length !== polynomString.split(')').length) {\r\n            return false\r\n        }\r\n\r\n        // Try to build the polynom\r\n        try {\r\n            P = new Polynom(polynomString);\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n\r\n        // Both polynom aren't the same (once developed and reduced => they cannot be equivalent)\r\n        if (!this.isEqual(P)) {\r\n            return false;\r\n        }\r\n\r\n        // Check if the provided (string) version is fully factorized.\r\n        // Run a regex on the string.\r\n        let polynomStringNormalized = polynomString.replaceAll('*', ''),\r\n            polynomStringReduced = '' + polynomStringNormalized,\r\n            factors: string[] = [];\r\n\r\n        for (let x of polynomStringNormalized.matchAll(/\\(([a-z0-9+\\-]+)\\)(\\^[0-9]*)?/g)) {\r\n\r\n            if (x[2] !== undefined) {\r\n                // if there is an exponential value, add it multiple times\r\n                for (let i = 0; i < +x[2].substring(1); i++) {\r\n                    factors.push(x[1])\r\n                }\r\n            } else {\r\n                // no power - add it once.\r\n                factors.push(x[1]);\r\n            }\r\n\r\n            // Remove the current polynom\r\n            polynomStringReduced = polynomStringReduced.replaceAll(x[0], '');\r\n        }\r\n        if (polynomStringReduced !== '') {\r\n            factors.push(polynomStringReduced);\r\n        }\r\n        let polyFactors = factors.map(x => new Polynom(x));\r\n\r\n        // polyFactors contain all polynoms.\r\n        let checkPolyFactors = polyFactors.filter(x => x.degree().geq(1) && !x.commonMonom().isOne())\r\n\r\n        // Some polynoms are not completely factorized.\r\n        if (checkPolyFactors.length > 0 && !soft) {\r\n            return false\r\n        }\r\n        if (checkPolyFactors.length > 0 && soft) {\r\n            polyFactors = polyFactors.filter(x => x.commonMonom().isOne())\r\n\r\n            let FactorizedConstant = new Fraction().one()\r\n            for (let p of checkPolyFactors) {\r\n                let k = p.commonMonom(),\r\n                    pFactor = p.clone().divide(k)\r\n\r\n                if (k.degree().isZero()) {\r\n                    FactorizedConstant.multiply(k.coefficient)\r\n                    polyFactors.push(pFactor.clone())\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        // Factorize the current polynom.\r\n        this.factorize();\r\n\r\n        // Compare the given factors with the generated factors\r\n        let sign = 1,\r\n            notFoundedFactors = []\r\n        for (let f of this.factors) {\r\n            // The factor is just a coefficient. Might be opposed\r\n            if (f.degree().isZero()) {\r\n                if (f.monoms[0].coefficient.isNegativeOne()) {\r\n                    sign = -sign\r\n                }\r\n            }\r\n\r\n            let factorFound = false\r\n            for (let i = 0; i < polyFactors.length; i++) {\r\n                if (f.isEqual(polyFactors[i])) {\r\n                    polyFactors.splice(i, 1);\r\n                    factorFound = true\r\n                    break;\r\n                } else if (f.isOpposedAt(polyFactors[i])) {\r\n                    polyFactors.splice(i, 1);\r\n                    sign = -sign;\r\n                    factorFound = true\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!factorFound) {\r\n                notFoundedFactors.push(f.clone())\r\n            }\r\n        }\r\n\r\n        // The polyfactors must be empty and the cumulative opposite factors must be 1.\r\n        return (polyFactors.length === 0 && sign === 1);\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n\r\n    isReduced = (polynomString: string): Boolean => {\r\n        // The polynom must be developed to be reduced.\r\n        if (!this.isDeveloped(polynomString)) {\r\n            return false\r\n        }\r\n\r\n        let P = new Polynom(polynomString)\r\n        if (P.monoms.length > this.monoms.length) {\r\n            return false\r\n        }\r\n\r\n        // TODO: Not ur the reduced systme checking is working properly !\r\n        for (let m of P.monoms) {\r\n            if (!m.coefficient.isReduced()) {\r\n                return false\r\n            }\r\n        }\r\n\r\n        return false\r\n    }\r\n\r\n    isDeveloped = (polynomString: string): Boolean => {\r\n        let P: Polynom;\r\n\r\n        // Start by removing the parenthis after a \"power\"\r\n        let pString = polynomString.replaceAll(/\\^\\(([-0-9/]+)\\)/g, '$1')\r\n\r\n        // There is at least one parenthese - it is not developed.\r\n        if (pString.includes('(') || pString.includes(')')) {\r\n            return false\r\n        }\r\n\r\n        // Try to build the polynom\r\n        try {\r\n            // Build the polynom\r\n            P = new Polynom(polynomString);\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n\r\n        // Both polynom aren't the same (once developed and reduced => they cannot be equivalent)\r\n        if (!this.isEqual(P)) {\r\n            return false;\r\n        }\r\n\r\n        // Check that everything is completely developed. Actually, there are no parentheses... so it is fully developed\r\n        return true\r\n\r\n        // // maybe it wasn't reduced and not ordered...\r\n        // // compare polynom string.\r\n        //\r\n        // // normalize the string\r\n        // let polynomStringNormalized = polynomString.replaceAll('[*\\s]', '')\r\n        //\r\n        // // Determine if it's the exact same string.\r\n        // // TODO: Maybe it's enough to just make this test !a\r\n        // return polynomStringNormalized === P.reduce().reorder().display\r\n    }\r\n\r\n    // -------------------------------------\r\n    reduce = (): Polynom => {\r\n        // Reduce the polynom\r\n        let values = this._monoms.map(x => x.clone()),\r\n            vars = [...this.variables]\r\n\r\n        // Group the monoms by similarity\r\n        let i = 0\r\n        while (i < this._monoms.length) {\r\n            for (let j = i + 1; j < this._monoms.length; j++) {\r\n                if (this._monoms[i].isSameAs(this._monoms[j])) {\r\n                    this._monoms[i].add(this._monoms[j])\r\n                    this._monoms.splice(j, 1)\r\n                    if (this._monoms[i].isZero()) {\r\n                        this._monoms[i] = new Monom().zero()\r\n                    }\r\n                    j--\r\n                }\r\n            }\r\n            i++\r\n        }\r\n\r\n        //\r\n        //\r\n        //\r\n        // let coeffs = values.filter(x => x.variables.length === 0)\r\n        //\r\n        // if (coeffs.length > 0) {\r\n        //     this._monoms.push(coeffs.reduce((a, b) => a.add(b)))\r\n        // }\r\n        //\r\n        // // Build the new monoms\r\n        // for (let letter of vars) {\r\n        //     // Monom with same letters, but might be of different degrees\r\n        //     let M = values.filter(x => x.hasLetter(letter))\r\n        //\r\n        //     while (M.length > 0) {\r\n        //         // Take the first element\r\n        //         const m = M.shift(), degree = m.degree(letter)\r\n        //\r\n        //         for (let a of M.filter(x => x.degree(letter).isEqual(degree))) {\r\n        //             m.add(a)\r\n        //         }\r\n        //\r\n        //         this._monoms.push(m)\r\n        //\r\n        //         // Make the new array.\r\n        //         M = M.filter(x => x.degree(letter).isNotEqual(degree))\r\n        //     }\r\n        //     // reduce the monom\r\n        //\r\n        // }\r\n\r\n\r\n        // Remove all null monoms\r\n        this._monoms = this._monoms.filter((m) => {\r\n            return m.coefficient.value !== 0\r\n        });\r\n\r\n        // Reduce all monoms coefficient.\r\n        for (const m of this._monoms) {\r\n            m.coefficient.reduce();\r\n        }\r\n\r\n        if (this.length === 0) {\r\n            return new Polynom().zero();\r\n        }\r\n\r\n        return this.reorder();\r\n    };\r\n\r\n    reorder = (letter: string = 'x', revert?: boolean): Polynom => {\r\n        if (revert === undefined) {\r\n            revert = false\r\n        }\r\n\r\n        // TODO: Must handle multiple setLetter reorder system\r\n        let otherLetters = this.variables.filter(x => x !== letter)\r\n        this._monoms.sort(function (a, b) {\r\n            let da = a.degree(letter).value,\r\n                db = b.degree(letter).value\r\n\r\n            // Values are different\r\n            if (da !== db) return revert ? da - db : db - da\r\n\r\n            // if values are equals, check other letters - it must be revert in that case !\r\n            if (otherLetters.length > 0) {\r\n                for (let L of otherLetters) {\r\n                    let da = a.degree(L).value,\r\n                        db = b.degree(L).value\r\n\r\n                    // Values are different\r\n                    if (da !== db) return revert ? da - db : db - da\r\n                }\r\n            }\r\n\r\n            return 0\r\n            // return b.degree(letter).clone().subtract(a.degree(letter)).value\r\n        });\r\n\r\n        return this;\r\n    };\r\n\r\n    degree = (letter?: string): Fraction => {\r\n        let d: Fraction = new Fraction().zero();\r\n        for (const m of this._monoms) {\r\n            d = Fraction.max(m.degree(letter).value, d);\r\n        }\r\n        return d;\r\n    };\r\n\r\n    letters = (): string[] => {\r\n        let L: string[] = [], S = new Set();\r\n\r\n        for (let m of this._monoms) {\r\n            S = new Set([...S, ...m.variables]);\r\n        }\r\n\r\n        // @ts-ignore\r\n        return [...S];\r\n    }\r\n\r\n    /**\r\n     * Replace a variable (letter) by a polynom.\r\n     * @param letter\r\n     * @param P\r\n     */\r\n    replaceBy = (letter: string, P: Polynom): Polynom => {\r\n        this.mark_as_dirty()\r\n\r\n        let pow: Fraction;\r\n        const resultPolynom: Polynom = new Polynom().zero();\r\n\r\n        for (const m of this.monoms) {\r\n            if (m.literal[letter] === undefined || m.literal[letter].isZero()) {\r\n                resultPolynom.add(m.clone());\r\n            } else {\r\n                // We have found a setLetter.\r\n                // Get the power and reset it.\r\n                pow = m.literal[letter].clone();\r\n                delete m.literal[letter];\r\n\r\n                // TODO: replaceBy works only with positive and natural pow\r\n                resultPolynom.add(P.clone().pow(Math.abs(pow.numerator)).multiply(m));\r\n            }\r\n        }\r\n\r\n        this._monoms = resultPolynom.reduce().reorder().monoms;\r\n        return this;\r\n    };\r\n\r\n    // Evaluate a polynom.\r\n    evaluate = (values: literalType | Fraction | number): Fraction => {\r\n        const r = new Fraction().zero();\r\n\r\n        this._monoms.forEach(monom => {\r\n            //console.log('Evaluate polynom: ', monom.display, values, monom.evaluate(values).display);\r\n            r.add(monom.evaluate(values));\r\n        });\r\n\r\n        return r;\r\n    };\r\n\r\n    evaluateAsNumeric = (values: { [Key: string]: number } | number): number => {\r\n        let r = 0\r\n        this._monoms.forEach(monom => {\r\n            r += monom.evaluateAsNumeric(values)\r\n        })\r\n\r\n        return r\r\n    }\r\n\r\n    derivative = (letter?: string): Polynom => {\r\n        let dP = new Polynom();\r\n\r\n        for (let m of this._monoms) {\r\n            dP.add(m.derivative(letter));\r\n        }\r\n        return dP;\r\n    }\r\n    // ------------------------------------------\r\n    // Misc polynoms functions\r\n\r\n    primitive = (letter?: string): Polynom => {\r\n        let dP = new Polynom();\r\n\r\n        for (let m of this._monoms) {\r\n            dP.add(m.primitive(letter))\r\n        }\r\n        return dP\r\n    }\r\n\r\n    integrate = (a: Fraction | number, b: Fraction | number, letter?: string): Fraction => {\r\n        const primitive = this.primitive(letter)\r\n\r\n        if (letter === undefined) {\r\n            letter = 'x'\r\n        }\r\n\r\n        let valuesA: literalType = {},\r\n            valuesB: literalType = {}\r\n        valuesA[letter] = new Fraction(a);\r\n        valuesB[letter] = new Fraction(b);\r\n\r\n        return primitive.evaluate(valuesB).subtract(primitive.evaluate(valuesA))\r\n    }\r\n\r\n    // -------------------------------------\r\n    /**\r\n     * Factorize a polynom and store the best results in factors.\r\n     * @param maxValue Defines the greatest value to search to (default is 20).\r\n     */\r\n    factorize = (letter?: string): Polynom[] => {\r\n        if (!this.dirty_factors) {\r\n            return this._factors\r\n        }\r\n\r\n        let factors: Polynom[] = [];\r\n        let P = this.clone().reorder()\r\n\r\n        // Extract the common monom\r\n        // 2x^3+6x^2 => 2x^2\r\n        let M = P.commonMonom()\r\n        // If the polynom starts with a negative monom, factorize it.\r\n        if (P.monomByDegree().coefficient.isStrictlyNegative() && M.coefficient.isStrictlyPositive() && !M.isOne()) {\r\n            M.opposed()\r\n        }\r\n\r\n        if (!M.isOne()) {\r\n            let tempPolynom: Polynom = new Polynom(M)\r\n            factors = [tempPolynom.clone()]\r\n            P = P.euclidian(tempPolynom).quotient;\r\n        }\r\n\r\n        // Main loop\r\n        let securityLoop = P.degree().clone().multiply(2).value,\r\n            maxDegree = 1\r\n        while (securityLoop >= 0) {\r\n            securityLoop--\r\n            if (P.monoms.length < 2) {\r\n                // The polynom has only one monom => 7x^2\r\n                // No need to continue.\r\n                if (!P.isOne()) {\r\n                    factors.push(P.clone())\r\n                    P.one()\r\n                }\r\n                break\r\n            } else if (P.degree(letter).isOne()) {\r\n                // The polynom is a first degree polynom => 3x-5\r\n                // No need to continue\r\n                factors.push(P.clone())\r\n                P.one()\r\n                break\r\n            } else {\r\n                // Create the list of all \"potential\" polynom dividers.\r\n                let allDividers: Polynom[] = this._getAllPotentialFactors(P, maxDegree, letter)\r\n                maxDegree = P.degree(letter).value\r\n\r\n                // Actually: 100ms\r\n                while (allDividers.length > 0) {\r\n                    let div = allDividers[0]\r\n\r\n                    if (!P.isDividableBy(div)) {\r\n                        // Not dividable. Remove it from the list\r\n                        allDividers.shift()\r\n                    } else {\r\n                        // It's dividable - so make the division\r\n                        let result = P.euclidian(div)\r\n\r\n                        // Add the factor\r\n                        factors.push(div)\r\n\r\n                        // As it's dividable, get the quotient.\r\n                        P = result.quotient.clone()\r\n\r\n                        // filter all dividers that are no more suitable.\r\n                        allDividers = allDividers.filter(x => {\r\n                            let pX = P.monoms[0],\r\n                                pC = P.monoms[P.monoms.length - 1],\r\n                                dX = x.monoms[0],\r\n                                dC = x.monoms[x.monoms.length - 1]\r\n\r\n                            // Check last item (degree zero)\r\n                            if (!pC.isDivisible(dC)) return false\r\n\r\n                            // Check the first item (degree max)\r\n                            return pX.isDivisible(dX);\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Maybe there is still something in the Polynom (not everything was possible to factorize)\r\n        if (!P.isOne()) {\r\n            factors.push(P.clone())\r\n        }\r\n\r\n        // Save the factors\r\n        this._factors = factors\r\n\r\n        // The factors list is no more dirty\r\n        this.dirty_factors = false\r\n\r\n        return this._factors;\r\n    }\r\n\r\n    isDividableBy = (div: Polynom): boolean => {\r\n        // Quick evaluation.\r\n        if (div.degree().isOne()) {\r\n            let zero = div.getZeroes()[0]\r\n\r\n            if (zero.exact instanceof Fraction) {\r\n                return this.evaluate(zero.exact).isZero()\r\n            } else {\r\n                return false\r\n            }\r\n        } else {\r\n            this.euclidianCache[div.tex] = this.euclidian(div)\r\n            return this.euclidianCache[div.tex].reminder.isZero()\r\n        }\r\n    }\r\n    // TODO: get zeroes for more than first degree and for more than natural degrees\r\n    getZeroes = (): ISolution[] => {\r\n        if (this.dirty_zeroes) {\r\n            let equ = new Equation(this.clone(), 0)\r\n            equ.solve()\r\n            this._zeroes = equ.solutions\r\n            this.dirty_zeroes = false\r\n        }\r\n\r\n        return this._zeroes\r\n    };\r\n\r\n    // TODO: analyse the next functions to determine if they are useful or not...\r\n    monomByDegree = (degree?: Fraction | number, letter?: string): Monom => {\r\n        if (degree === undefined) {\r\n            // return the highest degree monom.\r\n            return this.monomByDegree(this.degree(letter), letter);\r\n        }\r\n\r\n        // Reduce the polynom.\r\n        const M = this.clone().reduce();\r\n        for (const m of M._monoms) {\r\n            if (m.degree(letter).isEqual(degree)) {\r\n                return m.clone();\r\n            }\r\n        }\r\n\r\n        // Nothing was found - return the null monom.\r\n        return new Monom().zero();\r\n    };\r\n\r\n    monomsByDegree = (degree?: number | Fraction, letter?: string): Monom[] => {\r\n        if (degree === undefined) {\r\n            // return the highest degree monom.\r\n            return this.monomsByDegree(this.degree(letter));\r\n        }\r\n\r\n        // Reduce the polynom.\r\n        let Ms: Monom[] = [];\r\n\r\n        const M = this.clone().reduce();\r\n        for (const m of M._monoms) {\r\n            if (m.degree(letter) === degree) {\r\n                Ms.push(m.clone())\r\n            }\r\n        }\r\n\r\n        return Ms\r\n        // Nothing was found - retur\r\n    }\r\n\r\n    // Used in LinearSystem.tex\r\n    monomByLetter = (letter: string): Monom => {\r\n        const M = this.clone().reduce();\r\n        for (const m of M._monoms) {\r\n            if (m.hasLetter(letter)) {\r\n                return m.clone();\r\n            }\r\n        }\r\n\r\n        return new Monom().zero();\r\n    };\r\n\r\n    // Next functions are used for for commonMonom, which is used in the factorize method.\r\n    getDenominators = (): number[] => {\r\n        const denominators: number[] = [];\r\n        for (const m of this._monoms) {\r\n            denominators.push(m.coefficient.denominator);\r\n        }\r\n        return denominators;\r\n    };\r\n\r\n    getNumerators = (): number[] => {\r\n        const numerators: number[] = [];\r\n        for (const m of this._monoms) {\r\n            numerators.push(m.coefficient.numerator);\r\n        }\r\n        return numerators;\r\n    };\r\n\r\n    lcmDenominator = (): number => {\r\n        return Numeric.lcm(...this.getDenominators());\r\n    };\r\n    // ------------------------------------------\r\n    // Polynoms factorization functions\r\n\r\n    gcdDenominator = (): number => {\r\n        return Numeric.gcd(...this.getDenominators());\r\n    };\r\n\r\n    lcmNumerator = (): number => {\r\n        return Numeric.lcm(...this.getNumerators());\r\n    };\r\n\r\n    gcdNumerator = (): number => {\r\n        return Numeric.gcd(...this.getNumerators());\r\n    };\r\n    // ------------------------------------------\r\n    // Polynoms helpers functions\r\n    // -------------------------------------\r\n\r\n    commonMonom = (): Monom => {\r\n        let M = new Monom().one(), numerator: number, denominator: number, degree = this.degree();\r\n\r\n        numerator = this.gcdNumerator();\r\n        denominator = this.gcdDenominator();\r\n\r\n        M.coefficient = new Fraction(numerator, denominator);\r\n        for (let L of this.variables) {\r\n            // Initialize the setLetter with the max degree\r\n            M.setLetter(L, degree);\r\n            for (let m of this._monoms) {\r\n                M.setLetter(L, Fraction.min(m.degree(L), M.degree(L)));\r\n                if (M.degree(L).isZero()) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return M;\r\n    }\r\n\r\n    limitToInfinity = (letter?: string): Fraction => {\r\n        const M = this.monomByDegree(undefined, letter),\r\n            sign = M.coefficient.sign(),\r\n            degree = M.degree(letter)\r\n\r\n        if (degree.isStrictlyPositive()) {\r\n            return sign === 1 ? (new Fraction()).infinite() : (new Fraction()).infinite().opposed()\r\n        } else if (degree.isZero()) {\r\n            return M.coefficient\r\n        }\r\n\r\n        // Any other cases\r\n        return (new Fraction()).zero()\r\n    }\r\n    limitToNegativeInfinity = (letter?: string): Fraction => {\r\n        const M = this.monomByDegree(undefined, letter),\r\n            sign = M.coefficient.sign(),\r\n            degree = M.degree(letter)\r\n\r\n        if (degree.isStrictlyPositive()) {\r\n            return sign === -1 ? (new Fraction()).infinite() : (new Fraction()).infinite().opposed()\r\n        } else if (degree.isZero()) {\r\n            return M.coefficient\r\n        }\r\n\r\n        // Any other cases\r\n        return (new Fraction()).zero()\r\n    }\r\n\r\n    private _getAllPotentialFactors = (P: Polynom, maxDegree: number, letter: string): Polynom[] => {\r\n        let m1 = P.monoms[0].dividers,\r\n            m2 = P.monoms[P.monoms.length - 1].dividers\r\n\r\n        let allDividers: Polynom[] = []\r\n        m1.forEach(m1d => {\r\n            // Get only polynom that has a degree less than a specific value\r\n            if (m1d.degree(letter).leq(maxDegree)) {\r\n                m2.forEach(m2d => {\r\n                    if (m1d.degree(letter).isNotEqual(m2d.degree(letter))) {\r\n                        allDividers.push(new Polynom(m1d, m2d))\r\n                        allDividers.push(new Polynom(m1d, m2d.clone().opposed()))\r\n                    }\r\n                })\r\n            }\r\n        })\r\n\r\n        return allDividers\r\n\r\n    }\r\n\r\n    private _parseString(inputStr: string, ...values: unknown[]): Polynom {\r\n        if (values === undefined || values.length === 0) {\r\n            inputStr = '' + inputStr;\r\n            this._rawString = inputStr.trim().replaceAll(' ', '');\r\n\r\n            // Parse the polynom using the shutting yard algorithm\r\n            if (inputStr !== '' && !isNaN(Number(inputStr))) {\r\n                this.empty();\r\n                // It's a simple number.\r\n                let m = new Monom(inputStr);\r\n                // m.coefficient = new Fraction(inputStr);\r\n                // m.literalStr = '';\r\n                this.add(m);\r\n                return this;\r\n            }\r\n\r\n            // Parse the string.\r\n            return this.shutingYardToReducedPolynom(inputStr);\r\n        } else if (/^[a-z]/.test(inputStr)) {\r\n            // We assume the inputStr contains only letters.\r\n            this.empty();\r\n\r\n            let fractions = values.map(x => new Fraction(x));\r\n            // Multiple setLetter version\r\n            if (inputStr.length > 1) {\r\n                // TODO: check that the number of values given correspond to the letters (+1 eventually)\r\n                let letters = inputStr.split(''),\r\n                    i = 0;\r\n                for (let F of fractions) {\r\n                    let m = new Monom();\r\n                    m.coefficient = F.clone();\r\n                    m.literalStr = letters[i] || '';\r\n                    this.add(m);\r\n                    i++;\r\n                }\r\n            }\r\n            // Single setLetter version\r\n            else {\r\n                let n = fractions.length - 1;\r\n                for (let F of fractions) {\r\n                    let m = new Monom()\r\n                    m.coefficient = F.clone();\r\n                    m.literalStr = `${inputStr}^${n}`\r\n                    this.add(m);\r\n                    n--;\r\n                }\r\n            }\r\n            return this;\r\n        } else {\r\n            return this.zero();\r\n        }\r\n    }\r\n\r\n    private genDisplay = (output?: string, forceSign?: boolean, wrapParentheses?: boolean, withAllMultSign?: boolean): string => {\r\n        let P: string = '';\r\n\r\n        for (const k of this._monoms) {\r\n            if (k.coefficient.value === 0) {\r\n                continue;\r\n            }\r\n\r\n            // The monom to be displayed\r\n            let m\r\n            if (withAllMultSign) {\r\n                m = k.plotFunction\r\n            } else {\r\n                m = (output === 'tex') ? k.tex : k.display\r\n            }\r\n\r\n            P += `${(k.coefficient.sign() === 1 && (P !== '' || forceSign === true)) ? '+' : ''}${m}`;\r\n        }\r\n\r\n        if (wrapParentheses === true && this.length > 1) {\r\n            if (output === 'tex') {\r\n                P = `\\\\left( ${P} \\\\right)`;\r\n            } else {\r\n                P = `(${P})`;\r\n            }\r\n        }\r\n\r\n        if (P === '') {\r\n            P = '0';\r\n        }\r\n        return P;\r\n    };\r\n\r\n    /**\r\n     * Main parse using a shutting yard class\r\n     * @param inputStr\r\n     */\r\n    private shutingYardToReducedPolynom = (inputStr: string): Polynom => {\r\n        // Get the RPN array of the current expression\r\n        const SY: Shutingyard = new Shutingyard().parse(inputStr);\r\n        const rpn: { token: string, tokenType: string }[] = SY.rpn;\r\n\r\n        // New version for reducing shuting yard.\r\n        this.zero()\r\n\r\n        let stack: Polynom[] = [],\r\n            monom: Monom = new Monom()\r\n\r\n        // Loop through the\r\n        for (const element of rpn) {\r\n            this.addToken(stack, element);\r\n        }\r\n\r\n        if (stack.length === 1) {\r\n            this.add(stack[0])\r\n        }\r\n\r\n        return this.reorder()\r\n    }\r\n\r\n    private multiplyByPolynom = (P: Polynom): Polynom => {\r\n        const M: Monom[] = [];\r\n        for (const m1 of this._monoms) {\r\n            for (const m2 of P.monoms) {\r\n                M.push(Monom.xmultiply(m1, m2));\r\n            }\r\n        }\r\n\r\n        this._monoms = M;\r\n        return this.reduce();\r\n    };\r\n\r\n    private multiplyByFraction = (F: Fraction): Polynom => {\r\n        for (const m of this._monoms) {\r\n            m.coefficient.multiply(F);\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    private multiplyByInteger = (nb: number): Polynom => {\r\n        return this.multiplyByFraction(new Fraction(nb));\r\n    };\r\n\r\n    private multiplyByMonom = (M: Monom): Polynom => {\r\n        for (const m of this._monoms) {\r\n            m.multiply(M)\r\n        }\r\n        return this.reduce();\r\n    };\r\n\r\n    private divideByInteger = (nb: number): Polynom => {\r\n        const nbF = new Fraction(nb);\r\n        for (const m of this._monoms) {\r\n            m.coefficient.divide(nbF);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    private divideByFraction = (F: Fraction): Polynom => {\r\n        for (const m of this._monoms) {\r\n            m.coefficient.divide(F);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    private _factorize2ndDegree = (letter: string): Polynom[] => {\r\n        let P1: Polynom, P2: Polynom,\r\n            a, b, c, delta, x1, x2, factor;\r\n\r\n        // One variable only\r\n        if (this.numberOfVars === 1) {\r\n            a = this.monomByDegree(2, letter).coefficient;\r\n            b = this.monomByDegree(1, letter).coefficient;\r\n            c = this.monomByDegree(0, letter).coefficient;\r\n            delta = b.clone().pow(2).subtract(a.clone().multiply(c).multiply(4));\r\n\r\n            if (delta.isZero()) {\r\n                x1 = b.clone().opposed().divide(a.clone().multiply(2))\r\n                P1 = new Polynom(letter).subtract(x1.display).multiply(x1.denominator)\r\n                P2 = new Polynom(letter).subtract(x1.display).multiply(x1.denominator)\r\n                factor = a.divide(x1.denominator).divide(x1.denominator);\r\n\r\n                if (!factor.isOne()) {\r\n                    // TODO: Update new Polynom to accept anything...\r\n                    return [new Polynom(factor.display), P1, P2]\r\n                } else {\r\n                    return [P1, P2]\r\n                }\r\n            } else if (delta.isPositive() && delta.isSquare()) {\r\n                x1 = b.clone().opposed()\r\n                    .add(delta.clone().sqrt())\r\n                    .divide(a.clone().multiply(2))\r\n                x2 = b.clone().opposed()\r\n                    .subtract(delta.clone().sqrt())\r\n                    .divide(a.clone().multiply(2))\r\n\r\n                // (2x+5)(3x-2)\r\n                // 6x^2+11x-10\r\n                // a = 6, b = 11, c = -10\r\n                // delta = 121-4*6*(-10) = 361= 19^2\r\n                // x1 = (-11 + 19)  / 12 = 8/12 = 2/3\r\n                // x2 = (-11 - 19)  / 12 = -30/12 = -5/2\r\n                factor = a.divide(x1.denominator).divide(x2.denominator);\r\n                if (factor.isOne()) {\r\n                    return [\r\n                        new Polynom(letter).subtract(x1.display).multiply(x1.denominator),\r\n                        new Polynom(letter).subtract(x2.display).multiply(x2.denominator),\r\n                    ]\r\n                } else {\r\n                    return [\r\n                        new Polynom(factor.display),\r\n                        new Polynom(letter).subtract(x1.display).multiply(x1.denominator),\r\n                        new Polynom(letter).subtract(x2.display).multiply(x2.denominator),\r\n                    ]\r\n\r\n                }\r\n            } else {\r\n                // No solution possible - return the complete value.\r\n                return [this.clone()]\r\n            }\r\n        } else {\r\n            // If multiple variables, only handle perfect squares...\r\n            a = this.monomByDegree(2, letter);\r\n            b = this.monomByDegree(1, letter);\r\n            c = this.monomByDegree(0, letter);\r\n\r\n\r\n            if (a.isLiteralSquare() && c.isLiteralSquare()) {\r\n                // Check the middle item is same as...\r\n                if (b.clone().pow(2).isSameAs(a.clone().multiply(c))) {\r\n                    // Determine if the coefficient values matches.\r\n\r\n                    // Search 4 values (r, s, t, u) that matches:\r\n                    // (r X + s Y)(t X + u Y) = rt X^2 + (ru + st) XY + su Y^2\r\n\r\n                    let xPolynom = new Polynom('x', a.coefficient, b.coefficient, c.coefficient);\r\n                    let xFactors = xPolynom._factorize2ndDegree('x');\r\n\r\n                    let factors = [], xyzPolynom: Polynom;\r\n\r\n                    if (xFactors.length >= 2) {\r\n                        for (let p of xFactors) {\r\n                            if (p.degree().isZero()) {\r\n                                factors.push(p.clone())\r\n                            } else {\r\n                                xyzPolynom = p.clone();\r\n                                xyzPolynom.monoms[0].literal = a.literalSqrt\r\n                                xyzPolynom.monoms[1].literal = c.literalSqrt\r\n                                factors.push(xyzPolynom.clone())\r\n                            }\r\n                        }\r\n                        return factors\r\n                    }\r\n                }\r\n            }\r\n\r\n            return [this.clone()]\r\n        }\r\n    }\r\n\r\n    private _factorizeByGroups = (): Polynom[] => {\r\n        // TODO: Factorize by groups.\r\n        return [];\r\n    }\r\n}\r\n","/**\r\n * Rational polynom module contains everything necessary to handle rational polynoms.\r\n * @module Polynom\r\n */\r\n\r\nimport {IEuclidian, Polynom} from \"./polynom\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {literalType} from \"./monom\";\r\nimport {PARTICULAR_SOLUTION} from \"./equation\";\r\nimport {RationalStudy} from \"./study/rationalStudy\";\r\nimport {StudyConfig} from \"./study\";\r\n\r\n/**\r\n * Rational class can handle rational polynoms\r\n */\r\nexport class Rational {\r\n    private _denominator: Polynom;\r\n    private _numerator: Polynom;\r\n    private _rawString: string;\r\n\r\n    /**\r\n     *\r\n     * @param numerator\r\n     * @param denominator\r\n     */\r\n    constructor(numerator?: Polynom | string, denominator?: Polynom | string) {\r\n        if (numerator instanceof Polynom) {\r\n            this._numerator = numerator.clone()\r\n        } else if (typeof numerator === 'string') {\r\n            this._numerator = new Polynom(numerator)\r\n        } else {\r\n            this._numerator = new Polynom()\r\n        }\r\n\r\n        if (denominator instanceof Polynom) {\r\n            this._denominator = denominator.clone()\r\n        } else if (typeof denominator === 'string') {\r\n            this._denominator = new Polynom(denominator)\r\n        } else {\r\n            this._denominator = new Polynom()\r\n        }\r\n\r\n    }\r\n\r\n    get numerator(): Polynom {\r\n        return this._numerator\r\n    }\r\n\r\n    get denominator(): Polynom {\r\n        return this._denominator\r\n    }\r\n\r\n    get tex(): string {\r\n        return `\\\\frac{ ${this._numerator.tex} }{ ${this._denominator.tex} }`;\r\n    }\r\n\r\n    get display(): string {\r\n        return `(${this._numerator.display})/(${this._denominator.display})`;\r\n    }\r\n\r\n    get texFactors(): string {\r\n        return `\\\\frac{ ${this._numerator.texFactors} }{ ${this._denominator.texFactors} }`\r\n    }\r\n\r\n    get plotFunction(): string {\r\n        return `(${this._numerator.plotFunction})/(${this._denominator.plotFunction})`\r\n    }\r\n\r\n    clone = (): Rational => {\r\n        return new Rational(\r\n            this._numerator.clone(),\r\n            this._denominator.clone()\r\n        )\r\n    }\r\n\r\n    domain = (): string => {\r\n        let zeroes = this._denominator.getZeroes();\r\n\r\n        if (zeroes.length === 0 || zeroes[0].tex === PARTICULAR_SOLUTION.real) {\r\n            return PARTICULAR_SOLUTION.varnothing\r\n        } else if (zeroes[0].tex === PARTICULAR_SOLUTION.varnothing) {\r\n            return PARTICULAR_SOLUTION.real\r\n        } else {\r\n            return '\\\\mathbb{R}\\\\setminus\\\\left\\\\{' +\r\n                zeroes.map(x => x.tex).join(';') + '\\\\right\\\\}'\r\n        }\r\n    }\r\n\r\n    amplify = (P: Polynom): Rational => {\r\n        this._numerator.multiply(P);\r\n        this._denominator.multiply(P);\r\n\r\n        return this;\r\n    }\r\n\r\n    derivative = (letter?: string): Rational => {\r\n        let N = this._numerator.clone(),\r\n            D = this._denominator.clone(),\r\n            dN = N.clone().derivative(letter),\r\n            dD = D.clone().derivative(letter)\r\n\r\n        this._numerator = dN.clone().multiply(D).subtract(N.clone().multiply(dD))\r\n        this._denominator = D.clone().pow(2)\r\n\r\n        return this\r\n    }\r\n\r\n    factorize = (letter?: string): Rational => {\r\n        this._numerator.factorize(letter)\r\n        this._denominator.factorize(letter)\r\n        return this\r\n    }\r\n\r\n    simplify = (P: Polynom): Rational => {\r\n        let NumeratorEuclidien = this._numerator.euclidian(P);\r\n        if (!NumeratorEuclidien.reminder.isZero()) {\r\n            return this;\r\n        }\r\n\r\n        let DenominatorEuclidien = this._denominator.euclidian(P);\r\n        if (!DenominatorEuclidien.reminder.isZero()) {\r\n            return this;\r\n        }\r\n\r\n        this._numerator = NumeratorEuclidien.quotient;\r\n        this._denominator = DenominatorEuclidien.quotient;\r\n        return this;\r\n    }\r\n\r\n    reduce = (): Rational => {\r\n        this._numerator.factorize();\r\n        for (let f of this._numerator.factors) {\r\n\r\n            if(f.degree().isZero()){\r\n                // Do the simplify only if the factor can divide the denominator\r\n                if(this._denominator.commonMonom().coefficient.clone().divide(f.monomByDegree().coefficient).isNatural()){\r\n                    this.simplify(f);\r\n                }\r\n            }else {\r\n                this.simplify(f);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    opposed = (): Rational => {\r\n        this._numerator.opposed();\r\n        return this;\r\n    }\r\n\r\n    add = (R: Rational): Rational => {\r\n        // 1. Make sure both rational are at the same denominator\r\n        // 2. Add the numerators.\r\n        // 3. Simplify\r\n\r\n        // Store the adding denominator\r\n        let denominator = this._denominator.clone()\r\n\r\n        // Amplif the main rational polynom by the adding denominator\r\n        this.amplify(R._denominator)\r\n\r\n        // Add to the numerator the adding value...\r\n        this._numerator.add(R._numerator.clone().multiply(denominator));\r\n\r\n        return this;\r\n    }\r\n\r\n    subtract = (R: Rational): Rational => {\r\n        return this.add(R.clone().opposed())\r\n    }\r\n\r\n    euclidian = (): IEuclidian => {\r\n        return this._numerator.euclidian(this._denominator)\r\n    }\r\n\r\n    // TODO : where and how is used limits ?\r\n    limits = (value: Fraction | number, offset?: string, letter?: string): Fraction => {\r\n        if (value === Infinity || value === -Infinity) {\r\n            let {quotient, reminder} = this._numerator.clone().euclidian(this._denominator)\r\n\r\n            // quotient is positive => it will be infinite.\r\n            if (quotient.degree(letter).isStrictlyPositive()) {\r\n                return value === Infinity ? quotient.limitToInfinity(letter) : quotient.limitToNegativeInfinity(letter)\r\n                // return quotient.monomByDegree(undefined, letter).coefficient.sign()===1?(new Fraction()).infinite():(new Fraction()).infinite().opposed()\r\n            } else {\r\n                return quotient.monomByDegree(undefined, letter).coefficient\r\n            }\r\n        } else {\r\n            let evalValues: literalType = {},\r\n                evalValuesOffset: literalType = {},\r\n                theLimit: Fraction | number,\r\n                theSign: number,\r\n                FR = this.clone().reduce()\r\n\r\n            evalValues[letter === undefined ? 'x' : letter] = new Fraction(value)\r\n\r\n            if (offset !== 'above' && offset !== 'below') {\r\n                theLimit = FR._numerator.evaluate(evalValues)\r\n                    .divide(FR._denominator.evaluate(evalValues))\r\n\r\n                return theLimit.isInfinity() ? theLimit.abs() : theLimit\r\n            } else {\r\n                if (offset === 'above') {\r\n                    evalValuesOffset[letter === undefined ? 'x' : letter] = (new Fraction(value)).add(0.000001)\r\n                } else if (offset === 'below') {\r\n                    evalValuesOffset[letter === undefined ? 'x' : letter] = (new Fraction(value)).subtract(0.000001)\r\n                }\r\n\r\n                theLimit = FR._numerator.evaluate(evalValues)\r\n                    .divide(FR._denominator.evaluate(evalValues))\r\n                theSign = FR._numerator.evaluate(evalValuesOffset)\r\n                    .divide(FR._denominator.evaluate(evalValuesOffset)).sign()\r\n\r\n                if (theLimit.isInfinity()) {\r\n                    return theSign === 1 ? theLimit.abs() : theLimit.abs().opposed()\r\n                } else {\r\n                    return theLimit\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    evaluate = (values: literalType | Fraction | number): Fraction => {\r\n        const r = new Fraction().zero();\r\n\r\n        let N = this._numerator.evaluate(values),\r\n            D = this._denominator.evaluate(values)\r\n\r\n        return N.divide(D)\r\n    };\r\n\r\n    evaluateAsNumeric = (values: { [Key: string]: number } | number): number => {\r\n        return this._numerator.evaluateAsNumeric(values) / this._denominator.evaluateAsNumeric(values)\r\n    }\r\n\r\n    study = (config?:StudyConfig|string): RationalStudy => {\r\n        return new RationalStudy(this, config)\r\n    }\r\n}\r\n","/**\r\n * Rational polynom module contains everything necessary to handle rational polynoms.\r\n * @module Polynom\r\n */\r\n\r\nimport {Rational} from \"./rational\";\r\nimport {ISolution} from \"./equation\";\r\nimport {Polynom} from \"./polynom\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Point} from \"../geometry/point\";\r\nimport {NumExp} from \"../numexp\";\r\n\r\nexport type StudyableFunction = Rational\r\n\r\n\r\nexport enum ZEROTYPE {\r\n    ZERO = 'z',\r\n    DEFENCE = 'd',\r\n    NOTHING = 't'\r\n}\r\n\r\nexport interface IZero extends ISolution {\r\n    extrema: FUNCTION_EXTREMA,\r\n    type: ZEROTYPE\r\n}\r\n\r\nexport enum ASYMPTOTE {\r\n    VERTICAL = \"av\",\r\n    HORIZONTAL = \"ah\",\r\n    SLOPE = \"ao\",\r\n    HOLE = \"hole\"\r\n}\r\n\r\nexport enum ASYMPTOTE_POSITION {\r\n    \"LT\" = \"LT\",\r\n    \"RT\" = \"RT\",\r\n    \"LB\" = \"LB\",\r\n    \"RB\" = \"RB\"\r\n}\r\n\r\nexport interface IAsymptote {\r\n    deltaX: StudyableFunction\r\n    display: string,\r\n    fx: Polynom,\r\n    limits: string,\r\n    position: ASYMPTOTE_POSITION[]\r\n    tableOfSign: ITableOfSigns,\r\n    tex: string,\r\n    type: ASYMPTOTE,\r\n    zero: IZero,\r\n}\r\n\r\nexport enum FUNCTION_EXTREMA {\r\n    MIN = \"min\",\r\n    MAX = \"max\",\r\n    FLAT = \"flat\",\r\n    NOTHING = \"\"\r\n}\r\n\r\nexport interface IExtrema {\r\n    tex: {\r\n        x: string,\r\n        y: string\r\n    },\r\n    type: FUNCTION_EXTREMA,\r\n    value: {\r\n        x: number,\r\n        y: number\r\n    }\r\n\r\n}\r\n\r\nexport interface ITableOfSigns {\r\n    extremes: { [Key: string]: IExtrema },\r\n    factors: Polynom[],\r\n    fx: StudyableFunction,\r\n    signs: (string[])[],\r\n    tex: string\r\n    type: TABLE_OF_SIGNS\r\n    zeroes: IZero[],\r\n}\r\n\r\nexport enum TABLE_OF_SIGNS {\r\n    SIGNS = \"signs\",\r\n    GROWS = \"grows\",\r\n    VARIATIONS = \"variatins\"\r\n}\r\n\r\nexport interface StudyConfig {\r\n    asymptotes?: boolean,\r\n    derivative?: boolean,\r\n    domain?: boolean,\r\n    name?: string,\r\n    variable?: string,\r\n    signs?: boolean,\r\n    variations?: boolean\r\n}\r\n\r\n/**\r\n * The study class is a \"function study\" class that will get:\r\n * fx               : get the function\r\n * domain           : string\r\n * zeroes           : Object (tex, IZero)\r\n * signs            : table of signs + tex output  using tkz-tab\r\n * av               : vertical asymptotic\r\n * ah               : horizontal asymptotic\r\n * ao               : obliques\r\n * deltaX           : position relative\r\n * dx               : derivative\r\n * grows            : growing table + tex output  using tkz-tab\r\n * ddx              : drive seconde\r\n * variations       : variation table + tex output  using tkz-tab\r\n */\r\nexport class Study {\r\n    fx: StudyableFunction\r\n    private _asymptotes: IAsymptote[]\r\n    private _derivative: ITableOfSigns\r\n    private _signs: ITableOfSigns\r\n    private _variations: ITableOfSigns\r\n    private _zeroes: IZero[]\r\n    private _config: StudyConfig\r\n    private _name: string\r\n\r\n    constructor(fx: StudyableFunction, config?: StudyConfig | string) {\r\n        this.fx = fx\r\n\r\n        this._config = {\r\n            name :'f',\r\n            variable: 'x',\r\n            domain :true,\r\n            asymptotes :true,\r\n            signs :true,\r\n            derivative :true,\r\n            variations :true,\r\n        }\r\n\r\n        if (config) {\r\n            if (typeof config === 'string') {\r\n                const d = config.split(',')\r\n                this._config = {}\r\n                let n = d.filter(x=>x.includes('(') && x.includes(')'))\r\n\r\n                if(n.length===1){\r\n                    this._config.name = n[0].split('(')[0]\r\n                    this._config.variable = n[0].split('(')[1].split(')')[0]\r\n                }\r\n                this._config.domain = d.includes('d')\r\n                this._config.asymptotes = d.includes('a')\r\n                this._config.signs = d.includes('signs')\r\n                this._config.derivative = d.includes('dx')\r\n                this._config.variations = d.includes('ddx')\r\n            } else {\r\n                this._config = config\r\n            }\r\n        }\r\n\r\n        this.makeStudy()\r\n        return this\r\n    }\r\n\r\n    get name(): string {\r\n        return this._config.name;\r\n    }\r\n\r\n    set name(value: string) {\r\n        this._config.name = value;\r\n    }\r\n\r\n    get config(): StudyConfig {\r\n        return this._config;\r\n    }\r\n\r\n    set config(value: StudyConfig) {\r\n        this._config = value;\r\n    }\r\n\r\n    get zeroes(): IZero[] {\r\n        return this._zeroes;\r\n    }\r\n\r\n    get domain(): string {\r\n        return this.fx.domain()\r\n    }\r\n\r\n    get signs(): ITableOfSigns {\r\n        return this._signs;\r\n    }\r\n\r\n    get asymptotes(): IAsymptote[] {\r\n        return this._asymptotes;\r\n    }\r\n\r\n    get derivative(): ITableOfSigns {\r\n        return this._derivative;\r\n    }\r\n\r\n    get texSigns(): string {\r\n        return this._makeTexFromTableOfSigns(this._signs)\r\n    }\r\n\r\n    get texGrows(): string {\r\n        return this._makeTexFromTableOfSigns(this._derivative)\r\n    }\r\n\r\n    get texVariations(): string {\r\n        return this._makeTexFromTableOfSigns(this._variations)\r\n    }\r\n\r\n    makeStudy = (): void => {\r\n        this._zeroes = this.makeZeroes()\r\n\r\n        if (this._config.signs) this._signs = this.makeSigns()\r\n\r\n        if (this._config.asymptotes) this._asymptotes = this.makeAsymptotes()\r\n\r\n        if (this._config.derivative) this._derivative = this.makeDerivative()\r\n\r\n        if (this._config.variations) this._variations = this.makeVariation()\r\n\r\n        // Table of signs / derivative / variation\r\n        if (this._config.signs) this._signs.tex = this.texSigns\r\n\r\n        if (this._config.derivative) this._derivative.tex = this.texGrows\r\n\r\n        if (this._config.variations) this._variations.tex = this.texVariations\r\n    };\r\n\r\n    indexOfZero = (zeroes: IZero[], zero: IZero | ISolution): number => {\r\n        for (let i = 0; i < zeroes.length; i++) {\r\n            if (zeroes[i].tex === zero.tex) {\r\n                return i\r\n            }\r\n        }\r\n        return -1\r\n    };\r\n\r\n    makeOneLineForSigns = (factor: Polynom, zeroes: IZero[], zeroSign: ZEROTYPE): string[] => {\r\n        let oneLine: string[] = [],\r\n            currentZero = factor.getZeroes().map(x => x.tex)\r\n\r\n        // First +/- sign, before the first zero\r\n        oneLine.push('')\r\n        if (factor.degree().isZero()) {\r\n            oneLine.push(factor.monoms[0].coefficient.sign() === 1 ? '+' : '-')\r\n        } else {\r\n            oneLine.push(factor.evaluate(zeroes[0].value - 1).sign() === 1 ? '+' : '-')\r\n        }\r\n\r\n        for (let i = 0; i < zeroes.length; i++) {\r\n            // Add the zero if it's the current one\r\n            oneLine.push(currentZero.includes(zeroes[i].tex) ? zeroSign : ZEROTYPE.NOTHING)\r\n\r\n            // + / - sign after the current zero\r\n            if (i < zeroes.length - 1) {\r\n                oneLine.push(factor.evaluate((zeroes[i].value + zeroes[i + 1].value) / 2).sign() === 1 ? '+' : '-')\r\n            } else if (i === zeroes.length - 1) {\r\n                oneLine.push(factor.evaluate(zeroes[i].value + 1).sign() === 1 ? '+' : '-')\r\n            }\r\n\r\n        }\r\n        oneLine.push('')\r\n\r\n        return oneLine\r\n    }\r\n\r\n    makeSignsResult = (signs: (string[])[]): string[] => {\r\n\r\n        // Initialize the result line with the first line of the signs table\r\n        let resultLine: string[] = signs[0].map((x, index) => {\r\n            if (index === 0 || index === signs[0].length - 1) {\r\n                return ''\r\n            }\r\n\r\n            if (index % 2 === 0) {\r\n                return 't'\r\n            }\r\n\r\n            return '+'\r\n        })\r\n\r\n        // Go through each lines (except the first)\r\n        for (let current of signs) {\r\n\r\n            for (let i = 0; i < current.length; i++) {\r\n                if (i % 2 === 0) {\r\n                    // t, z or d\r\n                    if (resultLine[i] === 'd') {\r\n                        continue\r\n                    }\r\n                    if (current[i] !== 't') {\r\n                        resultLine[i] = current[i]\r\n                    }\r\n                } else {\r\n                    // + or -\r\n                    if (current[i] === '-') {\r\n                        resultLine[i] = resultLine[i] === '+' ? '-' : '+'\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return resultLine\r\n    }\r\n\r\n    makeGrowsResult = (tos: ITableOfSigns): { growsLine: string[], extremes: { [Key: string]: IExtrema } } => {\r\n\r\n        // Use the last line (=> resultLine) to grab the necessary information\r\n        let signsAsArray = Object.values(tos.signs),\r\n            resultLine = signsAsArray[signsAsArray.length - 1],\r\n            growsLine: string[] = [],\r\n            extremes: { [Key: string]: IExtrema } = {},\r\n            zeroes = tos.zeroes\r\n\r\n        // Get the extremes\r\n        for (let i = 0; i < zeroes.length; i++) {\r\n\r\n            // Get the corresponding item in the resultLine.\r\n            let pos = 2 * i + 2\r\n            if (resultLine[pos] === 'z') {\r\n\r\n                // It's a zero. Get the coordinates\r\n                let x: number, y: number, zero = zeroes[i].exact,\r\n                    pt: Point,\r\n                    xTex: string, yTex: string,\r\n                    pointType: FUNCTION_EXTREMA\r\n\r\n                // TODO: NumExp should parse something that isn't yet plotFunction\r\n                let exp = new NumExp(this.fx.plotFunction)\r\n\r\n                if (zero instanceof Fraction) {\r\n                    let value: Fraction = zero,\r\n                        evalY = this.fx.evaluate(value)\r\n\r\n                    x = zero.value\r\n                    y = evalY.value\r\n                    xTex = zero.tex\r\n                    yTex = evalY.tex\r\n                } else {\r\n                    x = zeroes[i].value\r\n                    y = exp.evaluate({x})\r\n\r\n                    xTex = x.toFixed(2)\r\n                    yTex = y.toFixed(2)\r\n                }\r\n\r\n                // Determine the type of the zero.\r\n                if (resultLine[pos - 1] === resultLine[pos + 1]) {\r\n                    pointType = FUNCTION_EXTREMA.FLAT\r\n                } else if (resultLine[pos - 1] === '+') {\r\n                    pointType = FUNCTION_EXTREMA.MAX\r\n                } else {\r\n                    pointType = FUNCTION_EXTREMA.MIN\r\n\r\n                }\r\n\r\n                // Add the point to the list\r\n                extremes[zeroes[i].tex] = {\r\n                    type: pointType,\r\n                    tex: {x: xTex, y: yTex},\r\n                    value: {x, y}\r\n                }\r\n            }\r\n        }\r\n\r\n        // Create the grows line, based on tkz-tab\r\n        // \\tkzTabLine{  ,  +  ,  z    ,  -  ,  d  ,  -  ,  z  ,  +  ,  }\r\n        // \\tkzTabVar{     -/  , +/$3$ ,       -D+/ , -/$1$  , +/  }\r\n        growsLine.push(resultLine[1] === '+' ? '-/' : '+/')\r\n        for (let i = 1; i < resultLine.length - 1; i++) {\r\n            if (resultLine[i] === \"z\") {\r\n                let extr = extremes[zeroes[(i - 2) / 2].tex]\r\n\r\n                growsLine.push(`${resultLine[i - 1]}/\\\\(${extr.type}(${extr.tex.x};${extr.tex.y})\\\\)`)\r\n            } else if (resultLine[i] === 'd') {\r\n                growsLine.push(`${resultLine[i - 1]}D${resultLine[i + 1] === '+' ? '-' : '+'}/`)\r\n            }\r\n        }\r\n        growsLine.push(`${resultLine[resultLine.length - 2]}/`)\r\n\r\n        return {growsLine, extremes}\r\n    }\r\n\r\n    makeVariationsResult = (tos: ITableOfSigns): { varsLine: string[], extremes: { [Key: string]: IExtrema } } => {\r\n        // TODO: make variations result is not yet implemented.\r\n        let extremes = {},\r\n            varsLine: string[] = []\r\n        return {varsLine, extremes}\r\n    }\r\n\r\n    makeZeroes(): IZero[] {\r\n        return []\r\n    };\r\n\r\n    makeSigns(): ITableOfSigns {\r\n        return {\r\n            type: TABLE_OF_SIGNS.SIGNS,\r\n            fx: null,\r\n            factors: [],\r\n            zeroes: [],\r\n            signs: [],\r\n            extremes: {},\r\n            tex: ''\r\n        }\r\n    };\r\n\r\n    makeAsymptotes(): IAsymptote[] {\r\n        return []\r\n    }\r\n\r\n    makeDerivative(): ITableOfSigns {\r\n        return {\r\n            type: TABLE_OF_SIGNS.GROWS,\r\n            fx: null,\r\n            factors: [],\r\n            zeroes: [],\r\n            signs: [],\r\n            extremes: {},\r\n            tex: ''\r\n        }\r\n    }\r\n\r\n    makeVariation(): ITableOfSigns {\r\n        return {\r\n            type: TABLE_OF_SIGNS.VARIATIONS,\r\n            fx: null,\r\n            factors: [],\r\n            zeroes: [],\r\n            signs: [],\r\n            extremes: {},\r\n            tex: ''\r\n        }\r\n    }\r\n\r\n    drawCode = (): string => {\r\n        // Function as string\r\n        let code = `f(x)=${this.fx.plotFunction}`\r\n\r\n        // Asymptotes\r\n        let i: number = 1\r\n        this.asymptotes.forEach(asymptote => {\r\n            if (asymptote.type === ASYMPTOTE.VERTICAL) {\r\n                code += `\\nav_${i}=line x=${asymptote.zero.value}->red,dash`\r\n                i++\r\n            } else if (asymptote.type === ASYMPTOTE.HORIZONTAL) {\r\n                code += `\\nah=line y=${asymptote.fx.monoms[0].coefficient.value}->orange,dash`\r\n            } else if (asymptote.type === ASYMPTOTE.SLOPE) {\r\n                code += `\\nao=line y=${asymptote.fx.plotFunction}->red,dash`\r\n            }\r\n            i++\r\n        })\r\n\r\n        // Extremes\r\n        for (let zero in this.derivative.extremes) {\r\n            let extreme = this.derivative.extremes[zero]\r\n\r\n            code += `\\nM_${i}(${extreme.value.x},${extreme.value.y})*`\r\n            i++\r\n        }\r\n\r\n        // Zeroes\r\n        this.zeroes.forEach(zero => {\r\n            if (zero.type === ZEROTYPE.ZERO) {\r\n                code += `\\nZ_${i}(${zero.value},0)*`\r\n                i++\r\n            }\r\n        })\r\n\r\n        return code\r\n    }\r\n\r\n    private _makeTexFromTableOfSigns = (tos: ITableOfSigns): string => {\r\n        let factors = tos.factors.map(x => `\\\\(${x.tex}\\\\)/1`),\r\n            factorsFx = `\\\\(${this._config.name}(${this._config.variable})\\\\)/1.2`,\r\n            zeroes = tos.zeroes\r\n\r\n        // Add the last lines \"label\"\r\n        if (tos.type === TABLE_OF_SIGNS.GROWS) {\r\n            factorsFx = `\\\\(${this._config.name}'(${this._config.variable})\\\\)/1.2,\\\\(f(x${this._config.variable})\\\\)/2`\r\n        } else if (tos.type === TABLE_OF_SIGNS.VARIATIONS) {\r\n            factorsFx = `\\\\(${this._config.name}''(${this._config.variable})\\\\)/1.2,\\\\(f(${this._config.variable})\\\\)/2`\r\n        }\r\n\r\n        // Create the tikzPicture header\r\n        let tex = `\\\\begin{tikzpicture}\r\n\\\\tkzTabInit[lgt=3,espcl=2,deltacl=0]{/1.2,${factors.join(',')},/.1,${factorsFx} }{{\\\\scriptsize \\\\hspace{1cm} \\\\(-\\\\infty\\\\)},\\\\(${zeroes.map(x => x.tex).join('\\\\),\\\\(')}\\\\),{\\\\scriptsize \\\\hspace{-1cm} \\\\(+\\\\infty\\\\)}}`\r\n\r\n        let pos\r\n        for (pos = 0; pos < tos.factors.length; pos++) {\r\n            tex += (`\\n\\\\tkzTabLine{${tos.signs[pos].join(',')}}`)\r\n        }\r\n\r\n        // Add the result line\r\n        tex += (`\\n\\\\tkzTabLine{${tos.signs[pos].join(',')}}`)\r\n        // Add the grows / vars line\r\n        if (tos.type === TABLE_OF_SIGNS.GROWS) {\r\n            tex += (`\\n\\\\tkzTabVar{${tos.signs[pos + 1].join(',')}}`)\r\n        } else if (tos.type === TABLE_OF_SIGNS.VARIATIONS) {\r\n            // TODO: Check variations table for as tex\r\n            tex += (`\\n\\\\tkzTabVar{${tos.signs[pos + 1].join(',')}}`)\r\n        }\r\n\r\n        tex += `\\n\\\\end{tikzpicture}`\r\n\r\n        return tex\r\n    }\r\n}\r\n","/**\r\n * The study class is a \"function study\" class that will get:\r\n * fx               : get the function\r\n * domain           : string\r\n * zeroes           : Object (tex, IZero)\r\n * signs            : table of signs + tex output  using tkz-tab\r\n * av               : vertical asymptotic\r\n * ah               : horizontal asymptotic\r\n * ao               : obliques\r\n * deltaX           : position relative\r\n * dx               : derivative\r\n * grows            : growing table + tex output  using tkz-tab\r\n * ddx              : drive seconde\r\n * variations       : variation table + tex output  using tkz-tab\r\n */\r\nimport {\r\n    ASYMPTOTE,\r\n    ASYMPTOTE_POSITION,\r\n    FUNCTION_EXTREMA,\r\n    IAsymptote,\r\n    ITableOfSigns,\r\n    IZero,\r\n    Study,\r\n    StudyableFunction, StudyConfig,\r\n    TABLE_OF_SIGNS,\r\n    ZEROTYPE\r\n} from \"../study\";\r\nimport {Rational} from \"../rational\";\r\nimport {Fraction} from \"../../coefficients/fraction\";\r\nimport {Polynom} from \"../polynom\";\r\n\r\nexport class RationalStudy extends Study {\r\n    constructor(fx: StudyableFunction, config?: StudyConfig|string) {\r\n        super(fx, config)\r\n\r\n        return this\r\n    }\r\n\r\n    makeZeroes(): IZero[] {\r\n        return this._getZeroes(this.fx)\r\n    };\r\n\r\n    makeSigns(): ITableOfSigns {\r\n        return this._getSigns(this.fx, this.zeroes)\r\n    };\r\n\r\n    makeAsymptotes(): IAsymptote[] {\r\n        const reduced: Rational = this.fx.clone().reduce()\r\n\r\n        // Vertical\r\n        let asymptotes: IAsymptote[] = []\r\n        this.zeroes.filter(x => x.type === ZEROTYPE.DEFENCE).forEach(zero => {\r\n            // Check if it's a hole or an asymptote\r\n            let Ztype = ASYMPTOTE.VERTICAL,\r\n                tex = `x=${zero.tex}`,\r\n                display = `x=${zero.display}`\r\n\r\n            // Check if it's a hole: the reduced polynom should not be null\r\n            if (zero.exact instanceof Fraction) {\r\n                if (reduced.denominator.evaluate(zero.exact).isNotZero()) {\r\n                    Ztype = ASYMPTOTE.HOLE\r\n                    tex = `(${zero.tex};${reduced.evaluate(zero.exact).tex})`\r\n                    display = `(${zero.display};${reduced.evaluate(zero.exact).display})`\r\n                }\r\n            } else {\r\n                if (reduced.denominator.evaluate(zero.value).isNotZero()) {\r\n                    Ztype = ASYMPTOTE.HOLE\r\n                    tex = `(${zero.tex};${reduced.evaluate(zero.value).tex})`\r\n                    display = `(${zero.display};${reduced.evaluate(zero.value).display})`\r\n                }\r\n            }\r\n\r\n            // Get the position before and after the asymptote.\r\n            const delta = 0.000001\r\n            let before = this.fx.evaluateAsNumeric(zero.value - delta),\r\n                after = this.fx.evaluateAsNumeric(zero.value + delta),\r\n                position: ASYMPTOTE_POSITION[] = [],\r\n                pm = \"\"\r\n\r\n            if (after < -10000) {\r\n                position.push(ASYMPTOTE_POSITION.RB)\r\n                pm += \"m\"\r\n            } else if (after > 10000) {\r\n                position.push(ASYMPTOTE_POSITION.RT)\r\n                pm += \"p\"\r\n            }\r\n\r\n            if (before < -10000) {\r\n                position.push(ASYMPTOTE_POSITION.LB)\r\n                pm += \"m\"\r\n            } else if (before > 10000) {\r\n                position.push(ASYMPTOTE_POSITION.LT)\r\n                pm += \"p\"\r\n            }\r\n\r\n            // Left and right are to infinity\r\n            // TODO: handle the case were one side of the asymptote isn't infinity (not possible in rational study?!)\r\n            if (pm === \"pp\") {\r\n                pm = \"+\"\r\n            } else if (pm === \"mm\") {\r\n                pm = \"-\"\r\n            } else {\r\n                pm = `\\\\${pm}`\r\n            }\r\n\r\n            asymptotes.push({\r\n                fx: null,\r\n                type: Ztype,\r\n                tex,\r\n                display,\r\n                zero: zero,\r\n                limits: `\\\\lim_{x\\\\to${zero.tex} }\\\\ f(x) = ${pm}\\\\infty`,\r\n                deltaX: null,\r\n                tableOfSign: null,\r\n                position\r\n            })\r\n        })\r\n\r\n        // Sloped asymptote\r\n        let NDegree = this.fx.numerator.degree(),\r\n            DDegree = this.fx.denominator.degree()\r\n        if (NDegree.isEqual(DDegree)) {\r\n            let H = this.fx.numerator.monomByDegree().coefficient.clone().divide(this.fx.denominator.monomByDegree().coefficient),\r\n                Htex = H.tex\r\n\r\n            let {reminder} = reduced.euclidian(),\r\n                deltaX = new Rational(reminder, reduced.denominator)\r\n\r\n            // Determine the position above or below on the left / right of the asymptote.\r\n            asymptotes.push({\r\n                fx: new Polynom(H),\r\n                type: ASYMPTOTE.HORIZONTAL,\r\n                tex: `y=${Htex}`,\r\n                display: `y=${H.display}`,\r\n                zero: null,\r\n                limits: `\\\\lim_{x\\\\to\\\\infty}\\\\ f(x) = ${Htex}`,\r\n                deltaX,\r\n                tableOfSign: this._getSigns(deltaX),\r\n                position: this._getHorizontalAsymptoteRelativePositon(deltaX)\r\n            })\r\n        } else if (DDegree.greater(NDegree)) {\r\n            asymptotes.push({\r\n                fx: new Polynom('0'),\r\n                type: ASYMPTOTE.HORIZONTAL,\r\n                tex: `y=0`,\r\n                display: `y=0`,\r\n                zero: null,\r\n                limits: `\\\\lim_{x\\\\to\\\\infty}\\\\ f(x) = ${0}`,\r\n                deltaX: null,\r\n                tableOfSign: null,\r\n                position: this._getHorizontalAsymptoteRelativePositon(this.fx)\r\n            })\r\n        } else if (NDegree.value - 1 === DDegree.value) {\r\n            // Calculate the slope\r\n            let {quotient, reminder} = reduced.euclidian(),\r\n                deltaX = new Rational(reminder, reduced.denominator)\r\n\r\n            asymptotes.push({\r\n                fx: quotient.clone(),\r\n                type: ASYMPTOTE.SLOPE,\r\n                tex: `y=${quotient.tex}`,\r\n                display: `y=${quotient.display}`,\r\n                zero: null,\r\n                limits: ``,\r\n                deltaX: new Rational(reminder, reduced.denominator),\r\n                tableOfSign: this._getSigns(deltaX),\r\n                position: this._getHorizontalAsymptoteRelativePositon(deltaX)\r\n            })\r\n        }\r\n\r\n        return asymptotes\r\n    };\r\n\r\n    _getHorizontalAsymptoteRelativePositon(deltaX: Rational, delta: number = 1000000): ASYMPTOTE_POSITION[] {\r\n\r\n        let position: ASYMPTOTE_POSITION[] = [],\r\n            before = deltaX.evaluateAsNumeric(-delta),\r\n            after = deltaX.evaluateAsNumeric(delta)\r\n\r\n        if (before >= 0) {\r\n            position.push(ASYMPTOTE_POSITION.LT)\r\n        } else {\r\n            position.push(ASYMPTOTE_POSITION.LB)\r\n        }\r\n\r\n        if (after >= 0) {\r\n            position.push(ASYMPTOTE_POSITION.RT)\r\n        } else {\r\n            position.push(ASYMPTOTE_POSITION.RB)\r\n        }\r\n\r\n        return position\r\n    }\r\n\r\n    makeDerivative(): ITableOfSigns {\r\n        let dx = this.fx.clone().derivative(),\r\n            tos = this._getSigns(dx, this._getZeroes(dx), TABLE_OF_SIGNS.GROWS)\r\n\r\n        let result = this.makeGrowsResult(tos)\r\n        tos.signs.push(result.growsLine)\r\n        tos.extremes = result.extremes\r\n        return tos\r\n    };\r\n\r\n    makeVariation(): ITableOfSigns {\r\n        // Get the zeroes, make signs.\r\n        let dx = this.derivative.fx.clone().derivative(),\r\n            tos = this._getSigns(dx, this._getZeroes(dx), TABLE_OF_SIGNS.VARIATIONS)\r\n\r\n        let result = this.makeVariationsResult(tos)\r\n        tos.signs.push(result.varsLine)\r\n        tos.extremes = result.extremes\r\n        return tos\r\n    };\r\n\r\n    private _getZeroes(fx: StudyableFunction) {\r\n        // All zeroes.\r\n        let zeroes: IZero[] = []\r\n\r\n        fx.numerator.getZeroes().filter(x => !isNaN(x.value)).forEach(z => {\r\n            // add the item\r\n            zeroes.push({\r\n                tex: z.tex,\r\n                display: z.display,\r\n                value: z.value,\r\n                exact: z.exact,\r\n                extrema: FUNCTION_EXTREMA.NOTHING,\r\n                type: ZEROTYPE.ZERO\r\n            })\r\n        })\r\n\r\n        fx.denominator.getZeroes().filter(x => !isNaN(x.value)).forEach(z => {\r\n            let idx = this.indexOfZero(zeroes, z)\r\n\r\n            if (idx !== -1) {\r\n                zeroes[idx].type = ZEROTYPE.DEFENCE\r\n            } else {\r\n                // Add the item\r\n                zeroes.push({\r\n                    tex: z.tex,\r\n                    display: z.display,\r\n                    value: z.value,\r\n                    exact: z.exact,\r\n                    extrema: FUNCTION_EXTREMA.NOTHING,\r\n                    type: ZEROTYPE.DEFENCE\r\n                })\r\n            }\r\n        })\r\n\r\n        // sort all zeroes\r\n        zeroes.sort((a, b) => a.value - b.value)\r\n\r\n        return zeroes\r\n    }\r\n\r\n    private _getSigns(fx: Rational, zeroes?: IZero[], typeOfTable?: TABLE_OF_SIGNS): ITableOfSigns {\r\n        // Factorize the rational\r\n        let signs: (string[])[] = [],\r\n            factors: Polynom[] = []\r\n\r\n        if (zeroes === undefined) {\r\n            zeroes = this._getZeroes(fx)\r\n        }\r\n\r\n        fx.numerator.factors.forEach(factor => {\r\n            signs.push(this.makeOneLineForSigns(factor, zeroes, ZEROTYPE.ZERO))\r\n            factors.push(factor.clone())\r\n        })\r\n\r\n        fx.denominator.factors.forEach(factor => {\r\n            signs.push(this.makeOneLineForSigns(factor, zeroes, ZEROTYPE.DEFENCE))\r\n            factors.push(factor.clone())\r\n        })\r\n\r\n        signs.push(this.makeSignsResult(signs))\r\n\r\n        return {\r\n            type: typeOfTable,\r\n            fx,\r\n            factors,\r\n            zeroes,\r\n            signs,\r\n            extremes: {},\r\n            tex: ''\r\n        }\r\n    }\r\n}\r\n","import {Numeric} from \"../numeric\";\r\n\r\nexport type FractionParsingType = number | string | Fraction\r\n\r\n/**\r\n * The fraction class make possible to handle\r\n * TODO: Write the documentation correctly.\r\n * \\\\(\\frac{a}{b}\\\\) or \\\\[\\frac{a}{b}\\\\]  values.\r\n */\r\nexport class Fraction {\r\n    private _denominator: number;\r\n    private _numerator: number;\r\n\r\n    constructor(value?: unknown, denominatorOrPeriodic?: number) {\r\n        this._numerator = 1;\r\n        this._denominator = 1;\r\n\r\n        if (value !== undefined) {\r\n            this.parse(value, denominatorOrPeriodic);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n\r\n    get numerator(): number {\r\n        return this._numerator;\r\n    }\r\n\r\n    set numerator(value: number) {\r\n        this._numerator = value;\r\n    }\r\n\r\n    get denominator(): number {\r\n        return this._denominator;\r\n    }\r\n\r\n    set denominator(value: number) {\r\n        this._denominator = value;\r\n    }\r\n\r\n    get value(): number {\r\n        return this._numerator / this._denominator;\r\n    }\r\n\r\n    // Display getter\r\n    get tex(): string {\r\n        if (this.isInfinity()) {\r\n            return `${this.sign() === 1 ? '+' : '-'}\\\\infty`\r\n        }\r\n\r\n        if (this.isExact()) {\r\n            if (this._denominator === 1) {\r\n                return `${this._numerator}`;\r\n            } else if (this._numerator < 0) {\r\n                return `-\\\\frac{ ${-this._numerator} }{ ${this._denominator} }`;\r\n            } else {\r\n                return `\\\\frac{ ${this._numerator} }{ ${this._denominator} }`;\r\n            }\r\n        } else {\r\n            return this.value.toFixed(3)\r\n        }\r\n    }\r\n\r\n    get texWithSign():string {\r\n        return this.isPositive() ? `+${this.tex}` : this.tex;\r\n    }\r\n\r\n    get display(): string {\r\n        if (this.isExact()) {\r\n            if (this._denominator === 1) {\r\n                return `${this._numerator}`;\r\n            } else {\r\n                return `${this._numerator}/${this._denominator}`;\r\n            }\r\n        } else {\r\n            return this.value.toFixed(3)\r\n        }\r\n    }\r\n\r\n    // Helper function to display fractions\r\n    get frac(): string {\r\n        return this.tex;\r\n    }\r\n\r\n    get dfrac(): string {\r\n        return this.tex.replace('\\\\frac', '\\\\dfrac');\r\n    }\r\n\r\n    get tfrac(): string {\r\n        return this.tex.replace('\\\\frac', '\\\\tfrac')\r\n    }\r\n\r\n    static max = (...fractions: (Fraction | number)[]): Fraction => {\r\n        let M = new Fraction(fractions[0])\r\n\r\n        for (let m of fractions) {\r\n            let compare = new Fraction(m)\r\n            if (compare.greater(M)) {\r\n                M = compare.clone()\r\n            }\r\n        }\r\n\r\n        return M\r\n    }\r\n\r\n    static min = (...fractions: (Fraction | number)[]): Fraction => {\r\n        let M = new Fraction(fractions[0])\r\n\r\n        for (let m of fractions) {\r\n            let compare = new Fraction(m)\r\n            if (compare.lesser(M)) {\r\n                M = compare.clone()\r\n            }\r\n        }\r\n\r\n        return M\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n\r\n    static average = (...fractions: (Fraction | number)[]): Fraction => {\r\n        let M = new Fraction().zero()\r\n\r\n        for (let f of fractions) {\r\n            M.add(f)\r\n        }\r\n\r\n        M.divide(fractions.length)\r\n\r\n        return M\r\n    }\r\n\r\n    static unique = (fractions: Fraction[], sorted?: boolean): Fraction[] => {\r\n        // TODO: make sure it's wokring -> test !\r\n        let unique: { [Key: string]: boolean } = {},\r\n            distinct: Fraction[] = []\r\n        fractions.forEach(x => {\r\n            if (!unique[x.clone().reduce().tex]) {\r\n                distinct.push(x.clone())\r\n                unique[x.tex] = true\r\n            }\r\n        })\r\n\r\n        if (sorted) {\r\n            return Fraction.sort(distinct)\r\n        } else {\r\n            return distinct\r\n        }\r\n    }\r\n\r\n    static sort = (fractions: Fraction[], reverse?: boolean): Fraction[] => {\r\n        // Todo make sure it's the correct order, not reverse -> make a test\r\n        let sorted = fractions.sort((a, b) => a.value - b.value)\r\n\r\n        if (reverse) {\r\n            sorted.reverse()\r\n        }\r\n\r\n        return sorted\r\n    }\r\n\r\n    isApproximative = (): boolean => {\r\n        return this._numerator.toString().length >= 15 && this._denominator.toString().length >= 15\r\n    }\r\n\r\n    isExact = (): boolean => {\r\n        return !this.isApproximative()\r\n    }\r\n\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse the value to get the numerator and denominator\r\n     * @param value : number or string to parse to get the fraction\r\n     * @param denominatorOrPeriodic (optional|number) : length of the periodic part: 2.333333 => 1 or denominator value\r\n     */\r\n    parse = (value: unknown, denominatorOrPeriodic?: number): Fraction => {\r\n        let S: string[];\r\n\r\n        // A null value means a zero fraction.\r\n        if (value === null || value === \"\") {\r\n            this._numerator = 0;\r\n            this._denominator = 1;\r\n            return this;\r\n        }\r\n\r\n        switch (typeof value) {\r\n            case \"string\":\r\n                // Split the string value in two parts: Numerator/Denominator\r\n                S = value.split('/');\r\n\r\n                // Security checks\r\n                if (S.length > 2) throw value + \" has too many divide signs\";\r\n                if (S.map(x => x === '' || isNaN(Number(x))).includes(true)) throw value + \" is not a valid number\"\r\n\r\n                if (S.length === 1) {\r\n                    // No divide sign - it's a number\r\n                    return this.parse(+S[0]);\r\n                } else if (S.length === 2) {\r\n                    // One divide signe\r\n                    // We check if the denominator is zero\r\n                    if (S[1] === '0') {\r\n                        this._numerator = NaN;\r\n                        this._denominator = 1;\r\n                    } else {\r\n                        this._numerator = +S[0];\r\n                        this._denominator = +S[1];\r\n                    }\r\n                } else {\r\n                    // More than one divide sign ?\r\n                    // This is impossible\r\n                    this._numerator = NaN;\r\n                    this._denominator = 1;\r\n                }\r\n                break;\r\n            case \"number\":\r\n                if (Number.isSafeInteger(value)) {\r\n                    // The given value is an integer\r\n                    this._numerator = +value;\r\n\r\n                    if (denominatorOrPeriodic === undefined || !Number.isSafeInteger(denominatorOrPeriodic)) {\r\n                        this._denominator = 1;\r\n                    } else {\r\n                        this._denominator = +denominatorOrPeriodic;\r\n                    }\r\n                } else {\r\n                    // The given value is a float number\r\n                    // Get the number of decimals after the float sign\r\n                    let [unit, decimal] = (value.toString()).split('.')\r\n                    let p: number = decimal?decimal.length:0;\r\n\r\n                    // Detect if the decimal part is periodic or not...\r\n\r\n\r\n                    // Transform the float number in two integer\r\n                    if (denominatorOrPeriodic === undefined) {\r\n                        this._numerator = value * Math.pow(10, p);\r\n                        this._denominator = Math.pow(10, p);\r\n                    } else if (Number.isSafeInteger(denominatorOrPeriodic)) {\r\n                        this._numerator = value * Math.pow(10, p) - Math.floor(value * Math.pow(10, p - denominatorOrPeriodic));\r\n                        this.denominator = Math.pow(10, p) - Math.pow(10, p - denominatorOrPeriodic)\r\n                    }\r\n\r\n                    this.reduce()\r\n                }\r\n                break;\r\n            case \"object\":\r\n                if (value instanceof Fraction) {\r\n                    this._numerator = +value.numerator;\r\n                    this._denominator = +value.denominator;\r\n                }\r\n                break;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n\r\n    clone = (): Fraction => {\r\n        let F = new Fraction();\r\n        F.numerator = +this._numerator;\r\n        F.denominator = +this._denominator;\r\n        return F;\r\n    };\r\n\r\n    zero = (): Fraction => {\r\n        this._numerator = 0;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    one = (): Fraction => {\r\n        this._numerator = 1;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    infinite = (): Fraction => {\r\n        this._numerator = Infinity;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    invalid = (): Fraction => {\r\n        this._numerator = NaN;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    opposed = (): Fraction => {\r\n        this._numerator = -this._numerator;\r\n        return this;\r\n    };\r\n\r\n    add = (F: Fraction | number): Fraction => {\r\n        if (F instanceof Fraction) {\r\n            let N: number = this._numerator,\r\n                D: number = this._denominator;\r\n\r\n            this._numerator = N * F.denominator + F.numerator * D;\r\n            this._denominator = D * F.denominator;\r\n        } else {\r\n            return this.add(new Fraction(F))\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    subtract = (F: Fraction | number): Fraction => {\r\n        if (F instanceof Fraction) {\r\n            return this.add(F.clone().opposed());\r\n        } else {\r\n            return this.add(-F)\r\n        }\r\n    };\r\n\r\n    multiply = (F: Fraction | number): Fraction => {\r\n        // Parse the value.\r\n        // If it's a fraction, return a clone of it\r\n        // If it's an integer, return the fraction F/1\r\n        let Q = new Fraction(F);\r\n\r\n        this._numerator = this._numerator * Q.numerator;\r\n        this._denominator = this._denominator * Q.denominator;\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    xMultiply = (...values: (Fraction | number)[]): Fraction => {\r\n        // Parse the value.\r\n        // If it's a fraction, return a clone of it\r\n        // If it's an integer, return the fraction F/1\r\n        for(let value of values){\r\n            let F = new Fraction(value)\r\n            this._numerator = this._numerator * F.numerator;\r\n            this._denominator = this._denominator * F.denominator;\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    divide = (F: Fraction | number): Fraction => {\r\n        let Q = new Fraction(F);\r\n\r\n        if (Q.numerator === 0) {\r\n            return new Fraction().infinite();\r\n        }\r\n\r\n        let N: number = +this._numerator,\r\n            D: number = +this._denominator;\r\n\r\n        this._numerator = N * Q.denominator;\r\n        this._denominator = D * Q.numerator;\r\n        return this.reduce();\r\n    };\r\n\r\n    invert = (): Fraction => {\r\n        let n = +this._numerator, d = +this._denominator;\r\n        this._numerator = d;\r\n        this._denominator = n;\r\n\r\n        return this;\r\n    }\r\n\r\n    pow = (p: number | Fraction): Fraction => {\r\n        // TODO: Fraction.pow with a value different than a safe integer !\r\n        if (p instanceof Fraction) {\r\n            return this.pow(p.value)\r\n        }\r\n\r\n        this.reduce();\r\n        if (p < 0) {\r\n            this.invert()\r\n        }\r\n\r\n        // Check if numerator and denominator are roots of...\r\n        // othervise, convert to numeric.\r\n        let controlNumerator = Math.floor(Math.pow(this._numerator, Math.abs(p))),\r\n            controlDenominator = Math.floor(Math.pow(this._denominator, Math.abs(p)))\r\n\r\n        if (controlNumerator ** Math.abs(p) === this._numerator\r\n            &&\r\n            controlDenominator ** Math.abs(p) === this._denominator) {\r\n\r\n            this._numerator = this._numerator ** Math.abs(p);\r\n            this._denominator = this._denominator ** Math.abs(p);\r\n        } else {\r\n            this._numerator = this._numerator ** Math.abs(p);\r\n            this._denominator = this._denominator ** Math.abs(p);\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    root = (p: number): Fraction => {\r\n        // TODO: nth - root of a fraction => this will return another type of coefficient.\r\n\r\n        // Check if they are perfect roots..\r\n        if (p === 0) {\r\n            return this;\r\n        }\r\n\r\n        // If negative, invert the fraction\r\n        if (p < 0) {\r\n            this.invert()\r\n        }\r\n\r\n        let n = Math.pow(this._numerator, Math.abs(1 / p)),\r\n            d = Math.pow(this._denominator, Math.abs(1 / p));\r\n\r\n        this._numerator = Math.pow(this._numerator, Math.abs(1 / p));\r\n        this._denominator = Math.pow(this._denominator, Math.abs(1 / p));\r\n        return this;\r\n    }\r\n\r\n    sqrt = (): Fraction => {\r\n        return this.root(2);\r\n    }\r\n\r\n    abs = (): Fraction => {\r\n        this._numerator = Math.abs(this._numerator);\r\n        this._denominator = Math.abs(this._denominator);\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations specific to fractions\r\n\r\n    // ------------------------------------------\r\n    reduce = (): Fraction => {\r\n        let g = Numeric.gcd(this._numerator, this._denominator);\r\n        this._numerator = this._numerator / g;\r\n        this._denominator = this._denominator / g;\r\n\r\n        if (this._denominator < 0) {\r\n            this._denominator = -this._denominator;\r\n            this._numerator = -this._numerator;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    amplify = (k: number): Fraction => {\r\n        if (Number.isSafeInteger(k)) {\r\n            this._numerator *= k;\r\n            this._denominator *= k;\r\n        }\r\n        return this;\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Compare the current coefficient with another coefficient\r\n     * @param F (Coefficient) The coefficient to compare\r\n     * @param sign (string| default is =): authorized values: =, <, <=, >, >= with some variations.\r\n     */\r\n    compare = (F: unknown, sign?: string): boolean => {\r\n        if (sign === undefined) {\r\n            sign = '=';\r\n        }\r\n\r\n        let compareFraction: Fraction\r\n        if (F instanceof Fraction) {\r\n            compareFraction = F.clone()\r\n        } else {\r\n            compareFraction = new Fraction(F)\r\n        }\r\n\r\n        switch (sign) {\r\n            case '>':\r\n                return this.value > compareFraction.value;\r\n            case \">=\" || \"=>\" || \"geq\":\r\n                return this.value >= compareFraction.value;\r\n            case \"<\":\r\n                return this.value < compareFraction.value;\r\n            case \"<=\" || \"=>\" || \"leq\":\r\n                return this.value <= compareFraction.value;\r\n            case \"=\":\r\n                // let F2: Fraction = compareFraction.clone().reduce(),\r\n                //     F1: Fraction = this.clone().reduce();\r\n                // return (F1.numerator === F2.numerator && F1.denominator === F2.denominator);\r\n                return this.value === compareFraction.value;\r\n            case \"<>\":\r\n                return this.value !== compareFraction.value;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /* Compare shortcuts */\r\n    lesser = (than: Fraction | number): Boolean => {\r\n        return this.compare(than, '<');\r\n    };\r\n    leq = (than: Fraction | number): Boolean => {\r\n        return this.compare(than, '<=');\r\n    };\r\n    greater = (than: Fraction | number): Boolean => {\r\n        return this.compare(than, '>');\r\n    };\r\n    geq = (than: Fraction | number): Boolean => {\r\n        return this.compare(than, '>=');\r\n    };\r\n    isEqual = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '=');\r\n    }\r\n    isNotEqual = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '<>');\r\n    }\r\n    isOpposed = (p: Fraction): boolean => {\r\n        return this.isEqual(p.clone().opposed());\r\n    }\r\n    isInverted = (p: Fraction): boolean => {\r\n        return this.isEqual(new Fraction().one().divide(p.clone()));\r\n    }\r\n    isZero = (): boolean => {\r\n        return this._numerator === 0;\r\n    }\r\n    isNotZero = (): boolean => {\r\n        return this._numerator !== 0;\r\n    }\r\n    isOne = (): boolean => {\r\n        return this._numerator === 1 && this._denominator === 1;\r\n    }\r\n    isNegativeOne = (): boolean => {\r\n        return this._numerator === -1 && this._denominator === 1;\r\n    }\r\n    isPositive = (): boolean => {\r\n        return this.sign() === 1;\r\n    }\r\n    isNegative = (): boolean => {\r\n        return this.sign() === -1;\r\n    }\r\n    isStrictlyPositive = (): boolean => {\r\n        return this.value > 0\r\n    }\r\n    isStrictlyNegative = (): Boolean => {\r\n        return this.value < 0\r\n    }\r\n    isNaN = (): boolean => {\r\n        return isNaN(this._numerator);\r\n    }\r\n    isInfinity = (): boolean => {\r\n        return Math.abs(this._numerator) === Infinity;\r\n    }\r\n    isFinite = (): boolean => {\r\n        return !this.isInfinity() && !this.isNaN();\r\n    }\r\n    isSquare = (): boolean => {\r\n        return Math.sqrt(this._numerator) % 1 === 0 && Math.sqrt(this._denominator) % 1 === 0\r\n    }\r\n    isReduced = (): boolean => {\r\n        return Math.abs(Numeric.gcd(this._numerator, this._denominator)) === 1\r\n    }\r\n    isNatural = (): boolean => {\r\n        return this.isRelative() && this.isPositive()\r\n    }\r\n    isRelative = (): boolean => {\r\n        return this.clone().reduce().denominator === 1\r\n    }\r\n    isRational = (): boolean => {\r\n        return !this.isRelative()\r\n    }\r\n    isEven = (): boolean => {\r\n        return this.isRelative() && this.value % 2 === 0\r\n    }\r\n    isOdd = (): boolean => {\r\n        return this.isRelative() && this.value % 2 === 1\r\n    }\r\n    sign = (): number => {\r\n        return (this._numerator * this._denominator >= 0) ? 1 : -1;\r\n    };\r\n\r\n\r\n    // TODO: The rest of the functions are not used or unnecessary ?\r\n    /**\r\n     * Simple function to determine if it's a fraction\r\n     */\r\n    areEquals = (...F: Fraction[]): boolean => {\r\n        for (let i = 0; i < F.length; i++) {\r\n            if (!this.isEqual(F[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n}","/**\r\n * NthRoot is something like \"a+b\\sqrt{3}\r\n */\r\nexport class NthRoot {\r\n    private _radical: number;\r\n    private _nth: number;\r\n    private _coefficient: number;\r\n    private _isValid:boolean;\r\n\r\n    constructor(...values: number[]) {\r\n        this._radical = 1;\r\n        this._coefficient = 1;\r\n        this._nth = 2;\r\n        this._isValid = true;\r\n\r\n        if(values !== undefined){\r\n            this.parse(values[0], values[1], values[2])\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get radical(): number {\r\n        return this._radical;\r\n    }\r\n\r\n    set radical(value: number) {\r\n        this._radical = value;\r\n    }\r\n\r\n    get nth(): number {\r\n        return this._nth;\r\n    }\r\n\r\n    set nth(value: number) {\r\n        if (Number.isSafeInteger(value) && value >= 2) {\r\n            this._nth = value;\r\n        } else {\r\n            // Error setting the nth root.\r\n            console.log('Error setting the nth root');\r\n            this._nth = 2;\r\n        }\r\n    }\r\n\r\n    get coefficient(): number {\r\n        return this._coefficient;\r\n    }\r\n\r\n    set coefficient(value: number) {\r\n        this._coefficient = value;\r\n    }\r\n\r\n    get tex(): string {\r\n        let C: string;\r\n\r\n        if (this._coefficient === 1) {\r\n            C = '';\r\n        } else if (this._coefficient === -1) {\r\n            C = '-';\r\n        } else {\r\n            C = this._coefficient.toString();\r\n        }\r\n\r\n        if (this._radical === 1) {\r\n            return `${this._coefficient}`;\r\n        } else {\r\n            if (this._nth === 2) {\r\n                return `${C}\\\\sqrt{${this._radical}}`\r\n            } else {\r\n                return `${C}\\\\sqrt[${this._nth}]{${this._radical}}`\r\n            }\r\n        }\r\n    }\r\n\r\n    get display(): string {\r\n        let C: string;\r\n\r\n        if (this._coefficient === 1) {\r\n            C = '';\r\n        } else if (this._coefficient === -1) {\r\n            C = '-';\r\n        } else {\r\n            C = this._coefficient.toString();\r\n        }\r\n\r\n        if (this._radical === 1) {\r\n            return `${this._coefficient}`;\r\n        } else {\r\n            if (this._nth === 2) {\r\n                return `${C}sqrt{${this._radical}}`\r\n            } else {\r\n                return `${C}root(${this._nth}){${this._radical}}`\r\n            }\r\n        }\r\n    }\r\n\r\n    get value(): number {\r\n        return this._coefficient * Math.pow(this._radical, 1 / this._nth);\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (radical: number, nthroot?: number, coefficient?: number): NthRoot => {\r\n        this._coefficient = (coefficient === undefined) ? 1 : coefficient;\r\n        this._nth = (nthroot === undefined) ? 2 : nthroot;\r\n        this._radical = (radical === undefined) ? 1 : radical;\r\n\r\n        if(this._nth%2===0 && this._radical<0){\r\n            this._isValid = false;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    reduce = (): NthRoot => {\r\n        // Max value to test.\r\n        let V = Math.floor(Math.pow(this._radical, 1 / this._nth));\r\n        while (V > 1) {\r\n            if (this._radical % Math.pow(V, this._nth) === 0) {\r\n                // It's dividable by V^n\r\n                this._coefficient *= V;\r\n                this._radical = this._radical / Math.pow(V, this._nth);\r\n\r\n                // Redifine the new testing value (this is optimization)\r\n                V = Math.floor(Math.pow(this._radical, 1 / this._nth));\r\n                continue;\r\n            }\r\n            V--;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    multiply = (N: NthRoot): NthRoot => {\r\n        this._radical *= N.radical;\r\n        return this.reduce();\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Help functions\r\n    // ------------------------------------------\r\n    hasRadical = ():boolean => {\r\n        return !(this._radical===1 || this._radical===0 || this._isValid===false)\r\n    };\r\n}","import {Point} from \"./point\";\r\nimport {Line, LinePropriety} from \"./line\";\r\nimport {Vector} from \"./vector\";\r\nimport {Triangle} from \"./triangle\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Equation} from \"../algebra/equation\";\r\nimport {Polynom} from \"../algebra/polynom\";\r\nimport {Monom} from \"../algebra/monom\";\r\n\r\nexport class Circle {\r\n    constructor(...values: unknown[]) {\r\n        this._exists = false\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values)\r\n        }\r\n    }\r\n\r\n    private _center: Point;\r\n\r\n    get center(): Point {\r\n        return this._center;\r\n    }\r\n\r\n    private _squareRadius: Fraction;\r\n\r\n    get squareRadius(): Fraction {\r\n        return this._squareRadius\r\n    }\r\n\r\n    private _cartesian: Equation;\r\n\r\n    get cartesian(): Equation {\r\n        return this._cartesian\r\n    }\r\n\r\n    private _exists: boolean;\r\n\r\n    get exists(): boolean {\r\n        return this._exists;\r\n    }\r\n\r\n    get radius(): { tex: string, display: string, value: number } {\r\n        if (this._squareRadius.isSquare()) {\r\n            return {\r\n                tex: this._squareRadius.clone().sqrt().tex,\r\n                display: this._squareRadius.clone().sqrt().display,\r\n                value: this._squareRadius.clone().sqrt().value\r\n            }\r\n        } else {\r\n            return {\r\n                tex: `\\\\sqrt{${this._squareRadius.tex}}`,\r\n                display: `sqrt(${this._squareRadius.display})`,\r\n                value: this._squareRadius.clone().sqrt().value\r\n            }\r\n        }\r\n        return this._squareRadius\r\n    }\r\n\r\n    get tex(): string {\r\n        if (this._exists) {\r\n            let cx, cy\r\n            if (this._center.x.isZero()) {\r\n                cx = 'x^2'\r\n            } else {\r\n                cx = `\\\\left(x${this._center.x.isNegative() ? '+' : '-'}${this._center.x.clone().abs().tex}\\\\right)^2`\r\n            }\r\n            if (this._center.y.isZero()) {\r\n                cy = 'y^2'\r\n            } else {\r\n                cy = `\\\\left(y${this._center.y.isNegative() ? '+' : '-'}${this._center.y.clone().abs().tex}\\\\right)^2`\r\n            }\r\n            return `${cx}+${cy}=${this._squareRadius.tex}`\r\n        } else {\r\n            return `\\\\text{le cercle n'existe pas.}`\r\n        }\r\n    }\r\n\r\n    get developed(): string {\r\n        return this._cartesian.tex\r\n    }\r\n\r\n    get display(): string {\r\n        if (this._exists) {\r\n            let cx, cy\r\n            if (this._center.x.isZero()) {\r\n                cx = 'x^2'\r\n            } else {\r\n                cx = `(x${this._center.x.isNegative() ? '+' : '-'}${this._center.x.clone().abs().tex})^2`\r\n            }\r\n            if (this._center.y.isZero()) {\r\n                cy = 'y^2'\r\n            } else {\r\n                cy = `(y${this._center.y.isNegative() ? '+' : '-'}${this._center.y.clone().abs().tex})^2`\r\n            }\r\n            return `${cx}+${cy}=${this._squareRadius.display}`\r\n        } else {\r\n            return `\\\\text{le cercle n'existe pas.}`\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the relative position between circle and line. It corresponds to the number of intersection.\r\n     * @param {Line} L\r\n     * @returns {number}\r\n     */\r\n    relativePosition = (L: Line): number => {\r\n        let distance = L.distanceTo(this.center), radius = Math.sqrt(this._squareRadius.value)\r\n\r\n        if (distance.value - radius > 0.0000000001) {\r\n            return 0 // external\r\n        } else if (Math.abs(distance.value - radius) < 0.0000000001) {\r\n            return 1 // tangent\r\n        } else {\r\n            return 2 // external\r\n        }\r\n    }\r\n\r\n    lineIntersection = (L: Line): Point[] => {\r\n        let intersectionPoints: Point[] = [], solX: Fraction\r\n\r\n        if (this._cartesian === null) {\r\n            return []\r\n        }\r\n        const equX = this._cartesian.clone(), lineX = L.equation.clone().isolate('x'),\r\n            lineY = L.equation.clone().isolate('y')\r\n\r\n        if (lineX instanceof Equation && lineY instanceof Equation) {\r\n            equX.replaceBy('y', lineY.right).simplify()\r\n            equX.solve()\r\n\r\n            for (let x of equX.solutions) {\r\n                if (x.exact === false && isNaN(x.value)) {\r\n                    continue\r\n                }\r\n\r\n                solX = new Fraction(x.exact === false ? x.value : x.exact)\r\n                intersectionPoints.push(new Point(solX.clone(), lineY.right.evaluate(solX)))\r\n            }\r\n        }\r\n\r\n        return intersectionPoints\r\n    }\r\n\r\n    tangents = (P: Point | Fraction): Line[] => {\r\n        if (P instanceof Fraction) {\r\n            return this._tangentsWithSlope(P)\r\n        } else if (this.isPointOnCircle(P)) {\r\n            return this._tangentsThroughOnePointOnTheCircle(P)\r\n        } else if (this.center.distanceTo(P).value > this.radius.value) {\r\n            //TODO:  Must check it's outside the circle\r\n            return this._tangentsThroughOnePointOutsideTheCircle(P)\r\n        } else {\r\n            console.log('No tangents as the point is inside !')\r\n        }\r\n        return []\r\n    }\r\n\r\n    isPointOnCircle = (P: Point): Boolean => {\r\n        return this._cartesian.test({x: P.x, y: P.y})\r\n    }\r\n\r\n    getPointsOnCircle = (numberIsInteger?: boolean): Point[] => {\r\n        if (numberIsInteger === undefined) {\r\n            numberIsInteger = false\r\n        }\r\n\r\n        // It means searching for pythagorician triples that make a perfect square.\r\n        // (x-4)^2 + (y+3)^2 = 15\r\n\r\n        let triplets = Numeric.pythagoricianTripletsWithTarget(this._squareRadius.value, true)\r\n\r\n        let points: Point[] = [], pt\r\n        triplets.forEach(triplet => {\r\n            // Allow positive / negative values\r\n            // x-a = t  => x = a + t\r\n            // x-a = -t => x = a - t\r\n\r\n            for (let k of [[1, 1], [-1, 1], [-1, -1], [1, -1]]) {\r\n                pt = new Point(\r\n                    this.center.x.clone().add(k[0] * triplet[0]),\r\n                    this.center.y.clone().add(k[1] * triplet[1])\r\n                )\r\n                // Check if the point is not already in points.\r\n                if (!pt.isInListOfPoints(points)) {\r\n                    points.push(pt)\r\n                }\r\n            }\r\n        })\r\n        return points\r\n    }\r\n\r\n    clone(): Circle {\r\n        this._center = this._center.clone()\r\n        this._squareRadius = this._squareRadius.clone()\r\n        this._calculateCartesian()\r\n        return this\r\n    }\r\n\r\n    private _tangentsThroughOnePointOnTheCircle = (P: Point): Line[] => {\r\n        let CT = new Vector(this._center, P)\r\n        return [new Line(P, CT, LinePropriety.Perpendicular)]\r\n    }\r\n\r\n    private _tangentsThroughOnePointOutsideTheCircle = (P: Point): Line[] => {\r\n        // y = mx + h\r\n        // px, py => h = -m px + py => mx - y -m.px + py = 0 =>\r\n        // Centre: cx, cy, radius: r\r\n        // (m.cx - cy -m.px + py)^2 = r^2  * (m^2  + 1)\r\n        // (m(cx-py) - (cy - py))^2 = r^2  * (m^2  + 1)\r\n\r\n        let cx_px = this.center.x.clone().subtract(P.x), cy_py = this.center.y.clone().subtract(P.y),\r\n            polyLeft = new Polynom('x'), polyRight = new Polynom('x^2+1')\r\n\r\n        polyLeft.multiply(cx_px).subtract(cy_py).pow(2)\r\n        polyRight.multiply(this.squareRadius)\r\n\r\n        let equ = new Equation(polyLeft, polyRight)\r\n        equ.moveLeft().simplify().solve()\r\n\r\n        return equ.solutions.map(sol => {\r\n            //  h = -m px + py\r\n            let h, equ = new Equation('y', 'x')\r\n\r\n            if (sol.exact instanceof Fraction) {\r\n                h = P.x.clone().opposed().multiply(sol.exact).add(P.y)\r\n                equ.right.multiply(sol.exact).add(h)\r\n            } else {\r\n                h = P.x.clone().opposed().multiply(sol.value).add(P.y)\r\n                equ.right.multiply(sol.value).add(h)\r\n            }\r\n\r\n            return new Line(equ)\r\n        })\r\n\r\n    }\r\n\r\n    private _tangentsWithSlope = (slope: Fraction): Line[] => {\r\n        // d(C;t)=r => ac1+bc2 + x = +- sqrt(a^2 + b^2)*r\r\n        // x = -ac1-bc2  +-  sqrt(a^2 + b^2)*r\r\n        // y = a/bx + h => ax-by + H = 0\r\n\r\n        const a = slope.numerator, b = -slope.denominator, c1 = this._center.x.clone(), c2 = this._center.y.clone(),\r\n            r = this._squareRadius\r\n\r\n        let sq = this._squareRadius.clone().multiply(slope.numerator ** 2 + slope.denominator ** 2),\r\n            x1 = c1.clone().multiply(a).opposed().subtract(c2.clone().multiply(b)).add(sq.clone().sqrt()),\r\n            x2 = c1.clone().multiply(a).opposed().subtract(c2.clone().multiply(b)).subtract(sq.clone().sqrt())\r\n\r\n        return [new Line(a, b, x1), new Line(a, b, x2)]\r\n    }\r\n\r\n    private _reset(): Circle {\r\n        this._center = null\r\n        this._squareRadius = null\r\n        this._cartesian = null\r\n        this._exists = false\r\n\r\n        return this\r\n    }\r\n\r\n    private parse(...values: unknown[]): Circle {\r\n        // Data can be given in these formats:\r\n        // one value, a string -> make it an Equation\r\n        // one value, an Equation\r\n        // one value, a circle -> clone it\r\n        // two values: two points (center and pointThrough)\r\n        // two values: point and Fraction (center and radius)\r\n        // three values: Point, Fraction, Boolean (center, square radius, true)\r\n\r\n        this._reset()\r\n\r\n        if (typeof values[0] === 'string') {\r\n            this._parseEquation(new Equation(values[0]))\r\n        } else if (values[0] instanceof Equation) {\r\n            this._parseEquation(values[0])\r\n        } else if (values[0] instanceof Circle) {\r\n            this._parseCopyCircle(values[0])\r\n        } else if (values[0] instanceof Point && values.length > 1) {\r\n            if (values[1] instanceof Point) {\r\n                if (values[2] instanceof Point) {\r\n                    this._parseThroughtThreePoints(values[0], values[1], values[2])\r\n                } else {\r\n                    this._parseCenterAndPointThrough(values[0], values[1])\r\n                }\r\n            } else if (values[1] instanceof Fraction || typeof values[1] === 'number') {\r\n                this._parseCenterAndRadius(values[0], values[1], (typeof values[2] === \"boolean\") ? values[2] : false)\r\n            }\r\n        }\r\n\r\n        // Calculate once the different values.\r\n        if (this._exists) {\r\n            this._calculateCartesian()\r\n\r\n            // If the square radius is zero or positive, the circle exists.\r\n            if (this._squareRadius !== undefined && this._squareRadius.isNegative()) {\r\n                this._exists = false\r\n            }\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    private _calculateCartesian() {\r\n        this._cartesian = (new Equation(new Polynom(`(x-(${this._center.x.display}))^2+(y-(${this._center.y.display}))^2`), new Polynom(`${this._squareRadius.display}`))).moveLeft()\r\n    }\r\n\r\n    private _parseCopyCircle(circle: Circle): Circle {\r\n        this._center = circle.center.clone()\r\n        this._squareRadius = circle.squareRadius.clone()\r\n        this._calculateCartesian()\r\n        this._exists = circle.exists\r\n        return this\r\n    }\r\n\r\n    private _parseCenterAndRadius(center: Point, radius: Fraction | number, square?: boolean): Circle {\r\n        this._center = center.clone()\r\n\r\n        if (square) {\r\n            this._squareRadius = (new Fraction(radius))\r\n        } else {\r\n            this._squareRadius = new Fraction(radius).pow(2)\r\n        }\r\n\r\n        this._exists = true\r\n        return this\r\n    }\r\n\r\n    private _parseCenterAndPointThrough(center: Point, pointThrough: Point): Circle {\r\n        this._center = center.clone()\r\n        this._squareRadius = new Vector(this._center, pointThrough).normSquare\r\n        this._exists = true\r\n        return this\r\n    }\r\n\r\n    private _parseEquation(equ: Equation): Circle {\r\n        this._exists = false\r\n\r\n        // Move everything to the left.\r\n        equ.moveLeft()\r\n\r\n        if (equ.degree('x').value === 2 && equ.degree('y').value === 2) {\r\n            // Both must be of degree 2.\r\n            let x2 = equ.left.monomByDegree(2, 'x'), y2 = equ.left.monomByDegree(2, 'y'), x1: Monom, y1: Monom, c: Monom\r\n\r\n            // Both square monoms must have the same coefficient.\r\n            if (x2.coefficient.isEqual(y2.coefficient)) {\r\n                equ.divide(x2.coefficient)\r\n\r\n                x1 = equ.left.monomByDegree(1, 'x')\r\n                y1 = equ.left.monomByDegree(1, 'y')\r\n\r\n                c = equ.left.monomByDegree(0)\r\n\r\n                this._center = new Point(x1.coefficient.clone().divide(2).opposed(), y1.coefficient.clone().divide(2).opposed())\r\n\r\n                this._squareRadius = c.coefficient.clone().opposed()\r\n                    .add(this._center.x.clone().pow(2))\r\n                    .add(this._center.y.clone().pow(2))\r\n\r\n                this._calculateCartesian()\r\n                this._exists = true\r\n            } else {\r\n                // The circle is not a valid circle\r\n                this._center = null\r\n                this._squareRadius = null\r\n                this._exists = false\r\n            }\r\n        }\r\n        return this\r\n    }\r\n\r\n    private _parseThroughtThreePoints(A: Point, B: Point, C: Point): Circle {\r\n        let T = new Triangle(A, B, C), mAB = T.remarquables.mediators.AB.clone(),\r\n            mAC = T.remarquables.mediators.AC.clone()\r\n        this.parse(mAB.intersection(mAC).point, A)\r\n\r\n        return this\r\n    }\r\n\r\n}","/**\r\n * This class works for 2d line in a plane.\r\n */\r\n\r\nimport {Vector} from \"./vector\";\r\nimport {Point} from \"./point\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Equation} from \"../algebra/equation\";\r\nimport {Polynom} from \"../algebra/polynom\";\r\nimport {Random} from \"../randomization/random\";\r\nimport {LinearSystem} from \"../algebra/linearSystem\";\r\nimport {Monom} from \"../algebra/monom\";\r\n\r\nexport enum LinePropriety {\r\n    None,\r\n    Parallel = 'parallel',\r\n    Perpendicular = 'perpendicular',\r\n    Tangent = 'tangent'\r\n}\r\n\r\nexport class Line {\r\n    // A line is defined as the canonical form\r\n    static PERPENDICULAR = LinePropriety.Perpendicular\r\n    static PARALLEL = LinePropriety.Parallel\r\n    private _referencePropriety: LinePropriety\r\n    private _referenceLine: Line\r\n    private _reduceBeforeDisplay: boolean\r\n\r\n    constructor(...values: unknown[]) {\r\n\r\n        this._exists = false;\r\n        this._reduceBeforeDisplay = true\r\n\r\n        if (values.length > 0) {\r\n            this.parse(...values);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // ax + by + c = 0\r\n    private _a: Fraction;\r\n\r\n    get a(): Fraction {\r\n        return this._a;\r\n    }\r\n\r\n    set a(value: Fraction) {\r\n        this._a = value;\r\n    }\r\n\r\n    private _b: Fraction;\r\n\r\n    get b(): Fraction {\r\n        return this._b;\r\n    }\r\n\r\n    set b(value: Fraction) {\r\n        this._b = value;\r\n    }\r\n\r\n    private _c: Fraction;\r\n\r\n    get c(): Fraction {\r\n        return this._c;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n\r\n    set c(value: Fraction) {\r\n        this._c = value;\r\n    }\r\n\r\n    private _OA: Point;\r\n\r\n    get OA(): Point {\r\n        return this._OA;\r\n    }\r\n\r\n    set OA(value: Point) {\r\n        this._OA = value;\r\n    }\r\n\r\n    private _d: Vector;\r\n\r\n    get d(): Vector {\r\n        return this._d;\r\n    }\r\n\r\n    set d(value: Vector) {\r\n        this._d = value;\r\n    }\r\n\r\n    private _n: Vector;\r\n\r\n    get n(): Vector {\r\n        return this._n;\r\n    }\r\n\r\n    private _exists: boolean\r\n\r\n    get exists(): boolean {\r\n        return this._exists;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    get equation(): Equation {\r\n        let equ = new Equation(new Polynom().parse('xy', this._a, this._b, this._c), new Polynom('0'))\r\n        if(this._reduceBeforeDisplay) {\r\n            return equ.simplify();\r\n        }else{\r\n            return equ\r\n        }\r\n    }\r\n\r\n    get system(): { x: Equation, y: Equation } {\r\n        let e1 = new Equation(\r\n            new Polynom('x'),\r\n            new Polynom(this._OA.x)\r\n                .add(new Monom('k').multiplyByNumber(this._d.x))\r\n        ),\r\n            e2 = new Equation(\r\n                new Polynom('y'),\r\n                new Polynom(this._OA.y)\r\n                    .add(new Monom('k').multiplyByNumber(this._d.y))\r\n            )\r\n\r\n        return {x: e1, y: e2}\r\n    }\r\n\r\n    get tex(): { canonical: string, mxh: string, parametric: string, equation: string, system: string } {\r\n        // canonical    =>  ax + by + c = 0\r\n        // mxh          =>  y = -a/b x - c/b\r\n        // parametric   =>  (xy) = OA + k*d\r\n        // equation     => ax + by = -c\r\n\r\n        let canonical = this.equation.clone().reorder(true);\r\n        // Make sur the first item is positive.\r\n        if (this._a.isNegative()) {\r\n            canonical.multiply(-1);\r\n        }\r\n\r\n        let d = this._d.clone()\r\n        if (this._reduceBeforeDisplay) {\r\n            d.simplifyDirection()\r\n        }\r\n\r\n        return {\r\n            canonical: canonical.tex,\r\n            equation: canonical.clone().reorder().tex,\r\n            mxh: this.slope.isInfinity() ? 'x=' + this.OA.x.tex : 'y=' + new Polynom().parse('x', this.slope, this.height).tex,\r\n            parametric: `${Point.pmatrix('x', 'y')} = ${Point.pmatrix(this._OA.x, this._OA.y)} + k\\\\cdot ${Point.pmatrix(d.x, d.y)}`,\r\n            system: `\\\\left\\\\{\\\\begin{aligned}\r\n            x &= ${(new Polynom(this._OA.x)\r\n                .add(new Monom(this._d.x).multiply(new Monom('k'))))\r\n                .reorder('k', true)\r\n                .tex}\\\\\\\\\\ \r\n            y &= ${(new Polynom(this._OA.y)\r\n                .add(new Monom(this._d.y).multiply(new Monom('k'))))\r\n                .reorder('k', true)\r\n                .tex}\r\n            \\\\end{aligned}\\\\right.`\r\n        }\r\n    }\r\n\r\n    get reduceBeforeDisplay(): boolean {\r\n        return this._reduceBeforeDisplay;\r\n    }\r\n\r\n    set reduceBeforeDisplay(value: boolean) {\r\n        this._reduceBeforeDisplay = value;\r\n    }\r\n\r\n    get display(): { canonical: string, mxh: string, parametric: string } {\r\n        // canonical    =>  ax + by + c = 0\r\n        // mxh          =>  y = -a/b x - c/b\r\n        // parametric   =>  (xy) = OA + k*d // not relevant in display mode.\r\n\r\n        let canonical = this.equation;\r\n        // Make sur the first item is positive.\r\n        if (this._a.isNegative()) {\r\n            canonical.multiply(-1);\r\n        }\r\n\r\n        return {\r\n            canonical: canonical.display,\r\n            mxh: this.slope.isInfinity() ? 'x=' + this.OA.x.display : 'y=' + new Polynom().parse('x', this.slope, this.height).display,\r\n            parametric: \"\"\r\n        }\r\n    }\r\n\r\n    get normal(): Vector {\r\n        return new Vector(this._a, this._b);\r\n    }\r\n\r\n    get director(): Vector {\r\n        return this._d.clone()\r\n    }\r\n\r\n    get slope(): Fraction {\r\n        return this._a.clone().opposed().divide(this._b);\r\n    }\r\n\r\n    get height(): Fraction {\r\n        return this._c.clone().opposed().divide(this._b);\r\n    }\r\n\r\n    randomPoint = (k?: number): Point => {\r\n        // Return a random point on the line.\r\n        return this._d\r\n            .clone()\r\n            .multiplyByScalar(Random.numberSym((k === undefined || k <= 1) ? 3 : k, false))\r\n            .add(this._OA.asVector)\r\n            .asPoint\r\n    }\r\n    randomNearPoint = (k?: number): Point => {\r\n        let pt = this.randomPoint(k)\r\n\r\n        let maxIterationTest = 10\r\n        while (this.isOnLine(pt) && maxIterationTest > 0) {\r\n            pt.x.add(Random.numberSym(1, false))\r\n            pt.y.add(Random.numberSym(1, false))\r\n            maxIterationTest--\r\n\r\n        }\r\n        return pt\r\n    }\r\n\r\n// ------------------------------------------\r\n    // Creation / parsing functions\r\n\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse data to a line\r\n     * @param {any} values\r\n     * @returns {Line}\r\n     */\r\n    parse = (...values: unknown[]): Line => {\r\n        this._exists = false;\r\n\r\n        // Nothing is given...\r\n        if (values.length === 0) {\r\n            return this\r\n        }\r\n\r\n        // One value only: already a line (clone it), an Equation, a string (as Equation)\r\n        if (values.length === 1) {\r\n            if (values[0] instanceof Line) {\r\n                // Already a Line\r\n                return values[0].clone()\r\n            } else if (values[0] instanceof Equation) {\r\n                // It's an Equation\r\n                return this.parseEquation(values[0])\r\n            } else if (typeof values[0] === \"string\") {\r\n                // It's a string - create an Equation from it.\r\n                try {\r\n                    let E = new Equation(values[0])\r\n                    return this.parse(E)\r\n                } catch (e) {\r\n                    return this\r\n                }\r\n            }\r\n        }\r\n\r\n        if (values.length === 2) {\r\n            if (values[0] instanceof Point && values[1] instanceof Vector) {\r\n                return this.parseByPointAndVector(values[0], values[1]);\r\n            } else if (values[0] instanceof Point && values[1] instanceof Point) {\r\n                return this.parseByPointAndVector(values[0], new Vector(values[0], values[1]));\r\n            } else if (values[0] instanceof Vector && values[1] instanceof Point) {\r\n                return this.parseByPointAndNormal(values[1], values[0])\r\n            }\r\n        }\r\n\r\n        if (values.length === 3) {\r\n            if (\r\n                (values[0] instanceof Fraction || typeof values[0] === 'number')\r\n                &&\r\n                (values[1] instanceof Fraction || typeof values[1] === 'number')\r\n                &&\r\n                (values[2] instanceof Fraction || typeof values[2] === 'number')\r\n            ) {\r\n                return this.parseByCoefficient(values[0], values[1], values[2]);\r\n            } else if (\r\n                values[0] instanceof Point && values[1] instanceof Vector\r\n            ) {\r\n                if (values[2] === LinePropriety.Perpendicular) {\r\n                    return this.parseByPointAndNormal(values[0], values[1])\r\n                } else if (values[2] === LinePropriety.Parallel) {\r\n                    return this.parseByPointAndVector(values[0], values[1])\r\n                }\r\n            } else if (values[0] instanceof Point && values[1] instanceof Line) {\r\n                if (values[2] === LinePropriety.Parallel || values[2] === null) {\r\n                    return this.parseByPointAndLine(values[0], values[1], LinePropriety.Parallel)\r\n                } else {\r\n                    return this.parseByPointAndLine(values[0], values[1], LinePropriety.Perpendicular)\r\n                }\r\n            }\r\n        }\r\n\r\n        // TODO: Add the ability to create line from a normal vector\r\n        console.log('Someting wrong happend while creating the line')\r\n        return this;\r\n    }\r\n\r\n    parseEquation = (equ: Equation): Line => {\r\n        // Reorder the eequation\r\n        equ.reorder(true)\r\n\r\n        // It must contain either x, y or both.\r\n        let letters = new Set(equ.letters());\r\n\r\n        // No 'x', no 'y' in the equations\r\n        if (!(letters.has('x') || letters.has('y'))) {\r\n            return this\r\n        }\r\n\r\n        // Another letter in the equation ?\r\n        for (let elem of ['x', 'y']) {\r\n            if (letters.has(elem)) {\r\n                letters.delete(elem)\r\n            }\r\n        }\r\n\r\n        if (letters.size > 0) {\r\n            return this\r\n        }\r\n\r\n        // Everything should be ok now...\r\n        return this.parseByCoefficient(equ.left.monomByLetter('x').coefficient, equ.left.monomByLetter('y').coefficient, equ.left.monomByDegree(0).coefficient)\r\n    }\r\n    parseByCoefficient = (a: Fraction | number, b: Fraction | number, c: Fraction | number): Line => {\r\n        this._a = new Fraction(a);\r\n        this._b = new Fraction(b);\r\n        this._c = new Fraction(c);\r\n\r\n        this._d = new Vector(this._b.clone(), this._a.clone().opposed());\r\n        this._OA = new Point(new Fraction().zero(), this._c.clone());\r\n        this._n = this._d.clone().normal();\r\n\r\n        this._exists = true;\r\n        return this;\r\n    }\r\n\r\n    parseByPointAndVector = (P: Point, d: Vector): Line => {\r\n        // OX = OP + k*d\r\n        // x = px + kdx     * dy\r\n        // y = py + kdy     * dx\r\n        // ------------------\r\n        // dy * x = px * dy + kdxdy\r\n        // dx * y = py * dx + kdxdy\r\n        // ------------------\r\n        // dy * x - dx * y = px * dy - py * dx\r\n        // dy * x - dx * y - (px * dy - py * dx) = 0\r\n        this.parseByCoefficient(\r\n            d.y,\r\n            d.x.clone().opposed(),\r\n            P.x.clone().multiply(d.y).subtract(P.y.clone().multiply(d.x)).opposed()\r\n        )\r\n\r\n        // Choose the current values as point and direction vector instead of the automatic version.\r\n        this._OA = P.clone();\r\n        this._d = d.clone();\r\n        this._n = this._d.clone().normal();\r\n\r\n        this._exists = true;\r\n        return this;\r\n    }\r\n\r\n    parseByPointAndNormal = (P: Point, n: Vector): Line => {\r\n        return this.parseByCoefficient(\r\n            n.x,\r\n            n.y,\r\n            P.x.clone().multiply(n.x)\r\n                .add(P.y.clone().multiply(n.y)).opposed()\r\n        )\r\n    }\r\n\r\n    parseByPointAndLine = (P: Point, L: Line, orientation?: LinePropriety): Line => {\r\n\r\n        if (orientation === undefined) {\r\n            orientation = LinePropriety.Parallel\r\n        }\r\n\r\n        if (orientation === LinePropriety.Parallel) {\r\n            return this.parseByPointAndNormal(P, L.normal)\r\n        } else if (orientation === LinePropriety.Perpendicular) {\r\n            return this.parseByPointAndNormal(P, L.director)\r\n        }\r\n\r\n        this._exists = false\r\n        return this\r\n    }\r\n\r\n    clone = (): Line => {\r\n        this._a = this._a.clone();\r\n        this._b = this._b.clone();\r\n        this._c = this._c.clone();\r\n\r\n        this._d = this._d.clone();\r\n        this._OA = this._OA.clone();\r\n        this._n = this._n.clone();\r\n\r\n        this._exists = this.exists\r\n        return this;\r\n    }\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    isOnLine = (pt: Point): Boolean => {\r\n        return this._a.clone()\r\n            .multiply(pt.x)\r\n            .add(\r\n                this._b.clone()\r\n                    .multiply(pt.y)\r\n            )\r\n            .add(this._c)\r\n            .isZero()\r\n    }\r\n\r\n    isParallelTo = (line: Line): Boolean => {\r\n        // Do they have the isSame direction ?\r\n        return this.slope.isEqual(line.slope) && this.height.isNotEqual(line.height);\r\n    }\r\n    isSameAs = (line: Line): Boolean => {\r\n        return this.slope.isEqual(line.slope) && this.height.isEqual(line.height);\r\n    }\r\n    isPerpendicularTo = (line: Line): Boolean => {\r\n        return this.d.isNormalTo(line.d)\r\n    }\r\n    isVertical = (): Boolean => {\r\n        return this.slope.isInfinity()\r\n    }\r\n    simplify = (): Line => {\r\n        let lcm = Numeric.lcm(this._a.denominator, this._b.denominator, this._c.denominator),\r\n            gcd = Numeric.gcd(this._a.numerator, this._b.numerator, this._c.numerator);\r\n\r\n        this.parseByCoefficient(\r\n            this._a.clone().multiply(lcm).divide(gcd),\r\n            this._b.clone().multiply(lcm).divide(gcd),\r\n            this._c.clone().multiply(lcm).divide(gcd),\r\n        )\r\n\r\n        return this\r\n    }\r\n\r\n    simplifyDirection = (): Line => {\r\n        this._d.simplifyDirection()\r\n        return this;\r\n    }\r\n    intersection = (line: Line): { point: Point, hasIntersection: boolean, isParallel: boolean, isSame: boolean } => {\r\n        let Pt = new Point(), isParallel = false, isSame = false, hasIntersection = true;\r\n\r\n        // this         => ax+by+c = 0\r\n        // line         => dx+ey+f = 0\r\n        //\r\n        //  aex + bey + ce = 0\r\n        //  dbx + bey + bf = 0\r\n        // (ae-db)x + ce-bf = 0\r\n        //\r\n        //  adx + bdy + cd = 0\r\n        //  adx + aey + af = 0\r\n        // (bd-ae)y + (cd-af)\r\n        //\r\n        // x = (bf-ce)/(ae-db)\r\n        // y = (af-cd)/(bd-ae)\r\n\r\n\r\n        // Theres is no 'y'\r\n        if (this._b.isZero() || line.b.isZero()) {\r\n            // TODO : handle no y in the line canonical form\r\n        }\r\n\r\n        if (this.isParallelTo(line)) {\r\n            Pt.x = null;\r\n            Pt.y = null;\r\n            isParallel = true;\r\n        } else if (this.isSameAs(line)) {\r\n            Pt.x = null;\r\n            Pt.y = null;\r\n            isSame = true;\r\n        } else {\r\n            Pt.x = this._b.clone().multiply(line.c).subtract(this._c.clone().multiply(line.b))\r\n                .divide(this._a.clone().multiply(line.b).subtract(this._b.clone().multiply(line.a)));\r\n            Pt.y = this._a.clone().multiply(line.c).subtract(this._c.clone().multiply(line.a))\r\n                .divide(this._b.clone().multiply(line.a).subtract(this._a.clone().multiply(line.b)));\r\n        }\r\n\r\n        return {\r\n            point: Pt,\r\n            hasIntersection: !(isParallel || isSame),\r\n            isParallel,\r\n            isSame\r\n        };\r\n    }\r\n\r\n    distanceTo(pt: Point): { value: number, fraction: Fraction, tex: string } {\r\n        let numerator = pt.x.clone().multiply(this._a)\r\n                .add(pt.y.clone().multiply(this._b))\r\n                .add(this._c).abs(),\r\n            d2 = this.normal.normSquare;\r\n\r\n        // The denominator is null - shouldn't be possible\r\n        if (d2.isZero()) {\r\n            return {\r\n                value: NaN,\r\n                tex: 'Not a line',\r\n                fraction: new Fraction().infinite()\r\n            }\r\n        }\r\n        // The denominator is a perfect square - simplify the tex result\r\n        let value = numerator.value / Math.sqrt(d2.value),\r\n            F = numerator.clone().divide(d2.clone().sqrt());\r\n\r\n        // The denominator is a perfect square.\r\n        if (d2.isSquare()) {\r\n            return {\r\n                value,\r\n                tex: F.tex,\r\n                fraction: F\r\n            }\r\n        }\r\n        // Complete answer...\r\n        return {\r\n            value,\r\n            tex: `\\\\frac{${numerator.tex}}{\\\\sqrt{${d2.tex}}}`,\r\n            fraction: F\r\n        };\r\n    }\r\n\r\n    hitSegment(A: Point, B: Point): boolean {\r\n        let iPt = this.intersection(\r\n            new Line(A, B)\r\n        )\r\n\r\n        // There is an intersection point\r\n        if (iPt.hasIntersection) {\r\n            return iPt.point.x.value >= Math.min(A.x.value, B.x.value)\r\n                && iPt.point.x.value <= Math.max(A.x.value, B.x.value)\r\n                && iPt.point.y.value >= Math.min(A.y.value, B.y.value)\r\n                && iPt.point.y.value <= Math.max(A.y.value, B.y.value)\r\n        }\r\n        return false;\r\n    }\r\n\r\n    getValueAtX = (value: Fraction | number): Fraction => {\r\n        const equ = this.equation.clone().isolate('y'),\r\n            F = new Fraction(value)\r\n\r\n        if (equ instanceof Equation) {\r\n            return equ.right.evaluate({x: F})\r\n        }\r\n        return\r\n    }\r\n    getValueAtY = (value: Fraction | number): Fraction => {\r\n        const equ = this.equation.clone().isolate('x'),\r\n            F = new Fraction(value)\r\n\r\n        if (equ instanceof Equation) {\r\n            return equ.right.evaluate({y: F})\r\n        }\r\n        return\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Special functions\r\n    // ------------------------------------------\r\n    canonicalAsFloatCoefficient(decimals: number): string {\r\n        if (decimals === undefined) {\r\n            decimals = 2;\r\n        }\r\n\r\n        let ca = this._a.value,\r\n            cb = this._b.value,\r\n            cc = this._c.value,\r\n            canonical = '';\r\n\r\n        if (!this._a.isZero()) {\r\n            if (this._a.isOne()) {\r\n                canonical = 'x'\r\n            } else if (this._a.clone().opposed().isOne()) {\r\n                canonical = '-x'\r\n            } else {\r\n                canonical = this._a.value.toFixed(decimals) + 'x'\r\n            }\r\n        }\r\n\r\n        if (!this._b.isZero()) {\r\n            if (this._b.isPositive()) {\r\n                canonical += '+'\r\n            }\r\n            canonical += this._b.value.toFixed(decimals) + 'y'\r\n        }\r\n\r\n        if (!this._c.isZero()) {\r\n            if (this._c.isPositive()) {\r\n                canonical += '+'\r\n            }\r\n            canonical += this._c.value.toFixed(decimals)\r\n        }\r\n\r\n\r\n        return canonical + '=0';\r\n    }\r\n}","/**\r\n * Vector module contains everything necessary to handle 2d or 3d vectors.\r\n * @module Vector\r\n */\r\nimport {Line} from \"./line\";\r\nimport {Vector} from \"./vector\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\n/**\r\n * Helper class - a way to identify an object {x: number, y: number}\r\n */\r\nclass PointXY {\r\n    x: number\r\n    y: number\r\n}\r\n\r\nexport class Point {\r\n    private _x: Fraction;   // 1st component\r\n    private _y: Fraction;   // 2nd component\r\n    private _exist: Boolean;\r\n\r\n    constructor(...values: unknown[]) {\r\n        this._x = new Fraction().zero();\r\n        this._y = new Fraction().zero();\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values);\r\n        }\r\n\r\n        return this\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get x(): Fraction {\r\n        return this._x;\r\n    }\r\n\r\n    set x(value: Fraction) {\r\n        this._x = value;\r\n    }\r\n\r\n    get y(): Fraction {\r\n        return this._y;\r\n    }\r\n\r\n    set y(value: Fraction) {\r\n        this._y = value;\r\n    }\r\n\r\n    get tex(): string {\r\n        let pts = [];\r\n\r\n        pts.push(this._x.tex);\r\n        pts.push(this._y.tex);\r\n\r\n        return `\\\\left(${pts.join(';')}\\\\right)`\r\n    }\r\n\r\n    get display(): string {\r\n        let pts = [];\r\n\r\n        pts.push(this._x.tex);\r\n        pts.push(this._y.tex);\r\n\r\n        return `(${pts.join(';')})`\r\n    }\r\n\r\n    get asVector(): Vector {\r\n        return new Vector(this.x, this.y)\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (...values: unknown[]): Point => {\r\n        // Initialize the value.\r\n        this.zero();\r\n\r\n        // Nothing is given\r\n        if (values.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        // One element is given - might be already a point !\r\n        if (values.length === 1) {\r\n            // it's already a point - clone it\r\n            if (values[0] instanceof Point) {\r\n                this._x = values[0].x.clone()\r\n                this._y = values[0].y.clone()\r\n                return this\r\n            }\r\n\r\n            // Value is given as string, comma separated.\r\n            if (typeof values[0] === 'string') {\r\n                let xy = values[0].split(',')\r\n                if (xy.length === 2) {\r\n                    this._x = new Fraction(xy[0]).reduce()\r\n                    this._y = new Fraction(xy[1]).reduce()\r\n                    return this\r\n                }\r\n            }\r\n\r\n            // Value given as an object with {x: value, y: value}\r\n            if(values[0] instanceof PointXY){\r\n                    this._x = new Fraction(values[0].x).reduce()\r\n                    this._y = new Fraction(values[0].y).reduce()\r\n                return this\r\n            } else {\r\n                return this.zero()\r\n            }\r\n        }\r\n\r\n        if (values.length === 2) {\r\n            this._x = new Fraction(values[0]).reduce()\r\n            this._y = new Fraction(values[1]).reduce()\r\n            return this\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    clone = (): Point => {\r\n        this._x = this._x.clone()\r\n        this._y = this._y.clone()\r\n\r\n        return this\r\n    }\r\n\r\n    zero = (): Point => {\r\n        this._x = new Fraction(null);\r\n        this._y = new Fraction(null);\r\n        return this;\r\n    }\r\n\r\n    origin = (): Point => {\r\n        this.zero();\r\n        return this;\r\n    }\r\n\r\n    middleOf = (P1: Point, P2: Point): Point => {\r\n        this._x = P1.x.clone().add(P2.x).divide(2);\r\n        this._y = P1.y.clone().add(P2.y).divide(2);\r\n\r\n        return this;\r\n    }\r\n    // ------------------------------------------\r\n    // Display functions\r\n    // ------------------------------------------\r\n    texValues = (numberOfDigits: number): string => {\r\n        let pts = [];\r\n\r\n        pts.push(this._x.value.toFixed(numberOfDigits === undefined ? 2 : numberOfDigits));\r\n        pts.push(this._y.value.toFixed(numberOfDigits === undefined ? 2 : numberOfDigits));\r\n\r\n        return `\\\\left(${pts.join(';')}\\\\right)`\r\n    }\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n\r\n    // ------------------------------------------\r\n    // Vector functions\r\n    // ------------------------------------------\r\n\r\n    // ------------------------------------------\r\n    // Static functions\r\n    // ------------------------------------------\r\n    static pmatrix = (a: any, b: any, c?: any): string => {\r\n        if (c === undefined) {\r\n            return `\\\\begin{pmatrix} ${a.tex ? a.tex : a} \\\\\\\\ ${b.tex ? b.tex : b} \\\\end{pmatrix}`;\r\n        } else {\r\n            return `\\\\begin{pmatrix} ${a.tex ? a.tex : a} \\\\\\\\ ${b.tex ? b.tex : b} \\\\\\\\ ${c.tex ? c.tex : c} \\\\end{pmatrix}`;\r\n        }\r\n    };\r\n\r\n    distanceTo = (item:Point|Line): { value: number, fraction: Fraction, tex: string } => {\r\n        let value = 0, fraction = new Fraction(), tex = ''\r\n\r\n        if(item instanceof Line){\r\n            return item.distanceTo(this)\r\n        }else if(item instanceof Point){\r\n            let V = new Vector(this, item)\r\n\r\n            value = V.norm\r\n            fraction = V.normSquare.sqrt()\r\n            tex = V.normSquare.isSquare() ? fraction.tex : `\\\\sqrt{\\\\frac{ ${V.normSquare.numerator} }{ ${V.normSquare.denominator} }}`\r\n        }\r\n        return { value, fraction, tex }\r\n    }\r\n\r\n    get key(): string {\r\n      return `${this.x.display};${this.y.display}`\r\n}\r\n    isInListOfPoints = (list: Point[]): boolean => {\r\n        const keyList = list.map(x=>x.key)\r\n\r\n        return keyList.includes(this.key)\r\n    }\r\n}\r\n","import {Point} from \"./point\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Vector} from \"./vector\";\r\nimport {Line} from \"./line\";\r\nimport {Equation} from \"../algebra/equation\";\r\n\r\nexport interface remarquableLines {\r\n    'medians': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    },\r\n    'mediators': {\r\n        'AB': Line,\r\n        'AC': Line,\r\n        'BC': Line,\r\n        'intersection': Point\r\n    },\r\n    'heights': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    },\r\n    'bisectors': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    },\r\n    externalBisectors: {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    }\r\n}\r\n\r\nexport class Triangle {\r\n    private _A: Point;\r\n    private _B: Point;\r\n    private _C: Point;\r\n    private _lines: {\r\n        'AB': Line,\r\n        'AC': Line,\r\n        'BC': Line\r\n    };\r\n    private _middles: {\r\n        'AB': Point,\r\n        'AC': Point,\r\n        'BC': Point\r\n    };\r\n    private _remarquables: remarquableLines;\r\n\r\n\r\n    constructor(...values: unknown[]) {\r\n\r\n        if (values.length > 0) {\r\n            this.parse(...values);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setters\r\n    // ------------------------------------------\r\n\r\n    get A(): Point {\r\n        return this._A;\r\n    }\r\n\r\n    get B(): Point {\r\n        return this._B;\r\n    }\r\n\r\n    get C(): Point {\r\n        return this._C;\r\n    }\r\n\r\n    get AB(): Vector {\r\n        return this.getSegment('A', 'B');\r\n    }\r\n\r\n    get BA(): Vector {\r\n        return this.getSegment('B', 'A');\r\n    }\r\n\r\n    get BC(): Vector {\r\n        return this.getSegment('B', 'C');\r\n    }\r\n\r\n    get CB(): Vector {\r\n        return this.getSegment('C', 'B');\r\n    }\r\n\r\n    get AC(): Vector {\r\n        return this.getSegment('A', 'C');\r\n    }\r\n\r\n    get CA(): Vector {\r\n        return this.getSegment('C', 'A');\r\n    }\r\n\r\n    get isRectangle(): boolean {\r\n        if (this.AB.isNormalTo(this.BC)) {\r\n            return true;\r\n        }\r\n        if (this.AB.isNormalTo(this.AC)) {\r\n            return true;\r\n        }\r\n        if (this.BC.isNormalTo(this.AC)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    get isEquilateral(): boolean {\r\n        return this.AB.normSquare.isEqual(this.BC.normSquare) &&\r\n            this.AB.normSquare.isEqual(this.AC.normSquare);\r\n    }\r\n\r\n    get isIsocele(): boolean {\r\n        return this.AB.normSquare.isEqual(this.BC.normSquare) ||\r\n            this.AB.normSquare.isEqual(this.AC.normSquare) ||\r\n            this.BC.normSquare.isEqual(this.AC.normSquare)\r\n    }\r\n\r\n    get lines(): { 'AB': Line, 'BC': Line, 'AC': Line } {\r\n        return this._lines;\r\n    }\r\n\r\n    get remarquables(): remarquableLines {\r\n        return this._remarquables;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Parse values to a triangle. Supported formats:\r\n     * Point, Point, Point\r\n     * x1, y1, x2, y2, x3, y3\r\n     * TODO: Something else ?\r\n     * @param values\r\n     */\r\n    parse = (...values: any): Triangle => {\r\n        if (values.length === 6) {\r\n            // Check if all values are number or fractions.\r\n            let v = values.map((x: any) => new Fraction(x));\r\n            return this.parse(\r\n                new Point(v[0], v[1]),\r\n                new Point(v[2], v[3]),\r\n                new Point(v[4], v[5]),\r\n            )\r\n        } else if (values.length === 3) {\r\n            // Possibilities:\r\n            // - Three points (or part of points, only dict for example, or array (TODO: Add the array syntax for point)\r\n            // - Three lines\r\n            // - Three lines as text.\r\n            if(values.filter((x:any) => typeof x === 'string').length===3) {\r\n                return this.parse( ...values.map((x:string) => new Line(x)) )\r\n            }else if(values.filter((x:any) => x instanceof Line).length===3) {\r\n                // We have three lines\r\n                this._lines = {\r\n                    'AB': values[0],\r\n                    'BC': values[1],\r\n                    'AC': values[2]\r\n                };\r\n\r\n                // Get the intersection points -> build the triangle using these intersection points.\r\n                let intersect = values[0].intersection(values[1]);\r\n                if (intersect.hasIntersection) {\r\n                    this._B = intersect.point.clone();\r\n                } else {\r\n                    return this;\r\n                }\r\n                intersect = values[1].intersection(values[2]);\r\n                if (intersect.hasIntersection) {\r\n                    this._C = intersect.point.clone();\r\n                } else {\r\n                    return this;\r\n                }\r\n                intersect = values[2].intersection(values[0]);\r\n                if (intersect.hasIntersection) {\r\n                    this._A = intersect.point.clone();\r\n                } else {\r\n                    return this;\r\n                }\r\n            }else {\r\n                // At least, one of the value is not a point.\r\n                if (values.filter((x: any) => (x instanceof Point)).length < 3) {\r\n                    return this.parse(\r\n                        new Point(values[0]),\r\n                        new Point(values[1]),\r\n                        new Point(values[2])\r\n                    )\r\n                }\r\n\r\n                // We have three points.\r\n                this._A = values[0].clone();\r\n                this._B = values[1].clone();\r\n                this._C = values[2].clone();\r\n\r\n                this._lines = {\r\n                    'AB': new Line(this._A, this._B),\r\n                    'BC': new Line(this._B, this._C),\r\n                    'AC': new Line(this._A, this._C)\r\n                };\r\n            }\r\n        } else if (values.length === 1) {\r\n            if (values[0] instanceof Triangle) {\r\n                return values[0].clone();\r\n            }\r\n        }\r\n\r\n        this._updateTriangle();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clone the Triangle class\r\n     */\r\n    clone = (): Triangle => {\r\n        this._A = this._A.clone();\r\n        this._B = this._B.clone();\r\n        this._C = this._C.clone();\r\n\r\n        this._lines = {\r\n            'AB': this._lines.AB.clone(),\r\n            'BC': this._lines.BC.clone(),\r\n            'AC': this._lines.AC.clone()\r\n        }\r\n\r\n        this._updateTriangle();\r\n        return this;\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Triangle operations and properties\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Generate the Line object for the three segments of the triangle\r\n     */\r\n    private _updateTriangle = () => {\r\n        this._middles = {\r\n            'AB': new Point().middleOf(this._A, this._B),\r\n            'AC': new Point().middleOf(this._A, this._C),\r\n            'BC': new Point().middleOf(this._B, this._C)\r\n        }\r\n\r\n        this._remarquables = this._calculateRemarquableLines();\r\n    }\r\n\r\n\r\n    /**\r\n     * Get the Point class for the given name\r\n     * @param ptName\r\n     */\r\n    private getPointByName = (ptName: string): Point => {\r\n        switch (ptName.toUpperCase()) {\r\n            case 'A':\r\n                return this._A;\r\n            case 'B':\r\n                return this._B;\r\n            case 'C':\r\n                return this._C;\r\n        }\r\n\r\n        // Something went wrong ! Return the first point\r\n        return this._A;\r\n    }\r\n    /**\r\n     * Get the vector for the segment given by name.\r\n     * @param ptName1\r\n     * @param ptName2\r\n     */\r\n    private getSegment = (ptName1: string, ptName2: string): Vector => {\r\n        return new Vector(\r\n            this.getPointByName(ptName1),\r\n            this.getPointByName(ptName2)\r\n        );\r\n    }\r\n\r\n    private _calculateRemarquableLines = (): remarquableLines => {\r\n        const  bA= this._calculateBisectors('A'),\r\n            bB= this._calculateBisectors('B'),\r\n            bC= this._calculateBisectors('C')\r\n\r\n        let remarquables: remarquableLines = {\r\n            'medians': {\r\n                'A': new Line(this._A, this._middles.BC),\r\n                'B': new Line(this._B, this._middles.AC),\r\n                'C': new Line(this._C, this._middles.AB),\r\n                'intersection': null\r\n            },\r\n            'mediators': {\r\n                'AB': new Line(this._middles.AB, new Vector(this._A, this._B).normal()),\r\n                'AC': new Line(this._middles.AC, new Vector(this._A, this._C).normal()),\r\n                'BC': new Line(this._middles.BC, new Vector(this._B, this._C).normal()),\r\n                'intersection': null\r\n            },\r\n            'heights': {\r\n                'A': new Line(this._A, new Vector(this._B, this._C).normal()),\r\n                'B': new Line(this._B, new Vector(this._A, this._C).normal()),\r\n                'C': new Line(this._C, new Vector(this._A, this._B).normal()),\r\n                'intersection': null\r\n            },\r\n            'bisectors': {\r\n                'A': bA.internal,\r\n                'B': bB.internal,\r\n                'C': bB.internal,\r\n                'intersection': null\r\n            },\r\n            externalBisectors: {\r\n                'A': bA.external,\r\n                'B': bB.external,\r\n                'C': bC.external,\r\n                'intersection': null\r\n            }\r\n        }\r\n\r\n        // As it's a triangle, we assume the lines are intersecting and aren't parallel or superposed.\r\n        remarquables.medians.intersection = remarquables.medians.A.intersection(remarquables.medians.B).point;\r\n        remarquables.mediators.intersection = remarquables.mediators.AB.intersection(remarquables.mediators.BC).point;\r\n        remarquables.heights.intersection = remarquables.heights.A.intersection(remarquables.heights.B).point;\r\n        remarquables.bisectors.intersection = remarquables.bisectors.A.intersection(remarquables.bisectors.B).point;\r\n\r\n        // Everything was calculated for the remarquable lines.\r\n        return remarquables;\r\n    }\r\n\r\n    private _calculateBisectors = (pt: string): { internal: Line, external: Line } => {\r\n        let tlines = this.lines, d1, d2;\r\n\r\n        if(pt==='A'){\r\n            d1 = tlines.AB;\r\n            d2 = tlines.AC;\r\n        }else if(pt==='B'){\r\n            d1 = tlines.AB;\r\n            d2 = tlines.BC;\r\n        }else if(pt==='C'){\r\n            d1 = tlines.BC;\r\n            d2 = tlines.AC;\r\n        }\r\n\r\n        let b1 = new Line(new Equation(d1.equation.left.clone().multiply(d2.n.simplify().norm), d2.equation.left.clone().multiply(d1.n.simplify().norm)).reorder(true).simplify()),\r\n            b2 = new Line(new Equation(d1.equation.left.clone().multiply(d2.n.simplify().norm), d2.equation.left.clone().multiply(d1.n.simplify().norm).opposed()).reorder(true).simplify());\r\n\r\n        // Must determine which bisectors is in the triangle\r\n        if(pt==='A'){\r\n            return b1.hitSegment(this.B, this.C)?{internal:b1, external: b2}:{internal:b2, external: b1};\r\n        }\r\n        if(pt==='B'){\r\n            return b1.hitSegment(this.A, this.C)?{internal:b1, external: b2}:{internal:b2, external: b1};\r\n        }\r\n        if(pt==='C'){\r\n            return b1.hitSegment(this.B, this.A)?{internal:b1, external: b2}:{internal:b2, external: b1};\r\n        }\r\n\r\n        // Default returns the first bisector\r\n        return {internal:b1, external: b2}\r\n    }\r\n}","/**\r\n * Vector module contains everything necessary to handle 2d or 3d vectors.\r\n * @module Vector\r\n */\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Point} from \"./point\";\r\n\r\nexport class Vector {\r\n    private _x: Fraction;   // 1st component\r\n    private _y: Fraction;   // 2nd component\r\n\r\n    constructor(...values: unknown[]) {\r\n        this._x = new Fraction().zero();\r\n        this._y = new Fraction().zero();\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values);\r\n        }\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get x(): Fraction {\r\n        return this._x;\r\n    }\r\n\r\n    set x(value: Fraction|number|string) {\r\n        this._x = new Fraction(value);\r\n    }\r\n\r\n    get y(): Fraction {\r\n        return this._y;\r\n    }\r\n\r\n    set y(value: Fraction|number|string) {\r\n        this._y = new Fraction(value);\r\n    }\r\n\r\n    get normSquare(): Fraction {\r\n        return this._x.clone().pow(2).add(this._y.clone().pow(2));\r\n    }\r\n\r\n    get norm(): number {\r\n        return Math.sqrt(this.normSquare.value);\r\n    }\r\n\r\n    get tex(): string {\r\n        return `\\\\begin{pmatrix}${this._x.tex} \\\\\\\\\\ ${this._y.tex} \\\\end{pmatrix}`\r\n    }\r\n\r\n    get asPoint(): Point {\r\n        return new Point(this.x, this.y)\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n    parse = (...values: any): Vector => {\r\n        // TODO: Must be more strict about what is given and limit to two dimensional vectors.p\r\n        // Maybe more than one value was given...\r\n        // Initialize the vector\r\n        this.zero();\r\n\r\n        if (values.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        if (values.length === 1) {\r\n            if (values[0] instanceof Vector) {\r\n                return values[0].clone()\r\n            } else {\r\n                return this._parseString(values[0])\r\n            }\r\n        }\r\n\r\n        if (values.length >= 2) {\r\n            // Two points are given - skip the third value.\r\n            if (values[0] instanceof Point && values[1] instanceof Point) {\r\n                this._x = values[1].x.clone().subtract(values[0].x)\r\n                this._y = values[1].y.clone().subtract(values[0].y)\r\n                return this;\r\n            }\r\n\r\n            // Fractions or a number are give\r\n            if (values[0] instanceof Fraction || !isNaN(values[0])) {\r\n                this._x = new Fraction(values[0])\r\n            }\r\n            if (values[1] instanceof Fraction || !isNaN(values[1])) {\r\n                this._y = new Fraction(values[1])\r\n            }\r\n\r\n            if(\r\n                (typeof values[0] === 'object' && !isNaN(values[0].x) && !isNaN(values[0].x)) &&\r\n                (typeof values[1] === 'object' && !isNaN(values[1].x) && !isNaN(values[1].x))\r\n            ){\r\n                this._x = new Fraction(+values[1].x-values[0].x)\r\n                this._y = new Fraction(+values[1].y-values[0].y)\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    clone = (): Vector => {\r\n        let V = new Vector();\r\n\r\n        if (this._x !== null) {\r\n            V.x = this._x.clone();\r\n        }\r\n        if (this._y !== null) {\r\n            V.y = this._y.clone();\r\n        }\r\n        return V;\r\n    }\r\n\r\n    reset = (): Vector => {\r\n        this._x = null;\r\n        this._y = null;\r\n        return this;\r\n    }\r\n\r\n    zero = (): Vector => {\r\n        this.reset();\r\n        this._x = new Fraction(null);\r\n        this._y = new Fraction(null);\r\n        return this;\r\n    }\r\n\r\n    one = (): Vector => {\r\n        this._x = new Fraction();\r\n        this._y = new Fraction();\r\n        return this;\r\n    }\r\n\r\n    private _parseString = (value: string): Vector => {\r\n        // Split comma, semi colon or single space.\r\n        let components = value.split(/[,;\\s]/g);\r\n\r\n        // Validate the fraction values.\r\n        this.x = new Fraction(components[0] || null);\r\n        this.y = new Fraction(components[1] || null);\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    opposed = (): Vector => {\r\n        this._x.opposed();\r\n        this._y.opposed();\r\n        return this;\r\n    }\r\n\r\n    add = (V: Vector): Vector => {\r\n        this._x.add(V.x);\r\n        this._y.add(V.y);\r\n\r\n        return this;\r\n    }\r\n\r\n    subtract = (V: Vector): Vector => {\r\n        return this.add(V.clone().opposed());\r\n    }\r\n\r\n    scalarProductWithVector = (V: Vector): Fraction => {\r\n        return Vector.scalarProduct(this, V)\r\n        // return this._x.clone().multiply(V.x).add(this._y.clone().multiply(V.y));\r\n    }\r\n\r\n    determinantWithVector = (V: Vector): Fraction => {\r\n        return Vector.determinant(this, V)\r\n    }\r\n\r\n    static scalarProduct = (v1: Vector, v2: Vector): Fraction => {\r\n        return v1.x.clone().multiply(v2.x).add(v1.y.clone().multiply(v2.y));\r\n    };\r\n\r\n    static determinant = (v1: Vector, v2: Vector): Fraction => {\r\n        return v1.x.clone().multiply(v2.y).subtract(v1.y.clone().multiply(v2.x))\r\n    }\r\n\r\n    normal = (): Vector => {\r\n        let x = this.x.clone().opposed(), y = this.y.clone();\r\n        this._x = y;\r\n        this._y = x;\r\n        return this;\r\n    }\r\n\r\n    isColinearTo = (v: Vector): boolean => {\r\n        return this.determinantWithVector(v).isZero()\r\n    }\r\n\r\n    isNormalTo = (v: Vector): boolean => {\r\n        return this.scalarProductWithVector(v).isZero()\r\n    }\r\n\r\n    get isNull(): boolean {\r\n        return this.x.isZero() && this.y.isZero()\r\n    }\r\n\r\n    multiplyByScalar = (k: any): Vector => {\r\n        let scalar = new Fraction(k);\r\n        this._x.multiply(scalar);\r\n        this._y.multiply(scalar);\r\n        return this;\r\n    }\r\n\r\n    divideByScalar = (k: any): Vector => {\r\n        return this.multiplyByScalar(new Fraction(k).invert());\r\n    }\r\n    // ------------------------------------------\r\n    // Vector functions\r\n    // ------------------------------------------\r\n\r\n    simplify = (): Vector => {\r\n        // Multiply by the lcm of denominators.\r\n        return this.multiplyByScalar(Numeric.lcm(this._x.denominator, this._y.denominator))\r\n            .divideByScalar(Numeric.gcd(this._x.numerator, this._y.numerator));\r\n    }\r\n\r\n    simplifyDirection = (): Vector => {\r\n        let lcm = Numeric.lcm(this.x.denominator, this.y.denominator),\r\n            gcd = Numeric.gcd(this.x.numerator, this.y.numerator);\r\n\r\n        this.x.multiply(lcm).divide(gcd);\r\n        this.y.multiply(lcm).divide(gcd);\r\n        return this\r\n    }\r\n\r\n    angleWith = (V: Vector, sharp?: Boolean, radian?: Boolean): number => {\r\n        let scalar = this.scalarProductWithVector(V).value,\r\n            toDegree = radian ? 1 : 180 / Math.PI;\r\n        if (sharp) {\r\n            scalar = Math.abs(scalar);\r\n        }\r\n\r\n        return toDegree * Math.acos(scalar / (this.norm * V.norm));\r\n    }\r\n}\r\n","export class Numeric {\r\n    static round(value: number, decimals: number = 2): number {\r\n        return Number(Math.round(Number(value + 'e' + decimals)) + 'e-' + decimals);\r\n    }\r\n\r\n    /**\r\n     * Get the list of the nth first prime numbers.\r\n     * @param nb : number of primes to choose from\r\n     */\r\n    static primes(nb?: number): number[] {\r\n        let primesValues: number[] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973];\r\n        if (nb === undefined) {\r\n            return primesValues;\r\n        } else {\r\n            return primesValues.slice(0, Math.min(primesValues.length, nb));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the list of all dividers of a number.\r\n     * @param value\r\n     */\r\n    static dividers(value: number): number[] {\r\n        let D: number[];\r\n        const maxV = Math.sqrt(Math.abs(value));\r\n\r\n        // Initialize the list of dividers.\r\n        D = [];\r\n\r\n        for (let i = 1; i <= maxV; i++) {\r\n            if (value % i === 0) {\r\n                D.push(i);\r\n                D.push(value / i);\r\n            }\r\n        }\r\n\r\n        // Order numbers.\r\n        D.sort(function (a, b) {\r\n            return a - b;\r\n        });\r\n\r\n        // Make sure the array of value is unique.\r\n        return [...new Set(D)];\r\n    }\r\n\r\n    /**\r\n     * Great Common Divisor\r\n     * @param values : number values\r\n     */\r\n    static gcd(...values: number[]): number {\r\n        // Define the gcd for two number\r\n        let gcd2 = function (a: number, b: number): number {\r\n            if (b === 0) {\r\n                return a;\r\n            }\r\n            return gcd2(b, a % b);\r\n        };\r\n\r\n        let g: number = 1,\r\n            i: number = 2;\r\n\r\n        // Nothing is given\r\n        if (values.length === 0) {\r\n            return 1;\r\n        }\r\n        // Only one number is given\r\n        if (values.length === 1) {\r\n            // The first number is zero\r\n            if (values[0] === 0) {\r\n                return 1;\r\n            }\r\n            // Return the number\r\n            return values[0];\r\n        }\r\n\r\n        // We have at least 2 numbers.\r\n        g = gcd2(values[0], values[1]);\r\n\r\n        // The gcd of the two first value is one ? It's already finished.\r\n        if (g === 1) {\r\n            return 1;\r\n        }\r\n\r\n        // The current gcd isn't one. Continue with all next values.\r\n        for (i = 2; i < values.length; i++) {\r\n            g = gcd2(g, values[i]);\r\n            // Escape if gcd is already one.\r\n            if (g === 1) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return Math.abs(g);\r\n    }\r\n\r\n    static divideNumbersByGCD(...values: number[]): number[] {\r\n        let gcd = Numeric.gcd(...values)\r\n\r\n        return values.map(x => x / gcd)\r\n    }\r\n\r\n    /**\r\n     * Least Common Multiple\r\n     * @param values: list of numbers\r\n     */\r\n    static lcm(...values: number[]): number {\r\n        return values.reduce(function (a, b) {\r\n            return Math.abs(a * b / Numeric.gcd(a, b));\r\n        });\r\n    }\r\n\r\n    static pythagoricianTripletsWithTarget(target: number, targetIsSquare?: boolean): number[][] {\r\n        // mthode inverse,  partir du triplet.\r\n        const triplets = [],\r\n            targetValue = targetIsSquare === true ? +target : target ** 2\r\n        for (let u = 0; u <= target; u++) {\r\n            for (let v = 0; v <= target; v++) {\r\n                if (u ** 2 + v ** 2 === targetValue) {\r\n                    triplets.push([u, v, target])\r\n                }\r\n            }\r\n        }\r\n\r\n        return triplets\r\n    }\r\n\r\n    static numberCorrection(value: number, epsilonDigit: number = 1, epsilonNumberOfDigits: number = 10, number_of_digits: number = 8) {\r\n        return +value.toFixed(number_of_digits)\r\n    }\r\n\r\n    static periodic(value: number): number {\r\n        if (Number.isSafeInteger(value)) {\r\n            return 0\r\n        }\r\n\r\n        // Assume it's with decimal.\r\n        let decimal = (value.toString()).split('.')[0]\r\n\r\n        // The decimal part is limited\r\n        if (decimal.length < 10) {\r\n            return 0\r\n        }\r\n\r\n        // Find the periodic if it exists.\r\n    }\r\n\r\n    static decompose(value: number): number[][] {\r\n        let dividers = Numeric.dividers(value),\r\n            limit = Math.sqrt(value),\r\n            arr = [],\r\n            u, v\r\n\r\n        while (dividers.length > 0) {\r\n            u = dividers.shift()\r\n            v = dividers.length > 0 ? dividers.pop() : +u\r\n\r\n            arr.push([u, v])\r\n        }\r\n\r\n        return arr\r\n    }\r\n}","import {Shutingyard, ShutingyardMode, ShutingyardType, tokenConstant} from \"./shutingyard\";\r\nimport {Fraction} from \"./coefficients/fraction\";\r\n\r\nexport class NumExp {\r\n    private _rpn: { token: string, tokenType: string }[]\r\n    private _expression: string\r\n    private _isValid: boolean\r\n\r\n    constructor(value: string, uniformize?:boolean) {\r\n        this._expression = value\r\n        try {\r\n            this._rpn = new Shutingyard(ShutingyardMode.NUMERIC).parse(value, uniformize || uniformize===undefined).rpn\r\n        }catch(e){\r\n            this._rpn = null\r\n            this._isValid = false\r\n        }\r\n    }\r\n\r\n    get rpn(): { token: string; tokenType: string }[] {\r\n        return this._rpn;\r\n    }\r\n\r\n    get isValid(): boolean {\r\n        if(this._isValid===undefined){\r\n            try {\r\n                const v = this.evaluate({x: 0})\r\n            }catch{\r\n                this._isValid = false\r\n            }\r\n        }\r\n        return this._isValid\r\n    }\r\n\r\n    set isValid(value: boolean){\r\n        this._isValid = value\r\n    }\r\n\r\n    get expression(): string {\r\n        return this._expression;\r\n    }\r\n\r\n    private _extractDecimalPart(value: number): string {\r\n        let decimal = value.toString()\r\n\r\n        if (!decimal.includes('.')) {\r\n            return ''\r\n        }\r\n\r\n        decimal = decimal.split('.')[1]\r\n\r\n        return decimal.substring(0, decimal.length - 2)\r\n    }\r\n\r\n    private _numberCorrection(value: number): number {\r\n        // Must modify the number if it's like:\r\n        // a: 3.0000000000000003\r\n        // b: 3.9999999999999994\r\n        // remove the last character\r\n        // check if around n last characters are either 0 or 9\r\n        // if it is, 'round' the number.\r\n\r\n        const epsilon = 0.00000000000001,\r\n            number_of_digits = 6\r\n\r\n        const decimal = this._extractDecimalPart(value)\r\n        if(decimal===''){return value}\r\n\r\n        const n9 = decimal.match(/9+$/g)\r\n        const n0 = decimal.match(/0+$/g)\r\n\r\n        if (n9 && n9[0].length >= number_of_digits) {\r\n            // New tested values.\r\n            const mod = this._extractDecimalPart(value + epsilon),\r\n                mod0 = mod.match(/0+$/g)\r\n\r\n            if(mod0 && mod0[0].length>= number_of_digits){\r\n                // The value can be changed. Remove all zeros!\r\n                return +((value+epsilon).toString().split(mod0[0])[0])\r\n            }\r\n        }\r\n\r\n        if (n0 && n0[0].length >= number_of_digits) {\r\n            // New tested values.\r\n            const mod = this._extractDecimalPart(value - epsilon),\r\n                mod9 = mod.match(/9+$/g)\r\n\r\n            if(mod9 && mod9[0].length>= number_of_digits){\r\n                // The value can be changed. Remove all nines!\r\n                return +(value.toString().split(n0[0])[0])\r\n            }\r\n        }\r\n\r\n        return value\r\n    }\r\n\r\n    private _addToStack(stack:number[], value: number): void {\r\n        stack.push(this._numberCorrection(value))\r\n    }\r\n\r\n    evaluate(values?: { [Key: string]: number }): number {\r\n        const stack: number[] = []\r\n\r\n        if(this._rpn===null){\r\n            this._isValid = false\r\n            return 0\r\n        }\r\n\r\n        this.isValid = true\r\n\r\n        for (const element of this._rpn) {\r\n            if (element.tokenType === ShutingyardType.COEFFICIENT) {\r\n                // May be a numeric value or a Fraction.\r\n                if (!isNaN(+element.token)) {\r\n                    this._addToStack(stack, +element.token)\r\n                } else {\r\n                    this._addToStack(stack, new Fraction(element.token).value)\r\n                }\r\n            } else if (element.tokenType === ShutingyardType.VARIABLE) {\r\n                if (values[element.token] !== undefined) {\r\n                    this._addToStack(stack, +values[element.token])\r\n                }\r\n            } else if (element.tokenType === ShutingyardType.CONSTANT) {\r\n                this._addToStack(stack, tokenConstant[element.token])\r\n            } else if (element.tokenType === ShutingyardType.OPERATION) {\r\n                if (element.token === '*') {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop()\r\n                    if(a === undefined || b === undefined){this.isValid = false}\r\n                    this._addToStack(stack, a * b)\r\n                } else if (element.token === '/') {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop()\r\n                    if(a === undefined || b === undefined){this.isValid = false}\r\n                    this._addToStack(stack, a / b)\r\n                } else if (element.token === '+') {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop()\r\n                    if(a === undefined || b === undefined){this.isValid = false}\r\n                    this._addToStack(stack, (+a) + (+b))\r\n                } else if (element.token === '-') {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop() || 0\r\n                    if(b === undefined){this.isValid = false}\r\n                    this._addToStack(stack, a - b)\r\n                } else if (element.token === '^') {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop()\r\n                    if(a === undefined || b === undefined){this.isValid = false}\r\n                    this._addToStack(stack, Math.pow(a, b))\r\n                }\r\n            } else if (element.tokenType === ShutingyardType.FUNCTION) {\r\n                const a = stack.pop()\r\n                if(a === undefined){this.isValid = false}\r\n                if (element.token === 'sin') {\r\n                    this._addToStack(stack, Math.sin(a))\r\n                } else if (element.token === 'cos') {\r\n                    this._addToStack(stack, Math.cos(a))\r\n                } else if (element.token === 'tan') {\r\n                    this._addToStack(stack, Math.tan(a))\r\n                } else if(element.token === 'sqrt') {\r\n                    this._addToStack(stack, Math.sqrt(a))\r\n                }else if(element.token ==='nthrt') {\r\n                    // TODO: support nthrt in num. exp.\r\n                    let b = stack.pop()\r\n                    if(a%2===0 && b<0){\r\n                        this._addToStack(stack, NaN)\r\n                    }else {\r\n                        this._addToStack(stack, (b < 0 ? -1 : 1) * Math.pow(Math.abs(b), 1 / a))\r\n                    }\r\n                } else if(element.token === 'ln'){\r\n                    this._addToStack(stack, Math.log(a))\r\n                } else if(element.token === 'log') {\r\n                    this._addToStack(stack, Math.log10(a))\r\n                }\r\n            }\r\n        }\r\n\r\n        if (stack.length === 1) {\r\n            return stack[0]\r\n        } else {\r\n            throw `There was a problem parsing: ${this._expression}`\r\n        }\r\n    }\r\n}\r\n","import {rndPolynom} from \"./rndPolynom\";\r\nimport {rndMonom} from \"./rndMonom\";\r\nimport {rndHelpers} from \"./rndHelpers\";\r\nimport {\r\n    randomCoefficientConfig,\r\n    randomGeometryLineConfig,\r\n    randomGeometryPointConfig,\r\n    randomMonomConfig,\r\n    randomPolynomConfig\r\n} from \"./rndTypes\";\r\nimport {rndFraction} from \"./rndFraction\";\r\nimport {Polynom} from \"../algebra/polynom\";\r\nimport {Monom} from \"../algebra/monom\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Line} from \"../geometry/line\";\r\nimport {rndGeometryLine} from \"./rndGeometryLine\";\r\nimport {Point} from \"../geometry/point\";\r\nimport {rndGeometryPoint} from \"./rndGeometryPoint\";\r\n\r\nexport * from \"./rndTypes\"\r\n\r\nexport namespace Random {\r\n    export function polynom(config?: randomPolynomConfig): Polynom {\r\n        return (new rndPolynom(config)).generate()\r\n    }\r\n\r\n    export function monom(config?: randomMonomConfig): Monom {\r\n        return (new rndMonom(config)).generate()\r\n    }\r\n\r\n    export function fraction(config?: randomCoefficientConfig): Fraction {\r\n        return (new rndFraction(config)).generate()\r\n    }\r\n\r\n    export function number(from: number, to: number, exclude?: number[]): number {\r\n        return rndHelpers.randomInt(from, to, exclude)\r\n    }\r\n\r\n    export function numberSym(max: number, allowZero?: boolean): number {\r\n        return rndHelpers.randomIntSym(max, allowZero)\r\n    }\r\n\r\n    export function prime(max: number): number {\r\n        return rndHelpers.randomPrime(max)\r\n    }\r\n\r\n    export function bool(percent?: number): boolean {\r\n        return rndHelpers.randomBool(percent)\r\n    }\r\n\r\n    export function array(arr: any[], number?: number): any[] {\r\n        return rndHelpers.randomArray(arr, number)\r\n    }\r\n\r\n    export function item(arr: any[]): any {\r\n        return rndHelpers.randomItem(arr)\r\n    }\r\n\r\n    export function shuffle(arr: any[]): any[] {\r\n        return rndHelpers.shuffleArray(arr)\r\n    }\r\n\r\n    export namespace Geometry {\r\n        export function line(config?: randomGeometryLineConfig): Line {\r\n            return (new rndGeometryLine(config).generate())\r\n        }\r\n\r\n        export function point(config?: randomGeometryPointConfig): Point {\r\n            return (new rndGeometryPoint(config).generate())\r\n        }\r\n\r\n    }\r\n}","export class randomCore {\r\n    protected _config: Object\r\n    protected _defaultConfig: Object\r\n    mergeConfig = (config: Object, defaultConfig: Object): Object => {\r\n        if (config !== undefined) {\r\n            return {...defaultConfig, ...config}\r\n        }\r\n        return defaultConfig\r\n    }\r\n\r\n    generate = (): unknown => {\r\n        return undefined\r\n    }\r\n\r\n    config = (config: Object): randomCore => {\r\n        this._config = this.mergeConfig(config, this._defaultConfig)\r\n        return this\r\n    }\r\n}","import {randomCore} from \"./randomCore\";\r\nimport {randomCoefficientConfig, randomMonomConfig, randomPolynomConfig} from \"./rndTypes\";\r\nimport {Random} from \"./random\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\n/**\r\n * Create a random monom based on a based configuration\r\n */\r\nexport class rndFraction extends randomCore {\r\n    declare protected _config: randomCoefficientConfig\r\n    declare protected _defaultConfig: randomCoefficientConfig\r\n\r\n    constructor(userConfig?: randomCoefficientConfig) {\r\n        super();\r\n\r\n        this._defaultConfig = {\r\n            negative: true,\r\n            max: 10,\r\n            reduced: true,\r\n            zero: true,\r\n            natural: false\r\n        }\r\n\r\n        this._config = this.mergeConfig(userConfig, this._defaultConfig)\r\n    }\r\n\r\n    generate = (): Fraction => {\r\n        let Q = new Fraction()\r\n\r\n        if(this._config.negative){\r\n            Q.numerator = Random.numberSym(this._config.max, this._config.zero)\r\n        }else {\r\n            Q.numerator = Random.number(this._config.zero ? 0 : 1, this._config.max)\r\n        }\r\n        if(this._config.natural){\r\n            Q.denominator = 1\r\n        }else {\r\n            let securityCount = 0\r\n            while(Q.isRelative() && securityCount<10) {\r\n                Q.denominator = Random.number(1, this._config.max)\r\n                securityCount++\r\n            }\r\n        }\r\n\r\n        return this._config.reduced?Q.reduce():Q\r\n    }\r\n}\r\n","import {randomCore} from \"./randomCore\";\r\nimport {Random, randomGeometryLineConfig} from \"./random\";\r\nimport {Line} from \"../geometry/line\";\r\nimport {Vector} from \"../geometry/vector\";\r\nimport {Point} from \"../geometry/point\";\r\n\r\n/**\r\n * Create a random monom based on a based configuration\r\n */\r\nexport class rndGeometryLine extends randomCore {\r\n    declare protected _config: randomGeometryLineConfig\r\n    declare protected _defaultConfig: randomGeometryLineConfig\r\n\r\n    constructor(userConfig?: randomGeometryLineConfig) {\r\n        super();\r\n\r\n        this._defaultConfig = {\r\n            A: {\r\n                x: Random.numberSym(10),\r\n                y: Random.numberSym(10)\r\n            },\r\n        }\r\n\r\n        // TODO: Strange that it raise an error\r\n        // @ts-ignore\r\n        this._config = this.mergeConfig(userConfig, this._defaultConfig)\r\n    }\r\n\r\n    generate = (): Line => {\r\n        // The A point exists.\r\n        const d = new Vector(\r\n            Random.numberSym(10),\r\n            Random.numberSym(10)\r\n        )\r\n\r\n        while (d.isNull) {\r\n            d.x = Random.numberSym(10)\r\n            d.y = Random.numberSym(10)\r\n        }\r\n\r\n        if (this._config.slope === 1) {\r\n            if (d.x.sign() !== d.y.sign()) {\r\n                d.y.opposed()\r\n            }\r\n        } else if (this._config.slope === -1) {\r\n            if (d.x.sign() !== d.y.sign()) {\r\n                d.y.opposed()\r\n            }\r\n        }\r\n\r\n        return new Line(new Point(this._config.A.x, this._config.A.y), d)\r\n    }\r\n}\r\n","import {randomCore} from \"./randomCore\";\r\nimport {Random, randomGeometryPointConfig} from \"./random\";\r\nimport {Point} from \"../geometry/point\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\n/**\r\n * Create a random monom based on a based configuration\r\n */\r\nexport class rndGeometryPoint extends randomCore {\r\n    declare protected _config: randomGeometryPointConfig\r\n    declare protected _defaultConfig: randomGeometryPointConfig\r\n\r\n    constructor(userConfig?: randomGeometryPointConfig) {\r\n        super();\r\n\r\n        this._defaultConfig = {\r\n            axis: true,\r\n            fraction: false,\r\n            max: 10\r\n        }\r\n\r\n        this._config = this.mergeConfig(userConfig, this._defaultConfig)\r\n    }\r\n\r\n    generate = (): Point => {\r\n        let x: Fraction, y: Fraction,\r\n            zeroX = this._config.axis === true || this._config.axis === 'x',\r\n            zeroY = this._config.axis === true || this._config.axis === 'y'\r\n\r\n        x = this._config.fraction ?\r\n            Random.fraction({max: this._config.max, zero: zeroX}) :\r\n            new Fraction(Random.numberSym(this._config.max, zeroX))\r\n\r\n        y = this._config.fraction ?\r\n            Random.fraction({max: this._config.max, zero: zeroY}) :\r\n            new Fraction(Random.numberSym(this._config.max, zeroY))\r\n\r\n        if (+this._config.quadrant === 1) {\r\n            x.abs()\r\n            y.abs()\r\n        }\r\n        if (+this._config.quadrant === 2) {\r\n            if (x.isPositive()) {\r\n                x.opposed()\r\n            }\r\n            if (y.isNegative()) {\r\n                y.opposed()\r\n            }\r\n        }\r\n        if (+this._config.quadrant === 3) {\r\n            if (x.isPositive()) {\r\n                x.opposed()\r\n            }\r\n            if (y.isPositive()) {\r\n                y.opposed()\r\n            }\r\n        }\r\n        if (+this._config.quadrant === 4) {\r\n            if (x.isNegative()) {\r\n                x.opposed()\r\n            }\r\n            if (y.isPositive()) {\r\n                y.opposed()\r\n            }\r\n        }\r\n\r\n        return new Point(x, y)\r\n    }\r\n}\r\n","/**\r\n * Random helpers\r\n */\r\nimport {Numeric} from \"../numeric\";\r\n\r\nexport class rndHelpers {\r\n\r\n    /**\r\n     * Random boolean with a percent ratio\r\n     * @param percent\r\n     */\r\n    static randomBool(percent: number = 0.5): boolean {\r\n        return Math.random() < percent;\r\n    }\r\n\r\n    /**\r\n     * Random integer between two values.\r\n     * @param a (number) : From this value to the second value. If the second is ommited, this value is the max value.\r\n     * @param b (number) : To this value. If this is ommited.\r\n     */\r\n    static randomInt(a: number, b?: number, exclude?: number[]): number {\r\n        if (b === undefined) {\r\n            if (a >= 0) {\r\n                return this.randomInt(0, a);\r\n            } else {\r\n                return this.randomInt(a, 0);\r\n            }\r\n        }\r\n\r\n        // Same start and end values\r\n        if (a === b) {\r\n            return a\r\n        }\r\n\r\n        // No exclusion\r\n        if (exclude === undefined) {\r\n            return Math.floor(Math.random() * (b - a + 1) + a);\r\n        }\r\n\r\n        // With exclusion\r\n        if (Math.abs(b - a) <= exclude.length) {\r\n            throw new Error('The number of excluded values is too high.')\r\n        }\r\n\r\n        let r = this.randomInt(a, b)\r\n        while (exclude.includes(r)) {\r\n            r = this.randomInt(a, b)\r\n        }\r\n        return r\r\n    }\r\n\r\n    /**\r\n     * Random integer between -max and max value.\r\n     * @param max (number) : determine the limits.\r\n     * @param zero (bool) : determine if zero is allowed or not.\r\n     */\r\n    static randomIntSym(max: number, zero?: boolean): number {\r\n        if (zero === false) {\r\n            return this.randomBool() ? this.randomInt(1, max) : -this.randomInt(1, max);\r\n        } else {\r\n            return this.randomInt(-max, max);\r\n        }\r\n    }\r\n\r\n    static randomPrime(max: number): number {\r\n        let primes = Numeric.primes()\r\n        if (max !== undefined) {\r\n            primes = primes.filter(x => x < max)\r\n        }\r\n        return this.randomItem(primes)\r\n    }\r\n\r\n    static randomArray(arr: any[], number?: number): any[] {\r\n        if (number === undefined) {\r\n            number = 1\r\n        }\r\n\r\n        // Return a clone array\r\n        if (arr.length <= 0) {\r\n            return Object.values(arr)\r\n        }\r\n\r\n        // Randomize the array and return the n first elements.\r\n        return rndHelpers.shuffleArray(arr).slice(0, number);\r\n    }\r\n\r\n    static randomItem(arr: any[]): any {\r\n        if (arr.length === 0) {\r\n            return ''\r\n        }\r\n        return arr[this.randomInt(0, arr.length - 1)]\r\n    }\r\n\r\n    static shuffleArray(arr: any[]): any[] {\r\n        // The Fisher-Yates algorithm\r\n        let shuffleArray = Object.values(arr)\r\n        for (let i = shuffleArray.length - 1; i > 0; i--) {\r\n            const j = Math.floor(Math.random() * (i + 1));\r\n            const temp = shuffleArray[i];\r\n            shuffleArray[i] = shuffleArray[j];\r\n            shuffleArray[j] = temp;\r\n        }\r\n\r\n        return shuffleArray;\r\n    }\r\n\r\n}","import {randomCore} from \"./randomCore\";\r\nimport {randomMonomConfig} from \"./rndTypes\";\r\nimport {Random} from \"./random\";\r\nimport {Monom} from \"../algebra/monom\";\r\n\r\n/**\r\n * Create a random monom based on a based configuration\r\n */\r\nexport class rndMonom extends randomCore {\r\n    declare protected _config: randomMonomConfig\r\n    declare protected _defaultConfig: randomMonomConfig\r\n\r\n    constructor(userConfig?: randomMonomConfig) {\r\n        super();\r\n\r\n        this._defaultConfig = {\r\n            letters: 'x',\r\n            degree: 2,\r\n            fraction: true,\r\n            zero: false\r\n        }\r\n\r\n        this._config = this.mergeConfig(userConfig, this._defaultConfig)\r\n    }\r\n\r\n    generate = (): Monom => {\r\n        // Create a monom instance\r\n        let M = new Monom()\r\n\r\n        // Generate the coefficient\r\n        if (typeof this._config.fraction === \"boolean\") {\r\n            M.coefficient = Random.fraction({\r\n                zero: this._config.zero,\r\n                reduced: true,\r\n                natural: !this._config.fraction\r\n            })\r\n        } else {\r\n            M.coefficient = Random.fraction(this._config.fraction)\r\n        }\r\n\r\n        // Calculate the degree of the monom\r\n        if (this._config.letters.length > 1) {\r\n            // Initialise each items...\r\n            for (let L of this._config.letters.split('')) {\r\n                M.setLetter(L, 0);\r\n            }\r\n            for (let i = 0; i < this._config.degree; i++) {\r\n                const L = Random.item(this._config.letters.split(\"\"))\r\n                M.setLetter(L, M.degree(L).clone().add(1))\r\n            }\r\n        } else {\r\n            M.setLetter(this._config.letters, this._config.degree)\r\n        }\r\n\r\n        return M\r\n    }\r\n}\r\n","import {randomCore} from \"./randomCore\";\r\nimport {randomPolynomConfig} from \"./rndTypes\";\r\nimport {rndMonom} from \"./rndMonom\";\r\nimport {Random} from \"./random\";\r\nimport {Polynom} from \"../algebra/polynom\";\r\nimport {Monom} from \"../algebra/monom\";\r\n\r\n/**\r\n * Random polynoms\r\n */\r\nexport class rndPolynom extends randomCore {\r\n    declare protected _config: randomPolynomConfig\r\n    declare protected _defaultConfig: randomPolynomConfig\r\n\r\n    constructor(userConfig?: randomPolynomConfig) {\r\n        super();\r\n\r\n        // Default config for a random polynom\r\n        this._defaultConfig = {\r\n            letters: 'x',\r\n            degree: 2,\r\n            fraction: false,\r\n            zero: false,\r\n            unit: false,\r\n            factorable: false,\r\n            allowNullMonom: true,\r\n            numberOfMonoms: 0,\r\n            positive: true\r\n        }\r\n\r\n        // Merge config with initialiser\r\n        this._config = this.mergeConfig(userConfig, this._defaultConfig)\r\n    }\r\n\r\n    generate = (): Polynom => {\r\n        if(this._config.factorable && this._config.degree>1){\r\n            return this.factorable()\r\n        }\r\n\r\n        // Create the polynom\r\n        let P = new Polynom().empty(),\r\n            M: Monom\r\n\r\n        for (let i = this._config.degree; i >= 0; i--) {\r\n            // Create monom of corresponding degree.\r\n            M = new rndMonom({\r\n                letters: this._config.letters,\r\n                degree: i,\r\n                fraction: this._config.fraction,\r\n                zero: (i === this._config.degree) ? false : this._config.allowNullMonom\r\n            }).generate()\r\n\r\n            // If degree is the greatest and unit is true, set the monom value to one.\r\n            if (this._config.unit && this._config.degree === i) {\r\n                M.coefficient.one()\r\n            }\r\n\r\n            // Add to the polynom\r\n            P.add(M)\r\n        }\r\n\r\n        // Make sure the first monom is positive.\r\n        if(this._config.positive && P.monomByDegree().coefficient.isNegative()){\r\n            P.monomByDegree().coefficient.opposed()\r\n        }\r\n\r\n        // If the number of monoms is greater than the allowed value, remove some of them... except the first one !\r\n        if (this._config.numberOfMonoms > 0 && this._config.numberOfMonoms < P.length) {\r\n            // Get the greatest degree monom\r\n            let M = P.monomByDegree().clone()\r\n            P.monoms = Random.array(P.monoms.slice(1), this._config.numberOfMonoms-1)\r\n            P.add(M).reorder().reduce()\r\n        }\r\n        return P\r\n    }\r\n\r\n    factorable = (): Polynom => {\r\n        let P = new Polynom().one()\r\n\r\n        let _factorableConfig = {...this._config}\r\n        _factorableConfig.degree = 1\r\n        _factorableConfig.factorable = false\r\n\r\n        for(let i=0; i<this._config.degree;i++){\r\n            P.multiply(Random.polynom(_factorableConfig))\r\n        }\r\n\r\n        return P\r\n    }\r\n}","export type tokenType = {\r\n    [key: string]: {\r\n        precedence: number,\r\n        associative: string,\r\n        type: string\r\n    }\r\n}\r\n\r\nexport const tokenConstant: { [Key: string]: number } = {\r\n    pi: Math.PI,\r\n    e: Math.exp(1)\r\n}\r\n\r\nexport enum ShutingyardType {\r\n    VARIABLE = 'variable',\r\n    COEFFICIENT = 'coefficient',\r\n    OPERATION = 'operation',\r\n    CONSTANT = 'constant',\r\n    FUNCTION = 'function',\r\n    MONOM = 'monom'\r\n}\r\n\r\nexport enum ShutingyardMode {\r\n    EXPRESSION = 'expression',\r\n    POLYNOM = 'polynom',\r\n    SET = 'set',\r\n    NUMERIC = 'numeric'\r\n}\r\n\r\nexport type Token = { token: string, tokenType: string }\r\n\r\nexport class Shutingyard {\r\n    readonly _mode: ShutingyardMode;\r\n    private _rpn: Token[] = [];\r\n    private _tokenConfig: tokenType;\r\n    private _tokenConstant: { [Key: string]: number }\r\n    private _tokenKeys: string[]\r\n    private _uniformize: boolean;\r\n\r\n    constructor(mode?: ShutingyardMode) {\r\n        this._mode = typeof mode === 'undefined' ? ShutingyardMode.POLYNOM : mode;\r\n        this.tokenConfigInitialization()\r\n    }\r\n\r\n    // Getter\r\n    get rpn() {\r\n        // console.log(this._rpn)\r\n        return this._rpn;\r\n    }\r\n\r\n    get rpnToken() {\r\n        return this._rpn.map(x => x.token)\r\n    }\r\n\r\n    /**\r\n     * Determin if the token is a defined operation\r\n     * Defined operations: + - * / ^ sin cos tan\r\n     * @param token\r\n     */\r\n    // isOperation(token: string): boolean {\r\n    //     if (token[0].match(/[+\\-*/^]/g)) {\r\n    //         return true;\r\n    //     }\r\n    //     //\r\n    //     // if (token.match(/^sin|cos|tan/g)) {\r\n    //     //     return true;\r\n    //     // }\r\n    //\r\n    //     return false;\r\n    // }\r\n\r\n    tokenConfigInitialization(): tokenType {\r\n        if (this._mode === ShutingyardMode.SET) {\r\n            this._tokenConfig = {\r\n                '&': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '|': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '!': {precedence: 4, associative: 'right', type: ShutingyardType.OPERATION},\r\n                '-': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION}\r\n            }\r\n            this._uniformize = false;\r\n        } else if (this._mode === ShutingyardMode.NUMERIC) {\r\n            this._tokenConfig = {\r\n                '^': {precedence: 4, associative: 'right', type: ShutingyardType.OPERATION},\r\n                '*': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '/': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '+': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '-': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '%': {precedence: 3, associative: 'right', type: ShutingyardType.OPERATION},\r\n                'sin': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'cos': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'tan': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'sqrt': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'nthrt': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'ln': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'log': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n            }\r\n            this._uniformize = false\r\n        } else if (this._mode === ShutingyardMode.EXPRESSION) {\r\n            this._tokenConfig = {\r\n                '^': {precedence: 4, associative: 'right', type: ShutingyardType.OPERATION},\r\n                '*': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '/': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '+': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '-': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '%': {precedence: 3, associative: 'right', type: ShutingyardType.OPERATION},\r\n                'sin': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'cos': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'tan': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'sqrt': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'nthrt': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n            }\r\n            this._uniformize = true\r\n        } else {\r\n            this._tokenConfig = {\r\n                '^': {precedence: 4, associative: 'right', type: ShutingyardType.OPERATION},\r\n                '*': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '/': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '+': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '-': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION},\r\n            }\r\n            this._uniformize = true\r\n        }\r\n\r\n        this._tokenKeys = Object.keys(this._tokenConfig).sort((a, b) => b.length - a.length)\r\n        return this._tokenConfig\r\n    }\r\n\r\n    /**\r\n     * Get the next token to analyse.\r\n     * @param expr (string) Expression to analyse\r\n     * @param start (number) CUrrent position in the expr string.\r\n     */\r\n    NextToken(expr: string, start: number): [string, number, string] {\r\n        let token: string, tokenType: string;\r\n        token = '';\r\n        tokenType = '';\r\n        // Case of parenthesis or comma (generic items)\r\n        if (expr[start] === '(') {\r\n            token = '(';\r\n            tokenType = '(';\r\n        }\r\n        // It's a closing parenthese\r\n        else if (expr[start] === ')') {\r\n            token = ')';\r\n            tokenType = ')';\r\n        }\r\n        // It's an argument separator for a function\r\n        else if (expr[start] === ',') {\r\n            token = ',';\r\n            tokenType = 'function-argument';\r\n        } else {\r\n            // Extract operation and function tokens\r\n            for (let key of this._tokenKeys) {\r\n                if (expr.substring(start, start + key.length) === key) {\r\n                    token += key;\r\n                    tokenType = this._tokenConfig[key].type\r\n                    break\r\n                }\r\n            }\r\n\r\n            // Extract constant\r\n            for (let key in tokenConstant) {\r\n                if (expr.substring(start, start + key.length) === key) {\r\n                    token += key;\r\n                    tokenType = ShutingyardType.CONSTANT\r\n                    break\r\n                }\r\n            }\r\n\r\n            if (token === '') {\r\n                // No function found ! Might be a coefficient !\r\n                if (expr[start].match(/[0-9]/)) {\r\n                    if (this._mode === ShutingyardMode.POLYNOM && false) {\r\n                        token = expr.substring(start).match(/^([0-9.,/]+)/)[0]\r\n                    } else {\r\n                        token = expr.substring(start).match(/^([0-9.]+)/)[0]\r\n                    }\r\n                    tokenType = ShutingyardType.COEFFICIENT\r\n                } else if (expr[start].match(/[a-zA-Z]/)) {\r\n                    token = expr.substring(start).match(/^([a-zA-Z])/)[0]\r\n                    tokenType = ShutingyardType.VARIABLE\r\n                } else {\r\n                    console.log('Unidentified token', expr[start], expr, start)\r\n                    token = expr[start]\r\n                    tokenType = ShutingyardType.MONOM\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        return [token, start + token.length, tokenType];\r\n    }\r\n\r\n    normalize(expr: string): string {\r\n        if(expr.length===1){return expr}\r\n\r\n        // Get the list of function token.\r\n        let fnToken: string[] = [],\r\n            kToken: string[] = []\r\n        for (let token in this._tokenConfig) {\r\n            if (this._tokenConfig[token].type === ShutingyardType.FUNCTION) {\r\n                fnToken.push(token)\r\n            }\r\n        }\r\n        // sort if from the lengthy to the smallest function\r\n        fnToken.sort((a, b) => b.length - a.length)\r\n\r\n        for (let token in tokenConstant) {\r\n                kToken.push(token)\r\n        }\r\n        // sort if from the lengthy to the smallest function\r\n        kToken.sort((a, b) => b.length - a.length)\r\n\r\n        let normalizedExpr: string = \"\",\r\n            i = 0,\r\n            crtToken,\r\n            nextToken\r\n\r\n        while (i < expr.length - 1) {\r\n            // Check if we have a function token.\r\n            // The function MUST have an open parentheses\r\n            let tokenIdx = 0\r\n            while (tokenIdx < fnToken.length) {\r\n                let token = fnToken[tokenIdx]\r\n                if (expr.slice(i, i + token.length + 1) === token + '(') {\r\n                    normalizedExpr += token + '('\r\n                    i += token.length + 1\r\n\r\n                    // Restart the scan for the function token\r\n                    tokenIdx = 0\r\n                } else {\r\n                    // scan for a next function token\r\n                    tokenIdx++\r\n                }\r\n            }\r\n\r\n            // Check for a constant\r\n            tokenIdx = 0\r\n            while (tokenIdx < kToken.length) {\r\n                let token = kToken[tokenIdx]\r\n                if (expr.slice(i, i + token.length) === token) {\r\n                    // We have found a constant.\r\n                    // add it, but with remove the last letter\r\n                    normalizedExpr += token.slice(0, -1)\r\n                    i += token.length-1\r\n\r\n                    // Exit the loop\r\n                    break\r\n                }\r\n                tokenIdx++\r\n            }\r\n\r\n            // The function token are solved.\r\n            crtToken = expr[i]\r\n            nextToken = expr[i + 1]\r\n            normalizedExpr += crtToken\r\n\r\n            if (crtToken.match(/[a-zA-Z]/g)) {\r\n                // Current element is a letter.\r\n                // if the next element is a letter, a number or an opening parentheses, add the multiplication sign.\r\n                if (nextToken?.match(/[a-zA-Z\\d(]/)) {\r\n                    normalizedExpr += '*'\r\n                }\r\n            } else if (crtToken.match(/\\d/)) {\r\n                // Current element is a number.\r\n                // if the next element is a letter or a parentheses, add the multiplication sign.\r\n                if (nextToken?.match(/[a-zA-Z(]/)) {\r\n                    normalizedExpr += '*'\r\n                }\r\n            } else if (crtToken === ')') {\r\n                // Current element is a closing parentheses.\r\n                // if the next element is a letter, a number or an opening parentheses, add the multiplication sign\r\n                if (nextToken?.match(/[a-zA-Z\\d(]/)) {\r\n                    normalizedExpr += '*'\r\n                }\r\n            }\r\n\r\n            // Go to next token\r\n            i++\r\n        }\r\n\r\n        // add the last token\r\n        return normalizedExpr + (nextToken===undefined?'':nextToken)\r\n    }\r\n\r\n    // /**\r\n    //  * Sanitize an expression by adding missing common operation (multiplication between parentheseses)\r\n    //  * @param expr\r\n    //  * @constructor\r\n    //  */\r\n    // Uniformizer(expr: string): string {\r\n    //     // TODO: Delete this old version\r\n    //     // Prefere \"normalize\", much more robust !\r\n    //     // Determiner if need to be uniformized\r\n    //     if (!this._uniformize) {\r\n    //         return expr\r\n    //     }\r\n    //\r\n    //     // Generate the list of function token.\r\n    //     let fnToken: string[] = []\r\n    //     for (let token in this._tokenConfig) {\r\n    //         if (this._tokenConfig[token].type === ShutingyardType.FUNCTION) {\r\n    //             fnToken.push(token)\r\n    //         }\r\n    //     }\r\n    //     // sort if from the lengthy to the smallest function\r\n    //     fnToken.sort((a, b) => b.length - a.length)\r\n    //     let tokenRegExp = new RegExp(`(${fnToken.join('|')})`, 'g')\r\n    //     let functionTokenOrder = Array.from(expr.matchAll(tokenRegExp))\r\n    //\r\n    //\r\n    //     let expr2;\r\n    //\r\n    //     // Replace all function by @\r\n    //     expr2 = expr.replace(tokenRegExp, '@')\r\n    //     // Add * before @ (functionn)\r\n    //     expr2 = expr2.replace(/([\\da-zA-Z])(@)/g, \"$1*$2\");\r\n    //\r\n    //     // Replace missing multiplication between two parenthese\r\n    //     expr2 = expr2.replace(/\\)\\(/g, ')*(');\r\n    //\r\n    //     // Replace missing multiplication between number or setLetter and parenthese.\r\n    //\r\n    //     // 3x(x-4) => 3x*(x-4)\r\n    //     expr2 = expr2.replace(/([\\da-zA-Z])(\\()/g, \"$1*$2\");\r\n    //\r\n    //     // (x-4)3x => (x-4)*3x\r\n    //     expr2 = expr2.replace(/(\\))([\\da-zA-Z])/g, \"$1*$2\");\r\n    //\r\n    //     // Add multiplication between number and letters.\r\n    //     // 3x => 3*x\r\n    //     expr2 = expr2.replace(/([0-9])([a-zA-Z])/g, \"$1*$2\");\r\n    //     expr2 = expr2.replace(/([a-zA-Z])([0-9])/g, \"$1*$2\");\r\n    //\r\n    //     // Remove letter between function token and it's parenthese.\r\n    //     // for (let token of fnToken) {\r\n    //     //     // Remove\r\n    //     //     expr2 = expr2.replace(new RegExp(token + '\\\\*', 'g'), token);\r\n    //     // }\r\n    //     // Add multiplication between letters ?\r\n    //     expr2 = expr2.replace(/([a-zA-Z])([a-zA-Z])/g, \"$1*$2\");\r\n    //     expr2 = expr2.replace(/([a-zA-Z])([a-zA-Z])/g, \"$1*$2\");\r\n    //\r\n    //     // Restore operation auto formatting (prevent adding the multiplication star)\r\n    //     let exprAsArray = expr2.split('@')\r\n    //\r\n    //     if (exprAsArray.length > 0) {\r\n    //         expr2 = \"\"\r\n    //         for (let idx in exprAsArray) {\r\n    //         }\r\n    //         for (let token of fnToken) {\r\n    //             // Remove\r\n    //\r\n    //             // expr2 = expr2.replace(new RegExp(token + '\\\\*', 'g'), token);\r\n    //         }\r\n    //     }\r\n    //\r\n    //     return expr2;\r\n    // }\r\n\r\n    /**\r\n     * Parse an expression using the shutting yard tree algorithms\r\n     * @param expr (string) Expression to analyse\r\n     * Returns a RPN list of items.\r\n     * @param uniformize\r\n     */\r\n    parse(expr: string, uniformize?: boolean): Shutingyard {\r\n        let outQueue: { token: string, tokenType: string }[] = [],    // Output queue\r\n            opStack: { token: string, tokenType: string }[] = [],     // Operation queue\r\n            token: string = '',\r\n            tokenPos: number = 0,\r\n            tokenType: string = '',\r\n            previousOpStatckLength = 0\r\n\r\n        // Normalize the input if required.\r\n        if (uniformize || this._uniformize) expr = this.normalize(expr)\r\n\r\n\r\n        let securityLoopLvl1 = 50,\r\n            securityLoopLvl2_default = 50,\r\n            securityLoopLvl2;\r\n\r\n        while (tokenPos < expr.length) {\r\n            securityLoopLvl1--;\r\n            if (securityLoopLvl1 === 0) {\r\n                console.log('SECURITY LEVEL 1 EXIT');\r\n                break;\r\n            }\r\n\r\n            // Get the next token and the corresponding new (ending) position\r\n            [token, tokenPos, tokenType] = this.NextToken(expr, tokenPos);\r\n\r\n            switch (tokenType) {\r\n                case 'monom':\r\n                case 'coefficient':\r\n                case 'variable':\r\n                case 'constant':\r\n                    outQueue.push({\r\n                        token,\r\n                        tokenType\r\n                    });\r\n                    break;\r\n                case 'operation':\r\n                    previousOpStatckLength = opStack.length;\r\n                    //If the token is an operator, o1, then:\r\n                    if (opStack.length > 0) {\r\n                        let opTop = opStack[opStack.length - 1];\r\n\r\n                        securityLoopLvl2 = +securityLoopLvl2_default;\r\n\r\n                        //while there is an operator token o2, at the top of the operator stack and\r\n                        while (opTop.token in this._tokenConfig && (\r\n                                //either o1 is left-associative and its precedence is less than or equal to that of o2,\r\n                                (this._tokenConfig[token].associative === 'left' && this._tokenConfig[token].precedence <= this._tokenConfig[opTop.token].precedence)\r\n                                ||\r\n                                //or o1 is right associative, and has precedence less than that of o2,\r\n                                (this._tokenConfig[token].associative === 'right' && this._tokenConfig[token].precedence < this._tokenConfig[opTop.token].precedence)\r\n                            )\r\n                            ) {\r\n\r\n                            /* Security exit ! */\r\n                            securityLoopLvl2--;\r\n                            if (securityLoopLvl2 === 0) {\r\n                                console.log('SECURITY LEVEL 2 OPERATION EXIT');\r\n                                break;\r\n                            }\r\n\r\n                            // Add the operation to the queue\r\n                            outQueue.push((opStack.pop()) || {token: '', tokenType: 'operation'});\r\n\r\n                            // Get the next operation on top of the Stack.\r\n                            if (opStack.length === 0) {\r\n                                break;\r\n                            }\r\n                            opTop = opStack[opStack.length - 1];\r\n                        }\r\n                    }\r\n                    //at the end of iteration push o1 onto the operator stack\r\n                    opStack.push({token, tokenType});\r\n                    break;\r\n                case 'function-argument':\r\n                    // TODO: check if the opStack exist.\r\n                    securityLoopLvl2 = +securityLoopLvl2_default;\r\n                    while (opStack[opStack.length - 1].token !== '(' && opStack.length > 0) {\r\n                        securityLoopLvl2--;\r\n                        if (securityLoopLvl2 === 0) {\r\n                            console.log('SECURITY LEVEL 2 FUNCTION ARGUMENT EXIT');\r\n                            break;\r\n                        }\r\n\r\n                        outQueue.push((opStack.pop()) || {token, tokenType});\r\n                    }\r\n                    break;\r\n                case '(':\r\n                    opStack.push({token, tokenType});\r\n                    // Add an empty value if next element is negative.\r\n                    if (expr[tokenPos] === '-') {\r\n                        outQueue.push({token: '0', tokenType: 'coefficient'});\r\n                    }\r\n                    break;\r\n                case ')':\r\n                    securityLoopLvl2 = +securityLoopLvl2_default;\r\n                    //Until the token at the top of the stack is a left parenthesis, pop operators off the stack onto the output queue.\r\n                    while (opStack[opStack.length - 1].token !== '(' && opStack.length > 1 /*Maybe zero !? */) {\r\n                        securityLoopLvl2--;\r\n                        if (securityLoopLvl2 === 0) {\r\n                            console.log('SECURITY LEVEL 2 CLOSING PARENTHESE EXIT');\r\n                            break;\r\n                        }\r\n\r\n                        outQueue.push((opStack.pop()) || {token, tokenType});\r\n                    }\r\n\r\n                    //Pop the left parenthesis from the stack, but not onto the output queue.\r\n                    opStack.pop();\r\n                    break;\r\n                case 'function':\r\n                    opStack.push({token, tokenType});\r\n                    break;\r\n                default:\r\n                    // In theory, everything should be handled.\r\n                    console.log(`SHUTING YARD: ${tokenType} : ${token} `);\r\n            }\r\n\r\n            // Output\r\n            // console.log(outQueue.concat(opStack.reverse()).join(\" \"));\r\n        }\r\n\r\n        // console.log(outQueue.concat(opStack.reverse()));\r\n        this._rpn = outQueue.concat(opStack.reverse());\r\n\r\n        return this;\r\n    }\r\n\r\n\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import {Numeric} from \"./maths/numeric\";\r\nimport {NumExp} from \"./maths/numexp\";\r\nimport {Shutingyard} from \"./maths/shutingyard\";\r\nimport {Random} from \"./maths/randomization/random\";\r\nimport {Fraction} from \"./maths/coefficients/fraction\";\r\nimport {NthRoot} from \"./maths/coefficients/nthRoot\";\r\nimport {Monom} from \"./maths/algebra/monom\";\r\nimport {Polynom} from \"./maths/algebra/polynom\";\r\nimport {Equation} from \"./maths/algebra/equation\";\r\nimport {LinearSystem} from \"./maths/algebra/linearSystem\";\r\nimport {Rational} from \"./maths/algebra/rational\";\r\nimport {Logicalset} from \"./maths/algebra/logicalset\";\r\nimport {Vector} from \"./maths/geometry/vector\";\r\nimport {Line} from \"./maths/geometry/line\";\r\nimport {Triangle} from \"./maths/geometry/triangle\";\r\nimport {Circle} from \"./maths/geometry/circle\";\r\nimport {Point} from \"./maths/geometry/point\";\r\n\r\n// Expose as global\r\nexport const PiMath = {\r\n    ShutingYard: Shutingyard,\r\n    Numeric: Numeric,\r\n    NumExp: NumExp,\r\n    Fraction: Fraction,\r\n    Root: NthRoot,\r\n    Monom: Monom,\r\n    Polynom: Polynom,\r\n    Equation: Equation,\r\n    LinearSystem: LinearSystem,\r\n    Rational: Rational,\r\n    Logicalset: Logicalset,\r\n    Random: Random,\r\n    Geometry: {\r\n        Vector: Vector,\r\n        Point: Point,\r\n        Line: Line,\r\n        Triangle: Triangle,\r\n        Circle: Circle\r\n    }\r\n};\r\n\r\n// (<any>window).Pi = PiMath\r\n"],"names":["PARTICULAR_SOLUTION","Equation","constructor","equations","_varnothing","varnothing","_real","real","hasVariable","letter","this","variables","includes","_randomizeDefaults","degree","parse","equationString","pStr","strSign","_findSign","split","create","Polynom","_formatSign","console","error","left","right","sign","_left","_right","_sign","clone","randomize","opts","moveLeft","subtract","zero","reorder","allLeft","monoms","filter","m","isZero","forEach","move","simplify","multiply","Numeric","lcm","getDenominators","divide","gcd","getNumerators","isolate","isOne","isMultiVariable","mMove","cMove","values","hasLetter","length","coefficient","replaceBy","P","value","F","Fraction","_reverseSign","invert","max","letters","Set","solve","_solutions","_polynom","_solveDegree1","_solveDegree2","_solveDegree3plus","makeSolutionsUnique","test","evaluate","isEqual","isSameAs","equ","p1","p2","isOpposedAt","isLinearTo","log","signStr","undefined","replace","isGreater","indexOf","isStrictEqual","isAlsoEqual","m1","monomByDegree","m0","v","opposed","s","d","tex","display","NaN","exact","delta","nthDelta","realX1","realX2","sX1","sX2","aF","bF","cF","denominator","a","b","Math","sqrt","v1","toFixed","v2","NthRoot","reduce","hasRadical","am","bm","tex1","tex2","display1","display2","S1","S2","frac","sol","factorize","factors","factor","leq","factorAsEquation","solutions","solution","push","isEquation","map","x","join","isReal","isVarnothing","signAsTex","raw","concat","numberOfVars","randomizeDefaults","static","sorted","solutionAsTex","uniqueSolutions","sort","LinearSystem","equationStrings","buildTex","operators","equStr","equArray","i","L","monomByLetter","o","startsWith","operatorsColumns","repeat","stepTex","steps","_resolutionSteps","operations","_equations","_findLetters","E","withResolution","_solveOneLetter","mergeEquations","eq1","eq2","factor1","factor2","eq1multiplied","eq2multiplied","add","_letters","isSolvable","LS","solutionAsDisplay","resolutionSteps","_linearReduction","c1","c2","gcdN","numerator","gcdD","isNegativeOne","merged","lastIndex","LE","reducedEquations","Array","result","_rpn","Shutingyard","ShutingyardMode","SET","rpn","_rawString","isLogicalset","tokenSets","reference","referenceSet","varStack","key","token","tokenType","second","pop","first","has","vennAB","A","B","vennABC","C","Monom","inputStr","_shutingYardToReducedMonom","_coefficient","_literal","copyLiterals","literal","addToken","stack","element","q1","q2","pow","ShutingyardType","COEFFICIENT","VARIABLE","M","one","setLetter","OPERATION","k","makeSame","clean","multiplyByNumber","nb","root","p","isSquare","compare","M1","M2","K","item","isLiteralSquare","isRational","isEven","hasFractionCoefficient","isNotZero","Object","t","n","r","tmpValues","evaluateAsNumeric","derivative","dM","primitive","areSameAs","areEquals","isDivisible","div","isStrictlyPositive","geq","isRelative","literalSqrt","literalStr","matchAll","keys","isNotEqual","dividers","abs","literals","_getLiteralDividers","monomDividers","N","displayWithSign","texWithSign","plotFunction","tfrac","arr","tmpList","litt","currentLetter","coeffN","coeffD","min","xmultiply","polynomString","mark_as_dirty","dirty_factors","dirty_zeroes","euclidianCache","CONSTANT","MONOM","FUNCTION","_monoms","_factors","_parseString","empty","Number","isSafeInteger","toString","multiplyByPolynom","multiplyByFraction","multiplyByMonom","multiplyByInteger","euclidian","quotient","reminder","maxMP","degreeP","newM","MaxIteration","divideByFraction","divideByInteger","cP1","cP2","isFactorized","soft","e","polynomStringNormalized","replaceAll","polynomStringReduced","substring","polyFactors","checkPolyFactors","commonMonom","FactorizedConstant","pFactor","notFoundedFactors","f","factorFound","splice","isReduced","isDeveloped","pString","j","revert","otherLetters","da","db","S","resultPolynom","monom","dP","integrate","valuesA","valuesB","isStrictlyNegative","tempPolynom","securityLoop","maxDegree","allDividers","_getAllPotentialFactors","isDividableBy","pX","pC","dX","dC","shift","getZeroes","_zeroes","monomsByDegree","Ms","denominators","numerators","lcmDenominator","gcdDenominator","lcmNumerator","gcdNumerator","limitToInfinity","infinite","limitToNegativeInfinity","m2","m1d","m2d","genDisplay","output","forceSign","wrapParentheses","withAllMultSign","shutingYardToReducedPolynom","nbF","_factorize2ndDegree","P1","P2","c","x1","x2","isPositive","xyzPolynom","xFactors","_factorizeByGroups","_dirty_factors","_dirty_zeroes","_euclidianCache","texString","_texString","zeroes","texFactors","factorsCount","simpleFactor","displayFactors","V","trim","isNaN","fractions","Rational","_numerator","_denominator","domain","amplify","D","dN","dD","NumeratorEuclidien","DenominatorEuclidien","isNatural","R","limits","offset","Infinity","theLimit","theSign","evalValues","evalValuesOffset","FR","isInfinity","study","config","RationalStudy","ZEROTYPE","ASYMPTOTE","ASYMPTOTE_POSITION","FUNCTION_EXTREMA","TABLE_OF_SIGNS","fx","makeStudy","makeZeroes","_config","signs","_signs","makeSigns","asymptotes","_asymptotes","makeAsymptotes","_derivative","makeDerivative","variations","_variations","makeVariation","texSigns","texGrows","texVariations","indexOfZero","makeOneLineForSigns","zeroSign","oneLine","currentZero","NOTHING","makeSignsResult","resultLine","index","current","makeGrowsResult","tos","signsAsArray","growsLine","extremes","pos","y","xTex","yTex","pointType","exp","NumExp","evalY","FLAT","MAX","MIN","type","extr","makeVariationsResult","varsLine","drawCode","code","asymptote","VERTICAL","HORIZONTAL","SLOPE","extreme","ZERO","_makeTexFromTableOfSigns","factorsFx","name","variable","GROWS","VARIATIONS","SIGNS","Study","super","_getZeroes","_getSigns","reduced","DEFENCE","Ztype","HOLE","before","after","position","pm","RB","RT","LB","LT","deltaX","tableOfSign","NDegree","DDegree","H","Htex","_getHorizontalAsymptoteRelativePositon","greater","dx","z","extrema","idx","typeOfTable","denominatorOrPeriodic","isApproximative","isExact","unit","decimal","floor","invalid","Q","xMultiply","controlNumerator","g","compareFraction","lesser","than","isOpposed","isInverted","isNegative","isFinite","isOdd","dfrac","average","unique","distinct","reverse","radical","nthroot","_nth","_radical","_isValid","nth","Circle","relativePosition","distance","distanceTo","center","radius","_squareRadius","lineIntersection","solX","intersectionPoints","_cartesian","equX","lineX","equation","lineY","Point","tangents","_tangentsWithSlope","isPointOnCircle","_tangentsThroughOnePointOnTheCircle","_tangentsThroughOnePointOutsideTheCircle","getPointsOnCircle","numberIsInteger","pt","triplets","pythagoricianTripletsWithTarget","points","triplet","isInListOfPoints","CT","Vector","_center","Line","LinePropriety","Perpendicular","cx_px","cy_py","polyLeft","polyRight","squareRadius","h","slope","sq","_exists","cartesian","exists","cx","cy","developed","_calculateCartesian","_reset","_parseEquation","_parseCopyCircle","_parseThroughtThreePoints","_parseCenterAndPointThrough","_parseCenterAndRadius","circle","square","pointThrough","normSquare","y1","y2","T","Triangle","mAB","remarquables","mediators","AB","mAC","AC","intersection","point","randomPoint","_d","multiplyByScalar","Random","numberSym","_OA","asVector","asPoint","randomNearPoint","maxIterationTest","isOnLine","parseEquation","parseByPointAndVector","parseByPointAndNormal","parseByCoefficient","Parallel","parseByPointAndLine","elem","delete","size","_a","_b","_c","_n","normal","orientation","director","isParallelTo","line","height","isPerpendicularTo","isNormalTo","isVertical","simplifyDirection","Pt","isParallel","isSame","hasIntersection","getValueAtX","getValueAtY","_reduceBeforeDisplay","OA","system","canonical","mxh","parametric","pmatrix","reduceBeforeDisplay","d2","fraction","hitSegment","iPt","canonicalAsFloatCoefficient","decimals","PERPENDICULAR","PARALLEL","PointXY","_x","_y","xy","origin","middleOf","texValues","numberOfDigits","pts","norm","list","_lines","intersect","_B","_C","_A","_updateTriangle","BC","_middles","_remarquables","_calculateRemarquableLines","getPointByName","ptName","toUpperCase","getSegment","ptName1","ptName2","bA","_calculateBisectors","bB","bC","internal","externalBisectors","external","medians","heights","bisectors","d1","tlines","lines","b1","b2","BA","CB","CA","isRectangle","isEquilateral","isIsocele","reset","components","scalarProductWithVector","scalarProduct","determinantWithVector","determinant","isColinearTo","scalar","divideByScalar","angleWith","sharp","radian","toDegree","PI","acos","isNull","round","primesValues","slice","maxV","gcd2","target","targetIsSquare","targetValue","u","epsilonDigit","epsilonNumberOfDigits","number_of_digits","uniformize","_expression","NUMERIC","isValid","expression","_extractDecimalPart","_numberCorrection","epsilon","n9","match","n0","mod0","mod9","_addToStack","tokenConstant","sin","cos","tan","log10","Geometry","polynom","rndPolynom","generate","rndMonom","rndFraction","number","from","to","exclude","rndHelpers","randomInt","allowZero","randomIntSym","prime","randomPrime","bool","percent","randomBool","array","randomArray","randomItem","shuffle","shuffleArray","rndGeometryLine","rndGeometryPoint","mergeConfig","defaultConfig","_defaultConfig","randomCore","userConfig","negative","natural","securityCount","zeroX","axis","zeroY","quadrant","random","Error","primes","temp","factorable","allowNullMonom","positive","numberOfMonoms","_factorableConfig","pi","mode","_mode","POLYNOM","tokenConfigInitialization","rpnToken","_tokenConfig","precedence","associative","_uniformize","EXPRESSION","_tokenKeys","NextToken","expr","start","normalize","fnToken","kToken","crtToken","nextToken","normalizedExpr","tokenIdx","outQueue","opStack","tokenPos","previousOpStatckLength","securityLoopLvl2","securityLoopLvl1","opTop","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","Logicalset"],"sourceRoot":""}