{"version":3,"file":"pi.min.js","mappings":"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AM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KA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","sources":["webpack://pimath/./src/index.ts","webpack://pimath/./src/maths/algebra/equation.ts","webpack://pimath/./src/maths/algebra/linearSystem.ts","webpack://pimath/./src/maths/algebra/logicalset.ts","webpack://pimath/./src/maths/algebra/monom.ts","webpack://pimath/./src/maths/algebra/polynom.ts","webpack://pimath/./src/maths/algebra/rational.ts","webpack://pimath/./src/maths/algebra/study.ts","webpack://pimath/./src/maths/algebra/study/rationalStudy.ts","webpack://pimath/./src/maths/coefficients/fraction.ts","webpack://pimath/./src/maths/coefficients/nthRoot.ts","webpack://pimath/./src/maths/expressions/numexp.ts","webpack://pimath/./src/maths/expressions/polynomexp.ts","webpack://pimath/./src/maths/geometry/circle.ts","webpack://pimath/./src/maths/geometry/line.ts","webpack://pimath/./src/maths/geometry/point.ts","webpack://pimath/./src/maths/geometry/triangle.ts","webpack://pimath/./src/maths/geometry/vector.ts","webpack://pimath/./src/maths/numeric.ts","webpack://pimath/./src/maths/randomization/random.ts","webpack://pimath/./src/maths/randomization/randomCore.ts","webpack://pimath/./src/maths/randomization/rndFraction.ts","webpack://pimath/./src/maths/randomization/rndHelpers.ts","webpack://pimath/./src/maths/randomization/rndMonom.ts","webpack://pimath/./src/maths/randomization/rndPolynom.ts","webpack://pimath/./src/maths/shutingyard.ts","webpack://pimath/webpack/bootstrap","webpack://pimath/webpack/startup"],"sourcesContent":["import {Numeric} from \"./maths/numeric\";\r\nimport {NumExp} from \"./maths/expressions/numexp\";\r\nimport {Shutingyard} from \"./maths/shutingyard\";\r\nimport {Random} from \"./maths/randomization/random\";\r\nimport {Fraction} from \"./maths/coefficients/fraction\";\r\nimport {NthRoot} from \"./maths/coefficients/nthRoot\";\r\nimport {Monom} from \"./maths/algebra/monom\";\r\nimport {Polynom} from \"./maths/algebra/polynom\";\r\nimport {Equation} from \"./maths/algebra/equation\";\r\nimport {LinearSystem} from \"./maths/algebra/linearSystem\";\r\nimport {Rational} from \"./maths/algebra/rational\";\r\nimport {Logicalset} from \"./maths/algebra/logicalset\";\r\nimport {PolynomExpFactor, PolynomExpProduct} from \"./maths/expressions/polynomexp\";\r\nimport {Vector} from \"./maths/geometry/vector\";\r\nimport {Line} from \"./maths/geometry/line\";\r\nimport {Triangle} from \"./maths/geometry/triangle\";\r\nimport {Circle} from \"./maths/geometry/circle\";\r\nimport {Point} from \"./maths/geometry/point\";\r\n\r\n// Expose as global\r\nexport const PiMath = {\r\n    ShutingYard: Shutingyard,\r\n    Numeric: Numeric,\r\n    NumExp: NumExp,\r\n    Fraction: Fraction,\r\n    Root: NthRoot,\r\n    Monom: Monom,\r\n    Polynom: Polynom,\r\n    Equation: Equation,\r\n    LinearSystem: LinearSystem,\r\n    Rational: Rational,\r\n    Logicalset: Logicalset,\r\n    Random: Random,\r\n    PolynomExpFactor: PolynomExpFactor,\r\n    PolynomExpProduct: PolynomExpProduct,\r\n    Geometry: {\r\n        Vector: Vector,\r\n        Point: Point,\r\n        Line: Line,\r\n        Triangle: Triangle,\r\n        Circle: Circle\r\n    }\r\n};\r\n(<any>window).Pi = PiMath\r\n","import {Polynom} from \"./polynom\";\r\nimport {literalType, Monom} from \"./monom\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {NthRoot} from \"../coefficients/nthRoot\";\r\n\r\n/**\r\n * Equation is a class to manage equations...\r\n */\r\nexport interface ISolution {\r\n    tex: string,\r\n    display: string,\r\n    value: number,\r\n    exact: unknown\r\n}\r\n\r\nexport enum PARTICULAR_SOLUTION {\r\n    real=\"\\\\mathbb{R}\",\r\n    varnothing=\"\\\\varnothing\"\r\n}\r\n\r\nexport class Equation {\r\n    private _polynom: Polynom;  // Used to solve the equation // TODO: remove the private value ?\r\n\r\n    // Undetermined texSolutions.\r\n    private _varnothing: string = PARTICULAR_SOLUTION.varnothing;\r\n    private _real: string = PARTICULAR_SOLUTION.real;\r\n\r\n    /**\r\n     * Create an Equation using two polynoms.\r\n     * Markdown *support* is cool\r\n     * @param equations\r\n     */\r\n    constructor(...equations: unknown[]) {\r\n        // Default equation\r\n        this._left = new Polynom().zero();\r\n        this._right = new Polynom().zero();\r\n        this._sign = '=';\r\n\r\n        if (equations.length === 1) {\r\n            if (equations[0] instanceof Equation) {\r\n                return equations[0].clone();\r\n            } else if (typeof equations[0] === 'string') {\r\n                this.parse(equations[0]);\r\n            }\r\n        } else if (equations.length === 2) {\r\n            if (equations[0] instanceof Polynom) {\r\n                this.left = equations[0].clone()\r\n            } else if (typeof equations[0] === 'string') {\r\n                this.left = new Polynom(equations[0])\r\n            }\r\n\r\n            if (equations[1] instanceof Polynom) {\r\n                this.right = equations[1].clone()\r\n            } else if (typeof equations[1] === 'string') {\r\n                this.right = new Polynom(equations[1])\r\n            }\r\n        } else {\r\n            // Return default empty equation\r\n            return this;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _left: Polynom;  // Left part of the equation\r\n\r\n    get left(): Polynom {\r\n        return this._left;\r\n    }\r\n\r\n    set left(value: Polynom) {\r\n        this._left = value;\r\n    }\r\n\r\n    private _right: Polynom; // Right part of the equation\r\n\r\n    get right(): Polynom {\r\n        return this._right;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n\r\n    set right(value: Polynom) {\r\n        this._right = value;\r\n    }\r\n\r\n    private _sign: string;   // Signe of the equation, by default =\r\n\r\n    get sign(): string {\r\n        return this._sign;\r\n    }\r\n\r\n    set sign(value: string) {\r\n        // Set the sign value as formatted.\r\n        this._sign = this._formatSign(value);\r\n    }\r\n\r\n    private _solutions: ISolution[]\r\n\r\n    // ------------------------------------------\r\n    get solutions(): ISolution[] {\r\n        return this._solutions\r\n    }\r\n\r\n    get isEquation() {\r\n        return true;\r\n    }\r\n\r\n    get solution(): string {\r\n        if (this._solutions.length === 1\r\n            &&\r\n            (\r\n                this._solutions[0].tex === this._real\r\n                || this._solutions[0].tex === this._varnothing\r\n                || this._solutions[0].tex.includes('\\\\left')\r\n            )\r\n        ) {\r\n            return `S = ${this._solutions[0]}`;\r\n        }\r\n        return `S = \\\\left{ ${this._solutions.map(x => x.tex).join(';')} \\\\right}`;\r\n    }\r\n\r\n    get isReal(): boolean {\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n        return this._solutions[0].tex === this._real;\r\n    }\r\n\r\n    get isVarnothing(): boolean {\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n        return this._solutions[0].tex === this._varnothing;\r\n    }\r\n\r\n    get signAsTex(): string {\r\n        if (this._sign === '>=' || this._sign === '=>' || this._sign === 'geq') {\r\n            return '\\\\geq';\r\n        }\r\n        if (this._sign === '<=' || this._sign === '=<' || this._sign === 'leq') {\r\n            return '\\\\leq';\r\n        }\r\n        return this._sign;\r\n    }\r\n\r\n    get tex(): string {\r\n        return `${this._left.tex}${this.signAsTex}${this._right.tex}`;\r\n    }\r\n\r\n    get display(): string {\r\n        return `${this._left.display}${this.signAsTex}${this._right.display}`;\r\n    }\r\n\r\n    get raw(): string {\r\n        return `${this._left.raw}${this.signAsTex}${this._right.raw}`;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        return [...new Set(this._right.variables.concat(this._left.variables))];\r\n    }\r\n\r\n    get numberOfVars(): number {\r\n        return this.variables.length;\r\n    }\r\n\r\n    hasVariable = (letter: string): boolean => {\r\n        return this.variables.includes(letter)\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n\r\n    // -----------------------------------------------\r\n    private _randomizeDefaults: { [key: string]: number | string | boolean } = {\r\n        degree: 2\r\n    };\r\n\r\n    get randomizeDefaults(): { [key: string]: number | string | boolean } {\r\n        return this._randomizeDefaults;\r\n    }\r\n\r\n    set randomizeDefaults(value) {\r\n        this._randomizeDefaults = value;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    parse = (equationString: string): Equation => {\r\n        let pStr: string[], strSign: string | false;\r\n        // Find the string separator\r\n        strSign = this._findSign(equationString);\r\n\r\n        if (strSign === false) {\r\n            console.error('The equation is not valid (no sign found)');\r\n            return;\r\n        }\r\n\r\n        // The StrSign is found\r\n        pStr = equationString.split(strSign);\r\n\r\n        return this.create(new Polynom(pStr[0]), new Polynom(pStr[1]), this._formatSign(strSign));\r\n    };\r\n\r\n    create = (left: Polynom, right: Polynom, sign?: string): Equation => {\r\n        this._left = left;\r\n        this._right = right;\r\n        this._sign = this._formatSign(sign);\r\n        return this;\r\n    };\r\n\r\n    clone = (): Equation => {\r\n        return new Equation().create(this._left.clone(), this._right.clone(), this._sign + '');\r\n    };\r\n\r\n    // -----------------------------------------------\r\n    // Equations generators and randomizers\r\n\r\n    randomize = (opts?: {}, sign?: string): Equation => {\r\n        // TODO: Generate equations randomly, using config.\r\n        return new Equation().create(new Polynom(), new Polynom(), sign);\r\n    };\r\n\r\n    // -----------------------------------------------\r\n    /**\r\n     * Reorder will move all monoms containing a letter on the left, all the other on the right.\r\n     */\r\n    moveLeft = (): Equation => {\r\n        this._left = this._left.clone().subtract(this._right)\r\n        this._right.zero()\r\n        return this;\r\n    }\r\n\r\n    reorder = (allLeft?: boolean): Equation => {\r\n        // Move all monoms of degree greater than 0 to the left.\r\n        // and all zero degree monoms to the right.\r\n        this._left.subtract(this._right);\r\n        this._right.zero();\r\n\r\n        if (allLeft) {\r\n            return this.moveLeft()\r\n        }\r\n        let mMove: Monom;\r\n        for (let m of this._left.monoms) {\r\n            if (m.degree().isZero()) {\r\n                mMove = m.clone();\r\n                this._left.subtract(mMove);\r\n                this._right.subtract(mMove);\r\n            }\r\n        }\r\n\r\n        // Reorder the left and right polynoms\r\n        this._left.reorder();\r\n        this._right.reorder();\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Multiply by the lcm denominator and divide by the gcm numerators.\r\n     */\r\n    simplify = (): Equation => {\r\n        this.multiply(Numeric.lcm(...this._left.getDenominators(), ...this._right.getDenominators()));\r\n        this.divide(Numeric.gcd(...this._left.getNumerators(), ...this._right.getNumerators()));\r\n        return this;\r\n    }\r\n\r\n\r\n    // -----------------------------------------------\r\n    // Equations operations\r\n\r\n    /**\r\n     * Reorder the polynom to have only one letter on the left, the rest on the right.\r\n     * @param letter\r\n     */\r\n    isolate = (letter?: string): Equation | false => {\r\n        // Determine if we can isolate the variables.\r\n\r\n        // Both part of the equations must be of the first degree.\r\n        //TODO: handle equations of degree two or more ?\r\n        if (!this.degree(letter).isOne()) {\r\n            return false;\r\n        }\r\n\r\n        // Modify the equation to isolate the asked variable.\r\n        // TODO: must handle equations like 3xy+5y=4 => y = 4/(3x-5)\r\n        if (this.isMultiVariable()) {\r\n            return false;\r\n        }\r\n\r\n        // Isolate the letter.\r\n        let mMove: Monom, cMove: Fraction;\r\n        // Start by moving everything to the left.\r\n        this._left.subtract(this._right);\r\n        this._right.zero();\r\n        for (let m of this._left.monoms) {\r\n            if (!m.hasLetter(letter)) {\r\n                mMove = m.clone();\r\n                this._left.add(mMove.clone().opposed());\r\n                this._right.add(mMove.clone().opposed());\r\n            }\r\n        }\r\n\r\n        // In theory, we should have only one item on the left.\r\n        if (this._left.length !== 1) {\r\n            return false;\r\n        }\r\n        cMove = this._left.monoms[0].coefficient.clone();\r\n        this._left.divide(cMove);\r\n        this._right.divide(cMove);\r\n        return this;\r\n    };\r\n\r\n    replaceBy = (letter: string, P: Polynom): Equation => {\r\n        this._left.replaceBy(letter, P)\r\n        this._right.replaceBy(letter, P)\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiple an equation by a fraction value.\r\n     * @param value\r\n     */\r\n    multiply = (value: unknown): Equation => {\r\n\r\n        // Make sure we have a fraction.\r\n        let F: Fraction = new Fraction(value);\r\n\r\n        // Multiply each part of the equation by the fraction\r\n        this._left.multiply(F);\r\n        this._right.multiply(F);\r\n\r\n        // The sign of the inequation must be changed.\r\n        if (this._sign !== '=' && F.sign() === -1) {\r\n            this._reverseSign();\r\n        }\r\n\r\n        return this.reorder();\r\n    };\r\n\r\n    /**\r\n     * divide an equation by a given value (transformed as a fraction)\r\n     *\r\n     * ```\r\n     * 8x+10=6x \\vert 2\r\n     * 4x+5=3x\r\n     * ```\r\n     *\r\n     * |>Alternatively with $3x-4$ maybe it's working ?\r\n     * $$\\frac{3x}{5}$$\r\n     *\r\n     * @param value\r\n     * @returns {Equation}\r\n     */\r\n    divide = (value: unknown): Equation => {\r\n        // Make sure we have a fraction.\r\n        let F: Fraction = new Fraction(value);\r\n\r\n        if (F.isZero()) {\r\n            return this;\r\n        } else {\r\n            return this.multiply(F.invert());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the degree of the equation\r\n     * @param letter\r\n     */\r\n    degree = (letter?: string): Fraction => {\r\n        return Fraction.max(this._left.degree(letter), this._right.degree(letter));\r\n    };\r\n\r\n    /**\r\n     * Determine if the equation contains more than one letter/variable.\r\n     */\r\n    isMultiVariable = (): boolean => {\r\n        return this._left.isMultiVariable || this._right.isMultiVariable;\r\n    };\r\n\r\n    letters = (): string[] => {\r\n        // @ts-ignore\r\n        return [...new Set([...this._left.letters(), ...this._right.letters()])];\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations helpers\r\n    // -----------------------------------------------\r\n\r\n    // -----------------------------------------------\r\n    solve = (): Equation => {\r\n        // Initialise the variables:\r\n        this._solutions = [];\r\n\r\n        // TODO: consolidate solving equations (inequations vs equations)\r\n        // TODO: work with not natural degrees ?\r\n        this._polynom = this._left.clone().subtract(this._right);\r\n\r\n        switch (this._polynom.degree().value) {\r\n            case 0:\r\n            case 1:\r\n                this._solveDegree1();\r\n                break;\r\n            case 2:\r\n                this._solveDegree2();\r\n                break;\r\n            default:\r\n                this._solveDegree3plus();\r\n        }\r\n\r\n        // cleanup the solutions.\r\n        this._solutions = Equation.makeSolutionsUnique(this._solutions)\r\n        return this;\r\n    };\r\n\r\n    static makeSolutionsUnique(solutions: ISolution[], sorted?: boolean):ISolution[] {\r\n        let solutionAsTex:string[] = [],\r\n            uniqueSolutions = solutions.filter(sol=>{\r\n                if(!solutionAsTex.includes(sol.tex)){\r\n                    solutionAsTex.push(sol.tex)\r\n                    return true\r\n                }else{\r\n                    return false\r\n                }\r\n            })\r\n\r\n        if(sorted===true){\r\n            uniqueSolutions.sort((a, b)=>a.value-b.value)\r\n        }\r\n        return uniqueSolutions\r\n    }\r\n\r\n    test = (values: literalType): Boolean => {\r\n        return this.left.evaluate(values).isEqual(this.right.evaluate(values))\r\n    }\r\n\r\n    private _findSign = (equationString: string): string | false => {\r\n        let strSign: string = '';\r\n\r\n        if (equationString.includes('geq')) {\r\n            return (equationString.includes('\\\\geq')) ? '\\\\geq' : 'geq';\r\n        } else if (equationString.includes('leq')) {\r\n            return (equationString.includes('\\\\leq')) ? '\\\\leq' : 'leq';\r\n        } else if (equationString.includes('>=')) {\r\n            return '>=';\r\n        } else if (equationString.includes('=>')) {\r\n            return '=>';\r\n        } else if (equationString.includes('>')) {\r\n            return '>';\r\n        } else if (equationString.includes('<=')) {\r\n            return '<=';\r\n        } else if (equationString.includes('=<')) {\r\n            return '=<';\r\n        } else if (equationString.includes('<')) {\r\n            return '<';\r\n        } else if (equationString.includes('=')) {\r\n            return '='\r\n        }\r\n        if (strSign === '') {\r\n            console.log('Equation: parse string : sign not found');\r\n            return false;\r\n        }\r\n    };\r\n\r\n    // -----------------------------------------------\r\n    // Equations solving algorithms\r\n\r\n    private _formatSign = (signStr: string): string => {\r\n        if (signStr === undefined) {\r\n            return '=';\r\n        }\r\n\r\n        if (signStr.includes('geq')) {\r\n            return '>=';\r\n        } else if (signStr.includes('>=')) {\r\n            return '>=';\r\n        } else if (signStr.includes('=>')) {\r\n            return '>=';\r\n        } else if (signStr.includes('>')) {\r\n            return '>';\r\n        } else if (signStr.includes('leq')) {\r\n            return '<=';\r\n        } else if (signStr.includes('<=')) {\r\n            return '<=';\r\n        } else if (signStr.includes('=<')) {\r\n            return '<=';\r\n        } else if (signStr.includes('<')) {\r\n            return '<';\r\n        } else {\r\n            return '='\r\n        }\r\n    };\r\n\r\n    private _reverseSign = (): Equation => {\r\n        if (this._sign === '=') {\r\n            return this;\r\n        }\r\n\r\n        if (this._sign.includes('<')) {\r\n            this._sign.replace('<', '>');\r\n            return this;\r\n        }\r\n        if (this._sign.includes('>')) {\r\n            this._sign.replace('>', '<');\r\n            return this;\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    private isGreater = (): boolean => {\r\n        if (this._sign.indexOf('>') !== -1) {\r\n            return true;\r\n        }\r\n        return this._sign.indexOf('geq') !== -1;\r\n\r\n    };\r\n\r\n    private isStrictEqual = (): boolean => {\r\n        return this._sign === '=';\r\n    };\r\n\r\n    private isAlsoEqual = (): boolean => {\r\n        if (this._sign.indexOf('=') !== -1) {\r\n            return true;\r\n        }\r\n        if (this._sign.indexOf('geq') !== -1) {\r\n            return true;\r\n        }\r\n        if (this._sign.indexOf('leq') !== -1) {\r\n            return true;\r\n        }\r\n    };\r\n\r\n    private _solveDegree1 = (letter?: string): ISolution[] => {\r\n        const m1 = this._polynom.monomByDegree(1, letter).coefficient,\r\n            m0 = this._polynom.monomByDegree(0, letter).coefficient,\r\n            v = m0.clone().opposed().divide(m1);\r\n        let s: string, d: string;\r\n\r\n        if (this.isStrictEqual()) {\r\n            if (m1.value === 0) {\r\n                // In this case, the coefficient of the x variable is zero.\r\n                if (m0.value === 0) {\r\n                    this._solutions = [{\r\n                        tex: this._real,\r\n                        display: \"RR\",\r\n                        value: NaN,\r\n                        exact: false\r\n                    }];\r\n                } else {\r\n                    this._solutions = [{\r\n                        tex: this._varnothing,\r\n                        display: \"O/\",\r\n                        value: NaN,\r\n                        exact: false\r\n                    }];\r\n                }\r\n            } else {\r\n                this._solutions = [{\r\n                    tex: v.tex,\r\n                    display: v.display,\r\n                    value: v.value,\r\n                    exact: v\r\n                }]\r\n            }\r\n        }\r\n        else {\r\n            if (m1.value === 0) {\r\n                // In this case, the coefficient of the x variable is zero.\r\n                if (m0.value === 0 && this.isAlsoEqual()) {\r\n                    s = '\\\\mathbb{R}';\r\n                    d = \"RR\"\r\n                } else {\r\n                    if (m0.value > 0) {\r\n                        s = this.isGreater() ? this._real : this._varnothing;\r\n                        s = this.isGreater() ? \"RR\" : \"O/\";\r\n                    } else {\r\n                        s = !this.isGreater() ? this._real : this._varnothing;\r\n                        s = !this.isGreater() ? \"RR\" : \"O/\";\r\n                    }\r\n                }\r\n            } else {\r\n                // Must handle the case if the m1 monom is negative.\r\n                if ((this.isGreater() && m1.sign() === 1) || (!this.isGreater() && m1.sign() === -1)) {\r\n                    s = `\\\\left${this.isAlsoEqual() ? '[' : ']'}${v.tex};+\\\\infty\\\\right[`;\r\n                    d = `${this.isAlsoEqual() ? '[' : ']'}${v.tex};+oo[`;\r\n                } else {\r\n                    s = `\\\\left]-\\\\infty;${v.tex} \\\\right${this.isAlsoEqual() ? ']' : '['}`;\r\n                    d = `]-oo;${v.tex}${this.isAlsoEqual() ? ']' : '['}`;\r\n                }\r\n            }\r\n            this._solutions = [{\r\n                tex: s,\r\n                display: d,\r\n                value: NaN,\r\n                exact: false\r\n            }];\r\n        }\r\n\r\n        return this._solutions;\r\n    };\r\n\r\n    private _solveDegree2 = (letter?: string): ISolution[] => {\r\n        let aF = this._polynom.monomByDegree(2, letter).coefficient,\r\n            bF = this._polynom.monomByDegree(1, letter).coefficient,\r\n            cF = this._polynom.monomByDegree(0, letter).coefficient,\r\n            delta: number, nthDelta: NthRoot,\r\n            lcm = Numeric.lcm(aF.denominator, bF.denominator, cF.denominator),\r\n            a = aF.multiply(lcm).value,\r\n            b = bF.multiply(lcm).value,\r\n            c = cF.multiply(lcm).value,\r\n            realX1: number, realX2: number,\r\n            sX1: string, sX2: string;\r\n\r\n        delta = b * b - 4 * a * c;\r\n\r\n        if (delta > 0) {\r\n            realX1 = (-b - Math.sqrt(delta)) / (2 * a);\r\n            realX2 = (-b + Math.sqrt(delta)) / (2 * a);\r\n\r\n            if (delta > 1.0e5) {\r\n                // The delta is too big to be parsed !\r\n                let v1 = ((-b - Math.sqrt(delta)) / (2 * a)).toFixed(5),\r\n                    v2 = ((-b + Math.sqrt(delta)) / (2 * a)).toFixed(5)\r\n\r\n                this._solutions = [\r\n                    {\r\n                        tex: v1,\r\n                        display: v1,\r\n                        value: realX1,\r\n                        exact: false\r\n                    },\r\n                    {\r\n                        tex: v2,\r\n                        display: v2,\r\n                        value: realX2,\r\n                        exact: false\r\n                    }\r\n                ]\r\n            } else {\r\n                nthDelta = new NthRoot(delta).reduce();\r\n                if (nthDelta.hasRadical()) {\r\n                    // -b +- coeff\\sqrt{radical}\r\n                    // -------------------------\r\n                    //           2a\r\n                    let gcd = Numeric.gcd(b, 2 * a, nthDelta.coefficient),\r\n                        am = a/gcd, bm = b/gcd\r\n                    nthDelta.coefficient = nthDelta.coefficient / gcd;\r\n\r\n                    if (a < 0) {\r\n                        am = -am\r\n                        bm = -bm\r\n                    }\r\n\r\n                    let tex1 = \"\", tex2 = \"\", display1 = \"\", display2 = \"\"\r\n\r\n                    tex1 = `${bm !== 0 ? ((-bm) + ' - ') : ''}${nthDelta.tex}`\r\n                    tex2 = `${bm !== 0 ? ((-bm) + ' + ') : ''}${nthDelta.tex}`\r\n                    display1 = `${bm !== 0 ? ((-bm) + ' - ') : ''}${nthDelta.display}`\r\n                    display2 = `${bm !== 0 ? ((-bm) + ' + ') : ''}${nthDelta.display}`\r\n\r\n                    if (am !== 1) {\r\n                        tex1 = `\\\\frac{ ${tex1} }{ ${2 * am} }`\r\n                        tex2 = `\\\\frac{ ${tex2} }{ ${2 * am} }`\r\n                    }\r\n\r\n                    this._solutions = [\r\n                        {\r\n                            tex: tex1,\r\n                            display: tex1,\r\n                            value: realX1,\r\n                            exact: false\r\n                        },\r\n                        {\r\n                            tex: tex2,\r\n                            display: tex2,\r\n                            value: realX2,\r\n                            exact: false\r\n                        },\r\n                    ]\r\n\r\n\r\n                    // if (b !== 0) {\r\n                    //     if (2 * a / gcd === 1) {\r\n                    //         this._solutions = [\r\n                    //             {\r\n                    //                 tex: `${-b / gcd} - ${nthDelta.tex}`,\r\n                    //                 value: realX1,\r\n                    //                 exact: false // TODO: implement exact value with nthroot\r\n                    //             },\r\n                    //             {\r\n                    //                 tex: `${-b / gcd} + ${nthDelta.tex}`,\r\n                    //                 value: realX2,\r\n                    //                 exact: false\r\n                    //             },\r\n                    //\r\n                    //         ]\r\n                    //     } else {\r\n                    //         this._solutions = [\r\n                    //             {\r\n                    //                 tex: `\\\\frac{${-b / gcd} - ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                    //                 value: realX1,\r\n                    //                 exact: false\r\n                    //             },\r\n                    //             {\r\n                    //                 tex: `\\\\frac{${-b / gcd} + ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                    //                 value: realX2,\r\n                    //                 exact: false\r\n                    //             },\r\n                    //         ]\r\n                    //     }\r\n                    // } else {\r\n                    //     if (2 * a / gcd === 1) {\r\n                    //         this._solutions = [\r\n                    //             {\r\n                    //                 tex: `- ${nthDelta.tex}`,\r\n                    //                 value: realX1,\r\n                    //                 exact: false\r\n                    //             },\r\n                    //             {\r\n                    //                 tex: `${nthDelta.tex}`,\r\n                    //                 value: realX2,\r\n                    //                 exact: false\r\n                    //             },\r\n                    //         ]\r\n                    //     } else {\r\n                    //         this._solutions = [\r\n                    //             {\r\n                    //                 tex: `\\\\frac{- ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                    //                 value: realX1,\r\n                    //                 exact: false\r\n                    //             },\r\n                    //             {\r\n                    //                 tex: `\\\\frac{${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                    //                 value: realX2,\r\n                    //                 exact: false\r\n                    //             },\r\n                    //         ]\r\n                    //     }\r\n                    // }\r\n                } else {\r\n                    // -b +- d / 2a\r\n                    const S1 = new Fraction(-b - nthDelta.coefficient, 2 * a).reduce(),\r\n                        S2 = new Fraction(-b + nthDelta.coefficient, 2 * a).reduce()\r\n                    this._solutions = [\r\n                        {\r\n                            tex: S1.frac,\r\n                            display: S1.display,\r\n                            value: realX1,\r\n                            exact: S1\r\n                        },\r\n                        {\r\n                            tex: S2.frac,\r\n                            display: S2.display,\r\n                            value: realX2,\r\n                            exact: S2\r\n                        }\r\n                    ]\r\n                }\r\n            }\r\n\r\n        } else if (delta === 0) {\r\n            const sol = new Fraction(-b, 2 * a).reduce()\r\n            this._solutions = [{\r\n                tex: sol.frac,\r\n                display: sol.display,\r\n                value: sol.value,\r\n                exact: sol\r\n            }];\r\n        } else {\r\n            this._solutions = [{\r\n                tex: this._varnothing,\r\n                display: \"O/\",\r\n                value: NaN,\r\n                exact: false\r\n            }];\r\n        }\r\n\r\n        // Handle now the inequations.\r\n        if (!this.isStrictEqual()) {\r\n            if (this._solutions.length === 2) {\r\n                sX1 = (realX1 < realX2) ? this._solutions[0].tex : this._solutions[1].tex;\r\n                sX2 = (realX1 < realX2) ? this._solutions[1].tex : this._solutions[0].tex;\r\n\r\n                if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                    this._solutions = [{\r\n                        tex: `\\\\left]-\\\\infty ; ${sX1}\\\\right${this.isAlsoEqual() ? ']' : '['} \\\\cup \\\\left${this.isAlsoEqual() ? '[' : ']'}${sX2};+\\\\infty\\\\right[`,\r\n                        display: `]-oo;${sX1}${this.isAlsoEqual() ? ']' : '['}uu${this.isAlsoEqual() ? '[' : ']'}${sX2};+oo[`,\r\n                        value: NaN,\r\n                        exact: false\r\n                    }\r\n                    ];\r\n                } else {\r\n                    this._solutions = [{\r\n                        tex: `\\\\left${this.isAlsoEqual() ? '[' : ']'}${sX1} ; ${sX2}\\\\right${this.isAlsoEqual() ? ']' : '['}`,\r\n                        display: `${this.isAlsoEqual() ? '[' : ']'}${sX1};${sX2}${this.isAlsoEqual() ? ']' : '['}`,\r\n                        value: NaN,\r\n                        exact: false\r\n                    }]\r\n                }\r\n            } else if (this._solutions.length === 1 && this._solutions[0].tex !== this._varnothing) {\r\n                if (!this.isAlsoEqual()) {\r\n                    if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                        this._solutions = [{\r\n                            tex: `\\\\left]-\\\\infty ; ${this._solutions[0].tex}\\\\right[ \\\\cup \\\\left]${this._solutions[0].tex};+\\\\infty\\\\right[`,\r\n                            display: `]-oo;${this._solutions[0].tex}[uu]${this._solutions[0].tex};+oo[`,\r\n                            value: NaN,\r\n                            exact: false\r\n                        }\r\n                        ];\r\n                    } else {\r\n                        this._solutions = [{\r\n                            tex: this._varnothing,\r\n                            display: \"O/\",\r\n                            value: NaN,\r\n                            exact: false\r\n                        }];\r\n                    }\r\n                } else {\r\n                    if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                        this._solutions = [{\r\n                            tex: this._real,\r\n                            display: \"RR\",\r\n                            value: NaN,\r\n                            exact: false\r\n                        }];\r\n                    } else {\r\n                        // this._texSolutions = [ this._texSolutions[0] ];\r\n                    }\r\n                }\r\n            } else {\r\n                if (this.isGreater()) {\r\n                    this._solutions = [{\r\n                        tex: aF.sign() === 1 ? this._real : this._varnothing,\r\n                        display: aF.sign() === 1 ? \"RR\" : \"O/\",\r\n                        value: NaN,\r\n                        exact: false\r\n                    }];\r\n                } else {\r\n                    this._solutions = [{\r\n                        tex: aF.sign() === -1 ? this._real : this._varnothing,\r\n                        display: aF.sign() === -1 ? \"RR\" : \"O/\",\r\n                        value: NaN,\r\n                        exact: false\r\n                    }];\r\n                }\r\n            }\r\n        }\r\n        return this._solutions;\r\n    };\r\n\r\n    private _solveDegree3plus = (letter?: string): ISolution[] => {\r\n        // Push everything to the left\r\n        // factorize\r\n        // solve each factors.\r\n        let equ = this.clone().moveLeft()\r\n        equ.left.factorize()\r\n\r\n        this._solutions = []\r\n\r\n        equ.left.factors.forEach(factor=>{\r\n            if(factor.degree(letter).leq(2)) {\r\n                let factorAsEquation = new Equation(factor, 0)\r\n                factorAsEquation.solve()\r\n                factorAsEquation.solutions.forEach(solution => {\r\n                    this._solutions.push(solution)\r\n                })\r\n            }else{\r\n                console.log(factor.tex, ': cannot actually get the solution of this equation')\r\n            }\r\n        })\r\n\r\n        // TODO: check equation resolution for more than degree 2\r\n        // this._solutions = [{tex: 'solve x - not yet handled', value: NaN, exact: false}];  // ESLint remove system :(\r\n        return this._solutions;\r\n    };\r\n}","import {Equation} from \"./equation\";\r\nimport {Polynom} from \"./polynom\";\r\nimport {Monom} from \"./monom\";\r\nimport {Random} from \"../randomization/random\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\n// TODO: Must check and rework\r\nexport class LinearSystem {\r\n    private _solutions: { [letter: string]: { value: Fraction, isReal: boolean, isVarnothing: boolean } };\r\n    private _resolutionSteps: LinearSystem[];\r\n    private _equations: Equation[];\r\n    private _letters: string[];\r\n\r\n    constructor(...equationStrings: string[]) {\r\n        this._equations = [];\r\n        this._letters = 'xyz'.split('');\r\n\r\n        if (equationStrings !== undefined && equationStrings.length > 0) {\r\n            this.parse(...equationStrings);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get equations(): Equation[] {\r\n        return this._equations;\r\n    }\r\n\r\n    set equations(value) {\r\n        this._equations = value;\r\n    }\r\n\r\n    get letters(): string {\r\n        return this._letters.join('')\r\n    }\r\n\r\n    set letters(value: string) {\r\n        this._letters = value.split('');\r\n    }\r\n\r\n    get isSolvable(): boolean {\r\n        let V = this.variables;\r\n\r\n        // TODO: in some case, it is possible to resolve systems if there isn't the isSame number of vars and equations\r\n        if (V.length !== this._equations.length) {\r\n            return false;\r\n        }\r\n\r\n        //TODO: Must check if two equations isn't a linear combination of the others ?\r\n\r\n        return true;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        let V: string[] = [];\r\n        for (let E of this._equations) {\r\n            V = V.concat(E.variables);\r\n        }\r\n        return [...new Set(V)].sort();\r\n    }\r\n\r\n    get tex(): string {\r\n        // Build the array of values.\r\n        // Reorder\r\n        // This clone the system :!!!\r\n        //TODO: Avoid cloning this linear system\r\n        let LS = this.clone().reorder(),\r\n            letters = LS.variables,\r\n            equStr: string[],\r\n            equArray: string[] = [],\r\n            m: Monom;\r\n\r\n        // TODO: Manage tex output of linear equations\r\n        for (let equ of LS.equations) {\r\n            equStr = [];\r\n            for (let L of letters) {\r\n                m = equ.left.monomByLetter(L);\r\n\r\n                if (equStr.length === 0) {\r\n                    equStr.push(m.isZero() ? '' : m.tex);\r\n                } else {\r\n                    equStr.push(m.isZero() ? '' : ((m.coefficient.sign() === 1) ? '+' : '') + m.tex);\r\n                }\r\n            }\r\n\r\n            // Add the equal sign\r\n            equStr.push('=');\r\n\r\n            // Add the right hand part of the equation (should be only a number, because it has been reordered)\r\n            equStr.push(equ.right.tex);\r\n\r\n            // Add to the list.\r\n            equArray.push(equStr.join('&'));\r\n        }\r\n\r\n        return `\\\\left\\\\{\\\\begin{array}{${\"r\".repeat(letters.length)}cl}${equArray.join('\\\\\\\\\\ ')}\\\\end{array}\\\\right.`;\r\n    }\r\n\r\n    get solution(): string {\r\n        let tex: string[] = [];\r\n\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n\r\n        for (let letter in this._solutions) {\r\n            if (this._solutions[letter].isReal) {\r\n                console.log(`Undetermined (letter ${letter})`);\r\n                return;\r\n            }\r\n            if (this._solutions[letter].isVarnothing) {\r\n                console.log(`Undefined (letter ${letter})`);\r\n                return;\r\n            }\r\n\r\n            tex.push(this._solutions[letter].value.tex);\r\n        }\r\n        return `\\\\left(${tex.join(';')}\\\\right)`;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (...equations: unknown[]): LinearSystem => {\r\n        this._equations = equations.map(value => new Equation(value));\r\n        this._findLetters();\r\n        return this;\r\n    };\r\n\r\n    setCoefficient = (...coefficients: string[]): LinearSystem => {\r\n        // Reset the equations list\r\n        this._equations = [];\r\n\r\n        let i = 0;\r\n        while (i < coefficients.length - this._letters.length) {\r\n            let left = new Polynom().parse(this._letters.join(''), ...coefficients.slice(i, i + this._letters.length)),\r\n                right = new Polynom(coefficients[i + this._letters.length].toString()),\r\n                equ = new Equation().create(left, right);\r\n            this._equations.push(equ.clone());\r\n\r\n            i = i + this._letters.length + 1;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    clone = (): LinearSystem => {\r\n        return new LinearSystem().parse(...this._equations.map(equ => equ.clone()));\r\n    };\r\n\r\n    setLetters = (...letters: string[]): LinearSystem => {\r\n        this._letters = letters;\r\n        return this\r\n    }\r\n    private _findLetters = (): LinearSystem => {\r\n        // Find all letters used.\r\n        let variables = new Set();\r\n\r\n        for (let equ of this._equations) {\r\n            variables = new Set([...variables, ...equ.variables]);\r\n        }\r\n\r\n        // TODO: How to transform (Set of string) to string[]\r\n        // @ts-ignore\r\n        this._letters = [...variables];\r\n        return this;\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations generators and randomizers\r\n    // -----------------------------------------------\r\n    generate = (...solutions: Fraction[] | number[]): LinearSystem => {\r\n        let solutionsF: Fraction[] = [];\r\n\r\n        // Convert the numbers to fractions if necessary\r\n        for (let s of solutions) {\r\n            if (typeof s === \"number\") {\r\n                solutionsF.push(new Fraction(s.toString()));\r\n            } else {\r\n                solutionsF.push(s.clone());\r\n            }\r\n        }\r\n\r\n        // Create the equations and make sure they are not linear combined.\r\n        this._equations = [];\r\n        for (let i = 0; i < solutions.length; i++) {\r\n            this._equations.push(this._generateOneEquation(...solutionsF));\r\n        }\r\n        return this;\r\n    };\r\n    private _generateOneEquation = (...solutions: Fraction[]): Equation => {\r\n        let coeff: number[] = [], leftValue: Fraction = new Fraction().zero(),\r\n            letters: string[] = ['x', 'y', 'z', 't', 'u', 'v', 'w', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l'],\r\n            equString: string = '', equ: Equation;\r\n        for (let i = 0; i < solutions.length; i++) {\r\n            coeff.push(Random.numberSym(5));\r\n            leftValue.add(solutions[i].clone().multiply(coeff[i]));\r\n            equString += `${(coeff[i] < 0) ? coeff[i] : '+' + coeff[i]}${letters[i]}`\r\n        }\r\n\r\n        // LeftValue contains the left part oof the equation - and is then the isSame as the right part.\r\n        // It might be a Fraction.\r\n\r\n        // Must check if it's not a linear combination\r\n        equ = new Equation(`${equString}=${leftValue.display}`);\r\n        if (equ.right.monoms[0].coefficient.denominator != 1) {\r\n            equ.multiply(new Fraction(equ.right.monoms[0].coefficient.denominator, 1));\r\n        }\r\n        if (this._checkIfLinerCombination(equ)) {\r\n            return equ;\r\n        } else {\r\n            return this._generateOneEquation(...solutions);\r\n        }\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    private _linearReduction(eq1: Equation, eq2: Equation, letter: string): Equation {\r\n        // TODO: handle other signs for equations ?\r\n        // Get the monom for the particular letter.\r\n        let c1 = eq1.left.monomByDegree(1, letter).coefficient.clone(),\r\n            c2 = eq2.left.monomByDegree(1, letter).coefficient.clone().opposed();\r\n\r\n        console.log('reduction: ', letter, eq1.tex, eq2.tex, c2.tex, c1.tex)\r\n        return this.mergeEquations(eq1, eq2, c2, c1);\r\n    }\r\n\r\n    mergeEquations = (eq1: Equation, eq2: Equation, factor1: unknown, factor2: unknown): Equation => {\r\n        // Set and clone the equations.\r\n\r\n        let eq1multiplied = eq1.clone().multiply(new Fraction(factor1)),\r\n            eq2multiplied = eq2.clone().multiply(new Fraction(factor2));\r\n\r\n        // @ts-ignore\r\n        console.log(eq1.tex, eq1multiplied.tex, factor1.tex)\r\n        // @ts-ignore\r\n        console.log(eq2.tex, eq2multiplied.tex, factor2.tex)\r\n\r\n        // Add both equations together.\r\n        eq1multiplied.left.add(eq2multiplied.left);\r\n        eq1multiplied.right.add(eq2multiplied.right);\r\n\r\n        console.log('resulting reduction', eq1multiplied.tex)\r\n        return eq1multiplied;\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Solvers algorithm\r\n    // ------------------------------------------\r\n    reorder = (): LinearSystem => {\r\n        for (let E of this._equations) {\r\n            E.reorder();\r\n        }\r\n        return this;\r\n    };\r\n\r\n    solve = (): LinearSystem => {\r\n        // Solve it by linear\r\n        this._solutions = {};\r\n        this._resolutionSteps = [];\r\n\r\n        // Reorder all equations.\r\n        this.reorder();\r\n\r\n        // Get all variables in the linear system\r\n        let V = this.variables.sort();\r\n\r\n        for (let letter of V) {\r\n            console.log('SOLVING FOR', letter)\r\n            this._solutions[letter] = this._solveOneLetter(letter, V)\r\n        }\r\n\r\n        // TODO: LinearSystem - solve: optimization and handle undetermined and undefined systems.\r\n        return this;\r\n    };\r\n\r\n    private _checkIfLinerCombination = (equ: Equation): boolean => {\r\n\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Linear reduction of the equations to have only one letter\r\n     * @param letter    letter to isolate\r\n     * @param V         list of variables in the linear system.\r\n     * @private\r\n     */\r\n    private _solveOneLetter(letter: string, V: string[]): { value: Fraction, isReal: boolean, isVarnothing: boolean } {\r\n        // list of equations.\r\n        let LE: Equation[] = this.clone().equations,\r\n            reducedEquations: Equation[] = [];\r\n\r\n        // Reduce the equations.\r\n        // Do it as long as there is more than one step, but no more than the number of equations.\r\n        for (let L of V) {\r\n            // remove the setLetter from all equations using linear combinations\r\n            if (L === letter) {\r\n                continue;\r\n            }\r\n\r\n            console.log('Removing the variable:  ', L)\r\n            // Linear reduction.\r\n            // TODO: Search for better association\r\n            for (let i = 0; i < LE.length - 1; i++) {\r\n                reducedEquations.push(this._linearReduction(LE[i], LE[i + 1], L));\r\n            }\r\n\r\n            console.log(reducedEquations.map(x=>x.tex))\r\n\r\n            // Keep track of each steps.\r\n            this._resolutionSteps.push(new LinearSystem().parse(...reducedEquations));\r\n\r\n            // Set the list of equations to the new version.\r\n            LE = this._resolutionSteps[this._resolutionSteps.length - 1].clone().equations;\r\n\r\n            // Reset the stack\r\n            reducedEquations = [];\r\n        }\r\n\r\n        // Solve the equations\r\n        let E = this._resolutionSteps[this._resolutionSteps.length - 1].equations[0];\r\n        E.solve()\r\n        console.log('Solutions for ', letter, ': ', E.solutions[0].tex)\r\n        return {\r\n            value: new Fraction(E.solutions[0].value),\r\n            isReal: E.isReal,\r\n            isVarnothing: E.isVarnothing\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Helpers\r\n    // ------------------------------------------\r\n    log = (): string => {\r\n        let str: string = '';\r\n\r\n        for (let E of this._equations) {\r\n            str += `${E.tex}\\\\n}`;\r\n        }\r\n\r\n        return str;\r\n    };\r\n}\r\n","/**\r\n * Polynom module contains everything necessary to handle polynoms.\r\n * @module Logicalset\r\n */\r\n\r\nimport {Shutingyard, ShutingyardMode} from '../shutingyard';\r\n\r\n/**\r\n * Polynom class can handle polynoms, reorder, resolve, ...\r\n */\r\n    export class Logicalset {\r\n        private _rawString: string;\r\n        private _rpn: { token: string, tokenType: string }[]\r\n\r\n        /**\r\n         *\r\n         * @param {string} value (optional) Default polynom to parse on class creation\r\n         */\r\n        constructor(value: string) {\r\n            this._rawString = value\r\n            this.parse(value)\r\n            return this;\r\n        }\r\n\r\n        get isLogicalset() {\r\n            return true;\r\n        };\r\n\r\n        private parse = (value: string): Logicalset => {\r\n            // TODO: Must format the value string to convert some items...\r\n\r\n            // Parse the updated value to the shutingyard algorithm\r\n            this._rpn = new Shutingyard(ShutingyardMode.SET).parse(value).rpn;\r\n\r\n            return this;\r\n        }\r\n\r\n        evaluate(tokenSets: { [key: string]: unknown[] }, reference?: unknown[]): unknown[] {\r\n            let varStack: (Set<unknown>)[] = []\r\n\r\n            let referenceSet: Set<unknown>\r\n            if (reference === undefined) {\r\n                referenceSet = new Set()\r\n                for (let key in tokenSets) {\r\n                    referenceSet = new Set([...referenceSet, ...tokenSets[key]])\r\n                }\r\n            } else {\r\n                referenceSet = new Set(reference)\r\n            }\r\n\r\n            for (let token of this._rpn) {\r\n                if (token.tokenType === 'variable') {\r\n                    // The variable has no token - assume it's empty.\r\n                    if (tokenSets[token.token] === undefined) {\r\n                        varStack.push(new Set())\r\n                    } else {\r\n                        varStack.push(new Set(tokenSets[token.token]));\r\n                    }\r\n\r\n                } else {\r\n                    switch (token.token) {\r\n                        case '&':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                varStack.push(new Set([...first].filter(x => second.has(x))))\r\n                            }\r\n                            break\r\n                        case '|':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n                                varStack.push(new Set([...first, ...second]))\r\n                            }\r\n                            break\r\n                        case '-':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n                                varStack.push(new Set([...first].filter(x => !second.has(x))))\r\n                            }\r\n                            break\r\n                        case '!':\r\n                            if (varStack.length >= 1) {\r\n                                let first = varStack.pop()\r\n\r\n                                varStack.push(new Set([...referenceSet].filter(x => !first.has(x))))\r\n                            }\r\n                            break\r\n                    }\r\n                }\r\n            }\r\n\r\n            return [...varStack[0]].sort();\r\n        }\r\n\r\n        vennAB(): any[] {\r\n            return this.evaluate({\r\n                    A: ['A', 'AB'],\r\n                    B: ['B', 'AB']\r\n                },\r\n                ['A', 'B', 'AB', 'E']\r\n            )\r\n        }\r\n\r\n        vennABC(): any[] {\r\n            return this.evaluate({\r\n                    A: ['A', 'AB', 'AC', 'ABC'],\r\n                    B: ['B', 'AB', 'BC', 'ABC'],\r\n                    C: ['C', 'AC', 'BC', 'ABC']\r\n                },\r\n                ['A', 'B', 'C', 'AB', 'AC', 'BC', 'E']\r\n            )\r\n        }\r\n\r\n        get rpn(): { token: string, tokenType: string }[] {\r\n            return this._rpn\r\n        }\r\n\r\n        get tex(): string {\r\n            let varStack: { token: string, tokenType: string } [] = []\r\n\r\n            for (let token of this._rpn) {\r\n                if (token.tokenType === 'variable') {\r\n                    varStack.push(token);\r\n                } else {\r\n                    switch (token.token) {\r\n                        case '&':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\cap ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                            break\r\n                        case '|':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\cup ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                            break\r\n                        case '-':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\setminus ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                            break\r\n                        case '!':\r\n                            if (varStack.length >= 1) {\r\n                                let first = varStack.pop()\r\n                                varStack.push({token: `\\\\overline{ ${first.token} }`, tokenType: 'variable'})\r\n                            }\r\n                            break\r\n                    }\r\n                }\r\n            }\r\n\r\n            return varStack[0].token\r\n        }\r\n    }","/***\r\n * Monom class\r\n */\r\nimport {Numeric} from \"../numeric\";\r\nimport {Shutingyard, ShutingyardType, Token} from \"../shutingyard\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\nexport type literalType = {\r\n    [Key: string]: Fraction\r\n}\r\n\r\nexport class Monom {\r\n    private _coefficient: Fraction;\r\n    private _literal: literalType;\r\n\r\n    /**\r\n     * Create a Monom\r\n     * Defined as \\\\(k \\\\cdot x^{n}\\\\), where \\\\( k,n \\in \\\\mathbb{Q}\\\\).\r\n     * Examples: \\\\(3x^2\\\\) or \\\\(3/5x^2\\\\)\r\n     * @param value (optional) string The value that should be parse. Can be a Monom, a Fraction, a string or a number. If nothing is provided, it will return the trivial monom (0).\r\n     */\r\n    constructor(value?: unknown) {\r\n        this.zero();\r\n\r\n        if (value !== undefined) {\r\n            // A string is given - try to parse the value.\r\n            this.parse(value);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    /**\r\n     * Get the coefficient \\\\(k\\\\) of the Monom \\\\(k\\\\cdot x^{n}\\\\)\r\n     * @returns {Fraction}\r\n     */\r\n    get coefficient(): Fraction {\r\n        return this._coefficient;\r\n    }\r\n\r\n    /**\r\n     * Set the coefficient \\\\(k\\\\) value of the monom\r\n     * @param {Fraction | number | string} F\r\n     */\r\n    set coefficient(F: Fraction | number | string) {\r\n        this._coefficient = new Fraction(F);\r\n    }\r\n\r\n    /**\r\n     * Get the literal part of \\\\(x^{n_1}y^{n_2}\\\\) as dictionary \\\\[\\\\begin{array}{ll}x&=n_1\\\\\\\\y&=n_2\\\\end{array}\\\\]\r\n     * @returns {literalType}\r\n     */\r\n    get literal(): literalType {\r\n        return this._literal;\r\n    }\r\n\r\n    /**\r\n     * Get the literal square roots of the Monom.\r\n     * TODO: remove this getter ? Is it used and is it correct ?\r\n     * @returns {literalType}\r\n     */\r\n    get literalSqrt(): literalType {\r\n        if (this.isLiteralSquare()) {\r\n            let L: literalType = {}\r\n            for (let key in this._literal) {\r\n                L[key] = this._literal[key].clone().sqrt()\r\n            }\r\n            return L;\r\n        } else {\r\n            return this._literal;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom. Must be a dictionary {x: Fraction, y: Fraction, ...}\r\n     * @param {literalType} L\r\n     */\r\n    set literal(L: literalType) {\r\n        this._literal = L;\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom from a string\r\n     * @param inputStr  String like x^2y^3\r\n     */\r\n    set literalStr(inputStr: string) {\r\n        // TODO : parse using shutingyard tree !\r\n\r\n        // Match all x^n\r\n        for (const v of [...inputStr.matchAll(/([a-z])\\^([+-]?[0-9]+)/g)]) {\r\n            // Create the default letter entry if necessary.\r\n            if (!(v[1] in this._literal)) {\r\n                this._literal[v[1]] = new Fraction().zero();\r\n            }\r\n\r\n            // Add the new value.\r\n            // TODO: actually, it adds only numeric value\r\n            this._literal[v[1]].add(+v[2]);\r\n        }\r\n\r\n        // Match all x\r\n        for (const v of [...inputStr.matchAll(/([a-z](?!\\^))/g)]) {\r\n            // Match all single letters\r\n            if (!(v[1] in this._literal)) {\r\n                this._literal[v[1]] = new Fraction().zero();\r\n            }\r\n\r\n            // Add one to the value.\r\n            this._literal[v[1]].add(1)\r\n        }\r\n    }\r\n\r\n    // Getter helpers.\r\n    /**\r\n     * Get the variables letters\r\n     */\r\n    get variables(): string[] {\r\n        let M = this.clone().clean();\r\n        return Object.keys(M.literal)\r\n    }\r\n\r\n    // Display getter\r\n    /**\r\n     * This display getter is to be used in the polynom display getter\r\n     */\r\n    get display(): string {\r\n        let L: string = '',\r\n            letters = Object.keys(this._literal).sort()\r\n        for (let letter of letters) {\r\n            if (this._literal[letter].isNotZero()) {\r\n                L += `${letter}`;\r\n                if (this._literal[letter].isNotEqual(1)) {\r\n                    L += `^(${this._literal[letter].display})`;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.display}`;\r\n            } else {\r\n                return '';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.display}${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    get dividers(): Monom[] {\r\n        // Decompose only if the coefficient is a natural number\r\n        if (!this.coefficient.isRelative()) {\r\n            return [this.clone()]\r\n        }\r\n\r\n\r\n        // Decompose only if the power values are natural numbers.\r\n        if (this.hasFractionCoefficient()) {\r\n            return [this.clone()]\r\n        }\r\n\r\n        // Security : do not do this if greater than 10000\r\n        if (this.coefficient.numerator > 1000000) {\r\n            return [this.clone()]\r\n        }\r\n\r\n        const dividers = Numeric.dividers(Math.abs(this.coefficient.numerator))\r\n\r\n        // Decompose the literals parts.\r\n        let literals: literalType[] = [];\r\n        for (let L in this.literal) {\r\n            // L is the letter.\r\n            literals = this._getLiteralDividers(literals, L)\r\n        }\r\n\r\n        const monomDividers: Monom[] = [];\r\n        if (literals.length > 0 && dividers.length > 0) {\r\n            for (let N of dividers) {\r\n                for (let L of literals) {\r\n                    let M = new Monom();\r\n                    M.coefficient = new Fraction(N)\r\n                    M.literal = L\r\n                    monomDividers.push(M)\r\n                }\r\n            }\r\n        } else if (dividers.length === 0) {\r\n            for (let L of literals) {\r\n                let M = new Monom();\r\n                M.coefficient = new Fraction().one()\r\n                M.literal = L\r\n                monomDividers.push(M)\r\n            }\r\n        } else {\r\n            for (let N of dividers) {\r\n                let M = new Monom();\r\n                M.coefficient = new Fraction(N)\r\n                monomDividers.push(M)\r\n            }\r\n        }\r\n\r\n        return monomDividers.length === 0 ? [new Monom().one()] : monomDividers;\r\n    }\r\n\r\n    private _getLiteralDividers(arr: literalType[], letter: string): literalType[] {\r\n        let tmpList: { [key: string]: Fraction }[] = [];\r\n\r\n        // Be default, this.literal[letter] should be a rational number.\r\n        for (let d = 0; d <= this.literal[letter].value; d++) {\r\n            if (arr.length === 0) {\r\n                let litt: literalType = {}\r\n                litt[letter] = new Fraction(d)\r\n                tmpList.push(litt)\r\n            } else {\r\n                for (let item of arr) {\r\n                    let litt: literalType = {}\r\n                    for (let currentLetter in item) {\r\n                        litt[currentLetter] = item[currentLetter]\r\n                    }\r\n                    litt[letter] = new Fraction(d)\r\n                    tmpList.push(litt)\r\n                }\r\n            }\r\n        }\r\n        return tmpList;\r\n    }\r\n\r\n    /**\r\n     * Display the monom, forcing the '+' sign to appear\r\n     */\r\n    get displayWithSign(): string {\r\n        let d: String = this.display;\r\n        return (d[0] !== '-' ? '+' : '') + d;\r\n    }\r\n\r\n    get texWithSign(): string {\r\n        if (this.coefficient.isStrictlyPositive()) {\r\n            return '+' + this.tex\r\n        }\r\n\r\n        return this.tex\r\n    }\r\n\r\n    get plotFunction(): string {\r\n\r\n        let L: string = '',\r\n            letters = Object.keys(this._literal).sort()\r\n\r\n        for (let letter of letters) {\r\n            if (this._literal[letter].isNotZero()) {\r\n                L += (L===''?\"\":\"*\") + `${letter}`\r\n                if (this._literal[letter].isNotEqual(1)) {\r\n                    L += `^(${this._literal[letter].display})`;\r\n                }\r\n            }\r\n        }\r\n\r\n        // No literal part\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.display}`;\r\n            } else {\r\n                return '';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.display}*${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the tex output of the monom\r\n     */\r\n    get tex(): string {\r\n        // TODO: display with square root !\r\n        let L: string = '',\r\n            letters = Object.keys(this._literal).sort()\r\n\r\n        for (let letter of letters) {\r\n            if (this._literal[letter].isNotZero()) {\r\n                L += `${letter}`;\r\n                if (this._literal[letter].isNotEqual(1)) {\r\n                    L += `^{${this._literal[letter].tfrac}}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.frac}`;\r\n            } else {\r\n                return '0';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.frac}${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // -----------------------------------------\r\n    /**\r\n     * Parse a string to a monom. The string may include fraction.\r\n     * @param inputStr\r\n     */\r\n    parse = (inputStr: unknown): Monom => {\r\n\r\n        if (typeof inputStr === 'string') {\r\n            this._shutingYardToReducedMonom(inputStr)\r\n        } else if (typeof inputStr === 'number') {\r\n            this._coefficient = new Fraction(inputStr)\r\n            this._literal = {}\r\n        } else if (inputStr instanceof Fraction) {\r\n            this._coefficient = inputStr.clone()\r\n            this._literal = {}\r\n        } else if (inputStr instanceof Monom) {\r\n            this._coefficient = inputStr._coefficient.clone()\r\n            this._literal = this.copyLiterals(inputStr.literal)\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    addToken = (stack: Monom[], element: Token): void => {\r\n\r\n        let q1: Monom, q2: Monom, m: Monom, letter: string, pow: Fraction\r\n\r\n        if (element.tokenType === ShutingyardType.COEFFICIENT) {\r\n            stack.push(new Monom(new Fraction(element.token)))\r\n\r\n        } else if (element.tokenType === ShutingyardType.VARIABLE) {\r\n            let M = new Monom().one()\r\n            M.setLetter(element.token, 1)\r\n            stack.push(M.clone())\r\n\r\n        } else if (element.tokenType === ShutingyardType.OPERATION) {\r\n            switch (element.token) {\r\n                case '-':\r\n                    // this should only happen for negative powers or for negative coefficient.\r\n                    q2 = (stack.pop()) || new Monom().zero()\r\n                    q1 = (stack.pop()) || new Monom().zero()\r\n\r\n                    stack.push(q1.subtract(q2))\r\n\r\n                    break;\r\n                case '*':\r\n                    // Get the last element in the stack\r\n                    q2 = (stack.pop()) || new Monom().one()\r\n                    q1 = (stack.pop()) || new Monom().one()\r\n\r\n                    stack.push(q1.multiply(q2))\r\n                    break\r\n                case '/':\r\n                    // Get the last element in the stack\r\n                    q2 = (stack.pop()) || new Monom().one()\r\n                    q1 = (stack.pop()) || new Monom().one()\r\n\r\n                    stack.push(q1.divide(q2))\r\n                    break\r\n                case '^':\r\n                    // get the two last elements in the stack\r\n                    pow = (stack.pop().coefficient) || new Fraction().one()\r\n                    m = (stack.pop()) || new Monom().one()\r\n\r\n                    letter = m.variables[0]\r\n\r\n                    if (letter !== undefined) {\r\n                        m.setLetter(letter, pow)\r\n                    }\r\n\r\n                    stack.push(m)\r\n                    // this.multiply(m.clone())\r\n                    break\r\n            }\r\n        }\r\n    }\r\n    private _shutingYardToReducedMonom = (inputStr: string): Monom => {\r\n        // Get the RPN array of the current expression\r\n        const SY: Shutingyard = new Shutingyard().parse(inputStr);\r\n        const rpn: { token: string, tokenType: string }[] = SY.rpn;\r\n\r\n        let stack: Monom[] = [], m, pow, letter, q1, q2\r\n\r\n        if (rpn.length === 0) {\r\n            this.zero()\r\n            return this\r\n        } else if (rpn.length === 1) {\r\n            const element = rpn[0]\r\n\r\n            this.one()\r\n            if (element.tokenType === 'coefficient') {\r\n                this.coefficient = new Fraction(element.token)\r\n            } else if (element.tokenType === 'variable') {\r\n                this.setLetter(element.token, 1)\r\n            }\r\n            return this\r\n        } else {\r\n            // Reset the monom\r\n            for (const element of rpn) {\r\n                this.addToken(stack, element)\r\n            }\r\n        }\r\n\r\n        this.one()\r\n        this.multiply(stack[0])\r\n        return this\r\n    }\r\n    /**\r\n     * Clone the current Monom.\r\n     */\r\n    clone = (): Monom => {\r\n        let F: Monom = new Monom();\r\n\r\n        F.coefficient = this._coefficient.clone();\r\n\r\n        // Copy the literal parts.\r\n        for (let k in this._literal) {\r\n            F.setLetter(k, this._literal[k].clone());\r\n        }\r\n        return F;\r\n    };\r\n\r\n    copyLiterals = (literal: literalType): literalType => {\r\n        let L: literalType = {}\r\n\r\n        for (let k in literal) {\r\n            L[k] = literal[k].clone()\r\n        }\r\n        return L\r\n    }\r\n\r\n    makeSame = (M: Monom): Monom => {\r\n        // Copy the literal parts.\r\n        for (let k in M._literal) {\r\n            this.setLetter(k, M._literal[k].clone());\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Create a zero value monom\r\n     */\r\n    zero = (): Monom => {\r\n        this._coefficient = new Fraction().zero();\r\n        this._literal = {};\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Create a one value monom\r\n     */\r\n    one = (): Monom => {\r\n        this._coefficient = new Fraction().one();\r\n        this._literal = {};\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Clean the monom by removing each letters with a power of zero.\r\n     */\r\n    clean = (): Monom => {\r\n        for (let letter in this._literal) {\r\n            if (this._literal[letter].isZero()) {\r\n                delete this._literal[letter];\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    reduce = (): Monom => {\r\n        this.clean()\r\n        this.coefficient.reduce()\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Get the opposed\r\n     * Returns a monom.\r\n     */\r\n    opposed = (): Monom => {\r\n        this._coefficient.opposed();\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Add all similar monoms. If they aren't similar, they are simply skipped.\r\n     * @param M (Monom[]) The monoms to add.\r\n     */\r\n    add = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            if (this.isSameAs(m)) {\r\n                if (this.isZero()) {\r\n                    this.makeSame(m)\r\n                }\r\n                this._coefficient.add(m.coefficient);\r\n            } else {\r\n                console.log('Add monom: ' + this.display + ' is not similar with ', m.display);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Subtract multiple monoms\r\n     * @param M (Monom[]) The monoms to subtract\r\n     */\r\n    subtract = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            if (this.isSameAs(m)) {\r\n                if (this.isZero()) {\r\n                    this.makeSame(m)\r\n                }\r\n                this._coefficient.add(m.clone().coefficient.opposed());\r\n            } else {\r\n                console.log('Subtract: Is not similar: ', m.display);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Multiple multiple monoms to the current monom\r\n     * @param M (Monom[]) The monoms to multiply to.\r\n     */\r\n    multiply = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            // Multiply the coefficient.\r\n            this._coefficient.multiply(m.coefficient);\r\n\r\n            // Multiply the literal parts.\r\n            for (let letter in m.literal) {\r\n                if (this._literal[letter] === undefined) {\r\n                    this._literal[letter] = m.literal[letter].clone()\r\n                } else {\r\n                    this._literal[letter].add(m.literal[letter])\r\n                }\r\n\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    multiplyByNumber = (F: Fraction | number): Monom => {\r\n        this._coefficient.multiply(F);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Divide the current monoms by multiple monoms\r\n     * @param M (Monom[])\r\n     */\r\n    divide = (...M: Monom[]): Monom => {\r\n        // Depending on the given value, choose the current item\r\n        for (let v of M) {\r\n            // Divide the coefficient\r\n            this._coefficient.divide(v.coefficient);\r\n\r\n            // Subtract the power values\r\n            for (let letter in v.literal) {\r\n                this._literal[letter] = (this._literal[letter] === undefined) ? v.literal[letter].clone().opposed() : this._literal[letter].subtract(v.literal[letter])\r\n\r\n                // If the power of a particular setLetter is zero, delete it from the literal part..\r\n                if (this._literal[letter].isZero()) {\r\n                    delete this._literal[letter];\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Get the pow of a monom.\r\n     * @param nb (number) : Mathematical pow\r\n     */\r\n    pow = (nb: number|Fraction): Monom => {\r\n        this._coefficient.pow(nb);\r\n        for (let letter in this._literal) {\r\n            this._literal[letter].multiply(nb)\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Get the nth-root of the monom\r\n     * @param p\r\n     */\r\n    root = (p: number): Monom => {\r\n        // TODO: determiner the nth root of a monom\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Return the square root of a monom\r\n     */\r\n    sqrt = (): Monom => {\r\n        if (this.isSquare()) {\r\n            this._coefficient.sqrt();\r\n            for (let letter in this._literal) {\r\n                this._literal[letter].clone().divide(2)\r\n            }\r\n        }\r\n        return this.root(2);\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n    // ------------------------------------------\r\n    compare = (M: Monom, sign?: string): boolean => {\r\n        // TODO: Build the compare systems.\r\n        if (sign === undefined) {\r\n            sign = '=';\r\n        }\r\n\r\n\r\n        switch (sign) {\r\n            case '=':\r\n                // To be equal, they must be the isSame\r\n                if (!this.compare(M, 'same')) {\r\n                    return false;\r\n                }\r\n\r\n                // The literal parts are the isSame. The coefficient must be equal\r\n                return this._coefficient.isEqual(M.coefficient);\r\n            case 'same':\r\n                // Get the list of all variables from both monoms.\r\n                let M1: string[] = this.variables,\r\n                    M2: string[] = M.variables,\r\n                    K: string[] = M1.concat(M2.filter((item) => M1.indexOf(item) < 0));\r\n\r\n                if(M1.length===0 && M2.length===0){return true}\r\n                // To compare, both must be different than zero.\r\n                if (!this.isZero() && !M.isZero()) {\r\n                    for (let key of K) {\r\n                        // The setLetter is not available in one of the monom\r\n                        if (this._literal[key] === undefined || M.literal[key] === undefined) {\r\n                            return false;\r\n                        }\r\n                        // The setLetter does not have the isSame power in each monoms.\r\n                        if (!this._literal[key].isEqual(M.literal[key])) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // All are positive check - the monoms are the sames.\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is null\r\n     */\r\n    isZero(): boolean {\r\n        return this._coefficient.value === 0;\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is one\r\n     */\r\n    isOne(): boolean {\r\n        return this._coefficient.value === 1 && this.variables.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Determine if two monoms are equals\r\n     * @param M\r\n     */\r\n    isEqual = (M: Monom): boolean => {\r\n        return this.compare(M, '=');\r\n    };\r\n\r\n    /**\r\n     * Determine if two monoms are similar\r\n     * @param M\r\n     */\r\n    isSameAs = (M: Monom): boolean => {\r\n        return this.compare(M, 'same');\r\n    };\r\n\r\n    isSquare = (): boolean => {\r\n        if (!this.coefficient.isSquare()) {\r\n            return false;\r\n        }\r\n        return this.isLiteralSquare();\r\n    }\r\n\r\n    isLiteralSquare = (): boolean => {\r\n        for (let letter in this.literal) {\r\n            // A literal square must have a natural power\r\n            if (this.literal[letter].isRational()) {\r\n                return false\r\n            }\r\n\r\n            // The natural power must be be even\r\n            if (this.literal[letter].isEven()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    hasFractionCoefficient = (): boolean => {\r\n        for (let letter in this._literal) {\r\n            if (this._literal[letter].isRational()) {\r\n                return true\r\n            }\r\n        }\r\n\r\n        return false\r\n    }\r\n    // ------------------------------------------\r\n    // Misc monoms functions\r\n    // -------------------------------------\r\n    /**\r\n     * Determine if a monom contains a setLetter in it's literal part\r\n     * @param letter\r\n     */\r\n    hasLetter = (letter?: string): boolean => {\r\n        // The letter was not found\r\n        if (this._literal[letter === undefined ? 'x' : letter] === undefined) {\r\n            return false\r\n        }\r\n\r\n        // The letter is found and is not zero !\r\n        return this._literal[letter === undefined ? 'x' : letter].isNotZero();\r\n    };\r\n\r\n    /**\r\n     * Set the power of a particular setLetter\r\n     * @param letter (string) Letter to change\r\n     * @param pow (number) Power of the setLetter (must be positive integer.\r\n     */\r\n    setLetter = (letter: string, pow: Fraction | number): void => {\r\n        if (pow instanceof Fraction) {\r\n            // Set the power of the letter to zero => remove it\r\n            if (this.hasLetter(letter) && pow.isZero()) {\r\n                delete this._literal[letter]\r\n            }\r\n\r\n            this._literal[letter] = pow.clone()\r\n        } else {\r\n            this.setLetter(letter, new Fraction(pow))\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Get the degree of a monom. If no setLetter is given, the result will be the global degree.\r\n     * @param letter (string) Letter to get to degree (power)\r\n     */\r\n    degree = (letter?: string): Fraction => {\r\n        if (this.variables.length === 0) {\r\n            return new Fraction().zero();\r\n        }\r\n        if (letter === undefined) {\r\n            // Not setLetter given -> we get the global monom degree (sum of all the letters).\r\n            return Object.values(this._literal).reduce((t, n) => t.clone().add(n));\r\n        } else {\r\n            // A setLetter is given -> get the corresponding power.\r\n            return this._literal[letter] === undefined ? new Fraction().zero() : this._literal[letter].clone();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Evaluate a monom. Each setLetter must be assigned to a Fraction.\r\n     * @param values    Dictionary of <setLetter: Fraction>\r\n     */\r\n    evaluate = (values: literalType | Fraction | number): Fraction => {\r\n        let r = this.coefficient.clone();\r\n\r\n        if (typeof values === 'number' || values instanceof Fraction) {\r\n            let tmpValues: literalType = {}\r\n            tmpValues[this.variables[0]] = new Fraction(values)\r\n            return this.evaluate(tmpValues);\r\n        }\r\n\r\n        if (typeof values === 'object') {\r\n            if(this.variables.length===0){\r\n                return this.coefficient\r\n            }\r\n            for (let L in this._literal) {\r\n                if (values[L] === undefined) {\r\n                    return new Fraction().zero();\r\n                }\r\n\r\n                let value = new Fraction(values[L])\r\n\r\n                r.multiply(value.pow(this._literal[L]))\r\n            }\r\n        }\r\n\r\n        return r;\r\n    };\r\n\r\n    evaluateAsNumeric = (values: { [Key: string]: number } | number): number => {\r\n        let r = this.coefficient.value\r\n\r\n        if (typeof values === 'number') {\r\n            let tmpValues: { [Key: string]: number } = {}\r\n            tmpValues[this.variables[0]] = values\r\n            return this.evaluateAsNumeric(tmpValues);\r\n        }\r\n\r\n        if (typeof values === 'object') {\r\n            if (this.variables.length === 0) {\r\n                return this.coefficient.value\r\n            }\r\n            for (let L in this._literal) {\r\n                if (values[L] === undefined) {\r\n                    return 0;\r\n                }\r\n\r\n                r *= values[L] ** (this._literal[L].value)\r\n            }\r\n        }\r\n\r\n        return r\r\n    }\r\n\r\n    /**\r\n     * Derivative the monom\r\n     * @param letter\r\n     */\r\n    derivative = (letter?: string): Monom => {\r\n        // No setLetter given - assume it's the setLetter 'x'\r\n        if (letter === undefined) {\r\n            letter = 'x';\r\n        }\r\n\r\n        if (this.hasLetter(letter)) {\r\n            let d = this._literal[letter].clone(),\r\n                dM = this.clone();\r\n\r\n            // Subtract one to the degree.\r\n            dM._literal[letter].subtract(1)\r\n\r\n            // Multiply the coefficient by the previous degree\r\n            dM._coefficient.multiply(new Fraction(d.clone()));\r\n            return dM;\r\n        } else {\r\n            return new Monom().zero();\r\n        }\r\n    };\r\n\r\n    primitive = (letter?: string): Monom => {\r\n        // TODO: derivative including the ln value => implies creating different monom system ?\r\n        if (letter === undefined) {\r\n            letter = 'x'\r\n        }\r\n\r\n        // Zero monom\r\n        let M = this.clone(), degree\r\n\r\n        if (M.hasLetter(letter)) {\r\n            degree = M.degree(letter).clone().add(1)\r\n            M.coefficient = M.coefficient.clone().divide(degree)\r\n            M.setLetter(letter, degree)\r\n        } else {\r\n            // There is no letter.\r\n\r\n            // The coefficient might be zero (=> x) or a number a (=> ax)\r\n            if (M.coefficient.isZero()) {\r\n                M.coefficient = new Fraction().one()\r\n            }\r\n            M.setLetter(letter, 1)\r\n        }\r\n\r\n        return M\r\n    }\r\n    // ----------------------------------------\r\n    // Static functions\r\n    // ----------------------------------------\r\n\r\n    /**\r\n     * Get the least common multiple of monoms\r\n     * @param monoms    Array of monoms\r\n     */\r\n    static lcm = (...monoms: Monom[]): Monom => {\r\n        // All the monoms must be with natural powers...\r\n        for (let m of monoms) {\r\n            if (m.hasFractionCoefficient()) {\r\n                return new Monom().zero()\r\n            }\r\n        }\r\n\r\n\r\n        let M = new Monom(),\r\n            coeffN: number[] = monoms.map(value => value.coefficient.numerator),\r\n            coeffD: number[] = monoms.map(value => value.coefficient.denominator),\r\n            n = Numeric.gcd(...coeffN),\r\n            d = Numeric.lcm(...coeffD);\r\n\r\n        // Get the coefficient.\r\n        M.coefficient = new Fraction(n, d).reduce();\r\n\r\n        // Set the literal parts - go through each monoms literal parts and get only the lowest degree of each letters.\r\n        for (let m of monoms) {\r\n            // Remove the inexistant letters from the resulting monom\r\n            for (let letter in M.literal) {\r\n                if (!(letter in m.literal)) {\r\n                    M.literal[letter].zero();\r\n                }\r\n            }\r\n            for (let letter in m.literal) {\r\n                if (M.literal[letter] === undefined && m.literal[letter].isStrictlyPositive()) {\r\n                    M.literal[letter] = m.literal[letter].clone();\r\n                } else {\r\n                    M.literal[letter] = new Fraction(Math.min(m.literal[letter].value, M.literal[letter].value))\r\n                }\r\n            }\r\n        }\r\n\r\n        return M;\r\n    };\r\n\r\n    /**\r\n     * Multiply two monoms and return a NEW monom.\r\n     * @param monoms\r\n     */\r\n    static xmultiply = (...monoms: Monom[]): Monom => {\r\n        let M = new Monom().one();\r\n\r\n        for (let m of monoms) {\r\n            M.multiply(m);\r\n        }\r\n\r\n        return M;\r\n    };\r\n\r\n\r\n    // TODO: The rest of the functions are not used or unnecessary ?\r\n    /**\r\n     * Determine if multiple monoms are similar\r\n     * @param M\r\n     */\r\n    areSameAs = (...M: Monom[]): boolean => {\r\n        let result: boolean = true;\r\n\r\n        // Check all monoms if they are the isSame as the \"this\" one.\r\n        for (let i = 0; i < M.length; i++) {\r\n            if (!this.isSameAs(M[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // All check passed -> all the monoms are similar.\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Determine if multiple monoms are equals\r\n     * @param M\r\n     */\r\n    areEquals = (...M: Monom[]): boolean => {\r\n        // They are not similar.\r\n        if (!this.areSameAs(...M)) {\r\n            return false;\r\n        }\r\n\r\n        // Check all coefficient. They must be equals.\r\n        for (let m of M) {\r\n            if (!this._coefficient.isEqual(m.coefficient)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // All checks passed.\r\n        return true;\r\n    };\r\n\r\n    isDivisible = (div:Monom):boolean => {\r\n        // For all variables (letters), the current monom must have a degree higher than the divider\r\n        if(div.degree().isStrictlyPositive()) {\r\n            for (let letter of div.variables) {\r\n                if (!this.degree(letter).geq(div.degree(letter))) {\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n\r\n        // If the coefficient is rational, we suppose we don't need to check the division by the coefficient.\r\n        if(this.coefficient.isRational() || div.coefficient.isRational()){return true}\r\n\r\n        return this.coefficient.clone().divide(div.coefficient).isRelative()\r\n    }\r\n\r\n}\r\n","/**\r\n * Polynom module contains everything necessary to handle polynoms.*\r\n */\r\n\r\nimport {literalType, Monom} from './monom';\r\nimport {Shutingyard, ShutingyardType, Token} from '../shutingyard';\r\nimport {Numeric} from '../numeric';\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Equation, ISolution} from \"./equation\";\r\nimport {Random} from \"../randomization/random\";\r\nimport monom = Random.monom;\r\n\r\nexport type PolynomParsingType = string | Polynom | number | Fraction | Monom\r\n\r\nexport interface IEuclidian {\r\n    quotient: Polynom,\r\n    reminder: Polynom\r\n}\r\n\r\n/**\r\n * Polynom class can handle polynoms, reorder, resolve, ...\r\n * ```\r\n * let P = new Polynom('3x-4')\r\n * ```\r\n */\r\nexport class Polynom {\r\n    private _dirty_factors: boolean\r\n    private _dirty_zeroes: boolean\r\n    private _euclidianCache: { [Key: string]: IEuclidian }\r\n    private _factors: Polynom[];\r\n    private _monoms: Monom[];\r\n    private _rawString: string;\r\n    private _texString: string;\r\n    private _zeroes: ISolution[]\r\n\r\n    /**\r\n     *\r\n     * @param {string} polynomString (optional) Default polynom to parse on class creation\r\n     * @param values\r\n     */\r\n    constructor(polynomString?: PolynomParsingType, ...values: unknown[]) {\r\n        this._monoms = [];\r\n        this._factors = [];\r\n        this.mark_as_dirty()\r\n\r\n        if (polynomString !== undefined) {\r\n            this.parse(polynomString, ...values);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    get euclidianCache(): { [p: string]: IEuclidian } {\r\n        return this._euclidianCache;\r\n    }\r\n\r\n    set euclidianCache(value: { [p: string]: IEuclidian }) {\r\n        this._euclidianCache = value;\r\n    }\r\n\r\n    get dirty_zeroes(): boolean {\r\n        return this._dirty_zeroes;\r\n    }\r\n\r\n    set dirty_zeroes(value: boolean) {\r\n        this._dirty_zeroes = value;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    get dirty_factors(): boolean {\r\n        return this._dirty_factors;\r\n    }\r\n\r\n    set dirty_factors(value: boolean) {\r\n        this._dirty_factors = value;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    get monoms() {\r\n        return this._monoms;\r\n    }\r\n\r\n    set monoms(M: Monom[]) {\r\n        this._monoms = M;\r\n    }\r\n\r\n    get zeroes(): ISolution[] {\r\n        return this.getZeroes()\r\n    }\r\n\r\n    get factors(): Polynom[] {\r\n        return this.factorize()\r\n    }\r\n\r\n    set factors(value: Polynom[]) {\r\n        this.mark_as_dirty()\r\n        this._factors = value;\r\n    }\r\n\r\n    get texString(): string {\r\n        return this._texString;\r\n    }\r\n\r\n    get texFactors(): string {\r\n        this.factorize()\r\n\r\n        if (this.factors.length <= 1) {\r\n            return this.tex\r\n        }\r\n\r\n        // Build an array of texFactors with the number of similar items.\r\n        let factorsCount: { [Key: string]: { degree: number, factor: Polynom } } = {}\r\n        for (let f of this.factors) {\r\n            if (factorsCount[f.tex] !== undefined) {\r\n                factorsCount[f.tex].degree++\r\n            } else {\r\n                factorsCount[f.tex] = {\r\n                    degree: 1,\r\n                    factor: f\r\n                }\r\n            }\r\n        }\r\n\r\n        // First round to put the 'monom' first\r\n        let simpleFactor = new Polynom().one()\r\n\r\n        for (let item of Object.values(factorsCount).filter(item => item.factor.monoms.length === 1)) {\r\n            simpleFactor.multiply(item.factor)\r\n        }\r\n\r\n        let tex = simpleFactor.isOne() ? '' : simpleFactor.tex\r\n\r\n        // Loop through all factors that contains at least 2 monoms.\r\n        for (let item of Object.values(factorsCount).filter(item => item.factor.monoms.length > 1)) {\r\n            if (item.factor.length > 1) {\r\n                tex += `\\\\left( ${item.factor.tex} \\\\right)${item.degree > 1 ? '^{ ' + item.degree + ' }' : ''}`\r\n            }\r\n        }\r\n\r\n        return tex;\r\n    }\r\n\r\n    get displayFactors() {\r\n        this.factorize()\r\n\r\n        if (this.factors.length <= 1) {\r\n            return this.display\r\n        }\r\n\r\n        // Build an array of texFactors with the number of similar items.\r\n        let factorsCount: { [Key: string]: { degree: number, factor: Polynom } } = {}\r\n        for (let f of this.factors) {\r\n            if (factorsCount[f.display] !== undefined) {\r\n                factorsCount[f.display].degree++\r\n            } else {\r\n                factorsCount[f.display] = {\r\n                    degree: 1,\r\n                    factor: f\r\n                }\r\n            }\r\n        }\r\n\r\n        // First round to put the 'monom' first\r\n        let simpleFactor = new Polynom().one()\r\n\r\n        for (let item of Object.values(factorsCount).filter(item => item.factor.monoms.length === 1)) {\r\n            simpleFactor.multiply(item.factor)\r\n        }\r\n\r\n        let display = simpleFactor.isOne() ? '' : simpleFactor.display\r\n\r\n        // Loop through all factors that contains at least 2 monoms.\r\n        for (let item of Object.values(factorsCount).filter(item => item.factor.monoms.length > 1)) {\r\n            if (item.factor.length > 1) {\r\n                display += `(${item.factor.display})${item.degree > 1 ? '^(' + item.degree + ')' : ''}`\r\n            }\r\n        }\r\n\r\n        return display;\r\n    }\r\n\r\n    get length() {\r\n        // TODO: Must reduce the monoms list to remove the zero coefficient.\r\n        return this._monoms.length;\r\n    }\r\n\r\n    get display(): string {\r\n        return this.genDisplay();\r\n    }\r\n\r\n    get raw(): string {\r\n        return this._rawString\r\n    }\r\n\r\n    get tex(): string {\r\n        return this.genDisplay('tex');\r\n    }\r\n\r\n    get isMultiVariable(): boolean {\r\n        const B = false;\r\n        for (const m of this._monoms) {\r\n            if (m.variables.length > 1) {\r\n                return true;\r\n            }\r\n        }\r\n        return B;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        let V: string[] = [];\r\n\r\n        for (const m of this._monoms) {\r\n            V = V.concat(m.variables);\r\n        }\r\n\r\n        // Remove duplicates.\r\n        V = [...new Set(V)];\r\n        V.sort()\r\n        return V;\r\n    }\r\n\r\n    get numberOfVars(): number {\r\n        return this.variables.length;\r\n    }\r\n\r\n    get plotFunction(): string {\r\n        return this.genDisplay('tex', false, false, true)\r\n    }\r\n\r\n    mark_as_dirty = (): void => {\r\n        this.dirty_factors = true\r\n        this.dirty_zeroes = true\r\n        this.euclidianCache = {}\r\n    }\r\n\r\n    addToken = (stack: Polynom[], element: Token): void => {\r\n        switch (element.tokenType) {\r\n            case ShutingyardType.COEFFICIENT:\r\n                stack.push(new Polynom(element.token))\r\n                break\r\n\r\n            case ShutingyardType.VARIABLE:\r\n                stack.push(new Polynom().add(new Monom(element.token)))\r\n                break\r\n\r\n            case ShutingyardType.CONSTANT:\r\n                // TODO: add constant support to Polynom parsing.\r\n                console.log('Actually, not supported - will be added later !')\r\n                break\r\n\r\n            case ShutingyardType.OPERATION:\r\n                if (stack.length >= 2) {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop()\r\n\r\n                    if (element.token === '+') {\r\n                        stack.push(a.add(b))\r\n                    } else if (element.token === '-') {\r\n                        stack.push(a.subtract(b))\r\n                    } else if (element.token === '*') {\r\n                        stack.push(a.multiply(b))\r\n                    } else if (element.token === '/') {\r\n                        if (b.degree().isStrictlyPositive()) {\r\n                            console.log('divide by a polynom -> should create a rational polynom !')\r\n                        } else {\r\n                            stack.push(a.divide(b.monoms[0].coefficient))\r\n\r\n                        }\r\n                    } else if (element.token === '^') {\r\n                        if (b.degree().isStrictlyPositive()) {\r\n                            console.error('Cannot elevate a polynom with another polynom !', a.tex, b.tex)\r\n                        } else {\r\n                            if (b.monoms[0].coefficient.isRelative()) {\r\n                                // Integer power\r\n                                stack.push(a.pow(b.monoms[0].coefficient.value))\r\n                            } else {\r\n                                // Only allow power if the previous polynom is only a monom, without coefficient.\r\n                                if (a.monoms.length === 1 && a.monoms[0].coefficient.isOne()) {\r\n                                    for (let letter in a.monoms[0].literal) {\r\n                                        a.monoms[0].literal[letter].multiply(b.monoms[0].coefficient)\r\n                                    }\r\n                                    stack.push(a)\r\n                                } else {\r\n                                    console.error('Cannot have power with fraction')\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (element.token === '-') {\r\n                        stack.push(stack.pop().opposed())\r\n                    } else {\r\n                        throw \"Error parsing the polynom \" + this._rawString\r\n                    }\r\n                }\r\n                break\r\n\r\n            case ShutingyardType.MONOM:\r\n                // Should never appear.\r\n                console.error('The monom token should not appear here')\r\n                break;\r\n\r\n            case ShutingyardType.FUNCTION:\r\n                // Should never appear.\r\n                console.error('The function token should not appear here - might be introduced later.')\r\n                break;\r\n        }\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse a string to a polynom.\r\n     * @param inputStr\r\n     * @param values: as string, numbers or fractions\r\n     */\r\n    parse = (inputStr: PolynomParsingType, ...values: unknown[]): Polynom => {\r\n        // Reset the main variables.\r\n        this._monoms = []\r\n        this._factors = []\r\n        this.mark_as_dirty()\r\n\r\n        // TODO: allow to enter a liste of Fraction (a, b, c, ...) to make a polynom ax^n + bx^(n-1) + cx^(n-2) + ...\r\n        if (typeof inputStr === 'string') {\r\n            return this._parseString(inputStr, ...values)\r\n        } else if (\r\n            (typeof inputStr === 'number' || inputStr instanceof Fraction || inputStr instanceof Monom)\r\n            && (values === undefined || values.length === 0)\r\n        ) {\r\n            this._monoms.push(new Monom(inputStr))\r\n        } else if (inputStr instanceof Monom && values.length > 0) {\r\n            this._monoms.push(new Monom(inputStr))\r\n            values.forEach(m => {\r\n                this._monoms.push(new Monom(m))\r\n            })\r\n        } else if (inputStr instanceof Polynom) {\r\n            for (const m of inputStr.monoms) {\r\n                this._monoms.push(m.clone())\r\n            }\r\n        }\r\n\r\n        return this\r\n    };\r\n\r\n    /**\r\n     * Clone the polynom\r\n     */\r\n    clone = (): Polynom => {\r\n        const P = new Polynom();\r\n        const M: Monom[] = [];\r\n\r\n        for (const m of this._monoms) {\r\n            M.push(m.clone());\r\n        }\r\n\r\n        P.monoms = M;\r\n\r\n        return P;\r\n    };\r\n\r\n    /**\r\n     * Set the polynom to zero.\r\n     * @returns {this}\r\n     */\r\n    zero = (): Polynom => {\r\n        this._monoms = [];\r\n        this._monoms.push(new Monom().zero());\r\n        this._rawString = '0';\r\n        this.mark_as_dirty()\r\n        return this;\r\n    };\r\n\r\n    one = (): Polynom => {\r\n        this._monoms = [];\r\n        this._monoms.push(new Monom().one());\r\n        this._rawString = '1';\r\n        this.mark_as_dirty()\r\n        return this;\r\n    }\r\n\r\n    empty = (): Polynom => {\r\n        this._monoms = [];\r\n        this._rawString = '';\r\n        this.mark_as_dirty()\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    opposed = (): Polynom => {\r\n        this._monoms = this._monoms.map(m => m.opposed());\r\n        this.mark_as_dirty()\r\n        return this;\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n\r\n    add = (...values: unknown[]): Polynom => {\r\n        this.mark_as_dirty()\r\n\r\n        // @ts-ignore\r\n        for (let value of values) {\r\n            if (value instanceof Polynom) {\r\n                this._monoms = this._monoms.concat(value.monoms);\r\n            } else if (value instanceof Monom) {\r\n                this._monoms.push(value.clone());\r\n            } else if (Number.isSafeInteger(value)) {\r\n                this._monoms.push(new Monom(value.toString()));\r\n            } else {\r\n                this._monoms.push(new Monom(value));\r\n            }\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    subtract = (...values: unknown[]): Polynom => {\r\n        this.mark_as_dirty()\r\n\r\n        for (let value of values) {\r\n            if (value instanceof Polynom) {\r\n                this._monoms = this._monoms.concat(value.clone().opposed().monoms);\r\n            } else if (value instanceof Monom) {\r\n                this._monoms.push(value.clone().opposed());\r\n            } else if (Number.isSafeInteger(value)) {\r\n                this._monoms.push(new Monom(value.toString()).opposed());\r\n            } else {\r\n                this._monoms.push(new Monom(value).opposed());\r\n            }\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    multiply = (value: unknown): Polynom => {\r\n        this.mark_as_dirty()\r\n\r\n        if (value instanceof Polynom) {\r\n            return this.multiplyByPolynom(value);\r\n        } else if (value instanceof Fraction) {\r\n            return this.multiplyByFraction(value);\r\n        } else if (value instanceof Monom) {\r\n            return this.multiplyByMonom(value);\r\n        } else if (Number.isSafeInteger(value) && typeof value === 'number') {\r\n            return this.multiplyByInteger(value);\r\n        }\r\n\r\n        // Something went wrong...\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Divide the current polynom by another polynom.\r\n     * @param P\r\n     * returns {quotient: Polynom, reminder: Polynom}\r\n     */\r\n    euclidian = (P: Polynom): IEuclidian => {\r\n\r\n        if (this.euclidianCache[P.tex] !== undefined) {\r\n            return this.euclidianCache[P.tex]\r\n        }\r\n\r\n        const letter: string = P.variables[0];\r\n        const quotient: Polynom = new Polynom().zero();\r\n        const reminder: Polynom = this.clone().reorder(letter);\r\n\r\n        // There is no variable - means it's a number\r\n        if (P.variables.length === 0) {\r\n            let q = this.clone().divide(P)\r\n            return {\r\n                quotient: this.clone().divide(P),\r\n                reminder: new Polynom().zero()\r\n            }\r\n        }\r\n\r\n        // Get at least a letter\r\n\r\n        const maxMP: Monom = P.monomByDegree(undefined, letter);\r\n        const degreeP: Fraction = P.degree(letter);\r\n\r\n        let newM: Monom;\r\n\r\n        // Make the euclidian division of the two polynoms.\r\n        let MaxIteration = this.degree(letter).clone().multiply(2);\r\n        while (reminder.degree(letter).geq(degreeP) && MaxIteration.isPositive()) {\r\n            MaxIteration.subtract(1)\r\n\r\n            // Get the greatest monom divided by the max monom of the divider\r\n            newM = reminder.monomByDegree(undefined, letter).clone().divide(maxMP);\r\n\r\n            if (newM.isZero()) {\r\n                break;\r\n            }\r\n\r\n            // Get the new quotient and reminder.\r\n            quotient.add(newM);\r\n            reminder.subtract(P.clone().multiply(newM));\r\n        }\r\n\r\n        quotient.reduce()\r\n        reminder.reduce()\r\n        return {quotient, reminder};\r\n    };\r\n\r\n    divide = (value: unknown): Polynom => {\r\n        this.mark_as_dirty()\r\n\r\n        if (value instanceof Fraction) {\r\n            return this.divideByFraction(value);\r\n        } else if (typeof value === 'number' && Number.isSafeInteger(value)) {\r\n            return this.divideByInteger(value);\r\n        } else if (value instanceof Polynom) {\r\n            if (value.monoms.length === 1 && value.variables.length === 0) {\r\n                return this.divideByFraction(value.monoms[0].coefficient)\r\n            }\r\n        }\r\n    }\r\n\r\n    pow = (nb: number): Polynom => {\r\n        this.mark_as_dirty()\r\n\r\n        if (!Number.isSafeInteger(nb)) {\r\n            return this.zero();\r\n        }\r\n        if (nb < 0) {\r\n            return this.zero();\r\n        }\r\n        if (nb === 0) {\r\n            return new Polynom();\r\n        }\r\n\r\n        const P = this.clone();\r\n        for (let i = 1; i < nb; i++) {\r\n            this.multiply(P);\r\n        }\r\n        return this.reduce();\r\n    };\r\n\r\n    // ------------------------------------------\r\n    /**\r\n     * Compare the current coefficient with another coefficient\r\n     * @param P\r\n     * @param sign (string| default is =): authorized values: =, <, <=, >, >= with some variations.\r\n     */\r\n    compare = (P: Polynom, sign?: string): boolean => {\r\n        if (sign === undefined) {\r\n            sign = '='\r\n        }\r\n\r\n        // Create clone version to reduce them without altering the original polynoms.\r\n        const cP1 = this.clone().reduce().reorder();\r\n        const cP2 = P.clone().reduce().reorder();\r\n\r\n        switch (sign) {\r\n            case '=':\r\n                // They must have the isSame length and the isSame degree\r\n                if (cP1.length !== cP2.length || cP1.degree().isNotEqual(cP2.degree())) {\r\n                    return false;\r\n                }\r\n\r\n                // Check if the coefficients are the isSame.\r\n                for (const i in cP1.monoms) {\r\n                    if (!cP1.monoms[i].isEqual(cP2.monoms[i])) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            case 'same':\r\n                // They must have the isSame length and the isSame degree\r\n                if (cP1.length !== cP2.length || cP1.degree() !== cP2.degree()) {\r\n                    return false;\r\n                }\r\n\r\n                for (const i in cP1.monoms) {\r\n                    if (!cP1.monoms[i].isSameAs(cP2.monoms[i])) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n\r\n    isZero(): boolean {\r\n        return (this._monoms.length === 1 && this._monoms[0].coefficient.isZero()) || this._monoms.length === 0;\r\n    }\r\n\r\n    isOne(): boolean {\r\n        return this._monoms.length === 1 && this._monoms[0].coefficient.isOne();\r\n    }\r\n\r\n    isEqual = (P: Polynom): boolean => {\r\n        return this.compare(P, '=');\r\n    };\r\n\r\n    isSameAs = (P: Polynom): boolean => {\r\n        return this.compare(P, 'same');\r\n    };\r\n\r\n    isOpposedAt = (P: Polynom): boolean => {\r\n        return this.compare(P.clone().opposed(), '=');\r\n    };\r\n\r\n    isFactorized = (polynomString: string): boolean => {\r\n        let P;\r\n\r\n        // Check if polynom is complete...\r\n        if(polynomString.split('(').length!==polynomString.split(')').length){\r\n            return false\r\n        }\r\n\r\n        // Try to build the polynom\r\n        try {\r\n            P = new Polynom(polynomString);\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n\r\n        // Both polynom aren't the same (once developed and reduced => they cannot be equivalent)\r\n        if (!this.isEqual(P)) {\r\n            return false;\r\n        }\r\n\r\n        // Check if the provided (string) version is fully factorized.\r\n        // Run a regex on the string.\r\n        let polynomStringNormalized = polynomString.replaceAll('*', ''),\r\n            polynomStringReduced = '' + polynomStringNormalized,\r\n            factors: string[] = [];\r\n\r\n        for (let x of polynomStringNormalized.matchAll(/\\(([a-z0-9+\\-]+)\\)(\\^[0-9]*)?/g)) {\r\n            if (x[2] !== undefined) {\r\n                for (let i = 0; i < +x[2].substring(1); i++) {\r\n                    factors.push(x[1])\r\n                }\r\n            } else {\r\n                factors.push(x[1]);\r\n            }\r\n            polynomStringReduced = polynomStringReduced.replaceAll(x[0], '');\r\n        }\r\n        if (polynomStringReduced !== '') {\r\n            factors.push(polynomStringReduced);\r\n        }\r\n        let polyFactors = factors.map(x => new Polynom(x));\r\n\r\n        // Factorize the current polynom.\r\n        this.factorize();\r\n\r\n        // console.log('RESULT BEFORE COMPARE')\r\n        // console.log(polynomString, polynomStringNormalized)\r\n        // console.log(factors)\r\n        // console.log(this.factors.map(x=>x.display))\r\n\r\n        // Compare the given factors with the generated factors\r\n        let sign = 1;\r\n        for (let f of this.factors) {\r\n            if(f.degree().isZero()){\r\n                if(f.monoms[0].coefficient.isNegativeOne()){\r\n                    sign=-sign\r\n                }\r\n            }\r\n            for (let i = 0; i < polyFactors.length; i++) {\r\n                if (f.isEqual(polyFactors[i])) {\r\n                    polyFactors.splice(i, 1);\r\n                    break;\r\n                } else if (f.isOpposedAt(polyFactors[i])) {\r\n                    polyFactors.splice(i, 1);\r\n                    sign = -sign;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // The polyfactors must be empty and the cumulative opposite factors must be 1.\r\n        return (polyFactors.length === 0 && sign === 1);\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n\r\n    isReduced = (polynomString: string): Boolean => {\r\n        // The polynom must be developed to be reduced.\r\n        if(!this.isDeveloped(polynomString)){return false}\r\n\r\n        let P = new Polynom(polynomString)\r\n        if(P.monoms.length > this.monoms.length){return false}\r\n\r\n        // TODO: Not ur the reduced systme checking is working properly !\r\n        for(let m of P.monoms){\r\n            if(!m.coefficient.isReduced()){return false}\r\n        }\r\n\r\n        return false\r\n    }\r\n\r\n    isDeveloped = (polynomString: string): Boolean => {\r\n        let P: Polynom;\r\n\r\n        // There is at least one parenthese - it is not developed.\r\n        if(polynomString.split('(').length + polynomString.split(')').length > 0){\r\n            return false\r\n        }\r\n\r\n        // Try to build the polynom\r\n        try {\r\n            // Build the polynom\r\n            P = new Polynom(polynomString);\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n\r\n        // Both polynom aren't the same (once developed and reduced => they cannot be equivalent)\r\n        if (!this.isEqual(P)) {\r\n            return false;\r\n        }\r\n\r\n        // Check that everything is completely developed. Actually, there are no parentheses... so it is fully developed\r\n\r\n        // maybe it wasn't reduced and not ordered...\r\n        // compare polynom string.\r\n\r\n        // normalize the string\r\n        let polynomStringNormalized = polynomString.replaceAll('[*\\s]', '')\r\n\r\n        // Determine if it's the exact same string.\r\n        // TODO: Maybe it's enough to just make this test !\r\n        return polynomStringNormalized === P.reduce().reorder().display\r\n    }\r\n\r\n    // -------------------------------------\r\n    reduce = (): Polynom => {\r\n        // Reduce the polynom\r\n        let values = [...this._monoms],\r\n            vars = [...this.variables]\r\n\r\n        this._monoms = []\r\n\r\n        let coeffs = values.filter(x=>x.variables.length===0)\r\n\r\n        if(coeffs.length>0){\r\n            this._monoms.push(coeffs.reduce((a, b)=>a.add(b)))\r\n        }\r\n\r\n        // Build the new monoms\r\n        for(let letter of vars){\r\n            // Monom with same letters, but might be of different degrees\r\n            let M = values.filter(x=>x.hasLetter(letter))\r\n\r\n            while(M.length>0){\r\n                // Take the first element\r\n                const m = M.shift(), degree=m.degree(letter)\r\n\r\n                for(let a of M.filter(x=>x.degree(letter).isEqual(degree))){\r\n                    m.add(a)\r\n                }\r\n\r\n                this._monoms.push(m)\r\n\r\n                // Make the new array.\r\n                M = M.filter(x=>x.degree(letter).isNotEqual(degree))\r\n            }\r\n            // reduce the monom\r\n\r\n        }\r\n\r\n        // Remove all null monoms\r\n        this._monoms = this._monoms.filter((m) => {\r\n            return m.coefficient.value !== 0\r\n        });\r\n\r\n        // Reduce all monoms coefficient.\r\n        for (const m of this._monoms) {\r\n            m.coefficient.reduce();\r\n        }\r\n\r\n        if (this.length === 0) {\r\n            return new Polynom().zero();\r\n        }\r\n        return this.reorder();\r\n    };\r\n\r\n    reorder = (letter: string = 'x'): Polynom => {\r\n        // TODO: Must handle multiple setLetter reorder system\r\n        let otherLetters = this.variables.filter(x=>x!==letter)\r\n        this._monoms.sort(function (a, b) {\r\n            let da = a.degree(letter).value,\r\n                db = b.degree(letter).value\r\n\r\n            // Values are different\r\n            if(da!==db)return db-da\r\n\r\n            // if values are equals, check other letters.\r\n            if(otherLetters.length>0){\r\n                for(let L of otherLetters){\r\n                    let da = a.degree(L).value,\r\n                        db = b.degree(L).value\r\n\r\n                    // Values are different\r\n                    if(da!==db)return db-da\r\n                }\r\n            }\r\n\r\n            return 0\r\n            // return b.degree(letter).clone().subtract(a.degree(letter)).value\r\n        });\r\n\r\n        return this;\r\n    };\r\n\r\n    degree = (letter?: string): Fraction => {\r\n        let d: Fraction = new Fraction().zero();\r\n        for (const m of this._monoms) {\r\n            d = Fraction.max(m.degree(letter).value, d);\r\n        }\r\n        return d;\r\n    };\r\n\r\n    letters = (): string[] => {\r\n        let L: string[] = [], S = new Set();\r\n\r\n        for (let m of this._monoms) {\r\n            S = new Set([...S, ...m.variables]);\r\n        }\r\n\r\n        // @ts-ignore\r\n        return [...S];\r\n    }\r\n\r\n    /**\r\n     * Replace a variable (letter) by a polynom.\r\n     * @param letter\r\n     * @param P\r\n     */\r\n    replaceBy = (letter: string, P: Polynom): Polynom => {\r\n        this.mark_as_dirty()\r\n\r\n        let pow: Fraction;\r\n        const resultPolynom: Polynom = new Polynom().zero();\r\n\r\n        for (const m of this.monoms) {\r\n            if (m.literal[letter] === undefined || m.literal[letter].isZero()) {\r\n                resultPolynom.add(m.clone());\r\n            } else {\r\n                // We have found a setLetter.\r\n                // Get the power and reset it.\r\n                pow = m.literal[letter].clone();\r\n                delete m.literal[letter];\r\n\r\n                // TODO: replaceBy works only with positive and natural pow\r\n                resultPolynom.add(P.clone().pow(Math.abs(pow.numerator)).multiply(m));\r\n            }\r\n        }\r\n\r\n        this._monoms = resultPolynom.reduce().reorder().monoms;\r\n        return this;\r\n    };\r\n\r\n    // Evaluate a polynom.\r\n    evaluate = (values: literalType | Fraction | number): Fraction => {\r\n        const r = new Fraction().zero();\r\n\r\n        this._monoms.forEach(monom => {\r\n            //console.log('Evaluate polynom: ', monom.display, values, monom.evaluate(values).display);\r\n            r.add(monom.evaluate(values));\r\n        });\r\n\r\n        return r;\r\n    };\r\n\r\n    evaluateAsNumeric = (values: { [Key: string]: number } | number): number => {\r\n        let r = 0\r\n        this._monoms.forEach(monom => {\r\n            r += monom.evaluateAsNumeric(values)\r\n        })\r\n\r\n        return r\r\n    }\r\n\r\n    derivative = (letter?: string): Polynom => {\r\n        let dP = new Polynom();\r\n\r\n        for (let m of this._monoms) {\r\n            dP.add(m.derivative(letter));\r\n        }\r\n        return dP;\r\n    }\r\n    // ------------------------------------------\r\n    // Misc polynoms functions\r\n\r\n    primitive = (letter?: string): Polynom => {\r\n        let dP = new Polynom();\r\n\r\n        for (let m of this._monoms) {\r\n            dP.add(m.primitive(letter))\r\n        }\r\n        return dP\r\n    }\r\n\r\n    integrate = (a: Fraction | number, b: Fraction | number, letter?: string): Fraction => {\r\n        const primitive = this.primitive(letter)\r\n\r\n        if (letter === undefined) {\r\n            letter = 'x'\r\n        }\r\n\r\n        let valuesA: literalType = {},\r\n            valuesB: literalType = {}\r\n        valuesA[letter] = new Fraction(a);\r\n        valuesB[letter] = new Fraction(b);\r\n\r\n        return primitive.evaluate(valuesB).subtract(primitive.evaluate(valuesA))\r\n    }\r\n\r\n    // -------------------------------------\r\n    /**\r\n     * Factorize a polynom and store the best results in factors.\r\n     * @param maxValue Defines the greatest value to search to (default is 20).\r\n     */\r\n    factorize = (letter?: string): Polynom[] => {\r\n        if (!this.dirty_factors) {\r\n            return this._factors\r\n        }\r\n\r\n        let factors: Polynom[] = [];\r\n        let P = this.clone().reorder()\r\n\r\n        // Extract the common monom\r\n        // 2x^3+6x^2 => 2x^2\r\n        let M = P.commonMonom()\r\n        // If the polynom starts with a negative monom, factorize it.\r\n        if(P.monomByDegree().coefficient.isStrictlyNegative() && M.coefficient.isStrictlyPositive() && !M.isOne()){\r\n            M.opposed()\r\n        }\r\n\r\n        if (!M.isOne()) {\r\n            let tempPolynom: Polynom = new Polynom(M)\r\n            factors = [tempPolynom.clone()]\r\n            P = P.euclidian(tempPolynom).quotient;\r\n        }\r\n\r\n        // Main loop\r\n        let securityLoop = P.degree().clone().multiply(2).value,\r\n            maxDegree = 1\r\n        while (securityLoop >= 0) {\r\n            securityLoop--\r\n            if (P.monoms.length < 2) {\r\n                // The polynom has only one monom => 7x^2\r\n                // No need to continue.\r\n                if (!P.isOne()) {\r\n                    factors.push(P.clone())\r\n                    P.one()\r\n                }\r\n                break\r\n            } else if (P.degree(letter).isOne()) {\r\n                // The polynom is a first degree polynom => 3x-5\r\n                // No need to continue\r\n                factors.push(P.clone())\r\n                P.one()\r\n                break\r\n            } else {\r\n                // Create the list of all \"potential\" polynom dividers.\r\n                let allDividers: Polynom[] = this._getAllPotentialFactors(P, maxDegree, letter)\r\n                maxDegree = P.degree(letter).value\r\n\r\n                // Actually: 100ms\r\n                while (allDividers.length > 0) {\r\n                    let div = allDividers[0]\r\n\r\n                    if (!P.isDividableBy(div)) {\r\n                        // Not dividable. Remove it from the list\r\n                        allDividers.shift()\r\n                    } else {\r\n                        // It's dividable - so make the division\r\n                        let result = P.euclidian(div)\r\n\r\n                        // Add the factor\r\n                        factors.push(div)\r\n\r\n                        // As it's dividable, get the quotient.\r\n                        P = result.quotient.clone()\r\n\r\n                        // filter all dividers that are no more suitable.\r\n                        allDividers = allDividers.filter(x => {\r\n                            let pX = P.monoms[0],\r\n                                pC = P.monoms[P.monoms.length - 1],\r\n                                dX = x.monoms[0],\r\n                                dC = x.monoms[x.monoms.length - 1]\r\n\r\n                            // Check last item (degree zero)\r\n                            if (!pC.isDivisible(dC)) {\r\n                                return false\r\n                            }\r\n\r\n                            // Check the first item (degree max)\r\n                            if (!pX.isDivisible(dX)) {\r\n                                return false\r\n                            }\r\n\r\n                            return true\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Maybe there is still something in the Polynom (not everything was possible to factorize)\r\n        if (!P.isOne()) {\r\n            factors.push(P.clone())\r\n        }\r\n\r\n        // Save the factors\r\n        this._factors = factors\r\n\r\n        // The factors list is no more dirty\r\n        this.dirty_factors = false\r\n\r\n        return this._factors;\r\n    }\r\n\r\n    isDividableBy = (div: Polynom): boolean => {\r\n        // Quick evaluation.\r\n        if (div.degree().isOne()) {\r\n            let zero = div.getZeroes()[0]\r\n\r\n            if (zero.exact instanceof Fraction) {\r\n                return this.evaluate(zero.exact).isZero()\r\n            } else {\r\n                return false\r\n            }\r\n        } else {\r\n            this.euclidianCache[div.tex] = this.euclidian(div)\r\n            return this.euclidianCache[div.tex].reminder.isZero()\r\n        }\r\n    }\r\n    // TODO: get zeroes for more than first degree and for more than natural degrees\r\n    getZeroes = (): ISolution[] => {\r\n        if (this.dirty_zeroes) {\r\n            let equ = new Equation(this.clone(), 0)\r\n            equ.solve()\r\n            this._zeroes = equ.solutions\r\n            this.dirty_zeroes = false\r\n        }\r\n\r\n        return this._zeroes\r\n    };\r\n\r\n    // TODO: analyse the next functions to determine if they are useful or not...\r\n    monomByDegree = (degree?: Fraction | number, letter?: string): Monom => {\r\n        if (degree === undefined) {\r\n            // return the highest degree monom.\r\n            return this.monomByDegree(this.degree(letter), letter);\r\n        }\r\n\r\n        // Reduce the polynom.\r\n        const M = this.clone().reduce();\r\n        for (const m of M._monoms) {\r\n            if (m.degree(letter).isEqual(degree)) {\r\n                return m.clone();\r\n            }\r\n        }\r\n\r\n        // Nothing was found - return the null monom.\r\n        return new Monom().zero();\r\n    };\r\n\r\n    monomsByDegree = (degree?: number | Fraction, letter?: string): Monom[] => {\r\n        if (degree === undefined) {\r\n            // return the highest degree monom.\r\n            return this.monomsByDegree(this.degree(letter));\r\n        }\r\n\r\n        // Reduce the polynom.\r\n        let Ms: Monom[] = [];\r\n\r\n        const M = this.clone().reduce();\r\n        for (const m of M._monoms) {\r\n            if (m.degree(letter) === degree) {\r\n                Ms.push(m.clone())\r\n            }\r\n        }\r\n\r\n        return Ms\r\n        // Nothing was found - retur\r\n    }\r\n\r\n    // Used in LinearSystem.tex\r\n    monomByLetter = (letter: string): Monom => {\r\n        const M = this.clone().reduce();\r\n        for (const m of M._monoms) {\r\n            if (m.hasLetter(letter)) {\r\n                return m.clone();\r\n            }\r\n        }\r\n\r\n        return new Monom().zero();\r\n    };\r\n\r\n    // Next functions are used for for commonMonom, which is used in the factorize method.\r\n    getDenominators = (): number[] => {\r\n        const denominators: number[] = [];\r\n        for (const m of this._monoms) {\r\n            denominators.push(m.coefficient.denominator);\r\n        }\r\n        return denominators;\r\n    };\r\n\r\n    getNumerators = (): number[] => {\r\n        const numerators: number[] = [];\r\n        for (const m of this._monoms) {\r\n            numerators.push(m.coefficient.numerator);\r\n        }\r\n        return numerators;\r\n    };\r\n\r\n    lcmDenominator = (): number => {\r\n        return Numeric.lcm(...this.getDenominators());\r\n    };\r\n    // ------------------------------------------\r\n    // Polynoms factorization functions\r\n\r\n    gcdDenominator = (): number => {\r\n        return Numeric.gcd(...this.getDenominators());\r\n    };\r\n\r\n    lcmNumerator = (): number => {\r\n        return Numeric.lcm(...this.getNumerators());\r\n    };\r\n\r\n    gcdNumerator = (): number => {\r\n        return Numeric.gcd(...this.getNumerators());\r\n    };\r\n    // ------------------------------------------\r\n    // Polynoms helpers functions\r\n    // -------------------------------------\r\n\r\n    commonMonom = (): Monom => {\r\n        let M = new Monom().one(), numerator: number, denominator: number, degree = this.degree();\r\n\r\n        numerator = this.gcdNumerator();\r\n        denominator = this.gcdDenominator();\r\n\r\n        M.coefficient = new Fraction(numerator, denominator);\r\n        for (let L of this.variables) {\r\n            // Initialize the setLetter with the max degree\r\n            M.setLetter(L, degree);\r\n            for (let m of this._monoms) {\r\n                M.setLetter(L, Fraction.min(m.degree(L), M.degree(L)));\r\n                if (M.degree(L).isZero()) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return M;\r\n    }\r\n\r\n    limitToInfinity = (letter?: string): Fraction => {\r\n        const M = this.monomByDegree(undefined, letter),\r\n            sign = M.coefficient.sign(),\r\n            degree = M.degree(letter)\r\n\r\n        if (degree.isStrictlyPositive()) {\r\n            return sign === 1 ? (new Fraction()).infinite() : (new Fraction()).infinite().opposed()\r\n        } else if (degree.isZero()) {\r\n            return M.coefficient\r\n        }\r\n\r\n        // Any other cases\r\n        return (new Fraction()).zero()\r\n    }\r\n    limitToNegativeInfinity = (letter?: string): Fraction => {\r\n        const M = this.monomByDegree(undefined, letter),\r\n            sign = M.coefficient.sign(),\r\n            degree = M.degree(letter)\r\n\r\n        if (degree.isStrictlyPositive()) {\r\n            return sign === -1 ? (new Fraction()).infinite() : (new Fraction()).infinite().opposed()\r\n        } else if (degree.isZero()) {\r\n            return M.coefficient\r\n        }\r\n\r\n        // Any other cases\r\n        return (new Fraction()).zero()\r\n    }\r\n\r\n    private _getAllPotentialFactors = (P: Polynom, maxDegree: number, letter: string): Polynom[] => {\r\n        let m1 = P.monoms[0].dividers,\r\n            m2 = P.monoms[P.monoms.length - 1].dividers\r\n\r\n        let allDividers: Polynom[] = []\r\n        m1.forEach(m1d => {\r\n            // Get only polynom that has a degree less than a specific value\r\n            if (m1d.degree(letter).leq(maxDegree)) {\r\n                m2.forEach(m2d => {\r\n                    if (m1d.degree(letter).isNotEqual(m2d.degree(letter))) {\r\n                        allDividers.push(new Polynom(m1d, m2d))\r\n                        allDividers.push(new Polynom(m1d, m2d.clone().opposed()))\r\n                    }\r\n                })\r\n            }\r\n        })\r\n\r\n        return allDividers\r\n\r\n    }\r\n\r\n    private _parseString(inputStr: string, ...values: unknown[]): Polynom {\r\n        if (values === undefined || values.length === 0) {\r\n            inputStr = '' + inputStr;\r\n            this._rawString = inputStr.trim().replaceAll(' ','');\r\n\r\n            // Parse the polynom using the shutting yard algorithm\r\n            if (inputStr !== '' && !isNaN(Number(inputStr))) {\r\n                this.empty();\r\n                // It's a simple number.\r\n                let m = new Monom(inputStr);\r\n                // m.coefficient = new Fraction(inputStr);\r\n                // m.literalStr = '';\r\n                this.add(m);\r\n                return this;\r\n            }\r\n\r\n            // Parse the string.\r\n            return this.shutingYardToReducedPolynom(inputStr);\r\n        } else if (/^[a-z]/.test(inputStr)) {\r\n            // We assume the inputStr contains only letters.\r\n            this.empty();\r\n\r\n            let fractions = values.map(x => new Fraction(x));\r\n            // Multiple setLetter version\r\n            if (inputStr.length > 1) {\r\n                // TODO: check that the number of values given correspond to the letters (+1 eventually)\r\n                let letters = inputStr.split(''),\r\n                    i = 0;\r\n                for (let F of fractions) {\r\n                    let m = new Monom();\r\n                    m.coefficient = F.clone();\r\n                    m.literalStr = letters[i] || '';\r\n                    this.add(m);\r\n                    i++;\r\n                }\r\n            }\r\n            // Single setLetter version\r\n            else {\r\n                let n = fractions.length - 1;\r\n                for (let F of fractions) {\r\n                    let m = new Monom()\r\n                    m.coefficient = F.clone();\r\n                    m.literalStr = `${inputStr}^${n}`\r\n                    this.add(m);\r\n                    n--;\r\n                }\r\n            }\r\n            return this;\r\n        } else {\r\n            return this.zero();\r\n        }\r\n    }\r\n\r\n    private genDisplay = (output?: string, forceSign?: boolean, wrapParentheses?: boolean, withAllMultSign?: boolean): string => {\r\n        let P: string = '';\r\n\r\n        for (const k of this._monoms) {\r\n            if (k.coefficient.value === 0) {\r\n                continue;\r\n            }\r\n\r\n            // The monom to be displayed\r\n            let m\r\n            if (withAllMultSign) {\r\n                m = k.plotFunction\r\n            } else {\r\n                m = (output === 'tex') ? k.tex : k.display\r\n            }\r\n\r\n            P += `${(k.coefficient.sign() === 1 && (P !== '' || forceSign === true)) ? '+' : ''}${m}`;\r\n        }\r\n\r\n        if (wrapParentheses === true && this.length > 1) {\r\n            if (output === 'tex') {\r\n                P = `\\\\left( ${P} \\\\right)`;\r\n            } else {\r\n                P = `(${P})`;\r\n            }\r\n        }\r\n\r\n        if (P === '') {\r\n            P = '0';\r\n        }\r\n        return P;\r\n    };\r\n\r\n    /**\r\n     * Main parse using a shutting yard class\r\n     * @param inputStr\r\n     */\r\n    private shutingYardToReducedPolynom = (inputStr: string): Polynom => {\r\n        // Get the RPN array of the current expression\r\n        const SY: Shutingyard = new Shutingyard().parse(inputStr);\r\n        const rpn: { token: string, tokenType: string }[] = SY.rpn;\r\n\r\n        // New version for reducing shuting yard.\r\n        this.zero()\r\n\r\n        let stack: Polynom[] = [],\r\n            monom: Monom = new Monom()\r\n\r\n        // Loop through the\r\n        for (const element of rpn) {\r\n            this.addToken(stack, element);\r\n        }\r\n\r\n        if (stack.length === 1) {\r\n            this.add(stack[0])\r\n        }\r\n\r\n        return this.reorder()\r\n    }\r\n\r\n    private multiplyByPolynom = (P: Polynom): Polynom => {\r\n        const M: Monom[] = [];\r\n        for (const m1 of this._monoms) {\r\n            for (const m2 of P.monoms) {\r\n                M.push(Monom.xmultiply(m1, m2));\r\n            }\r\n        }\r\n\r\n        this._monoms = M;\r\n        return this.reduce();\r\n    };\r\n\r\n    private multiplyByFraction = (F: Fraction): Polynom => {\r\n        for (const m of this._monoms) {\r\n            m.coefficient.multiply(F);\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    private multiplyByInteger = (nb: number): Polynom => {\r\n        return this.multiplyByFraction(new Fraction(nb));\r\n    };\r\n\r\n    private multiplyByMonom = (M: Monom): Polynom => {\r\n        for (const m of this._monoms) {\r\n            m.multiply(M)\r\n        }\r\n        return this.reduce();\r\n    };\r\n\r\n    private divideByInteger = (nb: number): Polynom => {\r\n        const nbF = new Fraction(nb);\r\n        for (const m of this._monoms) {\r\n            m.coefficient.divide(nbF);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    private divideByFraction = (F: Fraction): Polynom => {\r\n        for (const m of this._monoms) {\r\n            m.coefficient.divide(F);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    private _factorize2ndDegree = (letter: string): Polynom[] => {\r\n        let P1: Polynom, P2: Polynom,\r\n            a, b, c, delta, x1, x2, factor;\r\n\r\n        // One variable only\r\n        if (this.numberOfVars === 1) {\r\n            a = this.monomByDegree(2, letter).coefficient;\r\n            b = this.monomByDegree(1, letter).coefficient;\r\n            c = this.monomByDegree(0, letter).coefficient;\r\n            delta = b.clone().pow(2).subtract(a.clone().multiply(c).multiply(4));\r\n\r\n            if (delta.isZero()) {\r\n                x1 = b.clone().opposed().divide(a.clone().multiply(2))\r\n                P1 = new Polynom(letter).subtract(x1.display).multiply(x1.denominator)\r\n                P2 = new Polynom(letter).subtract(x1.display).multiply(x1.denominator)\r\n                factor = a.divide(x1.denominator).divide(x1.denominator);\r\n\r\n                if (!factor.isOne()) {\r\n                    // TODO: Update new Polynom to accept anything...\r\n                    return [new Polynom(factor.display), P1, P2]\r\n                } else {\r\n                    return [P1, P2]\r\n                }\r\n            } else if (delta.isPositive() && delta.isSquare()) {\r\n                x1 = b.clone().opposed()\r\n                    .add(delta.clone().sqrt())\r\n                    .divide(a.clone().multiply(2))\r\n                x2 = b.clone().opposed()\r\n                    .subtract(delta.clone().sqrt())\r\n                    .divide(a.clone().multiply(2))\r\n\r\n                // (2x+5)(3x-2)\r\n                // 6x^2+11x-10\r\n                // a = 6, b = 11, c = -10\r\n                // delta = 121-4*6*(-10) = 361= 19^2\r\n                // x1 = (-11 + 19)  / 12 = 8/12 = 2/3\r\n                // x2 = (-11 - 19)  / 12 = -30/12 = -5/2\r\n                factor = a.divide(x1.denominator).divide(x2.denominator);\r\n                if (factor.isOne()) {\r\n                    return [\r\n                        new Polynom(letter).subtract(x1.display).multiply(x1.denominator),\r\n                        new Polynom(letter).subtract(x2.display).multiply(x2.denominator),\r\n                    ]\r\n                } else {\r\n                    return [\r\n                        new Polynom(factor.display),\r\n                        new Polynom(letter).subtract(x1.display).multiply(x1.denominator),\r\n                        new Polynom(letter).subtract(x2.display).multiply(x2.denominator),\r\n                    ]\r\n\r\n                }\r\n            } else {\r\n                // No solution possible - return the complete value.\r\n                return [this.clone()]\r\n            }\r\n        } else {\r\n            // If multiple variables, only handle perfect squares...\r\n            a = this.monomByDegree(2, letter);\r\n            b = this.monomByDegree(1, letter);\r\n            c = this.monomByDegree(0, letter);\r\n\r\n\r\n            if (a.isLiteralSquare() && c.isLiteralSquare()) {\r\n                // Check the middle item is same as...\r\n                if (b.clone().pow(2).isSameAs(a.clone().multiply(c))) {\r\n                    // Determine if the coefficient values matches.\r\n\r\n                    // Search 4 values (r, s, t, u) that matches:\r\n                    // (r X + s Y)(t X + u Y) = rt X^2 + (ru + st) XY + su Y^2\r\n\r\n                    let xPolynom = new Polynom('x', a.coefficient, b.coefficient, c.coefficient);\r\n                    let xFactors = xPolynom._factorize2ndDegree('x');\r\n\r\n                    let factors = [], xyzPolynom: Polynom;\r\n\r\n                    if (xFactors.length >= 2) {\r\n                        for (let p of xFactors) {\r\n                            if (p.degree().isZero()) {\r\n                                factors.push(p.clone())\r\n                            } else {\r\n                                xyzPolynom = p.clone();\r\n                                xyzPolynom.monoms[0].literal = a.literalSqrt\r\n                                xyzPolynom.monoms[1].literal = c.literalSqrt\r\n                                factors.push(xyzPolynom.clone())\r\n                            }\r\n                        }\r\n                        return factors\r\n                    }\r\n                }\r\n            }\r\n\r\n            return [this.clone()]\r\n        }\r\n    }\r\n\r\n    private _factorizeByGroups = (): Polynom[] => {\r\n        // TODO: Factorize by groups.\r\n        return [];\r\n    }\r\n}\r\n","/**\r\n * Rational polynom module contains everything necessary to handle rational polynoms.\r\n * @module Polynom\r\n */\r\n\r\nimport {IEuclidian, Polynom} from \"./polynom\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {literalType} from \"./monom\";\r\nimport {PARTICULAR_SOLUTION} from \"./equation\";\r\nimport {RationalStudy} from \"./study/rationalStudy\";\r\nimport {StudyConfig} from \"./study\";\r\n\r\n/**\r\n * Rational class can handle rational polynoms\r\n */\r\nexport class Rational {\r\n    private _denominator: Polynom;\r\n    private _numerator: Polynom;\r\n    private _rawString: string;\r\n\r\n    /**\r\n     *\r\n     * @param numerator\r\n     * @param denominator\r\n     */\r\n    constructor(numerator?: Polynom | string, denominator?: Polynom | string) {\r\n        if (numerator instanceof Polynom) {\r\n            this._numerator = numerator.clone()\r\n        } else if (typeof numerator === 'string') {\r\n            this._numerator = new Polynom(numerator)\r\n        } else {\r\n            this._numerator = new Polynom()\r\n        }\r\n\r\n        if (denominator instanceof Polynom) {\r\n            this._denominator = denominator.clone()\r\n        } else if (typeof denominator === 'string') {\r\n            this._denominator = new Polynom(denominator)\r\n        } else {\r\n            this._denominator = new Polynom()\r\n        }\r\n\r\n    }\r\n\r\n    get numerator(): Polynom {\r\n        return this._numerator\r\n    }\r\n\r\n    get denominator(): Polynom {\r\n        return this._denominator\r\n    }\r\n\r\n    get tex(): string {\r\n        return `\\\\frac{ ${this._numerator.tex} }{ ${this._denominator.tex} }`;\r\n    }\r\n\r\n    get texFactors(): string {\r\n        return `\\\\frac{ ${this._numerator.texFactors} }{ ${this._denominator.texFactors} }`\r\n    }\r\n\r\n    get plotFunction(): string {\r\n        return `(${this._numerator.plotFunction})/(${this._denominator.plotFunction})`\r\n    }\r\n\r\n    clone = (): Rational => {\r\n        return new Rational(\r\n            this._numerator.clone(),\r\n            this._denominator.clone()\r\n        )\r\n    }\r\n\r\n    domain = (): string => {\r\n        let zeroes = this._denominator.getZeroes();\r\n\r\n        if (zeroes.length === 0 || zeroes[0].tex === PARTICULAR_SOLUTION.real) {\r\n            return PARTICULAR_SOLUTION.varnothing\r\n        } else if (zeroes[0].tex === PARTICULAR_SOLUTION.varnothing) {\r\n            return PARTICULAR_SOLUTION.real\r\n        } else {\r\n            return '\\\\mathbb{R}\\\\setminus\\\\left\\\\{' +\r\n                zeroes.map(x => x.tex).join(';') + '\\\\right\\\\}'\r\n        }\r\n    }\r\n\r\n    amplify = (P: Polynom): Rational => {\r\n        this._numerator.multiply(P);\r\n        this._denominator.multiply(P);\r\n\r\n        return this;\r\n    }\r\n\r\n    derivative = (letter?: string): Rational => {\r\n        let N = this._numerator.clone(),\r\n            D = this._denominator.clone(),\r\n            dN = N.clone().derivative(letter),\r\n            dD = D.clone().derivative(letter)\r\n\r\n        this._numerator = dN.clone().multiply(D).subtract(N.clone().multiply(dD))\r\n        this._denominator = D.clone().pow(2)\r\n\r\n        return this\r\n    }\r\n\r\n    factorize = (letter?: string): Rational => {\r\n        this._numerator.factorize(letter)\r\n        this._denominator.factorize(letter)\r\n        return this\r\n    }\r\n\r\n    simplify = (P: Polynom): Rational => {\r\n        let NumeratorEuclidien = this._numerator.euclidian(P);\r\n        if (!NumeratorEuclidien.reminder.isZero()) {\r\n            return this;\r\n        }\r\n\r\n        let DenominatorEuclidien = this._denominator.euclidian(P);\r\n        if (!DenominatorEuclidien.reminder.isZero()) {\r\n            return this;\r\n        }\r\n\r\n        this._numerator = NumeratorEuclidien.quotient;\r\n        this._denominator = DenominatorEuclidien.quotient;\r\n        return this;\r\n    }\r\n\r\n    reduce = (): Rational => {\r\n        this._numerator.factorize();\r\n        for (let f of this._numerator.factors) {\r\n            this.simplify(f);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    opposed = (): Rational => {\r\n        this._numerator.opposed();\r\n        return this;\r\n    }\r\n\r\n    add = (R: Rational): Rational => {\r\n        // 1. Make sure both rational are at the same denominator\r\n        // 2. Add the numerators.\r\n        // 3. Simplify\r\n\r\n        // Store the adding denominator\r\n        let denominator = this._denominator.clone()\r\n\r\n        // Amplif the main rational polynom by the adding denominator\r\n        this.amplify(R._denominator)\r\n\r\n        // Add to the numerator the adding value...\r\n        this._numerator.add(R._numerator.clone().multiply(denominator));\r\n\r\n        return this;\r\n    }\r\n\r\n    subtract = (R: Rational): Rational => {\r\n        return this.add(R.clone().opposed())\r\n    }\r\n\r\n    euclidian = (): IEuclidian => {\r\n        return this._numerator.euclidian(this._denominator)\r\n    }\r\n\r\n    // TODO : where and how is used limits ?\r\n    limits = (value: Fraction | number, offset?: string, letter?: string): Fraction => {\r\n        if (value === Infinity || value === -Infinity) {\r\n            let {quotient, reminder} = this._numerator.clone().euclidian(this._denominator)\r\n\r\n            // quotient is positive => it will be infinite.\r\n            if (quotient.degree(letter).isStrictlyPositive()) {\r\n                return value === Infinity ? quotient.limitToInfinity(letter) : quotient.limitToNegativeInfinity(letter)\r\n                // return quotient.monomByDegree(undefined, letter).coefficient.sign()===1?(new Fraction()).infinite():(new Fraction()).infinite().opposed()\r\n            } else {\r\n                return quotient.monomByDegree(undefined, letter).coefficient\r\n            }\r\n        } else {\r\n            let evalValues: literalType = {},\r\n                evalValuesOffset: literalType = {},\r\n                theLimit: Fraction | number,\r\n                theSign: number,\r\n                FR = this.clone().reduce()\r\n\r\n            evalValues[letter === undefined ? 'x' : letter] = new Fraction(value)\r\n\r\n            if (offset !== 'above' && offset !== 'below') {\r\n                theLimit = FR._numerator.evaluate(evalValues)\r\n                    .divide(FR._denominator.evaluate(evalValues))\r\n\r\n                return theLimit.isInfinity() ? theLimit.abs() : theLimit\r\n            } else {\r\n                if (offset === 'above') {\r\n                    evalValuesOffset[letter === undefined ? 'x' : letter] = (new Fraction(value)).add(0.000001)\r\n                } else if (offset === 'below') {\r\n                    evalValuesOffset[letter === undefined ? 'x' : letter] = (new Fraction(value)).subtract(0.000001)\r\n                }\r\n\r\n                theLimit = FR._numerator.evaluate(evalValues)\r\n                    .divide(FR._denominator.evaluate(evalValues))\r\n                theSign = FR._numerator.evaluate(evalValuesOffset)\r\n                    .divide(FR._denominator.evaluate(evalValuesOffset)).sign()\r\n\r\n                if (theLimit.isInfinity()) {\r\n                    return theSign === 1 ? theLimit.abs() : theLimit.abs().opposed()\r\n                } else {\r\n                    return theLimit\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    evaluate = (values: literalType | Fraction | number): Fraction => {\r\n        const r = new Fraction().zero();\r\n\r\n        let N = this._numerator.evaluate(values),\r\n            D = this._denominator.evaluate(values)\r\n\r\n        return N.divide(D)\r\n    };\r\n\r\n    evaluateAsNumeric = (values: { [Key: string]: number } | number): number => {\r\n        return this._numerator.evaluateAsNumeric(values) / this._denominator.evaluateAsNumeric(values)\r\n    }\r\n\r\n    study = (config?:StudyConfig|string): RationalStudy => {\r\n        return new RationalStudy(this, config)\r\n    }\r\n}\r\n","/**\r\n * Rational polynom module contains everything necessary to handle rational polynoms.\r\n * @module Polynom\r\n */\r\n\r\nimport {Rational} from \"./rational\";\r\nimport {ISolution} from \"./equation\";\r\nimport {Polynom} from \"./polynom\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Point} from \"../geometry/point\";\r\nimport {NumExp} from \"../expressions/numexp\";\r\n\r\nexport type StudyableFunction = Rational\r\n\r\n\r\nexport enum ZEROTYPE {\r\n    ZERO = 'z',\r\n    DEFENCE = 'd',\r\n    NOTHING = 't'\r\n}\r\n\r\nexport interface IZero extends ISolution {\r\n    extrema: FUNCTION_EXTREMA,\r\n    type: ZEROTYPE\r\n}\r\n\r\nexport enum ASYMPTOTE {\r\n    VERTICAL = \"av\",\r\n    HORIZONTAL = \"ah\",\r\n    SLOPE = \"ao\",\r\n    HOLE = \"hole\"\r\n}\r\n\r\nexport enum ASYMPTOTE_POSITION {\r\n    \"LT\" = \"LT\",\r\n    \"RT\" = \"RT\",\r\n    \"LB\" = \"LB\",\r\n    \"RB\" = \"RB\"\r\n}\r\n\r\nexport interface IAsymptote {\r\n    deltaX: StudyableFunction\r\n    display: string,\r\n    fx: Polynom,\r\n    limits: string,\r\n    position: ASYMPTOTE_POSITION[]\r\n    tableOfSign: ITableOfSigns,\r\n    tex: string,\r\n    type: ASYMPTOTE,\r\n    zero: IZero,\r\n}\r\n\r\nexport enum FUNCTION_EXTREMA {\r\n    MIN = \"min\",\r\n    MAX = \"max\",\r\n    FLAT = \"flat\",\r\n    NOTHING = \"\"\r\n}\r\n\r\nexport interface IExtrema {\r\n    tex: {\r\n        x: string,\r\n        y: string\r\n    },\r\n    type: FUNCTION_EXTREMA,\r\n    value: {\r\n        x: number,\r\n        y: number\r\n    }\r\n\r\n}\r\n\r\nexport interface ITableOfSigns {\r\n    extremes: { [Key: string]: IExtrema },\r\n    factors: Polynom[],\r\n    fx: StudyableFunction,\r\n    signs: (string[])[],\r\n    tex: string\r\n    type: TABLE_OF_SIGNS\r\n    zeroes: IZero[],\r\n}\r\n\r\nexport enum TABLE_OF_SIGNS {\r\n    SIGNS = \"signs\",\r\n    GROWS = \"grows\",\r\n    VARIATIONS = \"variatins\"\r\n}\r\n\r\nexport interface StudyConfig {\r\n    asymptotes?: boolean,\r\n    derivative?: boolean,\r\n    domain?: boolean,\r\n    name?: string,\r\n    signs?: boolean,\r\n    variations?: boolean\r\n}\r\n\r\n/**\r\n * The study class is a \"function study\" class that will get:\r\n * fx               : get the function\r\n * domain           : string\r\n * zeroes           : Object (tex, IZero)\r\n * signs            : table of signs + tex output  using tkz-tab\r\n * av               : vertical asymptotic\r\n * ah               : horizontal asymptotic\r\n * ao               : obliques\r\n * deltaX           : position relative\r\n * dx               : derivative\r\n * grows            : growing table + tex output  using tkz-tab\r\n * ddx              : drive seconde\r\n * variations       : variation table + tex output  using tkz-tab\r\n */\r\nexport class Study {\r\n    fx: StudyableFunction\r\n    private _asymptotes: IAsymptote[]\r\n    private _derivative: ITableOfSigns\r\n    private _signs: ITableOfSigns\r\n    private _variations: ITableOfSigns\r\n    private _zeroes: IZero[]\r\n    private _config: StudyConfig\r\n    private _name: string\r\n\r\n    constructor(fx: StudyableFunction, config?: StudyConfig | string) {\r\n        this.fx = fx\r\n\r\n        this._config = {\r\n            name :'f',\r\n            domain :true,\r\n            asymptotes :true,\r\n            signs :true,\r\n            derivative :true,\r\n            variations :true,\r\n        }\r\n\r\n        if (config) {\r\n            if (typeof config === 'string') {\r\n                const d = config.split(',')\r\n                this._config = {}\r\n                let n = d.filter(x=>x.includes('(x)'))\r\n                if(n.length===1){\r\n                    this._config.name = n[0].split('(x)')[0]\r\n                }\r\n                this._config.domain = d.includes('d')\r\n                this._config.asymptotes = d.includes('a')\r\n                this._config.signs = d.includes('signs')\r\n                this._config.derivative = d.includes('dx')\r\n                this._config.variations = d.includes('ddx')\r\n            } else {\r\n                this._config = config\r\n            }\r\n        }\r\n\r\n        this._name = this._config?.name ?? 'f'\r\n\r\n        this.makeStudy()\r\n        return this\r\n    }\r\n\r\n    get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    set name(value: string) {\r\n        this._name = value;\r\n    }\r\n\r\n    get config(): StudyConfig {\r\n        return this._config;\r\n    }\r\n\r\n    set config(value: StudyConfig) {\r\n        this._config = value;\r\n    }\r\n\r\n    get zeroes(): IZero[] {\r\n        return this._zeroes;\r\n    }\r\n\r\n    get domain(): string {\r\n        return this.fx.domain()\r\n    }\r\n\r\n    get signs(): ITableOfSigns {\r\n        return this._signs;\r\n    }\r\n\r\n    get asymptotes(): IAsymptote[] {\r\n        return this._asymptotes;\r\n    }\r\n\r\n    get derivative(): ITableOfSigns {\r\n        return this._derivative;\r\n    }\r\n\r\n    get texSigns(): string {\r\n        return this._makeTexFromTableOfSigns(this._signs)\r\n    }\r\n\r\n    get texGrows(): string {\r\n        return this._makeTexFromTableOfSigns(this._derivative)\r\n    }\r\n\r\n    get texVariations(): string {\r\n        return this._makeTexFromTableOfSigns(this._variations)\r\n    }\r\n\r\n    makeStudy = (): void => {\r\n        this._zeroes = this.makeZeroes()\r\n\r\n        if (this._config.signs) this._signs = this.makeSigns()\r\n\r\n        if (this._config.asymptotes) this._asymptotes = this.makeAsymptotes()\r\n\r\n        if (this._config.derivative) this._derivative = this.makeDerivative()\r\n\r\n        if (this._config.variations) this._variations = this.makeVariation()\r\n\r\n        // Table of signs / derivative / variation\r\n        if (this._config.signs) this._signs.tex = this.texSigns\r\n\r\n        if (this._config.derivative) this._derivative.tex = this.texGrows\r\n\r\n        if (this._config.variations) this._variations.tex = this.texVariations\r\n    };\r\n\r\n    indexOfZero = (zeroes: IZero[], zero: IZero | ISolution): number => {\r\n        for (let i = 0; i < zeroes.length; i++) {\r\n            if (zeroes[i].tex === zero.tex) {\r\n                return i\r\n            }\r\n        }\r\n        return -1\r\n    };\r\n\r\n    makeOneLineForSigns = (factor: Polynom, zeroes: IZero[], zeroSign: ZEROTYPE): string[] => {\r\n        let oneLine: string[] = [],\r\n            currentZero = factor.getZeroes().map(x => x.tex)\r\n\r\n        // First +/- sign, before the first zero\r\n        oneLine.push('')\r\n        if (factor.degree().isZero()) {\r\n            oneLine.push(factor.monoms[0].coefficient.sign() === 1 ? '+' : '-')\r\n        } else {\r\n            oneLine.push(factor.evaluate(zeroes[0].value - 1).sign() === 1 ? '+' : '-')\r\n        }\r\n\r\n        for (let i = 0; i < zeroes.length; i++) {\r\n            // Add the zero if it's the current one\r\n            oneLine.push(currentZero.includes(zeroes[i].tex) ? zeroSign : ZEROTYPE.NOTHING)\r\n\r\n            // + / - sign after the current zero\r\n            if (i < zeroes.length - 1) {\r\n                oneLine.push(factor.evaluate((zeroes[i].value + zeroes[i + 1].value) / 2).sign() === 1 ? '+' : '-')\r\n            } else if (i === zeroes.length - 1) {\r\n                oneLine.push(factor.evaluate(zeroes[i].value + 1).sign() === 1 ? '+' : '-')\r\n            }\r\n\r\n        }\r\n        oneLine.push('')\r\n\r\n        return oneLine\r\n    }\r\n\r\n    makeSignsResult = (signs: (string[])[]): string[] => {\r\n\r\n        // Initialize the result line with the first line of the signs table\r\n        let resultLine: string[] = signs[0].map((x, index) => {\r\n            if (index === 0 || index === signs[0].length - 1) {\r\n                return ''\r\n            }\r\n\r\n            if (index % 2 === 0) {\r\n                return 't'\r\n            }\r\n\r\n            return '+'\r\n        })\r\n\r\n        // Go through each lines (except the first)\r\n        for (let current of signs) {\r\n\r\n            for (let i = 0; i < current.length; i++) {\r\n                if (i % 2 === 0) {\r\n                    // t, z or d\r\n                    if (resultLine[i] === 'd') {\r\n                        continue\r\n                    }\r\n                    if (current[i] !== 't') {\r\n                        resultLine[i] = current[i]\r\n                    }\r\n                } else {\r\n                    // + or -\r\n                    if (current[i] === '-') {\r\n                        resultLine[i] = resultLine[i] === '+' ? '-' : '+'\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return resultLine\r\n    }\r\n\r\n    makeGrowsResult = (tos: ITableOfSigns): { growsLine: string[], extremes: { [Key: string]: IExtrema } } => {\r\n\r\n        // Use the last line (=> resultLine) to grab the necessary information\r\n        let signsAsArray = Object.values(tos.signs),\r\n            resultLine = signsAsArray[signsAsArray.length - 1],\r\n            growsLine: string[] = [],\r\n            extremes: { [Key: string]: IExtrema } = {},\r\n            zeroes = tos.zeroes\r\n\r\n        // Get the extremes\r\n        for (let i = 0; i < zeroes.length; i++) {\r\n\r\n            // Get the corresponding item in the resultLine.\r\n            let pos = 2 * i + 2\r\n            if (resultLine[pos] === 'z') {\r\n\r\n                // It's a zero. Get the coordinates\r\n                let x: number, y: number, zero = zeroes[i].exact,\r\n                    pt: Point,\r\n                    xTex: string, yTex: string,\r\n                    pointType: FUNCTION_EXTREMA\r\n\r\n                // TODO: NumExp should parse something that isn't yet plotFunction\r\n                let exp = new NumExp(this.fx.plotFunction)\r\n\r\n                if (zero instanceof Fraction) {\r\n                    let value: Fraction = zero,\r\n                        evalY = this.fx.evaluate(value)\r\n\r\n                    x = zero.value\r\n                    y = evalY.value\r\n                    xTex = zero.tex\r\n                    yTex = evalY.tex\r\n                } else {\r\n                    x = zeroes[i].value\r\n                    y = exp.evaluate({x})\r\n\r\n                    xTex = x.toFixed(2)\r\n                    yTex = y.toFixed(2)\r\n                }\r\n\r\n                // Determine the type of the zero.\r\n                if (resultLine[pos - 1] === resultLine[pos + 1]) {\r\n                    pointType = FUNCTION_EXTREMA.FLAT\r\n                } else if (resultLine[pos - 1] === '+') {\r\n                    pointType = FUNCTION_EXTREMA.MAX\r\n                } else {\r\n                    pointType = FUNCTION_EXTREMA.MIN\r\n\r\n                }\r\n\r\n                // Add the point to the list\r\n                extremes[zeroes[i].tex] = {\r\n                    type: pointType,\r\n                    tex: {x: xTex, y: yTex},\r\n                    value: {x, y}\r\n                }\r\n            }\r\n        }\r\n\r\n        // Create the grows line, based on tkz-tab\r\n        // \\tkzTabLine{  ,  +  ,  z    ,  -  ,  d  ,  -  ,  z  ,  +  ,  }\r\n        // \\tkzTabVar{     -/  , +/$3$ ,       -D+/ , -/$1$  , +/  }\r\n        growsLine.push(resultLine[1] === '+' ? '-/' : '+/')\r\n        for (let i = 1; i < resultLine.length - 1; i++) {\r\n            if (resultLine[i] === \"z\") {\r\n                let extr = extremes[zeroes[(i - 2) / 2].tex]\r\n\r\n                growsLine.push(`${resultLine[i - 1]}/\\\\(${extr.type}(${extr.tex.x};${extr.tex.y})\\\\)`)\r\n            } else if (resultLine[i] === 'd') {\r\n                growsLine.push(`${resultLine[i - 1]}D${resultLine[i + 1] === '+' ? '-' : '+'}/`)\r\n            }\r\n        }\r\n        growsLine.push(`${resultLine[resultLine.length - 2]}/`)\r\n\r\n        return {growsLine, extremes}\r\n    }\r\n\r\n    makeVariationsResult = (tos: ITableOfSigns): { varsLine: string[], extremes: { [Key: string]: IExtrema } } => {\r\n        // TODO: make variations result is not yet implemented.\r\n        let extremes = {},\r\n            varsLine: string[] = []\r\n        return {varsLine, extremes}\r\n    }\r\n\r\n    makeZeroes(): IZero[] {\r\n        return []\r\n    };\r\n\r\n    makeSigns(): ITableOfSigns {\r\n        return {\r\n            type: TABLE_OF_SIGNS.SIGNS,\r\n            fx: null,\r\n            factors: [],\r\n            zeroes: [],\r\n            signs: [],\r\n            extremes: {},\r\n            tex: ''\r\n        }\r\n    };\r\n\r\n    makeAsymptotes(): IAsymptote[] {\r\n        return []\r\n    }\r\n\r\n    makeDerivative(): ITableOfSigns {\r\n        return {\r\n            type: TABLE_OF_SIGNS.GROWS,\r\n            fx: null,\r\n            factors: [],\r\n            zeroes: [],\r\n            signs: [],\r\n            extremes: {},\r\n            tex: ''\r\n        }\r\n    }\r\n\r\n    makeVariation(): ITableOfSigns {\r\n        return {\r\n            type: TABLE_OF_SIGNS.VARIATIONS,\r\n            fx: null,\r\n            factors: [],\r\n            zeroes: [],\r\n            signs: [],\r\n            extremes: {},\r\n            tex: ''\r\n        }\r\n    }\r\n\r\n    drawCode = (): string => {\r\n        // Function as string\r\n        let code = `f(x)=${this.fx.plotFunction}`\r\n\r\n        // Asymptotes\r\n        let i: number = 1\r\n        this.asymptotes.forEach(asymptote => {\r\n            if (asymptote.type === ASYMPTOTE.VERTICAL) {\r\n                code += `\\nav_${i}=line x=${asymptote.zero.value}->red,dash`\r\n                i++\r\n            } else if (asymptote.type === ASYMPTOTE.HORIZONTAL) {\r\n                code += `\\nah=line y=${asymptote.fx.monoms[0].coefficient.value}->orange,dash`\r\n            } else if (asymptote.type === ASYMPTOTE.SLOPE) {\r\n                code += `\\nao=line y=${asymptote.fx.plotFunction}->red,dash`\r\n            }\r\n            i++\r\n        })\r\n\r\n        // Extremes\r\n        for (let zero in this.derivative.extremes) {\r\n            let extreme = this.derivative.extremes[zero]\r\n\r\n            code += `\\nM_${i}(${extreme.value.x},${extreme.value.y})*`\r\n            i++\r\n        }\r\n\r\n        // Zeroes\r\n        this.zeroes.forEach(zero => {\r\n            if (zero.type === ZEROTYPE.ZERO) {\r\n                code += `\\nZ_${i}(${zero.value},0)*`\r\n                i++\r\n            }\r\n        })\r\n\r\n        return code\r\n    }\r\n\r\n    private _makeTexFromTableOfSigns = (tos: ITableOfSigns): string => {\r\n        let factors = tos.factors.map(x => `\\\\(${x.tex}\\\\)/1`),\r\n            factorsFx = `\\\\(${this._name}(x)\\\\)/1.2`,\r\n            zeroes = tos.zeroes\r\n\r\n        // Add the last lines \"label\"\r\n        if (tos.type === TABLE_OF_SIGNS.GROWS) {\r\n            factorsFx = `\\\\(${this._name}'(x)\\\\)/1.2,\\\\(f(x)\\\\)/2`\r\n        } else if (tos.type === TABLE_OF_SIGNS.VARIATIONS) {\r\n            factorsFx = `\\\\(${this._name}''(x)\\\\)/1.2,\\\\(f(x)\\\\)/2`\r\n        }\r\n\r\n        // Create the tikzPicture header\r\n        let tex = `\\\\begin{tikzpicture}\r\n\\\\tkzTabInit[lgt=3,espcl=2,deltacl=0]{/1.2,${factors.join(',')},/.1,${factorsFx} }{{\\\\scriptsize \\\\hspace{1cm} \\\\(-\\\\infty\\\\)},\\\\(${zeroes.map(x => x.tex).join('\\\\),\\\\(')}\\\\),{\\\\scriptsize \\\\hspace{-1cm} \\\\(+\\\\infty\\\\)}}`\r\n\r\n        let pos\r\n        for (pos = 0; pos < tos.factors.length; pos++) {\r\n            tex += (`\\n\\\\tkzTabLine{${tos.signs[pos].join(',')}}`)\r\n        }\r\n\r\n        // Add the result line\r\n        tex += (`\\n\\\\tkzTabLine{${tos.signs[pos].join(',')}}`)\r\n        // Add the grows / vars line\r\n        if (tos.type === TABLE_OF_SIGNS.GROWS) {\r\n            tex += (`\\n\\\\tkzTabVar{${tos.signs[pos + 1].join(',')}}`)\r\n        } else if (tos.type === TABLE_OF_SIGNS.VARIATIONS) {\r\n            // TODO: Check variations table for as tex\r\n            tex += (`\\n\\\\tkzTabVar{${tos.signs[pos + 1].join(',')}}`)\r\n        }\r\n\r\n        tex += `\\n\\\\end{tikzpicture}`\r\n\r\n        return tex\r\n    }\r\n}\r\n","/**\r\n * The study class is a \"function study\" class that will get:\r\n * fx               : get the function\r\n * domain           : string\r\n * zeroes           : Object (tex, IZero)\r\n * signs            : table of signs + tex output  using tkz-tab\r\n * av               : vertical asymptotic\r\n * ah               : horizontal asymptotic\r\n * ao               : obliques\r\n * deltaX           : position relative\r\n * dx               : derivative\r\n * grows            : growing table + tex output  using tkz-tab\r\n * ddx              : drive seconde\r\n * variations       : variation table + tex output  using tkz-tab\r\n */\r\nimport {\r\n    ASYMPTOTE,\r\n    ASYMPTOTE_POSITION,\r\n    FUNCTION_EXTREMA,\r\n    IAsymptote,\r\n    ITableOfSigns,\r\n    IZero,\r\n    Study,\r\n    StudyableFunction, StudyConfig,\r\n    TABLE_OF_SIGNS,\r\n    ZEROTYPE\r\n} from \"../study\";\r\nimport {Rational} from \"../rational\";\r\nimport {Fraction} from \"../../coefficients/fraction\";\r\nimport {Polynom} from \"../polynom\";\r\n\r\nexport class RationalStudy extends Study {\r\n    constructor(fx: StudyableFunction, config?: StudyConfig|string) {\r\n        super(fx, config)\r\n\r\n        return this\r\n    }\r\n\r\n    makeZeroes(): IZero[] {\r\n        return this._getZeroes(this.fx)\r\n    };\r\n\r\n    makeSigns(): ITableOfSigns {\r\n        return this._getSigns(this.fx, this.zeroes)\r\n    };\r\n\r\n    makeAsymptotes(): IAsymptote[] {\r\n        const reduced: Rational = this.fx.clone().reduce()\r\n\r\n        // Vertical\r\n        let asymptotes: IAsymptote[] = []\r\n        this.zeroes.filter(x => x.type === ZEROTYPE.DEFENCE).forEach(zero => {\r\n            // Check if it's a hole or an asymptote\r\n            let Ztype = ASYMPTOTE.VERTICAL,\r\n                tex = `x=${zero.tex}`,\r\n                display = `x=${zero.display}`\r\n\r\n            // Check if it's a hole: the reduced polynom should not be null\r\n            if (zero.exact instanceof Fraction) {\r\n                if (reduced.denominator.evaluate(zero.exact).isNotZero()) {\r\n                    Ztype = ASYMPTOTE.HOLE\r\n                    tex = `(${zero.tex};${reduced.evaluate(zero.exact).tex})`\r\n                    display = `(${zero.display};${reduced.evaluate(zero.exact).display})`\r\n                }\r\n            } else {\r\n                if (reduced.denominator.evaluate(zero.value).isNotZero()) {\r\n                    Ztype = ASYMPTOTE.HOLE\r\n                    tex = `(${zero.tex};${reduced.evaluate(zero.value).tex})`\r\n                    display = `(${zero.display};${reduced.evaluate(zero.value).display})`\r\n                }\r\n            }\r\n\r\n            // Get the position before and after the asymptote.\r\n            const delta = 0.000001\r\n            let before = this.fx.evaluateAsNumeric(zero.value - delta),\r\n                after = this.fx.evaluateAsNumeric(zero.value + delta),\r\n                position: ASYMPTOTE_POSITION[] = [],\r\n                pm = \"\"\r\n\r\n            if (after < -10000) {\r\n                position.push(ASYMPTOTE_POSITION.RB)\r\n                pm += \"m\"\r\n            } else if (after > 10000) {\r\n                position.push(ASYMPTOTE_POSITION.RT)\r\n                pm += \"p\"\r\n            }\r\n\r\n            if (before < -10000) {\r\n                position.push(ASYMPTOTE_POSITION.LB)\r\n                pm += \"m\"\r\n            } else if (before > 10000) {\r\n                position.push(ASYMPTOTE_POSITION.LT)\r\n                pm += \"p\"\r\n            }\r\n\r\n            // Left and right are to infinity\r\n            // TODO: handle the case were one side of the asymptote isn't infinity (not possible in rational study?!)\r\n            if (pm === \"pp\") {\r\n                pm = \"+\"\r\n            } else if (pm === \"mm\") {\r\n                pm = \"-\"\r\n            } else {\r\n                pm = `\\\\${pm}`\r\n            }\r\n\r\n            asymptotes.push({\r\n                fx: null,\r\n                type: Ztype,\r\n                tex,\r\n                display,\r\n                zero: zero,\r\n                limits: `\\\\lim_{x\\\\to${zero.tex} }\\\\ f(x) = ${pm}\\\\infty`,\r\n                deltaX: null,\r\n                tableOfSign: null,\r\n                position\r\n            })\r\n        })\r\n\r\n        // Sloped asymptote\r\n        let NDegree = this.fx.numerator.degree(),\r\n            DDegree = this.fx.denominator.degree()\r\n        if (NDegree.isEqual(DDegree)) {\r\n            let H = this.fx.numerator.monomByDegree().coefficient.clone().divide(this.fx.denominator.monomByDegree().coefficient),\r\n                Htex = H.tex\r\n\r\n            let {reminder} = reduced.euclidian(),\r\n                deltaX = new Rational(reminder, reduced.denominator)\r\n\r\n            // Determine the position above or below on the left / right of the asymptote.\r\n            asymptotes.push({\r\n                fx: new Polynom(H),\r\n                type: ASYMPTOTE.HORIZONTAL,\r\n                tex: `y=${Htex}`,\r\n                display: `y=${H.display}`,\r\n                zero: null,\r\n                limits: `\\\\lim_{x\\\\to\\\\infty}\\\\ f(x) = ${Htex}`,\r\n                deltaX,\r\n                tableOfSign: this._getSigns(deltaX),\r\n                position: this._getHorizontalAsymptoteRelativePositon(deltaX)\r\n            })\r\n        } else if (DDegree.greater(NDegree)) {\r\n            asymptotes.push({\r\n                fx: new Polynom('0'),\r\n                type: ASYMPTOTE.HORIZONTAL,\r\n                tex: `y=0`,\r\n                display: `y=0`,\r\n                zero: null,\r\n                limits: `\\\\lim_{x\\\\to\\\\infty}\\\\ f(x) = ${0}`,\r\n                deltaX: null,\r\n                tableOfSign: null,\r\n                position: this._getHorizontalAsymptoteRelativePositon(this.fx)\r\n            })\r\n        } else if (NDegree.value - 1 === DDegree.value) {\r\n            // Calculate the slope\r\n            let {quotient, reminder} = reduced.euclidian(),\r\n                deltaX = new Rational(reminder, reduced.denominator)\r\n\r\n            asymptotes.push({\r\n                fx: quotient.clone(),\r\n                type: ASYMPTOTE.SLOPE,\r\n                tex: `y=${quotient.tex}`,\r\n                display: `y=${quotient.display}`,\r\n                zero: null,\r\n                limits: ``,\r\n                deltaX: new Rational(reminder, reduced.denominator),\r\n                tableOfSign: this._getSigns(deltaX),\r\n                position: this._getHorizontalAsymptoteRelativePositon(deltaX)\r\n            })\r\n        }\r\n\r\n        return asymptotes\r\n    };\r\n\r\n    _getHorizontalAsymptoteRelativePositon(deltaX: Rational, delta: number = 1000000): ASYMPTOTE_POSITION[] {\r\n\r\n        let position: ASYMPTOTE_POSITION[] = [],\r\n            before = deltaX.evaluateAsNumeric(-delta),\r\n            after = deltaX.evaluateAsNumeric(delta)\r\n\r\n        if (before >= 0) {\r\n            position.push(ASYMPTOTE_POSITION.LT)\r\n        } else {\r\n            position.push(ASYMPTOTE_POSITION.LB)\r\n        }\r\n\r\n        if (after >= 0) {\r\n            position.push(ASYMPTOTE_POSITION.RT)\r\n        } else {\r\n            position.push(ASYMPTOTE_POSITION.RB)\r\n        }\r\n\r\n        return position\r\n    }\r\n\r\n    makeDerivative(): ITableOfSigns {\r\n        let dx = this.fx.clone().derivative(),\r\n            tos = this._getSigns(dx, this._getZeroes(dx), TABLE_OF_SIGNS.GROWS)\r\n\r\n        let result = this.makeGrowsResult(tos)\r\n        tos.signs.push(result.growsLine)\r\n        tos.extremes = result.extremes\r\n        return tos\r\n    };\r\n\r\n    makeVariation(): ITableOfSigns {\r\n        // Get the zeroes, make signs.\r\n        let dx = this.derivative.fx.clone().derivative(),\r\n            tos = this._getSigns(dx, this._getZeroes(dx), TABLE_OF_SIGNS.VARIATIONS)\r\n\r\n        let result = this.makeVariationsResult(tos)\r\n        tos.signs.push(result.varsLine)\r\n        tos.extremes = result.extremes\r\n        return tos\r\n    };\r\n\r\n    private _getZeroes(fx: StudyableFunction) {\r\n        // All zeroes.\r\n        let zeroes: IZero[] = []\r\n\r\n        fx.numerator.getZeroes().filter(x => !isNaN(x.value)).forEach(z => {\r\n            // add the item\r\n            zeroes.push({\r\n                tex: z.tex,\r\n                display: z.display,\r\n                value: z.value,\r\n                exact: z.exact,\r\n                extrema: FUNCTION_EXTREMA.NOTHING,\r\n                type: ZEROTYPE.ZERO\r\n            })\r\n        })\r\n\r\n        fx.denominator.getZeroes().filter(x => !isNaN(x.value)).forEach(z => {\r\n            let idx = this.indexOfZero(zeroes, z)\r\n\r\n            if (idx !== -1) {\r\n                zeroes[idx].type = ZEROTYPE.DEFENCE\r\n            } else {\r\n                // Add the item\r\n                zeroes.push({\r\n                    tex: z.tex,\r\n                    display: z.display,\r\n                    value: z.value,\r\n                    exact: z.exact,\r\n                    extrema: FUNCTION_EXTREMA.NOTHING,\r\n                    type: ZEROTYPE.DEFENCE\r\n                })\r\n            }\r\n        })\r\n\r\n        // sort all zeroes\r\n        zeroes.sort((a, b) => a.value - b.value)\r\n\r\n        return zeroes\r\n    }\r\n\r\n    private _getSigns(fx: Rational, zeroes?: IZero[], typeOfTable?: TABLE_OF_SIGNS): ITableOfSigns {\r\n        // Factorize the rational\r\n        let signs: (string[])[] = [],\r\n            factors: Polynom[] = []\r\n\r\n        if (zeroes === undefined) {\r\n            zeroes = this._getZeroes(fx)\r\n        }\r\n\r\n        fx.numerator.factors.forEach(factor => {\r\n            signs.push(this.makeOneLineForSigns(factor, zeroes, ZEROTYPE.ZERO))\r\n            factors.push(factor.clone())\r\n        })\r\n\r\n        fx.denominator.factors.forEach(factor => {\r\n            signs.push(this.makeOneLineForSigns(factor, zeroes, ZEROTYPE.DEFENCE))\r\n            factors.push(factor.clone())\r\n        })\r\n\r\n        signs.push(this.makeSignsResult(signs))\r\n\r\n        return {\r\n            type: typeOfTable,\r\n            fx,\r\n            factors,\r\n            zeroes,\r\n            signs,\r\n            extremes: {},\r\n            tex: ''\r\n        }\r\n    }\r\n}\r\n","import {Numeric} from \"../numeric\";\r\n\r\nexport type FractionParsingType = number | string | Fraction\r\n\r\n/**\r\n * The fraction class make possible to handle\r\n * TODO: Write the documentation correctly.\r\n * \\\\(\\frac{a}{b}\\\\) or \\\\[\\frac{a}{b}\\\\]  values.\r\n */\r\nexport class Fraction {\r\n    private _denominator: number;\r\n    private _numerator: number;\r\n\r\n    constructor(value?: unknown, denominatorOrPeriodic?: number) {\r\n        this._numerator = 1;\r\n        this._denominator = 1;\r\n\r\n        if (value !== undefined) {\r\n            this.parse(value, denominatorOrPeriodic);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n\r\n    get numerator(): number {\r\n        return this._numerator;\r\n    }\r\n\r\n    set numerator(value: number) {\r\n        this._numerator = value;\r\n    }\r\n\r\n    get denominator(): number {\r\n        return this._denominator;\r\n    }\r\n\r\n    set denominator(value: number) {\r\n        this._denominator = value;\r\n    }\r\n\r\n    get value(): number {\r\n        return this._numerator / this._denominator;\r\n    }\r\n\r\n    // Display getter\r\n    get tex(): string {\r\n        if (this.isInfinity()) {\r\n            return `${this.sign() === 1 ? '+' : '-'}\\\\infty`\r\n        }\r\n\r\n        if (this.isExact()) {\r\n            if (this._denominator === 1) {\r\n                return `${this._numerator}`;\r\n            } else if (this._numerator < 0) {\r\n                return `-\\\\frac{ ${-this._numerator} }{ ${this._denominator} }`;\r\n            } else {\r\n                return `\\\\frac{ ${this._numerator} }{ ${this._denominator} }`;\r\n            }\r\n        } else {\r\n            return this.value.toFixed(3)\r\n        }\r\n    }\r\n\r\n    get texWithSign():string {\r\n        return this.isPositive() ? `+${this.tex}` : this.tex;\r\n    }\r\n\r\n    get display(): string {\r\n        if (this.isExact()) {\r\n            if (this._denominator === 1) {\r\n                return `${this._numerator}`;\r\n            } else {\r\n                return `${this._numerator}/${this._denominator}`;\r\n            }\r\n        } else {\r\n            return this.value.toFixed(3)\r\n        }\r\n    }\r\n\r\n    // Helper function to display fractions\r\n    get frac(): string {\r\n        return this.tex;\r\n    }\r\n\r\n    get dfrac(): string {\r\n        return this.tex.replace('\\\\frac', '\\\\dfrac');\r\n    }\r\n\r\n    get tfrac(): string {\r\n        return this.tex.replace('\\\\frac', '\\\\tfrac')\r\n    }\r\n\r\n    static max = (...fractions: (Fraction | number)[]): Fraction => {\r\n        let M = new Fraction(fractions[0])\r\n\r\n        for (let m of fractions) {\r\n            let compare = new Fraction(m)\r\n            if (compare.greater(M)) {\r\n                M = compare.clone()\r\n            }\r\n        }\r\n\r\n        return M\r\n    }\r\n\r\n    static min = (...fractions: (Fraction | number)[]): Fraction => {\r\n        let M = new Fraction(fractions[0])\r\n\r\n        for (let m of fractions) {\r\n            let compare = new Fraction(m)\r\n            if (compare.lesser(M)) {\r\n                M = compare.clone()\r\n            }\r\n        }\r\n\r\n        return M\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n\r\n    static average = (...fractions: (Fraction | number)[]): Fraction => {\r\n        let M = new Fraction().zero()\r\n\r\n        for (let f of fractions) {\r\n            M.add(f)\r\n        }\r\n\r\n        M.divide(fractions.length)\r\n\r\n        return M\r\n    }\r\n\r\n    static unique = (fractions: Fraction[], sorted?: boolean): Fraction[] => {\r\n        // TODO: make sure it's wokring -> test !\r\n        let unique: { [Key: string]: boolean } = {},\r\n            distinct: Fraction[] = []\r\n        fractions.forEach(x => {\r\n            if (!unique[x.clone().reduce().tex]) {\r\n                distinct.push(x.clone())\r\n                unique[x.tex] = true\r\n            }\r\n        })\r\n\r\n        if (sorted) {\r\n            return Fraction.sort(distinct)\r\n        } else {\r\n            return distinct\r\n        }\r\n    }\r\n\r\n    static sort = (fractions: Fraction[], reverse?: boolean): Fraction[] => {\r\n        // Todo make sure it's the correct order, not reverse -> make a test\r\n        let sorted = fractions.sort((a, b) => a.value - b.value)\r\n\r\n        if (reverse) {\r\n            sorted.reverse()\r\n        }\r\n\r\n        return sorted\r\n    }\r\n\r\n    isApproximative = (): boolean => {\r\n        return this._numerator.toString().length >= 15 && this._denominator.toString().length >= 15\r\n    }\r\n\r\n    isExact = (): boolean => {\r\n        return !this.isApproximative()\r\n    }\r\n\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse the value to get the numerator and denominator\r\n     * @param value : number or string to parse to get the fraction\r\n     * @param denominatorOrPeriodic (optional|number) : length of the periodic part: 2.333333 => 1 or denominator value\r\n     */\r\n    parse = (value: unknown, denominatorOrPeriodic?: number): Fraction => {\r\n        let S: string[];\r\n\r\n        // A null value means a zero fraction.\r\n        if (value === null || value === \"\") {\r\n            this._numerator = 0;\r\n            this._denominator = 1;\r\n            return this;\r\n        }\r\n\r\n        switch (typeof value) {\r\n            case \"string\":\r\n                // Split the string value in two parts: Numerator/Denominator\r\n                S = value.split('/');\r\n\r\n                // Security checks\r\n                if (S.length > 2) throw value + \" has too many divide signs\";\r\n                if (S.map(x => x === '' || isNaN(Number(x))).includes(true)) throw value + \" is not a valid number\"\r\n\r\n                if (S.length === 1) {\r\n                    // No divide sign - it's a number\r\n                    return this.parse(+S[0]);\r\n                } else if (S.length === 2) {\r\n                    // One divide signe\r\n                    // We check if the denominator is zero\r\n                    if (S[1] === '0') {\r\n                        this._numerator = NaN;\r\n                        this._denominator = 1;\r\n                    } else {\r\n                        this._numerator = +S[0];\r\n                        this._denominator = +S[1];\r\n                    }\r\n                } else {\r\n                    // More than one divide sign ?\r\n                    // This is impossible\r\n                    this._numerator = NaN;\r\n                    this._denominator = 1;\r\n                }\r\n                break;\r\n            case \"number\":\r\n                if (Number.isSafeInteger(value)) {\r\n                    // The given value is an integer\r\n                    this._numerator = +value;\r\n\r\n                    if (denominatorOrPeriodic === undefined || !Number.isSafeInteger(denominatorOrPeriodic)) {\r\n                        this._denominator = 1;\r\n                    } else {\r\n                        this._denominator = +denominatorOrPeriodic;\r\n                    }\r\n                } else {\r\n                    // The given value is a float number\r\n                    // Get the number of decimals after the float sign\r\n                    let [unit, decimal] = (value.toString()).split('.')\r\n                    let p: number = decimal?decimal.length:0;\r\n\r\n                    // Detect if the decimal part is periodic or not...\r\n\r\n\r\n                    // Transform the float number in two integer\r\n                    if (denominatorOrPeriodic === undefined) {\r\n                        this._numerator = value * Math.pow(10, p);\r\n                        this._denominator = Math.pow(10, p);\r\n                    } else if (Number.isSafeInteger(denominatorOrPeriodic)) {\r\n                        this._numerator = value * Math.pow(10, p) - Math.floor(value * Math.pow(10, p - denominatorOrPeriodic));\r\n                        this.denominator = Math.pow(10, p) - Math.pow(10, p - denominatorOrPeriodic)\r\n                    }\r\n\r\n                    this.reduce()\r\n                }\r\n                break;\r\n            case \"object\":\r\n                if (value instanceof Fraction) {\r\n                    this._numerator = +value.numerator;\r\n                    this._denominator = +value.denominator;\r\n                }\r\n                break;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n\r\n    clone = (): Fraction => {\r\n        let F = new Fraction();\r\n        F.numerator = +this._numerator;\r\n        F.denominator = +this._denominator;\r\n        return F;\r\n    };\r\n\r\n    zero = (): Fraction => {\r\n        this._numerator = 0;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    one = (): Fraction => {\r\n        this._numerator = 1;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    infinite = (): Fraction => {\r\n        this._numerator = Infinity;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    invalid = (): Fraction => {\r\n        this._numerator = NaN;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    opposed = (): Fraction => {\r\n        this._numerator = -this._numerator;\r\n        return this;\r\n    };\r\n\r\n    add = (F: Fraction | number): Fraction => {\r\n        if (F instanceof Fraction) {\r\n            let N: number = this._numerator,\r\n                D: number = this._denominator;\r\n\r\n            this._numerator = N * F.denominator + F.numerator * D;\r\n            this._denominator = D * F.denominator;\r\n        } else {\r\n            return this.add(new Fraction(F))\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    subtract = (F: Fraction | number): Fraction => {\r\n        if (F instanceof Fraction) {\r\n            return this.add(F.clone().opposed());\r\n        } else {\r\n            return this.add(-F)\r\n        }\r\n    };\r\n\r\n    multiply = (F: Fraction | number): Fraction => {\r\n        // Parse the value.\r\n        // If it's a fraction, return a clone of it\r\n        // If it's an integer, return the fraction F/1\r\n        let Q = new Fraction(F);\r\n\r\n        this._numerator = this._numerator * Q.numerator;\r\n        this._denominator = this._denominator * Q.denominator;\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    xMultiply = (...values: (Fraction | number)[]): Fraction => {\r\n        // Parse the value.\r\n        // If it's a fraction, return a clone of it\r\n        // If it's an integer, return the fraction F/1\r\n        for(let value of values){\r\n            let F = new Fraction(value)\r\n            this._numerator = this._numerator * F.numerator;\r\n            this._denominator = this._denominator * F.denominator;\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    divide = (F: Fraction | number): Fraction => {\r\n        let Q = new Fraction(F);\r\n\r\n        if (Q.numerator === 0) {\r\n            return new Fraction().infinite();\r\n        }\r\n\r\n        let N: number = +this._numerator,\r\n            D: number = +this._denominator;\r\n\r\n        this._numerator = N * Q.denominator;\r\n        this._denominator = D * Q.numerator;\r\n        return this.reduce();\r\n    };\r\n\r\n    invert = (): Fraction => {\r\n        let n = +this._numerator, d = +this._denominator;\r\n        this._numerator = d;\r\n        this._denominator = n;\r\n\r\n        return this;\r\n    }\r\n\r\n    pow = (p: number | Fraction): Fraction => {\r\n        // TODO: Fraction.pow with a value different than a safe integer !\r\n        if (p instanceof Fraction) {\r\n            return this.pow(p.value)\r\n        }\r\n\r\n        this.reduce();\r\n        if (p < 0) {\r\n            this.invert()\r\n        }\r\n\r\n        // Check if numerator and denominator are roots of...\r\n        // othervise, convert to numeric.\r\n        let controlNumerator = Math.floor(Math.pow(this._numerator, Math.abs(p))),\r\n            controlDenominator = Math.floor(Math.pow(this._denominator, Math.abs(p)))\r\n\r\n        if (controlNumerator ** Math.abs(p) === this._numerator\r\n            &&\r\n            controlDenominator ** Math.abs(p) === this._denominator) {\r\n\r\n            this._numerator = this._numerator ** Math.abs(p);\r\n            this._denominator = this._denominator ** Math.abs(p);\r\n        } else {\r\n            this._numerator = this._numerator ** Math.abs(p);\r\n            this._denominator = this._denominator ** Math.abs(p);\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    root = (p: number): Fraction => {\r\n        // TODO: nth - root of a fraction => this will return another type of coefficient.\r\n\r\n        // Check if they are perfect roots..\r\n        if (p === 0) {\r\n            return this;\r\n        }\r\n\r\n        // If negative, invert the fraction\r\n        if (p < 0) {\r\n            this.invert()\r\n        }\r\n\r\n        let n = Math.pow(this._numerator, Math.abs(1 / p)),\r\n            d = Math.pow(this._denominator, Math.abs(1 / p));\r\n\r\n        this._numerator = Math.pow(this._numerator, Math.abs(1 / p));\r\n        this._denominator = Math.pow(this._denominator, Math.abs(1 / p));\r\n        return this;\r\n    }\r\n\r\n    sqrt = (): Fraction => {\r\n        return this.root(2);\r\n    }\r\n\r\n    abs = (): Fraction => {\r\n        this._numerator = Math.abs(this._numerator);\r\n        this._denominator = Math.abs(this._denominator);\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations specific to fractions\r\n\r\n    // ------------------------------------------\r\n    reduce = (): Fraction => {\r\n        let g = Numeric.gcd(this._numerator, this._denominator);\r\n        this._numerator = this._numerator / g;\r\n        this._denominator = this._denominator / g;\r\n\r\n        if (this._denominator < 0) {\r\n            this._denominator = -this._denominator;\r\n            this._numerator = -this._numerator;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    amplify = (k: number): Fraction => {\r\n        if (Number.isSafeInteger(k)) {\r\n            this._numerator *= k;\r\n            this._denominator *= k;\r\n        }\r\n        return this;\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Compare the current coefficient with another coefficient\r\n     * @param F (Coefficient) The coefficient to compare\r\n     * @param sign (string| default is =): authorized values: =, <, <=, >, >= with some variations.\r\n     */\r\n    compare = (F: unknown, sign?: string): boolean => {\r\n        if (sign === undefined) {\r\n            sign = '=';\r\n        }\r\n\r\n        let compareFraction: Fraction\r\n        if (F instanceof Fraction) {\r\n            compareFraction = F.clone()\r\n        } else {\r\n            compareFraction = new Fraction(F)\r\n        }\r\n\r\n        switch (sign) {\r\n            case '>':\r\n                return this.value > compareFraction.value;\r\n            case \">=\" || \"=>\" || \"geq\":\r\n                return this.value >= compareFraction.value;\r\n            case \"<\":\r\n                return this.value < compareFraction.value;\r\n            case \"<=\" || \"=>\" || \"leq\":\r\n                return this.value <= compareFraction.value;\r\n            case \"=\":\r\n                // let F2: Fraction = compareFraction.clone().reduce(),\r\n                //     F1: Fraction = this.clone().reduce();\r\n                // return (F1.numerator === F2.numerator && F1.denominator === F2.denominator);\r\n                return this.value === compareFraction.value;\r\n            case \"<>\":\r\n                return this.value !== compareFraction.value;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /* Compare shortcuts */\r\n    lesser = (than: Fraction | number): Boolean => {\r\n        return this.compare(than, '<');\r\n    };\r\n    leq = (than: Fraction | number): Boolean => {\r\n        return this.compare(than, '<=');\r\n    };\r\n    greater = (than: Fraction | number): Boolean => {\r\n        return this.compare(than, '>');\r\n    };\r\n    geq = (than: Fraction | number): Boolean => {\r\n        return this.compare(than, '>=');\r\n    };\r\n    isEqual = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '=');\r\n    }\r\n    isNotEqual = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '<>');\r\n    }\r\n    isOpposed = (p: Fraction): boolean => {\r\n        return this.isEqual(p.clone().opposed());\r\n    }\r\n    isInverted = (p: Fraction): boolean => {\r\n        return this.isEqual(new Fraction().one().divide(p.clone()));\r\n    }\r\n    isZero = (): boolean => {\r\n        return this._numerator === 0;\r\n    }\r\n    isNotZero = (): boolean => {\r\n        return this._numerator !== 0;\r\n    }\r\n    isOne = (): boolean => {\r\n        return this._numerator === 1 && this._denominator === 1;\r\n    }\r\n    isNegativeOne = (): boolean => {\r\n        return this._numerator === -1 && this._denominator === 1;\r\n    }\r\n    isPositive = (): boolean => {\r\n        return this.sign() === 1;\r\n    }\r\n    isNegative = (): boolean => {\r\n        return this.sign() === -1;\r\n    }\r\n    isStrictlyPositive = (): boolean => {\r\n        return this.value > 0\r\n    }\r\n    isStrictlyNegative = (): Boolean => {\r\n        return this.value < 0\r\n    }\r\n    isNaN = (): boolean => {\r\n        return isNaN(this._numerator);\r\n    }\r\n    isInfinity = (): boolean => {\r\n        return Math.abs(this._numerator) === Infinity;\r\n    }\r\n    isFinite = (): boolean => {\r\n        return !this.isInfinity() && !this.isNaN();\r\n    }\r\n    isSquare = (): boolean => {\r\n        return Math.sqrt(this._numerator) % 1 === 0 && Math.sqrt(this._denominator) % 1 === 0\r\n    }\r\n    isReduced = (): boolean => {\r\n        return Math.abs(Numeric.gcd(this._numerator, this._denominator)) === 1\r\n    }\r\n    isNatural = (): boolean => {\r\n        return this.isRelative() && this.isPositive()\r\n    }\r\n    isRelative = (): boolean => {\r\n        return this.clone().reduce().denominator === 1\r\n    }\r\n    isRational = (): boolean => {\r\n        return !this.isRelative()\r\n    }\r\n    isEven = (): boolean => {\r\n        return this.isRelative() && this.value % 2 === 0\r\n    }\r\n    isOdd = (): boolean => {\r\n        return this.isRelative() && this.value % 2 === 1\r\n    }\r\n    sign = (): number => {\r\n        return (this._numerator * this._denominator >= 0) ? 1 : -1;\r\n    };\r\n\r\n\r\n    // TODO: The rest of the functions are not used or unnecessary ?\r\n    /**\r\n     * Simple function to determine if it's a fraction\r\n     */\r\n    areEquals = (...F: Fraction[]): boolean => {\r\n        for (let i = 0; i < F.length; i++) {\r\n            if (!this.isEqual(F[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n}","/**\r\n * NthRoot is something like \"a+b\\sqrt{3}\r\n */\r\nexport class NthRoot {\r\n    private _radical: number;\r\n    private _nth: number;\r\n    private _coefficient: number;\r\n    private _isValid:boolean;\r\n\r\n    constructor(...values: number[]) {\r\n        this._radical = 1;\r\n        this._coefficient = 1;\r\n        this._nth = 2;\r\n        this._isValid = true;\r\n\r\n        if(values !== undefined){\r\n            this.parse(values[0], values[1], values[2])\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get radical(): number {\r\n        return this._radical;\r\n    }\r\n\r\n    set radical(value: number) {\r\n        this._radical = value;\r\n    }\r\n\r\n    get nth(): number {\r\n        return this._nth;\r\n    }\r\n\r\n    set nth(value: number) {\r\n        if (Number.isSafeInteger(value) && value >= 2) {\r\n            this._nth = value;\r\n        } else {\r\n            // Error setting the nth root.\r\n            console.log('Error setting the nth root');\r\n            this._nth = 2;\r\n        }\r\n    }\r\n\r\n    get coefficient(): number {\r\n        return this._coefficient;\r\n    }\r\n\r\n    set coefficient(value: number) {\r\n        this._coefficient = value;\r\n    }\r\n\r\n    get tex(): string {\r\n        let C: string;\r\n\r\n        if (this._coefficient === 1) {\r\n            C = '';\r\n        } else if (this._coefficient === -1) {\r\n            C = '-';\r\n        } else {\r\n            C = this._coefficient.toString();\r\n        }\r\n\r\n        if (this._radical === 1) {\r\n            return `${this._coefficient}`;\r\n        } else {\r\n            if (this._nth === 2) {\r\n                return `${C}\\\\sqrt{${this._radical}}`\r\n            } else {\r\n                return `${C}\\\\sqrt[${this._nth}]{${this._radical}}`\r\n            }\r\n        }\r\n    }\r\n\r\n    get display(): string {\r\n        let C: string;\r\n\r\n        if (this._coefficient === 1) {\r\n            C = '';\r\n        } else if (this._coefficient === -1) {\r\n            C = '-';\r\n        } else {\r\n            C = this._coefficient.toString();\r\n        }\r\n\r\n        if (this._radical === 1) {\r\n            return `${this._coefficient}`;\r\n        } else {\r\n            if (this._nth === 2) {\r\n                return `${C}sqrt{${this._radical}}`\r\n            } else {\r\n                return `${C}root(${this._nth}){${this._radical}}`\r\n            }\r\n        }\r\n    }\r\n\r\n    get value(): number {\r\n        return this._coefficient * Math.pow(this._radical, 1 / this._nth);\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (radical: number, nthroot?: number, coefficient?: number): NthRoot => {\r\n        this._coefficient = (coefficient === undefined) ? 1 : coefficient;\r\n        this._nth = (nthroot === undefined) ? 2 : nthroot;\r\n        this._radical = (radical === undefined) ? 1 : radical;\r\n\r\n        if(this._nth%2===0 && this._radical<0){\r\n            this._isValid = false;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    reduce = (): NthRoot => {\r\n        // Max value to test.\r\n        let V = Math.floor(Math.pow(this._radical, 1 / this._nth));\r\n        while (V > 1) {\r\n            if (this._radical % Math.pow(V, this._nth) === 0) {\r\n                // It's dividable by V^n\r\n                this._coefficient *= V;\r\n                this._radical = this._radical / Math.pow(V, this._nth);\r\n\r\n                // Redifine the new testing value (this is optimization)\r\n                V = Math.floor(Math.pow(this._radical, 1 / this._nth));\r\n                continue;\r\n            }\r\n            V--;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    multiply = (N: NthRoot): NthRoot => {\r\n        this._radical *= N.radical;\r\n        return this.reduce();\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Help functions\r\n    // ------------------------------------------\r\n    hasRadical = ():boolean => {\r\n        return !(this._radical===1 || this._radical===0 || this._isValid===false)\r\n    };\r\n}","import {Shutingyard, ShutingyardMode, ShutingyardType, tokenConstant} from \"../shutingyard\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\nexport class NumExp {\r\n    private _rpn: { token: string, tokenType: string }[]\r\n    private _expression: string\r\n    private _isValid: boolean\r\n\r\n    constructor(value: string, uniformize?:boolean) {\r\n        this._expression = value\r\n        this._rpn = new Shutingyard(ShutingyardMode.NUMERIC).parse(value).rpn\r\n    }\r\n\r\n    get rpn(): { token: string; tokenType: string }[] {\r\n        return this._rpn;\r\n    }\r\n\r\n    get isValid(): boolean {\r\n        if(this._isValid===undefined){\r\n            this.evaluate({x: 0})\r\n        }\r\n        return this._isValid\r\n    }\r\n\r\n    set isValid(value: boolean){\r\n        this._isValid = value\r\n    }\r\n\r\n    get expression(): string {\r\n        return this._expression;\r\n    }\r\n\r\n    private _extractDecimalPart(value: number): string {\r\n        let decimal = value.toString()\r\n\r\n        if (!decimal.includes('.')) {\r\n            return ''\r\n        }\r\n\r\n        decimal = decimal.split('.')[1]\r\n\r\n        return decimal.substring(0, decimal.length - 2)\r\n    }\r\n\r\n    private _numberCorrection(value: number): number {\r\n        // Must modify the number if it's like:\r\n        // a: 3.0000000000000003\r\n        // b: 3.9999999999999994\r\n        // remove the last character\r\n        // check if around n last characters are either 0 or 9\r\n        // if it is, 'round' the number.\r\n\r\n        const epsilon = 0.00000000000001,\r\n            number_of_digits = 6\r\n\r\n        const decimal = this._extractDecimalPart(value)\r\n        if(decimal===''){return value}\r\n\r\n        const n9 = decimal.match(/9+$/g)\r\n        const n0 = decimal.match(/0+$/g)\r\n\r\n        if (n9 && n9[0].length >= number_of_digits) {\r\n            // New tested values.\r\n            const mod = this._extractDecimalPart(value + epsilon),\r\n                mod0 = mod.match(/0+$/g)\r\n\r\n            if(mod0 && mod0[0].length>= number_of_digits){\r\n                // The value can be changed. Remove all zeros!\r\n                return +((value+epsilon).toString().split(mod0[0])[0])\r\n            }\r\n        }\r\n\r\n        if (n0 && n0[0].length >= number_of_digits) {\r\n            // New tested values.\r\n            const mod = this._extractDecimalPart(value - epsilon),\r\n                mod9 = mod.match(/9+$/g)\r\n\r\n            if(mod9 && mod9[0].length>= number_of_digits){\r\n                // The value can be changed. Remove all nines!\r\n                return +(value.toString().split(n0[0])[0])\r\n            }\r\n        }\r\n\r\n        return value\r\n    }\r\n\r\n    private _addToStack(stack:number[], value: number): void {\r\n        stack.push(this._numberCorrection(value))\r\n    }\r\n\r\n    evaluate(values: { [Key: string]: number }): number {\r\n        const stack: number[] = []\r\n\r\n        this.isValid = true\r\n\r\n        for (const element of this._rpn) {\r\n            if (element.tokenType === ShutingyardType.COEFFICIENT) {\r\n                // May be a numeric value or a Fraction.\r\n                if (!isNaN(+element.token)) {\r\n                    this._addToStack(stack, +element.token)\r\n                } else {\r\n                    this._addToStack(stack, new Fraction(element.token).value)\r\n                }\r\n            } else if (element.tokenType === ShutingyardType.VARIABLE) {\r\n                if (values[element.token] !== undefined) {\r\n                    this._addToStack(stack, +values[element.token])\r\n                }\r\n            } else if (element.tokenType === ShutingyardType.CONSTANT) {\r\n                this._addToStack(stack, tokenConstant[element.token])\r\n            } else if (element.tokenType === ShutingyardType.OPERATION) {\r\n                if (element.token === '*') {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop()\r\n                    if(a === undefined || b === undefined){this.isValid = false}\r\n                    this._addToStack(stack, a * b)\r\n                } else if (element.token === '/') {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop()\r\n                    if(a === undefined || b === undefined){this.isValid = false}\r\n                    this._addToStack(stack, a / b)\r\n                } else if (element.token === '+') {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop()\r\n                    if(a === undefined || b === undefined){this.isValid = false}\r\n                    this._addToStack(stack, (+a) + (+b))\r\n                } else if (element.token === '-') {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop() || 0\r\n                    if(b === undefined){this.isValid = false}\r\n                    this._addToStack(stack, a - b)\r\n                } else if (element.token === '^') {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop()\r\n                    if(a === undefined || b === undefined){this.isValid = false}\r\n                    this._addToStack(stack, Math.pow(a, b))\r\n                }\r\n            } else if (element.tokenType === ShutingyardType.FUNCTION) {\r\n                const a = stack.pop()\r\n                if(a === undefined){this.isValid = false}\r\n                if (element.token === 'sin') {\r\n                    this._addToStack(stack, Math.sin(a))\r\n                } else if (element.token === 'cos') {\r\n                    this._addToStack(stack, Math.cos(a))\r\n                } else if (element.token === 'tan') {\r\n                    this._addToStack(stack, Math.tan(a))\r\n                } else if(element.token === 'sqrt') {\r\n                    this._addToStack(stack, Math.sqrt(a))\r\n                }else if(element.token ==='nthrt') {\r\n                    // TODO: support nthrt in num. exp.\r\n                    let b = stack.pop()\r\n                    if(a%2===0 && b<0){\r\n                        this._addToStack(stack, NaN)\r\n                    }else {\r\n                        this._addToStack(stack, (b < 0 ? -1 : 1) * Math.pow(Math.abs(b), 1 / a))\r\n                    }\r\n                } else if(element.token === 'ln'){\r\n                    this._addToStack(stack, Math.log(a))\r\n                } else if(element.token === 'log') {\r\n                    this._addToStack(stack, Math.log10(a))\r\n                }\r\n            }\r\n        }\r\n\r\n        if (stack.length === 1) {\r\n            return stack[0]\r\n        } else {\r\n            throw `There was a problem parsing: ${this._expression}`\r\n        }\r\n    }\r\n}\r\n","import {Polynom, PolynomParsingType} from \"../algebra/polynom\";\r\nimport {Fraction, FractionParsingType} from \"../coefficients/fraction\";\r\n\r\ntype PolynomExpMathFunctionType = { name: string; fn: Function, tex: string }\r\n\r\nexport class PolynomExpFactor {\r\n    constructor(polynom: PolynomParsingType, degree?: FractionParsingType, mathFunction?: PolynomExpMathFunctionType) {\r\n        this._polynom = new Polynom(polynom)\r\n        this._degree = new Fraction(degree === undefined ? 1 : degree)\r\n        this._fn = mathFunction\r\n        this._powerAsInteger = true\r\n        this._forceParenthesis = true\r\n\r\n    }\r\n\r\n    private _forceParenthesis: boolean\r\n\r\n    get forceParenthesis(): boolean {\r\n        return this._forceParenthesis;\r\n    }\r\n\r\n    set forceParenthesis(value: boolean) {\r\n        this._forceParenthesis = value;\r\n    }\r\n\r\n    private _fn: PolynomExpMathFunctionType\r\n\r\n    get fn(): PolynomExpMathFunctionType {\r\n        return this._fn;\r\n    }\r\n\r\n    set fn(value: PolynomExpMathFunctionType) {\r\n        this._fn = value;\r\n    }\r\n\r\n    private _powerAsInteger: boolean\r\n\r\n    get powerAsInteger(): boolean {\r\n        return this._powerAsInteger;\r\n    }\r\n\r\n    set powerAsInteger(value: boolean) {\r\n        this._powerAsInteger = value;\r\n    }\r\n\r\n    private _polynom: Polynom\r\n\r\n    get polynom(): Polynom {\r\n        return this._polynom;\r\n    }\r\n\r\n    set polynom(value: Polynom) {\r\n        this._polynom = value;\r\n    }\r\n\r\n    private _degree: Fraction\r\n\r\n    get degree(): Fraction {\r\n        return this._degree;\r\n    }\r\n\r\n    set degree(value: Fraction) {\r\n        this._degree = value;\r\n    }\r\n\r\n    get tex(): string {\r\n        let tex\r\n\r\n        if (this._degree.isOne() && (this._fn !== undefined || !this._forceParenthesis)) {\r\n            // If degree is one, no need to add the parenthesis.\r\n            tex = this._polynom.tex\r\n        } else {\r\n            // the degree is not one, add the parenthesis.\r\n            if (this._powerAsInteger && !this._degree.isRelative()) {\r\n                // the degree is a fraction and we want natural powers => use sqrt.\r\n                tex = `\\\\sqrt${this._degree.denominator !== 2 ? `[ ${this._degree.denominator} ]` : ''}{ ${this._polynom.tex} }^{ ${this._degree.numerator} }`\r\n            } else if (this.isCoefficient && this.firstCoefficient.isNatural()) {\r\n                // the value is a natural number (eg 3, 7, ...)\r\n                tex = this._polynom.tex + this._texDegree\r\n            } else {\r\n                // In any other case, add the parenthesis by default\r\n                tex = `\\\\left( ${this._polynom.tex} \\\\right)${this._texDegree}`\r\n            }\r\n        }\r\n\r\n        if (this._fn !== undefined && this._fn.tex !== undefined) {\r\n            tex = `${this._fn.tex}\\\\left( ${tex} \\\\right)`\r\n        }\r\n        return tex\r\n    }\r\n\r\n    get isCoefficient(): boolean {\r\n        // TODO: Maybe reduce the coefficient if it isn't of degree one.\r\n        return this._polynom.degree().isZero();\r\n\r\n    }\r\n\r\n    get firstCoefficient(): Fraction {\r\n        return this._polynom.monomByDegree().coefficient\r\n    }\r\n\r\n    private get _texDegree(): string {\r\n        if (this._degree.isOne()) {\r\n            return ''\r\n        } else {\r\n            return `^{ ${this._degree.tfrac} }`\r\n        }\r\n    }\r\n\r\n    setForceParenthesis(value?: boolean): PolynomExpFactor {\r\n        this._forceParenthesis = value === undefined || value\r\n        return this\r\n    }\r\n\r\n    derivative(letter?: string): PolynomExpProduct {\r\n        if (this._degree.isOne()) {\r\n            return new PolynomExpProduct(\r\n                new PolynomExpFactor(this._polynom.clone().derivative(letter))\r\n            )\r\n        } else {\r\n            return new PolynomExpProduct(\r\n                new PolynomExpFactor(this._degree.clone()),\r\n                new PolynomExpFactor(this._polynom.clone().derivative(letter)),\r\n                new PolynomExpFactor(this._polynom.clone(), this._degree.clone().subtract(1))\r\n            )\r\n        }\r\n    }\r\n}\r\n\r\nexport class PolynomExpProduct {\r\n    constructor(...values: PolynomExpFactor[]) {\r\n        this._factors = values || []\r\n        this._positive = true\r\n        this._asPositiveDegree = true\r\n    }\r\n\r\n    private _fn: PolynomExpMathFunctionType\r\n\r\n    get fn(): PolynomExpMathFunctionType {\r\n        return this._fn;\r\n    }\r\n\r\n    set fn(value: PolynomExpMathFunctionType) {\r\n        this._fn = value;\r\n    }\r\n\r\n    private _factors: PolynomExpFactor[]\r\n\r\n    get factors(): PolynomExpFactor[] {\r\n        return this._factors;\r\n    }\r\n\r\n    set factors(value: PolynomExpFactor[]) {\r\n        this._factors = value;\r\n    }\r\n\r\n    private _positive: boolean\r\n\r\n    get positive(): boolean {\r\n        return this._positive;\r\n    }\r\n\r\n    set positive(value: boolean) {\r\n        this._positive = value;\r\n    }\r\n\r\n    private _asPositiveDegree: boolean\r\n\r\n    get asPositiveDegree(): boolean {\r\n        return this._asPositiveDegree;\r\n    }\r\n\r\n    set asPositiveDegree(value: boolean) {\r\n        this._asPositiveDegree = value;\r\n    }\r\n\r\n    get tex(): string {\r\n        let parenthesis = this._factors.length>1\r\n        // Default value\r\n        let tex = this._factors.map(factor => factor.setForceParenthesis(parenthesis).tex).join(' \\\\cdot ')\r\n\r\n        // Change the value in some cases...\r\n        if (this._asPositiveDegree) {\r\n            const numerators = this._factors.filter(x => x.degree.isPositive()),\r\n                denominators = this._factors.filter(x => x.degree.isNegative())\r\n\r\n            let numeratorsAsTex, denominatorsAsTex\r\n\r\n            if (denominators.length > 0) {\r\n                if (numerators.length === 0) {\r\n                    numeratorsAsTex = [1]\r\n                } else if (numerators.length === 1) {\r\n                    numeratorsAsTex = [numerators[0].setForceParenthesis(false).tex]\r\n                } else {\r\n                    parenthesis = numerators.length>1\r\n                    numeratorsAsTex = numerators.map(factor => factor.setForceParenthesis(parenthesis).tex)\r\n                }\r\n\r\n                // Change all denominators degrees to positive.\r\n                denominators.map(x => x.degree.opposed())\r\n                if (denominators.length === 1) {\r\n                    denominatorsAsTex = [denominators[0].setForceParenthesis(false).tex]\r\n                } else {\r\n                    parenthesis = denominators.length>1\r\n                    denominatorsAsTex = denominators.map(factor => factor.setForceParenthesis(parenthesis).tex)\r\n                }\r\n                // restore all degrees to negative again.\r\n                denominators.map(x => x.degree.opposed())\r\n\r\n                tex = `\\\\frac{ ${numeratorsAsTex.join(' \\\\cdot ')} }{ ${denominatorsAsTex.join(' \\\\cdot ')} }`\r\n            }\r\n        }\r\n\r\n        // Apply the modification\r\n        if (this._fn !== undefined && this._fn.name !== undefined && this._fn.name !== '') {\r\n            tex = `${this._fn.tex}\\\\left( ${tex} \\\\right)`\r\n        }\r\n        return tex\r\n    }\r\n\r\n    reduce(): PolynomExpProduct {\r\n        let coefficients = this._factors.filter(factor => factor.isCoefficient),\r\n            polynoms = this._factors.filter(factor => !factor.isCoefficient)\r\n\r\n        let result = new Fraction().one()\r\n\r\n        if (coefficients.length > 1) {\r\n            for (const factor of coefficients) {\r\n                if (factor.degree.isPositive()) {\r\n                    result.multiply(factor.polynom.monoms[0].coefficient.pow(factor.degree))\r\n                } else {\r\n                    result.divide(factor.polynom.monoms[0].coefficient.pow(factor.degree.clone().abs()))\r\n                }\r\n            }\r\n        } else if (coefficients.length === 1) {\r\n            result = coefficients[0].polynom.monoms[0].coefficient\r\n        }\r\n\r\n        if (result.isOne()) {\r\n            this._factors = [...polynoms]\r\n        } else if (!result.isRelative()) {\r\n            this._factors = [\r\n                new PolynomExpFactor(result.numerator),\r\n                new PolynomExpFactor(result.denominator, -1),\r\n                ...polynoms\r\n            ]\r\n        } else {\r\n            this._factors = [\r\n                new PolynomExpFactor(result),\r\n                ...polynoms\r\n            ]\r\n        }\r\n        return this\r\n    }\r\n\r\n    integrate(letter?: string): PolynomExpProduct {\r\n        // Handle this kind of case:\r\n        // A * f' * F^n\r\n        // A * f' / F^n, n != 1\r\n        // A * f_1 * f_2 * f_3, where (f_1 * f_2)' = f_3\r\n        if (this._factors.length === 2) {\r\n            // Check polynoms degree: one must of one degree less than the other.\r\n            let d1 = this._factors[0].polynom.degree(letter).value,\r\n                d2 = this._factors[1].polynom.degree(letter).value\r\n\r\n            if (d1 === d2 + 1) {\r\n                return this._integrateWithInternalDerivative(this._factors[0], this._factors[1], letter)\r\n            } else if (d1 + 1 === d2) {\r\n                return this._integrateWithInternalDerivative(this._factors[1], this._factors[0], letter)\r\n            }\r\n        }\r\n        return\r\n    }\r\n\r\n    public applyMathFunction(mathFn: PolynomExpMathFunctionType): PolynomExpProduct {\r\n        this._fn = mathFn\r\n        return this\r\n    }\r\n\r\n    private _integrateWithInternalDerivative(P: PolynomExpFactor, Pinternal: PolynomExpFactor, letter?: string): PolynomExpProduct {\r\n        // Get the internal derivative\r\n        let internalDerivative: Polynom = P.polynom.clone().derivative(letter)\r\n\r\n        // Get the factor.\r\n        let {quotient, reminder} = Pinternal.polynom.clone().euclidian(internalDerivative)\r\n\r\n        if (reminder.isZero() && quotient.degree(letter).isZero()) {\r\n            // All the conditions are done. Actual situation is\r\n            // (4x-10)(x^2-5x+7)^9\r\n            // P1 = (x^2-5x+7), P2 = (2x-5)\r\n            // => 1/10 * quotient * (x^2-5x+7)^10\r\n\r\n            if (P.degree.isEqual(-1)) {\r\n                return (new PolynomExpProduct(\r\n                    new PolynomExpFactor(quotient, 1),\r\n                    new PolynomExpFactor(P.polynom.clone(), 1, {\r\n                        name: 'ln', tex: '\\\\ln', fn: (x: number) => Math.log(x)\r\n                    })\r\n                ))\r\n            } else {\r\n                return new PolynomExpProduct(\r\n                    new PolynomExpFactor(P.degree.clone().add(1).invert(), 1),\r\n                    new PolynomExpFactor(quotient, 1),\r\n                    new PolynomExpFactor(P.polynom.clone(), P.degree.clone().add(1))\r\n                )\r\n            }\r\n        }\r\n        return\r\n    }\r\n}","import {Point} from \"./point\";\r\nimport {Line, LinePropriety} from \"./line\";\r\nimport {Vector} from \"./vector\";\r\nimport {Triangle} from \"./triangle\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Equation} from \"../algebra/equation\";\r\nimport {Polynom} from \"../algebra/polynom\";\r\nimport {Monom} from \"../algebra/monom\";\r\n\r\nexport class Circle {\r\n    constructor(...values: unknown[]) {\r\n        this._exists = false\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values)\r\n        }\r\n    }\r\n\r\n    private _center: Point;\r\n\r\n    get center(): Point {\r\n        return this._center;\r\n    }\r\n\r\n    private _squareRadius: Fraction;\r\n\r\n    get squareRadius(): Fraction {\r\n        return this._squareRadius\r\n    }\r\n\r\n    private _cartesian: Equation;\r\n\r\n    get cartesian(): Equation {\r\n        return this._cartesian\r\n    }\r\n\r\n    private _exists: boolean;\r\n\r\n    get exists(): boolean {\r\n        return this._exists;\r\n    }\r\n\r\n    get radius(): { tex: string, display: string, value: number } {\r\n        if (this._squareRadius.isSquare()) {\r\n            return {\r\n                tex: this._squareRadius.clone().sqrt().tex,\r\n                display: this._squareRadius.clone().sqrt().display,\r\n                value: this._squareRadius.clone().sqrt().value\r\n            }\r\n        } else {\r\n            return {\r\n                tex: `\\\\sqrt{${this._squareRadius.tex}}`,\r\n                display: `sqrt(${this._squareRadius.display})`,\r\n                value: this._squareRadius.clone().sqrt().value\r\n            }\r\n        }\r\n        return this._squareRadius\r\n    }\r\n\r\n    get tex(): string {\r\n        if (this._exists) {\r\n            let cx, cy\r\n            if (this._center.x.isZero()) {\r\n                cx = 'x^2'\r\n            } else {\r\n                cx = `\\\\left(x${this._center.x.isNegative() ? '+' : '-'}${this._center.x.clone().abs().tex}\\\\right)^2`\r\n            }\r\n            if (this._center.y.isZero()) {\r\n                cy = 'y^2'\r\n            } else {\r\n                cy = `\\\\left(y${this._center.y.isNegative() ? '+' : '-'}${this._center.y.clone().abs().tex}\\\\right)^2`\r\n            }\r\n            return `${cx}+${cy}=${this._squareRadius.tex}`\r\n        } else {\r\n            return `\\\\text{le cercle n'existe pas.}`\r\n        }\r\n    }\r\n\r\n    get developed(): string {\r\n        return this._cartesian.tex\r\n    }\r\n\r\n    get display(): string {\r\n        if (this._exists) {\r\n            let cx, cy\r\n            if (this._center.x.isZero()) {\r\n                cx = 'x^2'\r\n            } else {\r\n                cx = `(x${this._center.x.isNegative() ? '+' : '-'}${this._center.x.clone().abs().tex})^2`\r\n            }\r\n            if (this._center.y.isZero()) {\r\n                cy = 'y^2'\r\n            } else {\r\n                cy = `(y${this._center.y.isNegative() ? '+' : '-'}${this._center.y.clone().abs().tex})^2`\r\n            }\r\n            return `${cx}+${cy}=${this._squareRadius.display}`\r\n        } else {\r\n            return `\\\\text{le cercle n'existe pas.}`\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the relative position between circle and line. It corresponds to the number of intersection.\r\n     * @param {Line} L\r\n     * @returns {number}\r\n     */\r\n    relativePosition = (L: Line): number => {\r\n        let distance = L.distanceTo(this.center), radius = Math.sqrt(this._squareRadius.value)\r\n\r\n        if (distance.value - radius > 0.0000000001) {\r\n            return 0 // external\r\n        } else if (Math.abs(distance.value - radius) < 0.0000000001) {\r\n            return 1 // tangent\r\n        } else {\r\n            return 2 // external\r\n        }\r\n    }\r\n\r\n    lineIntersection = (L: Line): Point[] => {\r\n        let intersectionPoints: Point[] = [], solX: Fraction\r\n\r\n        if (this._cartesian === null) {\r\n            return []\r\n        }\r\n        const equX = this._cartesian.clone(), lineX = L.equation.clone().isolate('x'),\r\n            lineY = L.equation.clone().isolate('y')\r\n\r\n        if (lineX instanceof Equation && lineY instanceof Equation) {\r\n            equX.replaceBy('y', lineY.right).simplify()\r\n            equX.solve()\r\n\r\n            for (let x of equX.solutions) {\r\n                if (x.exact === false && isNaN(x.value)) {\r\n                    continue\r\n                }\r\n\r\n                solX = new Fraction(x.exact === false ? x.value : x.exact)\r\n                intersectionPoints.push(new Point(solX.clone(), lineY.right.evaluate(solX)))\r\n            }\r\n        }\r\n\r\n        return intersectionPoints\r\n    }\r\n\r\n    tangents = (P: Point | Fraction): Line[] => {\r\n        if (P instanceof Fraction) {\r\n            return this._tangentsWithSlope(P)\r\n        } else if (this.isPointOnCircle(P)) {\r\n            return this._tangentsThroughOnePointOnTheCircle(P)\r\n        } else if (this.center.distanceTo(P).value > this.radius.value) {\r\n            //TODO:  Must check it's outside the circle\r\n            return this._tangentsThroughOnePointOutsideTheCircle(P)\r\n        } else {\r\n            console.log('No tangents as the point is inside !')\r\n        }\r\n        return []\r\n    }\r\n\r\n    isPointOnCircle = (P: Point): Boolean => {\r\n        return this._cartesian.test({x: P.x, y: P.y})\r\n    }\r\n\r\n    getPointsOnCircle = (numberIsInteger?: boolean): Point[] => {\r\n        if (numberIsInteger === undefined) {\r\n            numberIsInteger = false\r\n        }\r\n\r\n        // It means searching for pythagorician triples that make a perfect square.\r\n        // (x-4)^2 + (y+3)^2 = 15\r\n\r\n        let triplets = Numeric.pythagoricianTripletsWithTarget(this._squareRadius.value, true)\r\n\r\n        let points: Point[] = [], pt\r\n        triplets.forEach(triplet => {\r\n            // Allow positive / negative values\r\n            // x-a = t  => x = a + t\r\n            // x-a = -t => x = a - t\r\n\r\n            for (let k of [[1, 1], [-1, 1], [-1, -1], [1, -1]]) {\r\n                pt = new Point(\r\n                    this.center.x.clone().add(k[0] * triplet[0]),\r\n                    this.center.y.clone().add(k[1] * triplet[1])\r\n                )\r\n                // Check if the point is not already in points.\r\n                if (!pt.isInListOfPoints(points)) {\r\n                    points.push(pt)\r\n                }\r\n            }\r\n        })\r\n        return points\r\n    }\r\n\r\n    clone(): Circle {\r\n        this._center = this._center.clone()\r\n        this._squareRadius = this._squareRadius.clone()\r\n        this._calculateCartesian()\r\n        return this\r\n    }\r\n\r\n    private _tangentsThroughOnePointOnTheCircle = (P: Point): Line[] => {\r\n        let CT = new Vector(this._center, P)\r\n        return [new Line(P, CT, LinePropriety.Perpendicular)]\r\n    }\r\n\r\n    private _tangentsThroughOnePointOutsideTheCircle = (P: Point): Line[] => {\r\n        // y = mx + h\r\n        // px, py => h = -m px + py => mx - y -m.px + py = 0 =>\r\n        // Centre: cx, cy, radius: r\r\n        // (m.cx - cy -m.px + py)^2 = r^2  * (m^2  + 1)\r\n        // (m(cx-py) - (cy - py))^2 = r^2  * (m^2  + 1)\r\n\r\n        let cx_px = this.center.x.clone().subtract(P.x), cy_py = this.center.y.clone().subtract(P.y),\r\n            polyLeft = new Polynom('x'), polyRight = new Polynom('x^2+1')\r\n\r\n        polyLeft.multiply(cx_px).subtract(cy_py).pow(2)\r\n        polyRight.multiply(this.squareRadius)\r\n\r\n        let equ = new Equation(polyLeft, polyRight)\r\n        equ.moveLeft().simplify().solve()\r\n\r\n        return equ.solutions.map(sol => {\r\n            //  h = -m px + py\r\n            let h, equ = new Equation('y', 'x')\r\n\r\n            if (sol.exact instanceof Fraction) {\r\n                h = P.x.clone().opposed().multiply(sol.exact).add(P.y)\r\n                equ.right.multiply(sol.exact).add(h)\r\n            } else {\r\n                h = P.x.clone().opposed().multiply(sol.value).add(P.y)\r\n                equ.right.multiply(sol.value).add(h)\r\n            }\r\n\r\n            return new Line(equ)\r\n        })\r\n\r\n    }\r\n\r\n    private _tangentsWithSlope = (slope: Fraction): Line[] => {\r\n        // d(C;t)=r => ac1+bc2 + x = +- sqrt(a^2 + b^2)*r\r\n        // x = -ac1-bc2  +-  sqrt(a^2 + b^2)*r\r\n        // y = a/bx + h => ax-by + H = 0\r\n\r\n        const a = slope.numerator, b = -slope.denominator, c1 = this._center.x.clone(), c2 = this._center.y.clone(),\r\n            r = this._squareRadius\r\n\r\n        let sq = this._squareRadius.clone().multiply(slope.numerator ** 2 + slope.denominator ** 2),\r\n            x1 = c1.clone().multiply(a).opposed().subtract(c2.clone().multiply(b)).add(sq.clone().sqrt()),\r\n            x2 = c1.clone().multiply(a).opposed().subtract(c2.clone().multiply(b)).subtract(sq.clone().sqrt())\r\n\r\n        return [new Line(a, b, x1), new Line(a, b, x2)]\r\n    }\r\n\r\n    private _reset(): Circle {\r\n        this._center = null\r\n        this._squareRadius = null\r\n        this._cartesian = null\r\n        this._exists = false\r\n\r\n        return this\r\n    }\r\n\r\n    private parse(...values: unknown[]): Circle {\r\n        // Data can be given in these formats:\r\n        // one value, a string -> make it an Equation\r\n        // one value, an Equation\r\n        // one value, a circle -> clone it\r\n        // two values: two points (center and pointThrough)\r\n        // two values: point and Fraction (center and radius)\r\n        // three values: Point, Fraction, Boolean (center, square radius, true)\r\n\r\n        this._reset()\r\n\r\n        if (typeof values[0] === 'string') {\r\n            this._parseEquation(new Equation(values[0]))\r\n        } else if (values[0] instanceof Equation) {\r\n            this._parseEquation(values[0])\r\n        } else if (values[0] instanceof Circle) {\r\n            this._parseCopyCircle(values[0])\r\n        } else if (values[0] instanceof Point && values.length > 1) {\r\n            if (values[1] instanceof Point) {\r\n                if (values[2] instanceof Point) {\r\n                    this._parseThroughtThreePoints(values[0], values[1], values[2])\r\n                } else {\r\n                    this._parseCenterAndPointThrough(values[0], values[1])\r\n                }\r\n            } else if (values[1] instanceof Fraction || typeof values[1] === 'number') {\r\n                this._parseCenterAndRadius(values[0], values[1], (typeof values[2] === \"boolean\") ? values[2] : false)\r\n            }\r\n        }\r\n\r\n        // Calculate once the different values.\r\n        if (this._exists) {\r\n            this._calculateCartesian()\r\n\r\n            // If the square radius is zero or positive, the circle exists.\r\n            if (this._squareRadius !== undefined && this._squareRadius.isNegative()) {\r\n                this._exists = false\r\n            }\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    private _calculateCartesian() {\r\n        this._cartesian = (new Equation(new Polynom(`(x-(${this._center.x.display}))^2+(y-(${this._center.y.display}))^2`), new Polynom(`${this._squareRadius.display}`))).moveLeft()\r\n    }\r\n\r\n    private _parseCopyCircle(circle: Circle): Circle {\r\n        this._center = circle.center.clone()\r\n        this._squareRadius = circle.squareRadius.clone()\r\n        this._calculateCartesian()\r\n        this._exists = circle.exists\r\n        return this\r\n    }\r\n\r\n    private _parseCenterAndRadius(center: Point, radius: Fraction | number, square?: boolean): Circle {\r\n        this._center = center.clone()\r\n\r\n        if (square) {\r\n            this._squareRadius = (new Fraction(radius))\r\n        } else {\r\n            this._squareRadius = new Fraction(radius).pow(2)\r\n        }\r\n\r\n        this._exists = true\r\n        return this\r\n    }\r\n\r\n    private _parseCenterAndPointThrough(center: Point, pointThrough: Point): Circle {\r\n        this._center = center.clone()\r\n        this._squareRadius = new Vector(this._center, pointThrough).normSquare\r\n        this._exists = true\r\n        return this\r\n    }\r\n\r\n    private _parseEquation(equ: Equation): Circle {\r\n        this._exists = false\r\n\r\n        // Move everything to the left.\r\n        equ.moveLeft()\r\n\r\n        if (equ.degree('x').value === 2 && equ.degree('y').value === 2) {\r\n            // Both must be of degree 2.\r\n            let x2 = equ.left.monomByDegree(2, 'x'), y2 = equ.left.monomByDegree(2, 'y'), x1: Monom, y1: Monom, c: Monom\r\n\r\n            // Both square monoms must have the same coefficient.\r\n            if (x2.coefficient.isEqual(y2.coefficient)) {\r\n                equ.divide(x2.coefficient)\r\n\r\n                x1 = equ.left.monomByDegree(1, 'x')\r\n                y1 = equ.left.monomByDegree(1, 'y')\r\n\r\n                c = equ.left.monomByDegree(0)\r\n\r\n                this._center = new Point(x1.coefficient.clone().divide(2).opposed(), y1.coefficient.clone().divide(2).opposed())\r\n\r\n                this._squareRadius = c.coefficient.clone().opposed()\r\n                    .add(this._center.x.clone().pow(2))\r\n                    .add(this._center.y.clone().pow(2))\r\n\r\n                this._calculateCartesian()\r\n                this._exists = true\r\n            } else {\r\n                // The circle is not a valid circle\r\n                this._center = null\r\n                this._squareRadius = null\r\n                this._exists = false\r\n            }\r\n        }\r\n        return this\r\n    }\r\n\r\n    private _parseThroughtThreePoints(A: Point, B: Point, C: Point): Circle {\r\n        let T = new Triangle(A, B, C), mAB = T.remarquables.mediators.AB.clone(),\r\n            mAC = T.remarquables.mediators.AC.clone()\r\n        this.parse(mAB.intersection(mAC).point, A)\r\n\r\n        return this\r\n    }\r\n\r\n}","/**\r\n * This class works for 2d line in a plane.\r\n */\r\n\r\nimport {Vector} from \"./vector\";\r\nimport {Point} from \"./point\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Equation} from \"../algebra/equation\";\r\nimport {Polynom} from \"../algebra/polynom\";\r\n\r\nexport enum LinePropriety {\r\n    None,\r\n    Parallel='parallel',\r\n    Perpendicular = 'perpendicular',\r\n    Tangent = 'tangent'\r\n}\r\n\r\nexport class Line {\r\n    // A line is defined as the canonical form\r\n    // ax + by + c = 0\r\n    private _a: Fraction;\r\n    private _b: Fraction;\r\n    private _c: Fraction;\r\n    private _OA: Point;\r\n    private _d: Vector;\r\n    private _n: Vector;\r\n    private _exists: boolean\r\n\r\n    private _referencePropriety: LinePropriety\r\n    private _referenceLine: Line\r\n\r\n    static PERPENDICULAR = LinePropriety.Perpendicular\r\n    static PARALLEL = LinePropriety.Parallel\r\n\r\n    constructor(...values: unknown[]) {\r\n\r\n        this._exists = false;\r\n\r\n        if (values.length > 0) {\r\n            this.parse(...values);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    get exists(): boolean {\r\n        return this._exists;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get equation(): Equation {\r\n        return new Equation(new Polynom().parse('xy', this._a, this._b, this._c), new Polynom('0')).simplify();\r\n    }\r\n\r\n    get tex(): { canonical: string, mxh: string, parametric: string } {\r\n        // canonical    =>  ax + by + c = 0\r\n        // mxh          =>  y = -a/b x - c/b\r\n        // parametric   =>  (xy) = OA + k*d\r\n\r\n        let canonical = this.equation;\r\n        // Make sur the first item is positive.\r\n        if (this._a.isNegative()) {\r\n            canonical.multiply(-1);\r\n        }\r\n\r\n        return {\r\n            canonical: canonical.tex,\r\n            mxh: this.slope.isInfinity() ? 'x=' + this.OA.x.tex : 'y=' + new Polynom().parse('x', this.slope, this.height).tex,\r\n            parametric: `${Point.pmatrix('x', 'y')} = ${Point.pmatrix(this._OA.x, this._OA.y)} + k\\\\cdot ${Point.pmatrix(this._d.x, this._d.y)}`\r\n        }\r\n    }\r\n\r\n    get display(): { canonical: string, mxh: string, parametric: string } {\r\n        // canonical    =>  ax + by + c = 0\r\n        // mxh          =>  y = -a/b x - c/b\r\n        // parametric   =>  (xy) = OA + k*d // not relevant in display mode.\r\n\r\n        let canonical = this.equation;\r\n        // Make sur the first item is positive.\r\n        if (this._a.isNegative()) {\r\n            canonical.multiply(-1);\r\n        }\r\n\r\n        return {\r\n            canonical: canonical.display,\r\n            mxh: this.slope.isInfinity() ? 'x=' + this.OA.x.display : 'y=' + new Polynom().parse('x', this.slope, this.height).display,\r\n            parametric: \"\"\r\n        }\r\n    }\r\n\r\n    get a(): Fraction {\r\n        return this._a;\r\n    }\r\n\r\n    set a(value: Fraction) {\r\n        this._a = value;\r\n    }\r\n\r\n    get b(): Fraction {\r\n        return this._b;\r\n    }\r\n\r\n    set b(value: Fraction) {\r\n        this._b = value;\r\n    }\r\n\r\n    get c(): Fraction {\r\n        return this._c;\r\n    }\r\n\r\n    set c(value: Fraction) {\r\n        this._c = value;\r\n    }\r\n\r\n    get OA(): Point {\r\n        return this._OA;\r\n    }\r\n\r\n    set OA(value: Point) {\r\n        this._OA = value;\r\n    }\r\n\r\n    get d(): Vector {\r\n        return this._d;\r\n    }\r\n\r\n    get n(): Vector {\r\n        return this._n;\r\n    }\r\n\r\n    get normal(): Vector {\r\n        return new Vector(this._a, this._b);\r\n    }\r\n\r\n    get director(): Vector {\r\n        return this._d.clone()\r\n    }\r\n\r\n    set d(value: Vector) {\r\n        this._d = value;\r\n    }\r\n\r\n    get slope(): Fraction {\r\n        return this._a.clone().opposed().divide(this._b);\r\n    }\r\n\r\n    get height(): Fraction {\r\n        return this._c.clone().opposed().divide(this._b);\r\n    }\r\n\r\n// ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse data to a line\r\n     * @param {any} values\r\n     * @returns {Line}\r\n     */\r\n    parse = (...values: unknown[]): Line => {\r\n        this._exists = false;\r\n\r\n        // Nothing is given...\r\n        if (values.length === 0) {\r\n            return this\r\n        }\r\n\r\n        // One value only: already a line (clone it), an Equation, a string (as Equation)\r\n        if (values.length === 1) {\r\n            if (values[0] instanceof Line) {\r\n                // Already a Line\r\n                return values[0].clone()\r\n            } else if (values[0] instanceof Equation) {\r\n                // It's an Equation\r\n                return this.parseEquation(values[0])\r\n            } else if (typeof values[0] === \"string\") {\r\n                // It's a string - create an Equation from it.\r\n                try {\r\n                    let E = new Equation(values[0])\r\n                    return this.parse(E)\r\n                } catch (e) {\r\n                    return this\r\n                }\r\n            }\r\n        }\r\n\r\n        if (values.length === 2) {\r\n            if (values[0] instanceof Point && values[1] instanceof Vector) {\r\n                return this.parseByPointAndVector(values[0], values[1]);\r\n            } else if (values[0] instanceof Point && values[1] instanceof Point) {\r\n                return this.parseByPointAndVector(values[0], new Vector(values[0], values[1]));\r\n            } else if (values[0] instanceof Vector && values[1] instanceof Point) {\r\n                return this.parseByPointAndNormal(values[1], values[0])\r\n            }\r\n        }\r\n\r\n        if (values.length === 3) {\r\n            if (\r\n                (values[0] instanceof Fraction || typeof values[0] === 'number')\r\n                &&\r\n                (values[1] instanceof Fraction || typeof values[1] === 'number')\r\n                &&\r\n                (values[2] instanceof Fraction || typeof values[2] === 'number')\r\n            ) {\r\n                return this.parseByCoefficient(values[0], values[1], values[2]);\r\n            }else if (\r\n                values[0] instanceof Point && values[1] instanceof Vector\r\n            ){\r\n                if(values[2] === LinePropriety.Perpendicular){\r\n                    return this.parseByPointAndNormal(values[0], values[1])\r\n                }else if (values[2] === LinePropriety.Parallel){\r\n                    return this.parseByPointAndVector(values[0], values[1])\r\n                }\r\n            }else if (values[0] instanceof Point && values[1] instanceof Line ) {\r\n                if(values[2]===LinePropriety.Parallel || values[2]===null) {\r\n                    return this.parseByPointAndLine(values[0], values[1], LinePropriety.Parallel)\r\n                }else{\r\n                    return this.parseByPointAndLine(values[0], values[1], LinePropriety.Perpendicular)\r\n                }\r\n            }\r\n        }\r\n\r\n        // TODO: Add the ability to create line from a normal vector\r\n        console.log('Someting wrong happend while creating the line')\r\n        return this;\r\n    }\r\n\r\n    parseEquation = (equ: Equation): Line => {\r\n        // Reorder the eequation\r\n        equ.reorder(true)\r\n\r\n        // It must contain either x, y or both.\r\n        let letters = new Set(equ.letters());\r\n\r\n        // No 'x', no 'y' in the equations\r\n        if (!(letters.has('x') || letters.has('y'))) {\r\n            return this\r\n        }\r\n\r\n        // Another letter in the equation ?\r\n        for (let elem of ['x', 'y']) {\r\n            if (letters.has(elem)) {\r\n                letters.delete(elem)\r\n            }\r\n        }\r\n\r\n        if (letters.size > 0) {\r\n            return this\r\n        }\r\n\r\n        // Everything should be ok now...\r\n        return this.parseByCoefficient(equ.left.monomByLetter('x').coefficient, equ.left.monomByLetter('y').coefficient, equ.left.monomByDegree(0).coefficient)\r\n    }\r\n    parseByCoefficient = (a: Fraction | number, b: Fraction | number, c: Fraction | number): Line => {\r\n        this._a = new Fraction(a);\r\n        this._b = new Fraction(b);\r\n        this._c = new Fraction(c);\r\n\r\n        this._d = new Vector(this._b.clone(), this._a.clone().opposed());\r\n        this._OA = new Point(new Fraction().zero(), this._c.clone());\r\n        this._n = this._d.clone().normal();\r\n\r\n        this._exists = true;\r\n        return this;\r\n    }\r\n\r\n    parseByPointAndVector = (P: Point, d: Vector): Line => {\r\n        // OX = OP + k*d\r\n        // x = px + kdx     * dy\r\n        // y = py + kdy     * dx\r\n        // ------------------\r\n        // dy * x = px * dy + kdxdy\r\n        // dx * y = py * dx + kdxdy\r\n        // ------------------\r\n        // dy * x - dx * y = px * dy - py * dx\r\n        // dy * x - dx * y - (px * dy - py * dx) = 0\r\n        this.parseByCoefficient(\r\n            d.y,\r\n            d.x.clone().opposed(),\r\n            P.x.clone().multiply(d.y).subtract(P.y.clone().multiply(d.x)).opposed()\r\n        )\r\n\r\n        // Choose the current values as point and direction vector instead of the automatic version.\r\n        this._OA = P.clone();\r\n        this._d = d.clone();\r\n        this._n = this._d.clone().normal();\r\n\r\n        this._exists = true;\r\n        return this;\r\n    }\r\n\r\n    parseByPointAndNormal = (P: Point, n: Vector): Line => {\r\n        return this.parseByCoefficient(\r\n            n.x,\r\n            n.y,\r\n            P.x.clone().multiply(n.x)\r\n                .add(P.y.clone().multiply(n.y)).opposed()\r\n        )\r\n    }\r\n\r\n    parseByPointAndLine = (P: Point, L: Line, orientation?: LinePropriety): Line => {\r\n\r\n        if (orientation === undefined) {\r\n            orientation = LinePropriety.Parallel\r\n        }\r\n\r\n        if (orientation === LinePropriety.Parallel) {\r\n            return this.parseByPointAndNormal(P, L.normal)\r\n        } else if (orientation === LinePropriety.Perpendicular) {\r\n            return this.parseByPointAndNormal(P, L.director)\r\n        }\r\n\r\n        this._exists = false\r\n        return this\r\n    }\r\n\r\n    clone = (): Line => {\r\n        this._a = this._a.clone();\r\n        this._b = this._b.clone();\r\n        this._c = this._c.clone();\r\n\r\n        this._d = this._d.clone();\r\n        this._OA = this._OA.clone();\r\n        this._n = this._n.clone();\r\n\r\n        this._exists = this.exists\r\n        return this;\r\n    }\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    isParellelTo = (line: Line): Boolean => {\r\n        // Do they have the isSame direction ?\r\n        return this.slope.isEqual(line.slope) && this.height.isNotEqual(line.height);\r\n    }\r\n    isSameAs = (line: Line): Boolean => {\r\n        return this.slope.isEqual(line.slope) && this.height.isEqual(line.height);\r\n    }\r\n    isVertical = (): Boolean => {\r\n        return this.slope.isInfinity()\r\n    }\r\n    simplify = (): Line => {\r\n        let lcm = Numeric.lcm(this._a.denominator, this._b.denominator, this._c.denominator),\r\n            gcd = Numeric.gcd(this._a.numerator, this._b.numerator, this._c.numerator);\r\n\r\n        this.parseByCoefficient(\r\n            this._a.clone().multiply(lcm).divide(gcd),\r\n            this._b.clone().multiply(lcm).divide(gcd),\r\n            this._c.clone().multiply(lcm).divide(gcd),\r\n        )\r\n\r\n        return this\r\n    }\r\n\r\n    simplifyDirection = (): Line => {\r\n        let lcm = Numeric.lcm(this._d.x.denominator, this._d.y.denominator),\r\n            gcd = Numeric.gcd(this._d.x.numerator, this._d.y.numerator);\r\n\r\n        this._d.x.multiply(lcm).divide(gcd);\r\n        this._d.y.multiply(lcm).divide(gcd);\r\n        return this;\r\n    }\r\n    intersection = (line: Line): { point: Point, hasIntersection: boolean, isParallel: boolean, isSame: boolean } => {\r\n        let Pt = new Point(), isParallel = false, isSame = false, hasIntersection = true;\r\n\r\n        // this         => ax+by+c = 0\r\n        // line         => dx+ey+f = 0\r\n        //\r\n        //  aex + bey + ce = 0\r\n        //  dbx + bey + bf = 0\r\n        // (ae-db)x + ce-bf = 0\r\n        //\r\n        //  adx + bdy + cd = 0\r\n        //  adx + aey + af = 0\r\n        // (bd-ae)y + (cd-af)\r\n        //\r\n        // x = (bf-ce)/(ae-db)\r\n        // y = (af-cd)/(bd-ae)\r\n\r\n\r\n        // Theres is no 'y'\r\n        if (this._b.isZero() || line.b.isZero()) {\r\n            // TODO : handle no y in the line canonical form\r\n        }\r\n\r\n        if (this.isParellelTo(line)) {\r\n            Pt.x = null;\r\n            Pt.y = null;\r\n            isParallel = true;\r\n        } else if (this.isSameAs(line)) {\r\n            Pt.x = null;\r\n            Pt.y = null;\r\n            isSame = true;\r\n        } else {\r\n            Pt.x = this._b.clone().multiply(line.c).subtract(this._c.clone().multiply(line.b))\r\n                .divide(this._a.clone().multiply(line.b).subtract(this._b.clone().multiply(line.a)));\r\n            Pt.y = this._a.clone().multiply(line.c).subtract(this._c.clone().multiply(line.a))\r\n                .divide(this._b.clone().multiply(line.a).subtract(this._a.clone().multiply(line.b)));\r\n        }\r\n\r\n        return {\r\n            point: Pt,\r\n            hasIntersection: !(isParallel || isSame),\r\n            isParallel,\r\n            isSame\r\n        };\r\n    }\r\n\r\n    distanceTo(pt: Point): { value: number, fraction: Fraction, tex: string } {\r\n        let numerator = pt.x.clone().multiply(this._a)\r\n                .add(pt.y.clone().multiply(this._b))\r\n                .add(this._c).abs(),\r\n            d2 = this.normal.normSquare;\r\n\r\n        // The denominator is null - shouldn't be possible\r\n        if (d2.isZero()) {\r\n            return {\r\n                value: NaN,\r\n                tex: 'Not a line',\r\n                fraction: new Fraction().infinite()\r\n            }\r\n        }\r\n        // The denominator is a perfect square - simplify the tex result\r\n        let value = numerator.value / Math.sqrt(d2.value),\r\n            F = numerator.clone().divide(d2.clone().sqrt());\r\n\r\n        // The denominator is a perfect square.\r\n        if (d2.isSquare()) {\r\n            return {\r\n                value,\r\n                tex: F.tex,\r\n                fraction: F\r\n            }\r\n        }\r\n        // Complete answer...\r\n        return {\r\n            value,\r\n            tex: `\\\\frac{${numerator.tex}}{\\\\sqrt{${d2.tex}}}`,\r\n            fraction: F\r\n        };\r\n    }\r\n\r\n    hitSegment(A: Point, B: Point): boolean {\r\n        let iPt = this.intersection(\r\n            new Line(A, B)\r\n        )\r\n\r\n        // There is an intersection point\r\n        if (iPt.hasIntersection) {\r\n            return iPt.point.x.value >= Math.min(A.x.value, B.x.value)\r\n                && iPt.point.x.value <= Math.max(A.x.value, B.x.value)\r\n                && iPt.point.y.value >= Math.min(A.y.value, B.y.value)\r\n                && iPt.point.y.value <= Math.max(A.y.value, B.y.value)\r\n        }\r\n        return false;\r\n    }\r\n\r\n    getValueAtX = (value: Fraction|number): Fraction => {\r\n        const equ = this.equation.clone().isolate('y'),\r\n            F = new Fraction(value)\r\n\r\n        if(equ instanceof Equation){\r\n            return equ.right.evaluate({x: F})\r\n        }\r\n        return\r\n    }\r\n    getValueAtY = (value: Fraction|number): Fraction => {\r\n        const equ = this.equation.clone().isolate('x'),\r\n            F = new Fraction(value)\r\n\r\n        if(equ instanceof Equation){\r\n            return equ.right.evaluate({y: F})\r\n        }\r\n        return\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Special functions\r\n    // ------------------------------------------\r\n    canonicalAsFloatCoefficient(decimals: number): string {\r\n        if (decimals === undefined) {\r\n            decimals = 2;\r\n        }\r\n\r\n        let ca = this._a.value,\r\n            cb = this._b.value,\r\n            cc = this._c.value,\r\n            canonical = '';\r\n\r\n        if (!this._a.isZero()) {\r\n            if (this._a.isOne()) {\r\n                canonical = 'x'\r\n            } else if (this._a.clone().opposed().isOne()) {\r\n                canonical = '-x'\r\n            } else {\r\n                canonical = this._a.value.toFixed(decimals) + 'x'\r\n            }\r\n        }\r\n\r\n        if (!this._b.isZero()) {\r\n            if (this._b.isPositive()) {\r\n                canonical += '+'\r\n            }\r\n            canonical += this._b.value.toFixed(decimals) + 'y'\r\n        }\r\n\r\n        if (!this._c.isZero()) {\r\n            if (this._c.isPositive()) {\r\n                canonical += '+'\r\n            }\r\n            canonical += this._c.value.toFixed(decimals)\r\n        }\r\n\r\n\r\n        return canonical + '=0';\r\n    }\r\n}","/**\r\n * Vector module contains everything necessary to handle 2d or 3d vectors.\r\n * @module Vector\r\n */\r\nimport {Line} from \"./line\";\r\nimport {Vector} from \"./vector\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\n/**\r\n * Helper class - a way to identify an object {x: number, y: number}\r\n */\r\nclass PointXY {\r\n    x: number\r\n    y: number\r\n}\r\n\r\nexport class Point {\r\n    private _x: Fraction;   // 1st component\r\n    private _y: Fraction;   // 2nd component\r\n    private _exist: Boolean;\r\n\r\n    constructor(...values: unknown[]) {\r\n        this._x = new Fraction().zero();\r\n        this._y = new Fraction().zero();\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values);\r\n        }\r\n\r\n        return this\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get x(): Fraction {\r\n        return this._x;\r\n    }\r\n\r\n    set x(value: Fraction) {\r\n        this._x = value;\r\n    }\r\n\r\n    get y(): Fraction {\r\n        return this._y;\r\n    }\r\n\r\n    set y(value: Fraction) {\r\n        this._y = value;\r\n    }\r\n\r\n    get tex(): string {\r\n        let pts = [];\r\n\r\n        pts.push(this._x.tex);\r\n        pts.push(this._y.tex);\r\n\r\n        return `\\\\left(${pts.join(';')}\\\\right)`\r\n    }\r\n\r\n    get display(): string {\r\n        let pts = [];\r\n\r\n        pts.push(this._x.tex);\r\n        pts.push(this._y.tex);\r\n\r\n        return `(${pts.join(';')})`\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (...values: unknown[]): Point => {\r\n        // Initialize the value.\r\n        this.zero();\r\n\r\n        // Nothing is given\r\n        if (values.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        // One element is given - might be already a point !\r\n        if (values.length === 1) {\r\n            // it's already a point - clone it\r\n            if (values[0] instanceof Point) {\r\n                this._x = values[0].x.clone()\r\n                this._y = values[0].y.clone()\r\n                return this\r\n            }\r\n\r\n            // Value is given as string, comma separated.\r\n            if (typeof values[0] === 'string') {\r\n                let xy = values[0].split(',')\r\n                if (xy.length === 2) {\r\n                    this._x = new Fraction(xy[0]).reduce()\r\n                    this._y = new Fraction(xy[1]).reduce()\r\n                    return this\r\n                }\r\n            }\r\n\r\n            // Value given as an object with {x: value, y: value}\r\n            if(values[0] instanceof PointXY){\r\n                    this._x = new Fraction(values[0].x).reduce()\r\n                    this._y = new Fraction(values[0].y).reduce()\r\n                return this\r\n            } else {\r\n                return this.zero()\r\n            }\r\n        }\r\n\r\n        if (values.length === 2) {\r\n            this._x = new Fraction(values[0]).reduce()\r\n            this._y = new Fraction(values[1]).reduce()\r\n            return this\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    clone = (): Point => {\r\n        this._x = this._x.clone()\r\n        this._y = this._y.clone()\r\n\r\n        return this\r\n    }\r\n\r\n    zero = (): Point => {\r\n        this._x = new Fraction(null);\r\n        this._y = new Fraction(null);\r\n        return this;\r\n    }\r\n\r\n    origin = (): Point => {\r\n        this.zero();\r\n        return this;\r\n    }\r\n\r\n    middleOf = (P1: Point, P2: Point): Point => {\r\n        this._x = P1.x.clone().add(P2.x).divide(2);\r\n        this._y = P1.y.clone().add(P2.y).divide(2);\r\n\r\n        return this;\r\n    }\r\n    // ------------------------------------------\r\n    // Display functions\r\n    // ------------------------------------------\r\n    texValues = (numberOfDigits: number): string => {\r\n        let pts = [];\r\n\r\n        pts.push(this._x.value.toFixed(numberOfDigits === undefined ? 2 : numberOfDigits));\r\n        pts.push(this._y.value.toFixed(numberOfDigits === undefined ? 2 : numberOfDigits));\r\n\r\n        return `\\\\left(${pts.join(';')}\\\\right)`\r\n    }\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n\r\n    // ------------------------------------------\r\n    // Vector functions\r\n    // ------------------------------------------\r\n\r\n    // ------------------------------------------\r\n    // Static functions\r\n    // ------------------------------------------\r\n    static pmatrix = (a: any, b: any, c?: any): string => {\r\n        if (c === undefined) {\r\n            return `\\\\begin{pmatrix} ${a.tex ? a.tex : a} \\\\\\\\ ${b.tex ? b.tex : b} \\\\end{pmatrix}`;\r\n        } else {\r\n            return `\\\\begin{pmatrix} ${a.tex ? a.tex : a} \\\\\\\\ ${b.tex ? b.tex : b} \\\\\\\\ ${c.tex ? c.tex : c} \\\\end{pmatrix}`;\r\n        }\r\n    };\r\n\r\n    distanceTo = (item:Point|Line): { value: number, fraction: Fraction, tex: string } => {\r\n        let value = 0, fraction = new Fraction(), tex = ''\r\n\r\n        if(item instanceof Line){\r\n            return item.distanceTo(this)\r\n        }else if(item instanceof Point){\r\n            let V = new Vector(this, item)\r\n\r\n            value = V.norm\r\n            fraction = V.normSquare.sqrt()\r\n            tex = V.normSquare.isSquare() ? fraction.tex : `\\\\sqrt{\\\\frac{ ${V.normSquare.numerator} }{ ${V.normSquare.denominator} }}`\r\n        }\r\n        return { value, fraction, tex }\r\n    }\r\n\r\n    get key(): string {\r\n      return `${this.x.display};${this.y.display}`\r\n}\r\n    isInListOfPoints = (list: Point[]): boolean => {\r\n        const keyList = list.map(x=>x.key)\r\n\r\n        return keyList.includes(this.key)\r\n    }\r\n}\r\n","import {Point} from \"./point\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Vector} from \"./vector\";\r\nimport {Line} from \"./line\";\r\nimport {Equation} from \"../algebra/equation\";\r\n\r\nexport interface remarquableLines {\r\n    'medians': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    },\r\n    'mediators': {\r\n        'AB': Line,\r\n        'AC': Line,\r\n        'BC': Line,\r\n        'intersection': Point\r\n    },\r\n    'heights': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    },\r\n    'bisectors': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    }\r\n}\r\n\r\nexport class Triangle {\r\n    private _A: Point;\r\n    private _B: Point;\r\n    private _C: Point;\r\n    private _lines: {\r\n        'AB': Line,\r\n        'AC': Line,\r\n        'BC': Line\r\n    };\r\n    private _middles: {\r\n        'AB': Point,\r\n        'AC': Point,\r\n        'BC': Point\r\n    };\r\n    private _remarquables: remarquableLines;\r\n\r\n\r\n    constructor(...values: unknown[]) {\r\n\r\n        if (values.length > 0) {\r\n            this.parse(...values);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setters\r\n    // ------------------------------------------\r\n\r\n    get A(): Point {\r\n        return this._A;\r\n    }\r\n\r\n    get B(): Point {\r\n        return this._B;\r\n    }\r\n\r\n    get C(): Point {\r\n        return this._C;\r\n    }\r\n\r\n    get AB(): Vector {\r\n        return this.getSegment('A', 'B');\r\n    }\r\n\r\n    get BA(): Vector {\r\n        return this.getSegment('B', 'A');\r\n    }\r\n\r\n    get BC(): Vector {\r\n        return this.getSegment('B', 'C');\r\n    }\r\n\r\n    get CB(): Vector {\r\n        return this.getSegment('C', 'B');\r\n    }\r\n\r\n    get AC(): Vector {\r\n        return this.getSegment('A', 'C');\r\n    }\r\n\r\n    get CA(): Vector {\r\n        return this.getSegment('C', 'A');\r\n    }\r\n\r\n    get isRectangle(): boolean {\r\n        if (this.AB.isNormalTo(this.BC)) {\r\n            return true;\r\n        }\r\n        if (this.AB.isNormalTo(this.AC)) {\r\n            return true;\r\n        }\r\n        if (this.BC.isNormalTo(this.AC)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    get isEquilateral(): boolean {\r\n        return this.AB.normSquare.isEqual(this.BC.normSquare) &&\r\n            this.AB.normSquare.isEqual(this.AC.normSquare);\r\n    }\r\n\r\n    get isIsocele(): boolean {\r\n        return this.AB.normSquare.isEqual(this.BC.normSquare) ||\r\n            this.AB.normSquare.isEqual(this.AC.normSquare) ||\r\n            this.BC.normSquare.isEqual(this.AC.normSquare)\r\n    }\r\n\r\n    get lines(): { 'AB': Line, 'BC': Line, 'AC': Line } {\r\n        return this._lines;\r\n    }\r\n\r\n    get remarquables(): remarquableLines {\r\n        return this._remarquables;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Parse values to a triangle. Supported formats:\r\n     * Point, Point, Point\r\n     * x1, y1, x2, y2, x3, y3\r\n     * TODO: Something else ?\r\n     * @param values\r\n     */\r\n    parse = (...values: any): Triangle => {\r\n        if (values.length === 6) {\r\n            // Check if all values are number or fractions.\r\n            let v = values.map((x: any) => new Fraction(x));\r\n            return this.parse(\r\n                new Point(v[0], v[1]),\r\n                new Point(v[2], v[3]),\r\n                new Point(v[4], v[5]),\r\n            )\r\n        } else if (values.length === 3) {\r\n            // Possibilities:\r\n            // - Three points (or part of points, only dict for example, or array (TODO: Add the array syntax for point)\r\n            // - Three lines\r\n            // - Three lines as text.\r\n            if(values.filter((x:any) => typeof x === 'string').length===3) {\r\n                return this.parse( ...values.map((x:string) => new Line(x)) )\r\n            }else if(values.filter((x:any) => x instanceof Line).length===3) {\r\n                // We have three lines\r\n                this._lines = {\r\n                    'AB': values[0],\r\n                    'BC': values[1],\r\n                    'AC': values[2]\r\n                };\r\n\r\n                // Get the intersection points -> build the triangle using these intersection points.\r\n                let intersect = values[0].intersection(values[1]);\r\n                if (intersect.hasIntersection) {\r\n                    this._B = intersect.point.clone();\r\n                } else {\r\n                    return this;\r\n                }\r\n                intersect = values[1].intersection(values[2]);\r\n                if (intersect.hasIntersection) {\r\n                    this._C = intersect.point.clone();\r\n                } else {\r\n                    return this;\r\n                }\r\n                intersect = values[2].intersection(values[0]);\r\n                if (intersect.hasIntersection) {\r\n                    this._A = intersect.point.clone();\r\n                } else {\r\n                    return this;\r\n                }\r\n            }else {\r\n                // At least, one of the value is not a point.\r\n                if (values.filter((x: any) => (x instanceof Point)).length < 3) {\r\n                    return this.parse(\r\n                        new Point(values[0]),\r\n                        new Point(values[1]),\r\n                        new Point(values[2])\r\n                    )\r\n                }\r\n\r\n                // We have three points.\r\n                this._A = values[0].clone();\r\n                this._B = values[1].clone();\r\n                this._C = values[2].clone();\r\n\r\n                this._lines = {\r\n                    'AB': new Line(this._A, this._B),\r\n                    'BC': new Line(this._B, this._C),\r\n                    'AC': new Line(this._A, this._C)\r\n                };\r\n            }\r\n        } else if (values.length === 1) {\r\n            if (values[0] instanceof Triangle) {\r\n                return values[0].clone();\r\n            }\r\n        }\r\n\r\n        this._updateTriangle();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clone the Triangle class\r\n     */\r\n    clone = (): Triangle => {\r\n        this._A = this._A.clone();\r\n        this._B = this._B.clone();\r\n        this._C = this._C.clone();\r\n\r\n        this._lines = {\r\n            'AB': this._lines.AB.clone(),\r\n            'BC': this._lines.BC.clone(),\r\n            'AC': this._lines.AC.clone()\r\n        }\r\n\r\n        this._updateTriangle();\r\n        return this;\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Triangle operations and properties\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Generate the Line object for the three segments of the triangle\r\n     */\r\n    private _updateTriangle = () => {\r\n        this._middles = {\r\n            'AB': new Point().middleOf(this._A, this._B),\r\n            'AC': new Point().middleOf(this._A, this._C),\r\n            'BC': new Point().middleOf(this._B, this._C)\r\n        }\r\n\r\n        this._remarquables = this._calculateRemarquableLines();\r\n    }\r\n\r\n\r\n    /**\r\n     * Get the Point class for the given name\r\n     * @param ptName\r\n     */\r\n    private getPointByName = (ptName: string): Point => {\r\n        switch (ptName.toUpperCase()) {\r\n            case 'A':\r\n                return this._A;\r\n            case 'B':\r\n                return this._B;\r\n            case 'C':\r\n                return this._C;\r\n        }\r\n\r\n        // Something went wrong ! Return the first point\r\n        return this._A;\r\n    }\r\n    /**\r\n     * Get the vector for the segment given by name.\r\n     * @param ptName1\r\n     * @param ptName2\r\n     */\r\n    private getSegment = (ptName1: string, ptName2: string): Vector => {\r\n        return new Vector(\r\n            this.getPointByName(ptName1),\r\n            this.getPointByName(ptName2)\r\n        );\r\n    }\r\n\r\n    private _calculateRemarquableLines = (): remarquableLines => {\r\n        let remarquables: remarquableLines = {\r\n            'medians': {\r\n                'A': new Line(this._A, this._middles.BC),\r\n                'B': new Line(this._B, this._middles.AC),\r\n                'C': new Line(this._C, this._middles.AB),\r\n                'intersection': null\r\n            },\r\n            'mediators': {\r\n                'AB': new Line(this._middles.AB, new Vector(this._A, this._B).normal()),\r\n                'AC': new Line(this._middles.AC, new Vector(this._A, this._C).normal()),\r\n                'BC': new Line(this._middles.BC, new Vector(this._B, this._C).normal()),\r\n                'intersection': null\r\n            },\r\n            'heights': {\r\n                'A': new Line(this._A, new Vector(this._B, this._C).normal()),\r\n                'B': new Line(this._B, new Vector(this._A, this._C).normal()),\r\n                'C': new Line(this._C, new Vector(this._A, this._B).normal()),\r\n                'intersection': null\r\n            },\r\n            'bisectors': {\r\n                'A': this._calculateBisectors('A'),\r\n                'B': this._calculateBisectors('B'),\r\n                'C': this._calculateBisectors('C'),\r\n                'intersection': null\r\n            }\r\n        }\r\n\r\n        // As it's a triangle, we assume the lines are intersecting and aren't parallel or superposed.\r\n        remarquables.medians.intersection = remarquables.medians.A.intersection(remarquables.medians.B).point;\r\n        remarquables.mediators.intersection = remarquables.mediators.AB.intersection(remarquables.mediators.BC).point;\r\n        remarquables.heights.intersection = remarquables.heights.A.intersection(remarquables.heights.B).point;\r\n        remarquables.bisectors.intersection = remarquables.bisectors.A.intersection(remarquables.bisectors.B).point;\r\n\r\n        // Everything was calculated for the remarquable lines.\r\n        return remarquables;\r\n    }\r\n\r\n    private _calculateBisectors = (pt: string): Line => {\r\n        let tlines = this.lines, d1, d2;\r\n\r\n        if(pt==='A'){\r\n            d1 = tlines.AB;\r\n            d2 = tlines.AC;\r\n        }else if(pt==='B'){\r\n            d1 = tlines.AB;\r\n            d2 = tlines.BC;\r\n        }else if(pt==='C'){\r\n            d1 = tlines.BC;\r\n            d2 = tlines.AC;\r\n        }\r\n\r\n        let b1 = new Line(new Equation(d1.equation.left.clone().multiply(d2.n.simplify().norm), d2.equation.left.clone().multiply(d1.n.simplify().norm)).reorder(true).simplify()),\r\n            b2 = new Line(new Equation(d1.equation.left.clone().multiply(d2.n.simplify().norm), d2.equation.left.clone().multiply(d1.n.simplify().norm).opposed()).reorder(true).simplify());\r\n\r\n        // Must determine which bisectors is in the triangle\r\n        if(pt==='A'){\r\n            return b1.hitSegment(this.B, this.C)?b1:b2;\r\n        }\r\n        if(pt==='B'){\r\n            return b1.hitSegment(this.A, this.C)?b1:b2;\r\n        }\r\n        if(pt==='C'){\r\n            return b1.hitSegment(this.B, this.A)?b1:b2;\r\n        }\r\n\r\n        // Default returns the first bisector\r\n        return b1;\r\n    }\r\n}","/**\r\n * Vector module contains everything necessary to handle 2d or 3d vectors.\r\n * @module Vector\r\n */\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Point} from \"./point\";\r\n\r\nexport class Vector {\r\n    private _x: Fraction;   // 1st component\r\n    private _y: Fraction;   // 2nd component\r\n\r\n    constructor(...values: unknown[]) {\r\n        this._x = new Fraction().zero();\r\n        this._y = new Fraction().zero();\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values);\r\n        }\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get x(): Fraction {\r\n        return this._x;\r\n    }\r\n\r\n    set x(value: Fraction) {\r\n        this._x = value;\r\n    }\r\n\r\n    get y(): Fraction {\r\n        return this._y;\r\n    }\r\n\r\n    set y(value: Fraction) {\r\n        this._y = value;\r\n    }\r\n\r\n    get normSquare(): Fraction {\r\n        return this._x.clone().pow(2).add(this._y.clone().pow(2));\r\n    }\r\n\r\n    get norm(): number {\r\n        return Math.sqrt(this.normSquare.value);\r\n    }\r\n\r\n    get tex(): string {\r\n        return `\\\\begin{pmatrix}${this._x.tex} \\\\\\\\\\ ${this._y.tex} \\\\end{pmatrix}`\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n    parse = (...values: any): Vector => {\r\n        // TODO: Must be more strict about what is given and limit to two dimensional vectors.p\r\n        // Maybe more than one value was given...\r\n        // Initialize the vector\r\n        this.zero();\r\n\r\n        if (values.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        if (values.length === 1) {\r\n            if (values[0] instanceof Vector) {\r\n                return values[0].clone()\r\n            } else {\r\n                return this._parseString(values[0])\r\n            }\r\n        }\r\n\r\n        if (values.length >= 2) {\r\n            // Two points are given - skip the third value.\r\n            if (values[0] instanceof Point && values[1] instanceof Point) {\r\n                this._x = values[1].x.clone().subtract(values[0].x)\r\n                this._y = values[1].y.clone().subtract(values[0].y)\r\n                return this;\r\n            }\r\n\r\n            // Fractions or a number are give\r\n            if (values[0] instanceof Fraction || !isNaN(values[0])) {\r\n                this._x = new Fraction(values[0])\r\n            }\r\n            if (values[1] instanceof Fraction || !isNaN(values[1])) {\r\n                this._y = new Fraction(values[1])\r\n            }\r\n\r\n            if(\r\n                (typeof values[0] === 'object' && !isNaN(values[0].x) && !isNaN(values[0].x)) &&\r\n                (typeof values[1] === 'object' && !isNaN(values[1].x) && !isNaN(values[1].x))\r\n            ){\r\n                this._x = new Fraction(+values[1].x-values[0].x)\r\n                this._y = new Fraction(+values[1].y-values[0].y)\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    clone = (): Vector => {\r\n        let V = new Vector();\r\n\r\n        if (this._x !== null) {\r\n            V.x = this._x.clone();\r\n        }\r\n        if (this._y !== null) {\r\n            V.y = this._y.clone();\r\n        }\r\n        return V;\r\n    }\r\n\r\n    reset = (): Vector => {\r\n        this._x = null;\r\n        this._y = null;\r\n        return this;\r\n    }\r\n\r\n    zero = (): Vector => {\r\n        this.reset();\r\n        this._x = new Fraction(null);\r\n        this._y = new Fraction(null);\r\n        return this;\r\n    }\r\n\r\n    one = (): Vector => {\r\n        this._x = new Fraction();\r\n        this._y = new Fraction();\r\n        return this;\r\n    }\r\n\r\n    private _parseString = (value: string): Vector => {\r\n        // Split comma, semi colon or single space.\r\n        let components = value.split(/[,;\\s]/g);\r\n\r\n        // Validate the fraction values.\r\n        this.x = new Fraction(components[0] || null);\r\n        this.y = new Fraction(components[1] || null);\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    opposed = (): Vector => {\r\n        this._x.opposed();\r\n        this._y.opposed();\r\n        return this;\r\n    }\r\n\r\n    add = (V: Vector): Vector => {\r\n        this._x.add(V.x);\r\n        this._y.add(V.y);\r\n\r\n        return this;\r\n    }\r\n\r\n    subtract = (V: Vector): Vector => {\r\n        return this.add(V.clone().opposed());\r\n    }\r\n\r\n    scalarProductWithVector = (V: Vector): Fraction => {\r\n        // TODO: Add the scalar factor !!!!\r\n        return this._x.clone().multiply(V.x).add(this._y.clone().multiply(V.y));\r\n    }\r\n\r\n    static scalarProduct = (v1: Vector, v2: Vector): number => {\r\n        // TODO: Transform to fraction with nthroot.\r\n        return v1.x.value * v2.x.value + v1.y.value * v2.y.value;\r\n    };\r\n\r\n    normal = (): Vector => {\r\n        let x = this.x.clone().opposed(), y = this.y.clone();\r\n        this._x = y;\r\n        this._y = x;\r\n        return this;\r\n    }\r\n\r\n    isNormalTo = (v: Vector): boolean => {\r\n        return this.scalarProductWithVector(v).isZero()\r\n    }\r\n\r\n    multiplyByScalar = (k: any): Vector => {\r\n        let scalar = new Fraction(k);\r\n        this._x.multiply(scalar);\r\n        this._y.multiply(scalar);\r\n        return this;\r\n    }\r\n\r\n    divideByScalar = (k: any): Vector => {\r\n        return this.multiplyByScalar(new Fraction(k).invert());\r\n    }\r\n    // ------------------------------------------\r\n    // Vector functions\r\n    // ------------------------------------------\r\n\r\n    simplify = (): Vector => {\r\n        // Multiply by the lcm of denominators.\r\n        return this.multiplyByScalar(Numeric.lcm(this._x.denominator, this._y.denominator))\r\n            .divideByScalar(Numeric.gcd(this._x.numerator, this._y.numerator));\r\n    }\r\n\r\n    angleWith = (V: Vector, sharp?: Boolean, radian?: Boolean): number => {\r\n        let scalar = this.scalarProductWithVector(V).value,\r\n            toDegree = radian ? 1 : 180 / Math.PI;\r\n        if (sharp) {\r\n            scalar = Math.abs(scalar);\r\n        }\r\n\r\n        return toDegree * Math.acos(scalar / (this.norm * V.norm));\r\n    }\r\n}\r\n","export class Numeric{\r\n    static round(value:number, decimals:number=2):number {\r\n        return Number(Math.round(Number(value+'e'+decimals))+'e-'+decimals);\r\n    }\r\n\r\n    /**\r\n     * Get the list of the nth first prime numbers.\r\n     * @param nb : number of primes to choose from\r\n     */\r\n    static primes(nb?:number):number[]{\r\n        let primesValues:number[] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973];\r\n        if(nb === undefined){\r\n            return primesValues;\r\n        }else{\r\n            return primesValues.slice(0,Math.min(primesValues.length,nb));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the list of all dividers of a number.\r\n     * @param value\r\n     */\r\n    static dividers(value:number):number[]{\r\n        let D: number[];\r\n        const maxV = Math.sqrt(Math.abs(value));\r\n\r\n        // Initialize the list of dividers.\r\n        D = [];\r\n\r\n        for(let i=1; i<=maxV; i++){\r\n            if(value%i===0){\r\n                D.push(i);\r\n                D.push(value/i);\r\n            }\r\n        }\r\n\r\n        // Order numbers.\r\n        D.sort(function(a, b){return a-b;});\r\n\r\n        // Make sure the array of value is unique.\r\n        return [...new Set(D)];\r\n    }\r\n    /**\r\n     * Great Common Divisor\r\n     * @param values : number values\r\n     */\r\n    static gcd(...values:number[]):number{\r\n        // Define the gcd for two number\r\n        let gcd2 = function(a:number,b:number):number{\r\n            if(b===0){return a;}\r\n            return gcd2(b, a%b);\r\n        };\r\n\r\n        let g:number = 1,\r\n            i:number = 2;\r\n\r\n        // Nothing is given\r\n        if(values.length===0){return 1;}\r\n        // Only one number is given\r\n        if(values.length===1){\r\n            // The first number is zero\r\n            if(values[0]===0){return 1;}\r\n            // Return the number\r\n            return values[0];\r\n        }\r\n\r\n        // We have at least 2 numbers.\r\n        g = gcd2(values[0],values[1]);\r\n\r\n        // The gcd of the two first value is one ? It's already finished.\r\n        if(g===1){return 1;}\r\n\r\n        // The current gcd isn't one. Continue with all next values.\r\n        for(i=2; i<values.length; i++){\r\n            g = gcd2(g, values[i]);\r\n            // Escape if gcd is already one.\r\n            if(g===1){break;}\r\n        }\r\n\r\n        return Math.abs(g);\r\n    }\r\n\r\n    static divideNumbersByGCD(...values: number[]): number[]{\r\n        let gcd = Numeric.gcd(...values)\r\n\r\n        return values.map(x=>x/gcd)\r\n    }\r\n    /**\r\n     * Least Common Multiple\r\n     * @param values: list of numbers\r\n     */\r\n    static lcm(...values:number[]):number{\r\n        return values.reduce(function(a,b){\r\n            return Math.abs(a * b / Numeric.gcd(a, b));\r\n        });\r\n    }\r\n\r\n    static pythagoricianTripletsWithTarget(target: number, targetIsSquare?:boolean): number[][] {\r\n        // mthode inverse,  partir du triplet.\r\n        const triplets = [],\r\n            targetValue = targetIsSquare===true?+target:target**2\r\n        for(let u = 0; u <= target; u++){\r\n            for(let v = 0; v <=target; v++){\r\n                if(u**2+v**2===targetValue){\r\n                    triplets.push([u, v, target])\r\n                }\r\n            }\r\n        }\r\n\r\n        return triplets\r\n    }\r\n\r\n    static numberCorrection(value: number, epsilonDigit:number = 1, epsilonNumberOfDigits: number = 10, number_of_digits: number = 6){\r\n\r\n        // Must modify the number if it's like:\r\n        // a: 3.0000000000000003\r\n        // b: 3.9999999999999994\r\n        // remove the last character\r\n        // check if around n last characters are either 0 or 9\r\n        // if it is, 'round' the number.\r\n        function extractDecimalPart(valueToExtract: number, decimalLength: number){\r\n            let decimal = valueToExtract.toString()\r\n\r\n            if (!decimal.includes('.')) {\r\n                return ''\r\n            }\r\n\r\n            decimal = decimal.split('.')[1]\r\n            return decimal.substring(0, decimalLength)\r\n        }\r\n\r\n        const epsilon = Number(`0.${\"0\".repeat(epsilonNumberOfDigits-1)}${epsilonDigit}`)\r\n        const decimal = extractDecimalPart(value, epsilonNumberOfDigits)\r\n        if(decimal===''){return value}\r\n\r\n        const n9 = decimal.match(/9+$/g)\r\n        const n0 = decimal.match(/0+$/g)\r\n\r\n        if (n9 && n9[0].length >= number_of_digits) {\r\n            // New tested values.\r\n            const mod = extractDecimalPart(value + epsilon, epsilonNumberOfDigits),\r\n                mod0 = mod.match(/0+$/g)\r\n\r\n            if(mod0 && mod0[0].length>= number_of_digits){\r\n                return +((value+epsilon).toString().split(mod0[0])[0])\r\n            }\r\n        }\r\n\r\n        if (n0 && n0[0].length >= number_of_digits) {\r\n            // New tested values.\r\n            const mod = extractDecimalPart(value - epsilon, epsilonNumberOfDigits),\r\n                mod9 = mod.match(/9+$/g)\r\n\r\n            if(mod9 && mod9[0].length>= number_of_digits){\r\n                // The value can be changed. Remove all nines!\r\n                return +(value.toString().split(n0[0])[0])\r\n            }\r\n        }\r\n\r\n        return value\r\n    }\r\n\r\n    static periodic(value: number):number{\r\n        if(Number.isSafeInteger(value)){return 0}\r\n\r\n        // Assume it's with decimal.\r\n        let decimal = (value.toString()).split('.')[0]\r\n\r\n        // The decimal part is limited\r\n        if(decimal.length<10){return 0}\r\n\r\n        // Find the periodic if it exists.\r\n    }\r\n\r\n    static decompose(value: number): number[][]{\r\n        let dividers = Numeric.dividers(value),\r\n            limit = Math.sqrt(value),\r\n            arr = [],\r\n            u, v\r\n\r\n        while(dividers.length>0){\r\n            u = dividers.shift()\r\n            v = dividers.length>0?dividers.pop():+u\r\n\r\n            arr.push([u,v])\r\n        }\r\n\r\n        return arr\r\n    }\r\n}","import {rndPolynom} from \"./rndPolynom\";\r\nimport {rndMonom} from \"./rndMonom\";\r\nimport {rndHelpers} from \"./rndHelpers\";\r\nimport {randomCoefficientConfig, randomMonomConfig, randomPolynomConfig} from \"./rndTypes\";\r\nimport {rndFraction} from \"./rndFraction\";\r\nimport {Polynom} from \"../algebra/polynom\";\r\nimport {Monom} from \"../algebra/monom\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\nexport * from \"./rndTypes\"\r\n\r\nexport namespace Random {\r\n    export function polynom(config?: randomPolynomConfig): Polynom {\r\n        return (new rndPolynom(config)).generate()\r\n    }\r\n\r\n    export function monom(config?: randomMonomConfig): Monom {\r\n        return (new rndMonom(config)).generate()\r\n    }\r\n\r\n    export function fraction(config?: randomCoefficientConfig): Fraction {\r\n        return (new rndFraction(config)).generate()\r\n    }\r\n\r\n    export function number(from: number, to: number): number {\r\n        return rndHelpers.randomInt(from, to)\r\n    }\r\n\r\n    export function numberSym(max: number, allowZero?: boolean): number {\r\n        return rndHelpers.randomIntSym(max, allowZero)\r\n    }\r\n\r\n    export function prime(max: number): number {\r\n        return rndHelpers.randomPrime(max)\r\n    }\r\n\r\n    export function bool(percent?: number): boolean {\r\n        return rndHelpers.randomBool(percent)\r\n    }\r\n\r\n    export function array(arr: any[], number?: number): any[] {\r\n        return rndHelpers.randomArray(arr, number)\r\n    }\r\n\r\n    export function item(arr: any[]): any {\r\n        return rndHelpers.randomItem(arr)\r\n    }\r\n\r\n    export function shuffle(arr: any[]): any[] {\r\n        return rndHelpers.shuffleArray(arr)\r\n    }\r\n}","export class randomCore {\r\n    protected _config: Object\r\n    protected _defaultConfig: Object\r\n    mergeConfig = (config: Object, defaultConfig: Object): Object => {\r\n        if (config !== undefined) {\r\n            return {...defaultConfig, ...config}\r\n        }\r\n        return defaultConfig\r\n    }\r\n\r\n    generate = (): unknown => {\r\n        return undefined\r\n    }\r\n\r\n    config = (config: Object): randomCore => {\r\n        this._config = this.mergeConfig(config, this._defaultConfig)\r\n        return this\r\n    }\r\n}","import {randomCore} from \"./randomCore\";\r\nimport {randomCoefficientConfig, randomMonomConfig, randomPolynomConfig} from \"./rndTypes\";\r\nimport {Random} from \"./random\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\n/**\r\n * Create a random monom based on a based configuration\r\n */\r\nexport class rndFraction extends randomCore {\r\n    declare protected _config: randomCoefficientConfig\r\n    declare protected _defaultConfig: randomCoefficientConfig\r\n\r\n    constructor(userConfig?: randomCoefficientConfig) {\r\n        super();\r\n\r\n        this._defaultConfig = {\r\n            negative: true,\r\n            max: 10,\r\n            reduced: true,\r\n            zero: true,\r\n            natural: false\r\n        }\r\n\r\n        this._config = this.mergeConfig(userConfig, this._defaultConfig)\r\n    }\r\n\r\n    generate = (): Fraction => {\r\n        let Q = new Fraction()\r\n\r\n        if(this._config.negative){\r\n            Q.numerator = Random.numberSym(this._config.max, this._config.zero)\r\n        }else {\r\n            Q.numerator = Random.number(this._config.zero ? 0 : 1, this._config.max)\r\n        }\r\n        if(this._config.natural){\r\n            Q.denominator = 1\r\n        }else {\r\n            let securityCount = 0\r\n            while(Q.isRelative() && securityCount<10) {\r\n                Q.denominator = Random.number(1, this._config.max)\r\n                securityCount++\r\n            }\r\n        }\r\n\r\n        return this._config.reduced?Q.reduce():Q\r\n    }\r\n}\r\n","/**\r\n * Random helpers\r\n */\r\nimport {Numeric} from \"../numeric\";\r\n\r\nexport class rndHelpers {\r\n\r\n    /**\r\n     * Random boolean with a percent ratio\r\n     * @param percent\r\n     */\r\n    static randomBool(percent:number=0.5):boolean{\r\n        return Math.random()<percent;\r\n    }\r\n\r\n    /**\r\n     * Random integer between two values.\r\n     * @param a (number) : From this value to the second value. If the second is ommited, this value is the max value.\r\n     * @param b (number) : To this value. If this is ommited.\r\n     */\r\n    static randomInt(a:number, b?:number):number{\r\n        if(b===undefined){return this.randomInt(0,a);}\r\n\r\n        return Math.floor(Math.random() * (b - a + 1) + a);\r\n    }\r\n\r\n    /**\r\n     * Random integer between -max and max value.\r\n     * @param max (number) : determine the limits.\r\n     * @param zero (bool) : determine if zero is allowed or not.\r\n     */\r\n    static randomIntSym(max:number, zero?:boolean):number{\r\n        if(zero===false){\r\n            return this.randomBool()?this.randomInt(1,max):-this.randomInt(1,max);\r\n        }else{\r\n            return this.randomInt(-max, max);\r\n        }\r\n    }\r\n\r\n    static randomPrime(max: number): number {\r\n        let primes = Numeric.primes()\r\n        if(max!==undefined){\r\n            primes = primes.filter(x=>x<max)\r\n        }\r\n        return this.randomItem(primes)\r\n    }\r\n\r\n    static randomArray(arr: any[], number?:number):any[]{\r\n        if(number===undefined){number = 1}\r\n\r\n        // Return a clone array\r\n        if(arr.length<=0){return Object.values(arr)}\r\n\r\n        // Randomize the array and return the n first elements.\r\n        return rndHelpers.shuffleArray(arr).slice(0,number);\r\n    }\r\n\r\n    static randomItem(arr: any[]): any{\r\n        if(arr.length===0){return ''}\r\n        return this.randomArray(arr, 1)[0]\r\n    }\r\n\r\n    static shuffleArray(arr: any[]): any[] {\r\n        // The Fisher-Yates algorithm\r\n        let shuffleArray = Object.values(arr)\r\n        for (let i = shuffleArray.length - 1; i > 0; i--) {\r\n            const j = Math.floor(Math.random() * (i + 1));\r\n            const temp = shuffleArray[i];\r\n            shuffleArray[i] = shuffleArray[j];\r\n            shuffleArray[j] = temp;\r\n        }\r\n\r\n        return shuffleArray;\r\n    }\r\n\r\n}","import {randomCore} from \"./randomCore\";\r\nimport {randomMonomConfig} from \"./rndTypes\";\r\nimport {Random} from \"./random\";\r\nimport {Monom} from \"../algebra/monom\";\r\n\r\n/**\r\n * Create a random monom based on a based configuration\r\n */\r\nexport class rndMonom extends randomCore {\r\n    declare protected _config: randomMonomConfig\r\n    declare protected _defaultConfig: randomMonomConfig\r\n\r\n    constructor(userConfig?: randomMonomConfig) {\r\n        super();\r\n\r\n        this._defaultConfig = {\r\n            letters: 'x',\r\n            degree: 2,\r\n            fraction: true,\r\n            zero: false\r\n        }\r\n\r\n        this._config = this.mergeConfig(userConfig, this._defaultConfig)\r\n    }\r\n\r\n    generate = (): Monom => {\r\n        // Create a monom instance\r\n        let M = new Monom()\r\n\r\n        // Generate the coefficient\r\n        if (typeof this._config.fraction === \"boolean\") {\r\n            M.coefficient = Random.fraction({\r\n                zero: this._config.zero,\r\n                reduced: true,\r\n                natural: !this._config.fraction\r\n            })\r\n        } else {\r\n            M.coefficient = Random.fraction(this._config.fraction)\r\n        }\r\n\r\n        // Calculate the degree of the monom\r\n        if (this._config.letters.length > 1) {\r\n            // Initialise each items...\r\n            for (let L of this._config.letters.split('')) {\r\n                M.setLetter(L, 0);\r\n            }\r\n            for (let i = 0; i < this._config.degree; i++) {\r\n                const L = Random.item(this._config.letters.split(\"\"))\r\n                M.setLetter(L, M.degree(L).clone().add(1))\r\n            }\r\n        } else {\r\n            M.setLetter(this._config.letters, this._config.degree)\r\n        }\r\n\r\n        return M\r\n    }\r\n}\r\n","import {randomCore} from \"./randomCore\";\r\nimport {randomPolynomConfig} from \"./rndTypes\";\r\nimport {rndMonom} from \"./rndMonom\";\r\nimport {Random} from \"./random\";\r\nimport {Polynom} from \"../algebra/polynom\";\r\nimport {Monom} from \"../algebra/monom\";\r\n\r\n/**\r\n * Random polynoms\r\n */\r\nexport class rndPolynom extends randomCore {\r\n    declare protected _config: randomPolynomConfig\r\n    declare protected _defaultConfig: randomPolynomConfig\r\n\r\n    constructor(userConfig?: randomPolynomConfig) {\r\n        super();\r\n\r\n        // Default config for a random polynom\r\n        this._defaultConfig = {\r\n            letters: 'x',\r\n            degree: 2,\r\n            fraction: false,\r\n            zero: false,\r\n            unit: false,\r\n            factorable: false,\r\n            allowNullMonom: true,\r\n            numberOfMonoms: 0,\r\n            positive: true\r\n        }\r\n\r\n        // Merge config with initialiser\r\n        this._config = this.mergeConfig(userConfig, this._defaultConfig)\r\n    }\r\n\r\n    generate = (): Polynom => {\r\n        if(this._config.factorable && this._config.degree>1){\r\n            return this.factorable()\r\n        }\r\n\r\n        // Create the polynom\r\n        let P = new Polynom().empty(),\r\n            M: Monom\r\n\r\n        for (let i = this._config.degree; i >= 0; i--) {\r\n            // Create monom of corresponding degree.\r\n            M = new rndMonom({\r\n                letters: this._config.letters,\r\n                degree: i,\r\n                fraction: this._config.fraction,\r\n                zero: (i === this._config.degree) ? false : this._config.allowNullMonom\r\n            }).generate()\r\n\r\n            // If degree is the greatest and unit is true, set the monom value to one.\r\n            if (this._config.unit && this._config.degree === i) {\r\n                M.coefficient.one()\r\n            }\r\n\r\n            // Add to the polynom\r\n            P.add(M)\r\n        }\r\n\r\n        // Make sure the first monom is positive.\r\n        if(this._config.positive && P.monomByDegree().coefficient.isNegative()){\r\n            P.monomByDegree().coefficient.opposed()\r\n        }\r\n\r\n        // If the number of monoms is greater than the allowed value, remove some of them... except the first one !\r\n        if (this._config.numberOfMonoms > 0 && this._config.numberOfMonoms < P.length) {\r\n            // Get the greatest degree monom\r\n            let M = P.monomByDegree().clone()\r\n            P.monoms = Random.array(P.monoms.slice(1), this._config.numberOfMonoms-1)\r\n            P.add(M).reorder().reduce()\r\n        }\r\n        return P\r\n    }\r\n\r\n    factorable = (): Polynom => {\r\n        let P = new Polynom().one()\r\n\r\n        let _factorableConfig = {...this._config}\r\n        _factorableConfig.degree = 1\r\n        _factorableConfig.factorable = false\r\n\r\n        for(let i=0; i<this._config.degree;i++){\r\n            P.multiply(Random.polynom(_factorableConfig))\r\n        }\r\n\r\n        return P\r\n    }\r\n}","export type tokenType = {\r\n    [key: string]: {\r\n        precedence: number,\r\n        associative: string,\r\n        type: string\r\n    }\r\n}\r\n\r\nexport const tokenConstant: { [Key: string]: number } = {\r\n    pi: Math.PI,\r\n    e: Math.exp(1)\r\n}\r\n\r\nexport enum ShutingyardType {\r\n    VARIABLE = 'variable',\r\n    COEFFICIENT = 'coefficient',\r\n    OPERATION = 'operation',\r\n    CONSTANT = 'constant',\r\n    FUNCTION = 'function',\r\n    MONOM = 'monom'\r\n}\r\n\r\nexport enum ShutingyardMode {\r\n    EXPRESSION = 'expression',\r\n    POLYNOM = 'polynom',\r\n    SET = 'set',\r\n    NUMERIC = 'numeric'\r\n}\r\n\r\nexport type Token = { token: string, tokenType: string }\r\n\r\nexport class Shutingyard {\r\n    readonly _mode: ShutingyardMode;\r\n    private _rpn: Token[] = [];\r\n    private _tokenConfig: tokenType;\r\n    private _tokenConstant: { [Key: string]: number }\r\n    private _tokenKeys: string[]\r\n    private _uniformize: boolean;\r\n\r\n    constructor(mode?: ShutingyardMode) {\r\n        this._mode = typeof mode === 'undefined' ? ShutingyardMode.POLYNOM : mode;\r\n        this.tokenConfigInitialization()\r\n    }\r\n\r\n    // Getter\r\n    get rpn() {\r\n        // console.log(this._rpn)\r\n        return this._rpn;\r\n    }\r\n\r\n    get rpnToken() {\r\n        return this._rpn.map(x => x.token)\r\n    }\r\n\r\n    /**\r\n     * Determin if the token is a defined operation\r\n     * Defined operations: + - * / ^ sin cos tan\r\n     * @param token\r\n     */\r\n    // isOperation(token: string): boolean {\r\n    //     if (token[0].match(/[+\\-*/^]/g)) {\r\n    //         return true;\r\n    //     }\r\n    //     //\r\n    //     // if (token.match(/^sin|cos|tan/g)) {\r\n    //     //     return true;\r\n    //     // }\r\n    //\r\n    //     return false;\r\n    // }\r\n\r\n    tokenConfigInitialization(): tokenType {\r\n        if (this._mode === ShutingyardMode.SET) {\r\n            this._tokenConfig = {\r\n                '&': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '|': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '!': {precedence: 4, associative: 'right', type: ShutingyardType.OPERATION},\r\n                '-': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION}\r\n            }\r\n            this._uniformize = false;\r\n        } else if (this._mode === ShutingyardMode.NUMERIC) {\r\n            this._tokenConfig = {\r\n                '^': {precedence: 4, associative: 'right', type: ShutingyardType.OPERATION},\r\n                '*': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '/': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '+': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '-': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '%': {precedence: 3, associative: 'right', type: ShutingyardType.OPERATION},\r\n                'sin': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'cos': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'tan': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'sqrt': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'nthrt': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'ln': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'log': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n            }\r\n            this._uniformize = false\r\n        } else if (this._mode === ShutingyardMode.EXPRESSION) {\r\n            this._tokenConfig = {\r\n                '^': {precedence: 4, associative: 'right', type: ShutingyardType.OPERATION},\r\n                '*': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '/': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '+': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '-': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '%': {precedence: 3, associative: 'right', type: ShutingyardType.OPERATION},\r\n                'sin': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'cos': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'tan': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'sqrt': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'nthrt': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n            }\r\n            this._uniformize = true\r\n        } else {\r\n            this._tokenConfig = {\r\n                '^': {precedence: 4, associative: 'right', type: ShutingyardType.OPERATION},\r\n                '*': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '/': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '+': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '-': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION},\r\n            }\r\n            this._uniformize = true\r\n        }\r\n\r\n        this._tokenKeys = Object.keys(this._tokenConfig).sort((a, b) => b.length - a.length)\r\n        return this._tokenConfig\r\n    }\r\n\r\n    /**\r\n     * Get the next token to analyse.\r\n     * @param expr (string) Expression to analyse\r\n     * @param start (number) CUrrent position in the expr string.\r\n     */\r\n    NextToken(expr: string, start: number): [string, number, string] {\r\n        let token: string, tokenType: string;\r\n        token = '';\r\n        tokenType = '';\r\n        // Case of parenthesis or comma (generic items)\r\n        if (expr[start] === '(') {\r\n            token = '(';\r\n            tokenType = '(';\r\n        }\r\n        // It's a closing parenthese\r\n        else if (expr[start] === ')') {\r\n            token = ')';\r\n            tokenType = ')';\r\n        }\r\n        // It's an argument separator for a function\r\n        else if (expr[start] === ',') {\r\n            token = ',';\r\n            tokenType = 'function-argument';\r\n        } else {\r\n            // Extract operation and function tokens\r\n            for (let key of this._tokenKeys) {\r\n                if (expr.substring(start, start + key.length) === key) {\r\n                    token += key;\r\n                    tokenType = this._tokenConfig[key].type\r\n                    break\r\n                }\r\n            }\r\n\r\n            // Extract constant\r\n            for (let key in tokenConstant) {\r\n                if (expr.substring(start, start + key.length) === key) {\r\n                    token += key;\r\n                    tokenType = ShutingyardType.CONSTANT\r\n                    break\r\n                }\r\n            }\r\n\r\n            if (token === '') {\r\n                // No function found ! Might be a coefficient !\r\n                if (expr[start].match(/[0-9]/)) {\r\n                    if (this._mode === ShutingyardMode.POLYNOM && false) {\r\n                        token = expr.substring(start).match(/^([0-9.,/]+)/)[0]\r\n                    } else {\r\n                        token = expr.substring(start).match(/^([0-9.]+)/)[0]\r\n                    }\r\n                    tokenType = ShutingyardType.COEFFICIENT\r\n                } else if (expr[start].match(/[a-zA-Z]/)) {\r\n                    token = expr.substring(start).match(/^([a-zA-Z])/)[0]\r\n                    tokenType = ShutingyardType.VARIABLE\r\n                } else {\r\n                    console.log('Unidentified token', expr[start], expr, start)\r\n                    token = expr[start]\r\n                    tokenType = ShutingyardType.MONOM\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        return [token, start + token.length, tokenType];\r\n    }\r\n\r\n    normalize(expr: string): string {\r\n        if(expr.length===1){return expr}\r\n\r\n        // Get the list of function token.\r\n        let fnToken: string[] = [],\r\n            kToken: string[] = []\r\n        for (let token in this._tokenConfig) {\r\n            if (this._tokenConfig[token].type === ShutingyardType.FUNCTION) {\r\n                fnToken.push(token)\r\n            }\r\n        }\r\n        // sort if from the lengthy to the smallest function\r\n        fnToken.sort((a, b) => b.length - a.length)\r\n\r\n        for (let token in tokenConstant) {\r\n                kToken.push(token)\r\n        }\r\n        // sort if from the lengthy to the smallest function\r\n        kToken.sort((a, b) => b.length - a.length)\r\n\r\n\r\n\r\n\r\n        let normalizedExpr: string = \"\",\r\n            i = 0,\r\n            crtToken,\r\n            nextToken\r\n\r\n        while (i < expr.length - 1) {\r\n            // Check if we have a function token.\r\n            // The function MUST have an open parentheses\r\n            let tokenIdx = 0\r\n            while (tokenIdx < fnToken.length) {\r\n                let token = fnToken[tokenIdx]\r\n                if (expr.slice(i, i + token.length + 1) === token + '(') {\r\n                    normalizedExpr += token + '('\r\n                    i += token.length + 1\r\n\r\n                    // Restart the scan for the function token\r\n                    tokenIdx = 0\r\n                } else {\r\n                    // scan for a next function token\r\n                    tokenIdx++\r\n                }\r\n            }\r\n\r\n            // Check for a constant\r\n            tokenIdx = 0\r\n            while (tokenIdx < kToken.length) {\r\n                let token = kToken[tokenIdx]\r\n                if (expr.slice(i, i + token.length) === token) {\r\n                    // We have found a constant.\r\n                    // add it, but with remove the last letter\r\n                    normalizedExpr += token.slice(0, -1)\r\n                    i += token.length-1\r\n\r\n                    // Exit the loop\r\n                    break\r\n                }\r\n                tokenIdx++\r\n            }\r\n\r\n            // The function token are solved.\r\n            crtToken = expr[i]\r\n            nextToken = expr[i + 1]\r\n            normalizedExpr += crtToken\r\n            if (crtToken.match(/[a-zA-Z]/g)) {\r\n                // Current element is a letter.\r\n                // if the next element is a letter, a number or an opening parentheses, add the multiplication sign.\r\n                if (nextToken.match(/[a-zA-Z\\d(]/)) {\r\n                    normalizedExpr += '*'\r\n                }\r\n            } else if (crtToken.match(/\\d/)) {\r\n                // Current element is a number.\r\n                // if the next element is a letter or a parentheses, add the multiplication sign.\r\n                if (nextToken.match(/[a-zA-Z(]/)) {\r\n                    normalizedExpr += '*'\r\n                }\r\n            } else if (crtToken === ')') {\r\n                // Current element is a closing parentheses.\r\n                // if the next element is a letter, a number or an opening parentheses, add the multiplication sign\r\n                if (nextToken.match(/[a-zA-Z\\d(]/)) {\r\n                    normalizedExpr += '*'\r\n                }\r\n            }\r\n\r\n            // Go to next token\r\n            i++\r\n        }\r\n\r\n        // add the last token\r\n        return normalizedExpr + nextToken\r\n    }\r\n\r\n    /**\r\n     * Sanitize an expression by adding missing common operation (multiplication between parentheseses)\r\n     * @param expr\r\n     * @constructor\r\n     */\r\n    Uniformizer(expr: string): string {\r\n        // TODO: Delete this old version\r\n        // Prefere \"normalize\", much more robust !\r\n        // Determiner if need to be uniformized\r\n        if (!this._uniformize) {\r\n            return expr\r\n        }\r\n\r\n        // Generate the list of function token.\r\n        let fnToken: string[] = []\r\n        for (let token in this._tokenConfig) {\r\n            if (this._tokenConfig[token].type === ShutingyardType.FUNCTION) {\r\n                fnToken.push(token)\r\n            }\r\n        }\r\n        // sort if from the lengthy to the smallest function\r\n        fnToken.sort((a, b) => b.length - a.length)\r\n        let tokenRegExp = new RegExp(`(${fnToken.join('|')})`, 'g')\r\n        let functionTokenOrder = Array.from(expr.matchAll(tokenRegExp))\r\n\r\n\r\n        let expr2;\r\n\r\n        // Replace all function by @\r\n        expr2 = expr.replace(tokenRegExp, '@')\r\n        // Add * before @ (functionn)\r\n        expr2 = expr2.replace(/([\\da-zA-Z])(@)/g, \"$1*$2\");\r\n\r\n        // Replace missing multiplication between two parenthese\r\n        expr2 = expr2.replace(/\\)\\(/g, ')*(');\r\n\r\n        // Replace missing multiplication between number or setLetter and parenthese.\r\n\r\n        // 3x(x-4) => 3x*(x-4)\r\n        expr2 = expr2.replace(/([\\da-zA-Z])(\\()/g, \"$1*$2\");\r\n\r\n        // (x-4)3x => (x-4)*3x\r\n        expr2 = expr2.replace(/(\\))([\\da-zA-Z])/g, \"$1*$2\");\r\n\r\n        // Add multiplication between number and letters.\r\n        // 3x => 3*x\r\n        expr2 = expr2.replace(/([0-9])([a-zA-Z])/g, \"$1*$2\");\r\n        expr2 = expr2.replace(/([a-zA-Z])([0-9])/g, \"$1*$2\");\r\n\r\n        // Remove letter between function token and it's parenthese.\r\n        // for (let token of fnToken) {\r\n        //     // Remove\r\n        //     expr2 = expr2.replace(new RegExp(token + '\\\\*', 'g'), token);\r\n        // }\r\n        // Add multiplication between letters ?\r\n        expr2 = expr2.replace(/([a-zA-Z])([a-zA-Z])/g, \"$1*$2\");\r\n        expr2 = expr2.replace(/([a-zA-Z])([a-zA-Z])/g, \"$1*$2\");\r\n\r\n        // Restore operation auto formatting (prevent adding the multiplication star)\r\n        let exprAsArray = expr2.split('@')\r\n\r\n        if (exprAsArray.length > 0) {\r\n            expr2 = \"\"\r\n            for (let idx in exprAsArray) {\r\n            }\r\n            for (let token of fnToken) {\r\n                // Remove\r\n\r\n                // expr2 = expr2.replace(new RegExp(token + '\\\\*', 'g'), token);\r\n            }\r\n        }\r\n\r\n        return expr2;\r\n    }\r\n\r\n    /**\r\n     * Parse an expression using the shutting yard tree algorithms\r\n     * @param expr (string) Expression to analyse\r\n     * Returns a RPN list of items.\r\n     * @param operators\r\n     */\r\n    parse(expr: string, operators?: string[]): Shutingyard {\r\n        let outQueue: { token: string, tokenType: string }[] = [],    // Output queue\r\n            opStack: { token: string, tokenType: string }[] = [],     // Operation queue\r\n            token: string = '',\r\n            tokenPos: number = 0,\r\n            tokenType: string = '',\r\n            previousOpStatckLength = 0\r\n\r\n        // Normalize the input if required.\r\n        if (this._uniformize) expr = this.normalize(expr)\r\n\r\n        let securityLoopLvl1 = 50,\r\n            securityLoopLvl2_default = 50,\r\n            securityLoopLvl2;\r\n\r\n        while (tokenPos < expr.length) {\r\n            securityLoopLvl1--;\r\n            if (securityLoopLvl1 === 0) {\r\n                console.log('SECURITY LEVEL 1 EXIT');\r\n                break;\r\n            }\r\n\r\n            // Get the next token and the corresponding new (ending) position\r\n            [token, tokenPos, tokenType] = this.NextToken(expr, tokenPos);\r\n\r\n            switch (tokenType) {\r\n                case 'monom':\r\n                case 'coefficient':\r\n                case 'variable':\r\n                case 'constant':\r\n                    outQueue.push({\r\n                        token,\r\n                        tokenType\r\n                    });\r\n                    break;\r\n                case 'operation':\r\n                    previousOpStatckLength = opStack.length;\r\n                    //If the token is an operator, o1, then:\r\n                    if (opStack.length > 0) {\r\n                        let opTop = opStack[opStack.length - 1];\r\n\r\n                        securityLoopLvl2 = +securityLoopLvl2_default;\r\n\r\n                        //while there is an operator token o2, at the top of the operator stack and\r\n                        while (opTop.token in this._tokenConfig && (\r\n                                //either o1 is left-associative and its precedence is less than or equal to that of o2,\r\n                                (this._tokenConfig[token].associative === 'left' && this._tokenConfig[token].precedence <= this._tokenConfig[opTop.token].precedence)\r\n                                ||\r\n                                //or o1 is right associative, and has precedence less than that of o2,\r\n                                (this._tokenConfig[token].associative === 'right' && this._tokenConfig[token].precedence < this._tokenConfig[opTop.token].precedence)\r\n                            )\r\n                            ) {\r\n\r\n                            /* Security exit ! */\r\n                            securityLoopLvl2--;\r\n                            if (securityLoopLvl2 === 0) {\r\n                                console.log('SECURITY LEVEL 2 OPERATION EXIT');\r\n                                break;\r\n                            }\r\n\r\n                            // Add the operation to the queue\r\n                            outQueue.push((opStack.pop()) || {token: '', tokenType: 'operation'});\r\n\r\n                            // Get the next operation on top of the Stack.\r\n                            if (opStack.length === 0) {\r\n                                break;\r\n                            }\r\n                            opTop = opStack[opStack.length - 1];\r\n                        }\r\n                    }\r\n                    //at the end of iteration push o1 onto the operator stack\r\n                    opStack.push({token, tokenType});\r\n                    break;\r\n                case 'function-argument':\r\n                    // TODO: check if the opStack exist.\r\n                    securityLoopLvl2 = +securityLoopLvl2_default;\r\n                    while (opStack[opStack.length - 1].token !== '(' && opStack.length > 0) {\r\n                        securityLoopLvl2--;\r\n                        if (securityLoopLvl2 === 0) {\r\n                            console.log('SECURITY LEVEL 2 FUNCTION ARGUMENT EXIT');\r\n                            break;\r\n                        }\r\n\r\n                        outQueue.push((opStack.pop()) || {token, tokenType});\r\n                    }\r\n                    break;\r\n                case '(':\r\n                    opStack.push({token, tokenType});\r\n                    // Add an empty value if next element is negative.\r\n                    if (expr[tokenPos] === '-') {\r\n                        outQueue.push({token: '0', tokenType: 'coefficient'});\r\n                    }\r\n                    break;\r\n                case ')':\r\n                    securityLoopLvl2 = +securityLoopLvl2_default;\r\n                    //Until the token at the top of the stack is a left parenthesis, pop operators off the stack onto the output queue.\r\n                    while (opStack[opStack.length - 1].token !== '(' && opStack.length > 1 /*Maybe zero !? */) {\r\n                        securityLoopLvl2--;\r\n                        if (securityLoopLvl2 === 0) {\r\n                            console.log('SECURITY LEVEL 2 CLOSING PARENTHESE EXIT');\r\n                            break;\r\n                        }\r\n\r\n                        outQueue.push((opStack.pop()) || {token, tokenType});\r\n                    }\r\n\r\n                    //Pop the left parenthesis from the stack, but not onto the output queue.\r\n                    opStack.pop();\r\n                    break;\r\n                case 'function':\r\n                    opStack.push({token, tokenType});\r\n                    break;\r\n                default:\r\n                    // In theory, everything should be handled.\r\n                    console.log(`SHUTING YARD: ${tokenType} : ${token} `);\r\n            }\r\n\r\n            // Output\r\n            // console.log(outQueue.concat(opStack.reverse()).join(\" \"));\r\n        }\r\n\r\n        // console.log(outQueue.concat(opStack.reverse()));\r\n        this._rpn = outQueue.concat(opStack.reverse());\r\n\r\n        return this;\r\n    }\r\n\r\n\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(607);\n"],"names":["ShutingYard","Shutingyard","Numeric","NumExp","Fraction","Root","NthRoot","Monom","Polynom","Equation","LinearSystem","Rational","Logicalset","Random","PolynomExpFactor","PolynomExpProduct","Geometry","Vector","Point","Line","Triangle","Circle","window","Pi","PARTICULAR_SOLUTION","constructor","equations","_varnothing","varnothing","_real","real","hasVariable","letter","this","variables","includes","_randomizeDefaults","degree","parse","equationString","pStr","strSign","_findSign","split","create","_formatSign","console","error","left","right","sign","_left","_right","_sign","clone","randomize","opts","moveLeft","subtract","zero","reorder","allLeft","mMove","m","monoms","isZero","simplify","multiply","lcm","getDenominators","divide","gcd","getNumerators","isolate","isOne","isMultiVariable","cMove","hasLetter","add","opposed","length","coefficient","replaceBy","P","value","F","_reverseSign","invert","max","letters","Set","solve","_solutions","_polynom","_solveDegree1","_solveDegree2","_solveDegree3plus","makeSolutionsUnique","test","values","evaluate","isEqual","log","signStr","undefined","replace","isGreater","indexOf","isStrictEqual","isAlsoEqual","m1","monomByDegree","m0","v","s","d","tex","display","NaN","exact","delta","nthDelta","realX1","realX2","sX1","sX2","aF","bF","cF","denominator","a","b","Math","sqrt","v1","toFixed","v2","reduce","hasRadical","am","bm","tex1","tex2","display1","display2","S1","S2","frac","sol","equ","factorize","factors","forEach","factor","leq","factorAsEquation","solutions","solution","push","isEquation","map","x","join","isReal","isVarnothing","signAsTex","raw","concat","numberOfVars","randomizeDefaults","static","sorted","solutionAsTex","uniqueSolutions","filter","sort","equationStrings","_equations","_findLetters","setCoefficient","coefficients","i","_letters","slice","toString","setLetters","generate","solutionsF","_generateOneEquation","coeff","leftValue","equString","numberSym","_checkIfLinerCombination","mergeEquations","eq1","eq2","factor1","factor2","eq1multiplied","eq2multiplied","E","_resolutionSteps","V","_solveOneLetter","str","isSolvable","equStr","LS","equArray","L","monomByLetter","repeat","_linearReduction","c1","c2","LE","reducedEquations","_rpn","ShutingyardMode","SET","rpn","_rawString","isLogicalset","tokenSets","reference","referenceSet","varStack","key","token","tokenType","second","pop","first","has","vennAB","A","B","vennABC","C","inputStr","_shutingYardToReducedMonom","_coefficient","_literal","copyLiterals","literal","addToken","stack","element","q1","q2","pow","ShutingyardType","COEFFICIENT","VARIABLE","M","one","setLetter","OPERATION","k","makeSame","clean","isSameAs","multiplyByNumber","nb","root","p","isSquare","compare","M1","M2","K","item","isLiteralSquare","isRational","isEven","hasFractionCoefficient","isNotZero","Object","t","n","r","tmpValues","evaluateAsNumeric","derivative","dM","primitive","areSameAs","areEquals","isDivisible","div","isStrictlyPositive","geq","isRelative","literalSqrt","literalStr","matchAll","keys","isNotEqual","dividers","numerator","abs","literals","_getLiteralDividers","monomDividers","N","arr","tmpList","litt","currentLetter","displayWithSign","texWithSign","plotFunction","tfrac","coeffN","coeffD","min","xmultiply","polynomString","mark_as_dirty","dirty_factors","dirty_zeroes","euclidianCache","CONSTANT","MONOM","FUNCTION","_monoms","_factors","_parseString","empty","Number","isSafeInteger","multiplyByPolynom","multiplyByFraction","multiplyByMonom","multiplyByInteger","euclidian","quotient","reminder","maxMP","degreeP","newM","MaxIteration","isPositive","divideByFraction","divideByInteger","cP1","cP2","isOpposedAt","isFactorized","e","polynomStringNormalized","replaceAll","polynomStringReduced","substring","polyFactors","f","isNegativeOne","splice","isReduced","isDeveloped","vars","coeffs","shift","otherLetters","da","db","S","resultPolynom","monom","dP","integrate","valuesA","valuesB","commonMonom","isStrictlyNegative","tempPolynom","securityLoop","maxDegree","allDividers","_getAllPotentialFactors","isDividableBy","result","pX","pC","dX","dC","getZeroes","_zeroes","monomsByDegree","Ms","denominators","numerators","lcmDenominator","gcdDenominator","lcmNumerator","gcdNumerator","limitToInfinity","infinite","limitToNegativeInfinity","m2","m1d","m2d","genDisplay","output","forceSign","wrapParentheses","withAllMultSign","shutingYardToReducedPolynom","nbF","_factorize2ndDegree","P1","P2","c","x1","x2","xyzPolynom","xFactors","_factorizeByGroups","_euclidianCache","_dirty_zeroes","_dirty_factors","zeroes","texString","_texString","texFactors","factorsCount","simpleFactor","displayFactors","trim","isNaN","fractions","_numerator","_denominator","domain","amplify","D","dN","dD","NumeratorEuclidien","DenominatorEuclidien","R","limits","offset","Infinity","theLimit","theSign","evalValues","evalValuesOffset","FR","isInfinity","study","config","RationalStudy","ZEROTYPE","ASYMPTOTE","FUNCTION_EXTREMA","TABLE_OF_SIGNS","ASYMPTOTE_POSITION","fx","makeStudy","makeZeroes","_config","signs","_signs","makeSigns","asymptotes","_asymptotes","makeAsymptotes","_derivative","makeDerivative","variations","_variations","makeVariation","texSigns","texGrows","texVariations","indexOfZero","makeOneLineForSigns","zeroSign","oneLine","currentZero","NOTHING","makeSignsResult","resultLine","index","current","makeGrowsResult","tos","signsAsArray","growsLine","extremes","pos","y","xTex","yTex","pointType","exp","evalY","FLAT","MAX","MIN","type","extr","makeVariationsResult","varsLine","drawCode","code","asymptote","VERTICAL","HORIZONTAL","SLOPE","extreme","ZERO","_makeTexFromTableOfSigns","factorsFx","_name","GROWS","VARIATIONS","name","SIGNS","Study","super","_getZeroes","_getSigns","reduced","DEFENCE","Ztype","HOLE","before","after","position","pm","RB","RT","LB","LT","deltaX","tableOfSign","NDegree","DDegree","H","Htex","_getHorizontalAsymptoteRelativePositon","greater","dx","z","extrema","idx","typeOfTable","denominatorOrPeriodic","isApproximative","isExact","unit","decimal","floor","invalid","Q","xMultiply","controlNumerator","g","compareFraction","lesser","than","isOpposed","isInverted","isNegative","isFinite","isNatural","isOdd","dfrac","average","unique","distinct","reverse","radical","nthroot","_nth","_radical","_isValid","nth","uniformize","_expression","NUMERIC","isValid","expression","_extractDecimalPart","_numberCorrection","epsilon","n9","match","n0","mod0","mod9","_addToStack","tokenConstant","sin","cos","tan","log10","polynom","mathFunction","_degree","_fn","_powerAsInteger","_forceParenthesis","forceParenthesis","fn","powerAsInteger","isCoefficient","firstCoefficient","_texDegree","setForceParenthesis","_positive","_asPositiveDegree","positive","asPositiveDegree","parenthesis","numeratorsAsTex","denominatorsAsTex","polynoms","d1","d2","_integrateWithInternalDerivative","applyMathFunction","mathFn","Pinternal","internalDerivative","relativePosition","distance","distanceTo","center","radius","_squareRadius","lineIntersection","solX","intersectionPoints","_cartesian","equX","lineX","equation","lineY","tangents","_tangentsWithSlope","isPointOnCircle","_tangentsThroughOnePointOnTheCircle","_tangentsThroughOnePointOutsideTheCircle","getPointsOnCircle","numberIsInteger","pt","triplets","pythagoricianTripletsWithTarget","points","triplet","isInListOfPoints","CT","_center","LinePropriety","Perpendicular","cx_px","cy_py","polyLeft","polyRight","squareRadius","h","slope","sq","_exists","cartesian","exists","cx","cy","developed","_calculateCartesian","_reset","_parseEquation","_parseCopyCircle","_parseThroughtThreePoints","_parseCenterAndPointThrough","_parseCenterAndRadius","circle","square","pointThrough","normSquare","y1","y2","T","mAB","remarquables","mediators","AB","mAC","AC","intersection","point","parseEquation","parseByPointAndVector","parseByPointAndNormal","parseByCoefficient","Parallel","parseByPointAndLine","elem","delete","size","_a","_b","_c","_d","_OA","_n","normal","orientation","director","isParellelTo","line","height","isVertical","simplifyDirection","Pt","isParallel","isSame","hasIntersection","getValueAtX","getValueAtY","canonical","mxh","OA","parametric","pmatrix","fraction","hitSegment","iPt","canonicalAsFloatCoefficient","decimals","PERPENDICULAR","PARALLEL","PointXY","_x","_y","xy","origin","middleOf","texValues","numberOfDigits","pts","norm","list","_lines","intersect","_B","_C","_A","_updateTriangle","BC","_middles","_remarquables","_calculateRemarquableLines","getPointByName","ptName","toUpperCase","getSegment","ptName1","ptName2","_calculateBisectors","medians","heights","bisectors","tlines","lines","b1","b2","BA","CB","CA","isRectangle","isNormalTo","isEquilateral","isIsocele","reset","components","scalarProductWithVector","multiplyByScalar","scalar","divideByScalar","angleWith","sharp","radian","toDegree","PI","acos","scalarProduct","round","primesValues","maxV","gcd2","target","targetIsSquare","targetValue","u","epsilonDigit","epsilonNumberOfDigits","number_of_digits","extractDecimalPart","valueToExtract","decimalLength","rndPolynom","rndMonom","rndFraction","number","from","to","rndHelpers","randomInt","allowZero","randomIntSym","prime","randomPrime","bool","percent","randomBool","array","randomArray","randomItem","shuffle","shuffleArray","mergeConfig","defaultConfig","_defaultConfig","randomCore","userConfig","negative","natural","securityCount","random","primes","j","temp","factorable","allowNullMonom","numberOfMonoms","_factorableConfig","pi","mode","_mode","POLYNOM","tokenConfigInitialization","rpnToken","_tokenConfig","precedence","associative","_uniformize","EXPRESSION","_tokenKeys","NextToken","expr","start","normalize","fnToken","kToken","crtToken","nextToken","normalizedExpr","tokenIdx","Uniformizer","expr2","tokenRegExp","RegExp","Array","exprAsArray","operators","outQueue","opStack","tokenPos","previousOpStatckLength","securityLoopLvl2","securityLoopLvl1","opTop","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call"],"sourceRoot":""}