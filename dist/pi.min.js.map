{"version":3,"file":"pi.min.js","mappings":"mDAAA,eACA,SACA,SACA,SACA,SACA,SACA,SACA,QACA,SACA,SACA,SACA,SACA,QACA,SACA,OACA,SACA,SACA,SAGa,IAAS,CAClBA,YAAa,EAAAC,YACbC,QAAS,EAAAA,QACTC,OAAQ,EAAAA,OACRC,SAAU,EAAAA,SACVC,KAAM,EAAAC,QACNC,MAAO,EAAAA,MACPC,QAAS,EAAAA,QACTC,SAAU,EAAAA,SACVC,aAAc,EAAAA,aACdC,SAAU,EAAAA,SACVC,WAAY,EAAAA,WACZC,OAAQ,EAAAA,OACRC,iBAAkB,EAAAA,iBAClBC,kBAAmB,EAAAA,kBACnBC,SAAU,CACNC,OAAQ,EAAAA,OACRC,MAAO,EAAAA,MACPC,KAAM,EAAAA,KACNC,SAAU,EAAAA,SACVC,OAAQ,EAAAA,SAGVC,OAAQC,GAAK,K,uGC3CnB,cAEA,SACA,SACA,SAWA,IAAYC,GAAZ,SAAYA,GACR,qBACA,4BAFJ,CAAYA,EAAA,EAAAA,sBAAA,EAAAA,oBAAmB,KAK/B,MAAaf,EAYTgB,eAAeC,GAMX,GAdI,KAAAC,YAAsBH,EAAoBI,WAC1C,KAAAC,MAAgBL,EAAoBM,KAmJpC,KAAAC,mBAAmE,CACvEC,OAAQ,GAYZ,KAAAC,MAASC,IACL,IAAIC,EAAgBC,EAIpB,GAFAA,EAAUC,KAAKC,UAAUJ,IAET,IAAZE,EAQJ,OAFAD,EAAOD,EAAeK,MAAMH,GAErBC,KAAKG,OAAO,IAAI,EAAAhC,QAAQ2B,EAAK,IAAK,IAAI,EAAA3B,QAAQ2B,EAAK,IAAKE,KAAKI,YAAYL,IAP5EM,QAAQC,MAAM,8CAUtB,KAAAH,OAAS,CAACI,EAAeC,EAAgBC,KACrCT,KAAKU,MAAQH,EACbP,KAAKW,OAASH,EACdR,KAAKY,MAAQZ,KAAKI,YAAYK,GACvBT,MAGX,KAAAa,MAAQ,KACG,IAAIzC,GAAW+B,OAAOH,KAAKU,MAAMG,QAASb,KAAKW,OAAOE,QAASb,KAAKY,MAAQ,IAMvF,KAAAE,UAAY,CAACC,EAAWN,KAEb,IAAIrC,GAAW+B,OAAO,IAAI,EAAAhC,QAAW,IAAI,EAAAA,QAAWsC,GAO/D,KAAAO,SAAW,KACPhB,KAAKU,MAAQV,KAAKU,MAAMG,QAAQI,SAASjB,KAAKW,QAC9CX,KAAKW,OAAOO,OACLlB,MAGX,KAAAmB,QAAWC,IAMP,GAHApB,KAAKU,MAAMO,SAASjB,KAAKW,QACzBX,KAAKW,OAAOO,OAERE,EACA,OAAOpB,KAAKgB,WAEhB,IAAIK,EACJ,IAAK,IAAIC,KAAKtB,KAAKU,MAAMa,OACjBD,EAAE3B,SAAS6B,WACXH,EAAQC,EAAET,QACVb,KAAKU,MAAMO,SAASI,GACpBrB,KAAKW,OAAOM,SAASI,IAO7B,OAFArB,KAAKU,MAAMS,UACXnB,KAAKW,OAAOQ,UACLnB,MAMX,KAAAyB,SAAW,KACPzB,KAAK0B,SAAS,EAAA7D,QAAQ8D,OAAO3B,KAAKU,MAAMkB,qBAAsB5B,KAAKW,OAAOiB,oBAC1E5B,KAAK6B,OAAO,EAAAhE,QAAQiE,OAAO9B,KAAKU,MAAMqB,mBAAoB/B,KAAKW,OAAOoB,kBAC/D/B,MAWX,KAAAgC,QAAWC,IAKP,IAAKjC,KAAKL,OAAOsC,GAAQC,QACrB,OAAO,EAKX,GAAIlC,KAAKmC,kBACL,OAAO,EAIX,IAAId,EAAce,EAElBpC,KAAKU,MAAMO,SAASjB,KAAKW,QACzBX,KAAKW,OAAOO,OACZ,IAAK,IAAII,KAAKtB,KAAKU,MAAMa,OAChBD,EAAEe,UAAUJ,KACbZ,EAAQC,EAAET,QACVb,KAAKU,MAAM4B,IAAIjB,EAAMR,QAAQ0B,WAC7BvC,KAAKW,OAAO2B,IAAIjB,EAAMR,QAAQ0B,YAKtC,OAA0B,IAAtBvC,KAAKU,MAAM8B,SAGfJ,EAAQpC,KAAKU,MAAMa,OAAO,GAAGkB,YAAY5B,QACzCb,KAAKU,MAAMmB,OAAOO,GAClBpC,KAAKW,OAAOkB,OAAOO,GACZpC,OAGX,KAAA0C,UAAY,CAACT,EAAgBU,KACzB3C,KAAKU,MAAMgC,UAAUT,EAAQU,GAC7B3C,KAAKW,OAAO+B,UAAUT,EAAQU,GACvB3C,MAOX,KAAA0B,SAAYkB,IAGR,IAAIC,EAAc,IAAI,EAAA9E,SAAS6E,GAW/B,OARA5C,KAAKU,MAAMgB,SAASmB,GACpB7C,KAAKW,OAAOe,SAASmB,GAGF,MAAf7C,KAAKY,QAA+B,IAAdiC,EAAEpC,QACxBT,KAAK8C,eAGF9C,MAiBX,KAAA6B,OAAUe,IAEN,IAAIC,EAAc,IAAI,EAAA9E,SAAS6E,GAE/B,OAAIC,EAAErB,SACKxB,KAEAA,KAAK0B,SAASmB,EAAEE,WAQ/B,KAAApD,OAAUsC,GACC,EAAAlE,SAASiF,IAAIhD,KAAKU,MAAMf,OAAOsC,GAASjC,KAAKW,OAAOhB,OAAOsC,IAMtE,KAAAE,gBAAkB,IACPnC,KAAKU,MAAMyB,iBAAmBnC,KAAKW,OAAOwB,gBAGrD,KAAAc,QAAU,IAEC,IAAI,IAAIC,IAAI,IAAIlD,KAAKU,MAAMuC,aAAcjD,KAAKW,OAAOsC,aAQhE,KAAAE,MAAQ,KAQJ,OANAnD,KAAKoD,WAAa,GAIlBpD,KAAKqD,SAAWrD,KAAKU,MAAMG,QAAQI,SAASjB,KAAKW,QAEzCX,KAAKqD,SAAS1D,SAASiD,OAC3B,KAAK,EACL,KAAK,EACD5C,KAAKsD,gBACL,MACJ,KAAK,EACDtD,KAAKuD,gBACL,MACJ,QACIvD,KAAKwD,oBAKb,OADAxD,KAAKoD,WAAahF,EAASqF,oBAAoBzD,KAAKoD,YAC7CpD,MAoBX,KAAA0D,KAAQC,GACG3D,KAAKO,KAAKqD,SAASD,GAAQE,QAAQ7D,KAAKQ,MAAMoD,SAASD,IAG1D,KAAA1D,UAAaJ,GAGbA,EAAeiE,SAAS,OAChBjE,EAAeiE,SAAS,SAAY,QAAU,MAC/CjE,EAAeiE,SAAS,OACvBjE,EAAeiE,SAAS,SAAY,QAAU,MAC/CjE,EAAeiE,SAAS,MACxB,KACAjE,EAAeiE,SAAS,MACxB,KACAjE,EAAeiE,SAAS,KACxB,IACAjE,EAAeiE,SAAS,MACxB,KACAjE,EAAeiE,SAAS,MACxB,KACAjE,EAAeiE,SAAS,KACxB,IACAjE,EAAeiE,SAAS,KACxB,KAGPzD,QAAQ0D,IAAI,4CACL,GAOP,KAAA3D,YAAe4D,QACHC,IAAZD,EACO,IAGPA,EAAQF,SAAS,QAEVE,EAAQF,SAAS,OAEjBE,EAAQF,SAAS,MAHjB,KAKAE,EAAQF,SAAS,KACjB,IACAE,EAAQF,SAAS,QAEjBE,EAAQF,SAAS,OAEjBE,EAAQF,SAAS,MAHjB,KAKAE,EAAQF,SAAS,KACjB,IAEA,IAIP,KAAAhB,aAAe,IACA,MAAf9C,KAAKY,MACEZ,KAGPA,KAAKY,MAAMkD,SAAS,MACpB9D,KAAKY,MAAMsD,QAAQ,IAAK,KACjBlE,MAEPA,KAAKY,MAAMkD,SAAS,MACpB9D,KAAKY,MAAMsD,QAAQ,IAAK,KACjBlE,MAGJA,KAGH,KAAAmE,UAAY,KACiB,IAA7BnE,KAAKY,MAAMwD,QAAQ,OAGe,IAA/BpE,KAAKY,MAAMwD,QAAQ,OAItB,KAAAC,cAAgB,IACE,MAAfrE,KAAKY,MAGR,KAAA0D,YAAc,KACe,IAA7BtE,KAAKY,MAAMwD,QAAQ,OAGY,IAA/BpE,KAAKY,MAAMwD,QAAQ,SAGY,IAA/BpE,KAAKY,MAAMwD,QAAQ,aAAvB,EAKI,KAAAd,cAAiBrB,IACrB,MAAMsC,EAAKvE,KAAKqD,SAASmB,cAAc,EAAGvC,GAAQQ,YAC9CgC,EAAKzE,KAAKqD,SAASmB,cAAc,EAAGvC,GAAQQ,YAC5CiC,EAAID,EAAG5D,QAAQ0B,UAAUV,OAAO0C,GACpC,IAAII,EAqDJ,OAnDI3E,KAAKqE,gBACY,IAAbE,EAAG3B,MAEc,IAAb6B,EAAG7B,MACH5C,KAAKoD,WAAa,CAAC,CACfwB,IAAK5E,KAAKR,MACVoD,MAAOiC,IACPC,OAAO,IAGX9E,KAAKoD,WAAa,CAAC,CACfwB,IAAK5E,KAAKV,YACVsD,MAAOiC,IACPC,OAAO,IAIf9E,KAAKoD,WAAa,CAAC,CACfwB,IAAKF,EAAEE,IACPhC,MAAO8B,EAAE9B,MACTkC,MAAOJ,KAQPC,EAHS,IAAbJ,EAAG3B,MAEc,IAAb6B,EAAG7B,OAAe5C,KAAKsE,cACnB,cAEAG,EAAG7B,MAAQ,EACP5C,KAAKmE,YAAcnE,KAAKR,MAAQQ,KAAKV,YAEpCU,KAAKmE,YAA2BnE,KAAKV,YAAlBU,KAAKR,MAKhCQ,KAAKmE,aAA6B,IAAdI,EAAG9D,SAAmBT,KAAKmE,cAA8B,IAAfI,EAAG9D,OAC9D,SAAST,KAAKsE,cAAgB,MAAQ,QAAQI,uBAE9C,qBAAqBA,cAAc1E,KAAKsE,cAAgB,MAAQ,QAG5EtE,KAAKoD,WAAa,CAAC,CACfwB,IAAKD,EACL/B,MAAOiC,IACPC,OAAO,KAIR9E,KAAKoD,YAGR,KAAAG,cAAiBtB,IACrB,IAGI8C,EAAeC,EAKfC,EAAgBC,EAChBC,EAAaC,EATbC,EAAKrF,KAAKqD,SAASmB,cAAc,EAAGvC,GAAQQ,YAC5C6C,EAAKtF,KAAKqD,SAASmB,cAAc,EAAGvC,GAAQQ,YAC5C8C,EAAKvF,KAAKqD,SAASmB,cAAc,EAAGvC,GAAQQ,YAE5Cd,EAAM,EAAA9D,QAAQ8D,IAAI0D,EAAGG,YAAaF,EAAGE,YAAaD,EAAGC,aACrDC,EAAIJ,EAAG3D,SAASC,GAAKiB,MACrB8C,EAAIJ,EAAG5D,SAASC,GAAKiB,MAOzB,GAFAmC,EAAQW,EAAIA,EAAI,EAAID,EAJZF,EAAG7D,SAASC,GAAKiB,MAMrBmC,EAAQ,EAIR,GAHAE,IAAWS,EAAIC,KAAKC,KAAKb,KAAW,EAAIU,GACxCP,IAAWQ,EAAIC,KAAKC,KAAKb,KAAW,EAAIU,GAEpCV,EAAQ,IAER/E,KAAKoD,WAAa,CACd,CACIwB,OAAQc,EAAIC,KAAKC,KAAKb,KAAW,EAAIU,IAAII,QAAQ,GACjDjD,MAAOqC,EACPH,OAAO,GAEX,CACIF,OAAQc,EAAIC,KAAKC,KAAKb,KAAW,EAAIU,IAAII,QAAQ,GACjDjD,MAAOsC,EACPJ,OAAO,SAKf,GADAE,EAAW,IAAI,EAAA/G,QAAQ8G,GAAOe,SAC1Bd,EAASe,aAAc,CAIvB,IAAIjE,EAAM,EAAAjE,QAAQiE,IAAI4D,EAAG,EAAID,EAAGT,EAASvC,aACzCuC,EAASvC,YAAcuC,EAASvC,YAAcX,EAMtC9B,KAAKoD,WAFH,IAANsC,EACI,EAAID,EAAI3D,GAAQ,EACE,CACd,CACI8C,IAAK,IAAIc,EAAI5D,OAASkD,EAASJ,MAC/BhC,MAAOqC,EACPH,OAAO,GAEX,CACIF,IAAK,IAAIc,EAAI5D,OAASkD,EAASJ,MAC/BhC,MAAOsC,EACPJ,OAAO,IAKG,CACd,CACIF,IAAK,YAAYc,EAAI5D,OAASkD,EAASJ,UAAU,EAAIa,EAAI3D,MACzDc,MAAOqC,EACPH,OAAO,GAEX,CACIF,IAAK,YAAYc,EAAI5D,OAASkD,EAASJ,UAAU,EAAIa,EAAI3D,MACzDc,MAAOsC,EACPJ,OAAO,IAKf,EAAIW,EAAI3D,GAAQ,EACE,CACd,CACI8C,IAAK,KAAKI,EAASJ,MACnBhC,MAAOqC,EACPH,OAAO,GAEX,CACIF,IAAK,GAAGI,EAASJ,MACjBhC,MAAOsC,EACPJ,OAAO,IAIG,CACd,CACIF,IAAK,aAAaI,EAASJ,UAAU,EAAIa,EAAI3D,MAC7Cc,MAAOqC,EACPH,OAAO,GAEX,CACIF,IAAK,WAAWI,EAASJ,UAAU,EAAIa,EAAI3D,MAC3Cc,MAAOsC,EACPJ,OAAO,QAKpB,CAEH,MAAMkB,EAAK,IAAI,EAAAjI,UAAU2H,EAAIV,EAASvC,YAAa,EAAIgD,GAAGK,SACtDG,EAAK,IAAI,EAAAlI,UAAU2H,EAAIV,EAASvC,YAAa,EAAIgD,GAAGK,SACxD9F,KAAKoD,WAAa,CACd,CACIwB,IAAKoB,EAAGE,MACRtD,MAAOqC,EACPH,MAAOkB,GAEX,CACIpB,IAAKqB,EAAGC,MACRtD,MAAOsC,EACPJ,MAAOmB,SAMpB,GAAc,IAAVlB,EAAa,CACpB,MAAMoB,EAAM,IAAI,EAAApI,UAAU2H,EAAG,EAAID,GAAGK,SACpC9F,KAAKoD,WAAa,CAAC,CACfwB,IAAKuB,EAAID,MACTtD,MAAOuD,EAAIvD,MACXkC,MAAOqB,SAGXnG,KAAKoD,WAAa,CAAC,CACfwB,IAAK5E,KAAKV,YACVsD,MAAOiC,IACPC,OAAO,IAmEf,OA9DK9E,KAAKqE,kBACyB,IAA3BrE,KAAKoD,WAAWZ,QAChB2C,EAAOF,EAASC,EAAUlF,KAAKoD,WAAW,GAAGwB,IAAM5E,KAAKoD,WAAW,GAAGwB,IACtEQ,EAAOH,EAASC,EAAUlF,KAAKoD,WAAW,GAAGwB,IAAM5E,KAAKoD,WAAW,GAAGwB,IAEjE5E,KAAKmE,aAA6B,IAAdkB,EAAG5E,SAAmBT,KAAKmE,cAA8B,IAAfkB,EAAG5E,OAClET,KAAKoD,WAAa,CAAC,CACfwB,IAAK,qBAAqBO,WAAanF,KAAKsE,cAAgB,IAAM,mBAAmBtE,KAAKsE,cAAgB,IAAM,MAAMc,qBACtHxC,MAAOiC,IACPC,OAAO,IAIX9E,KAAKoD,WAAa,CAAC,CACfwB,IAAK,SAAS5E,KAAKsE,cAAgB,IAAM,MAAMa,OAASC,WAAapF,KAAKsE,cAAgB,IAAM,MAChG1B,MAAOiC,IACPC,OAAO,KAGmB,IAA3B9E,KAAKoD,WAAWZ,QAAgBxC,KAAKoD,WAAW,GAAGwB,MAAQ5E,KAAKV,YAClEU,KAAKsE,eAgBDtE,KAAKmE,aAA6B,IAAdkB,EAAG5E,SAAmBT,KAAKmE,cAA8B,IAAfkB,EAAG5E,UAClET,KAAKoD,WAAa,CAAC,CACfwB,IAAK5E,KAAKR,MACVoD,MAAOiC,IACPC,OAAO,KAnBV9E,KAAKmE,aAA6B,IAAdkB,EAAG5E,SAAmBT,KAAKmE,cAA8B,IAAfkB,EAAG5E,OAClET,KAAKoD,WAAa,CAAC,CACfwB,IAAK,qBAAqB5E,KAAKoD,WAAW,GAAGwB,4BAA4B5E,KAAKoD,WAAW,GAAGwB,uBAC5FhC,MAAOiC,IACPC,OAAO,IAIX9E,KAAKoD,WAAa,CAAC,CACfwB,IAAK5E,KAAKV,YACVsD,MAAOiC,IACPC,OAAO,IAef9E,KAAKmE,YACLnE,KAAKoD,WAAa,CAAC,CACfwB,IAAmB,IAAdS,EAAG5E,OAAeT,KAAKR,MAAQQ,KAAKV,YACzCsD,MAAOiC,IACPC,OAAO,IAGX9E,KAAKoD,WAAa,CAAC,CACfwB,KAAoB,IAAfS,EAAG5E,OAAgBT,KAAKR,MAAQQ,KAAKV,YAC1CsD,MAAOiC,IACPC,OAAO,KAKhB9E,KAAKoD,YAGR,KAAAI,kBAAqBvB,IAIzB,IAAImE,EAAMpG,KAAKa,QAAQG,WAmBvB,OAlBAoF,EAAI7F,KAAK8F,YAETrG,KAAKoD,WAAa,GAElBgD,EAAI7F,KAAK+F,QAAQC,SAAQC,IACrB,GAAGA,EAAO7G,OAAOsC,GAAQwE,IAAI,GAAI,CAC7B,IAAIC,EAAmB,IAAItI,EAASoI,EAAQ,GAC5CE,EAAiBvD,QACjBuD,EAAiBC,UAAUJ,SAAQK,IAC/B5G,KAAKoD,WAAWyD,KAAKD,WAGzBvG,QAAQ0D,IAAIyC,EAAO5B,IAAK,0DAMzB5E,KAAKoD,YA5wBZpD,KAAKU,OAAQ,IAAI,EAAAvC,SAAU+C,OAC3BlB,KAAKW,QAAS,IAAI,EAAAxC,SAAU+C,OAC5BlB,KAAKY,MAAQ,IAEY,IAArBvB,EAAUmD,OAAc,CACxB,GAAInD,EAAU,aAAcjB,EACxB,OAAOiB,EAAU,GAAGwB,QACW,iBAAjBxB,EAAU,IACxBW,KAAKJ,MAAMP,EAAU,QAEtB,IAAyB,IAArBA,EAAUmD,OAcjB,OAAOxC,KAbHX,EAAU,aAAc,EAAAlB,QACxB6B,KAAKO,KAAOlB,EAAU,GAAGwB,QACM,iBAAjBxB,EAAU,KACxBW,KAAKO,KAAO,IAAI,EAAApC,QAAQkB,EAAU,KAGlCA,EAAU,aAAc,EAAAlB,QACxB6B,KAAKQ,MAAQnB,EAAU,GAAGwB,QACK,iBAAjBxB,EAAU,KACxBW,KAAKQ,MAAQ,IAAI,EAAArC,QAAQkB,EAAU,KAO3C,OAAOW,KAKPO,WACA,OAAOP,KAAKU,MAGZH,SAAKqC,GACL5C,KAAKU,MAAQkC,EAKbpC,YACA,OAAOR,KAAKW,OAMZH,UAAMoC,GACN5C,KAAKW,OAASiC,EAKdnC,WACA,OAAOT,KAAKY,MAGZH,SAAKmC,GAEL5C,KAAKY,MAAQZ,KAAKI,YAAYwC,GAM9B+D,gBACA,OAAO3G,KAAKoD,WAGZ0D,iBACA,OAAO,EAGPF,eACA,OAA+B,IAA3B5G,KAAKoD,WAAWZ,QAGZxC,KAAKoD,WAAW,GAAGwB,MAAQ5E,KAAKR,OAC7BQ,KAAKoD,WAAW,GAAGwB,MAAQ5E,KAAKV,cAChCU,KAAKoD,WAAW,GAAGwB,IAAId,SAAS,UAKpC,eAAe9D,KAAKoD,WAAW2D,KAAIC,GAAKA,EAAEpC,MAAKqC,KAAK,gBAFhD,OAAOjH,KAAKoD,WAAW,KAKlC8D,aAIA,YAHwBjD,IAApBjE,KAAKoD,YACLpD,KAAKmD,QAEFnD,KAAKoD,WAAW,GAAGwB,MAAQ5E,KAAKR,MAGvC2H,mBAIA,YAHwBlD,IAApBjE,KAAKoD,YACLpD,KAAKmD,QAEFnD,KAAKoD,WAAW,GAAGwB,MAAQ5E,KAAKV,YAGvC8H,gBACA,MAAmB,OAAfpH,KAAKY,OAAiC,OAAfZ,KAAKY,OAAiC,QAAfZ,KAAKY,MAC5C,QAEQ,OAAfZ,KAAKY,OAAiC,OAAfZ,KAAKY,OAAiC,QAAfZ,KAAKY,MAC5C,QAEJZ,KAAKY,MAGZgE,UACA,MAAO,GAAG5E,KAAKU,MAAMkE,MAAM5E,KAAKoH,YAAYpH,KAAKW,OAAOiE,MAGxDyC,cACA,MAAO,GAAGrH,KAAKU,MAAM2G,UAAUrH,KAAKoH,YAAYpH,KAAKW,OAAO0G,UAG5DC,UACA,MAAO,GAAGtH,KAAKU,MAAM4G,MAAMtH,KAAKoH,YAAYpH,KAAKW,OAAO2G,MAGxDC,gBACA,MAAO,IAAI,IAAIrE,IAAIlD,KAAKW,OAAO4G,UAAUC,OAAOxH,KAAKU,MAAM6G,aAG3DE,mBACA,OAAOzH,KAAKuH,UAAU/E,OAYtBkF,wBACA,OAAO1H,KAAKN,mBAGZgI,sBAAkB9E,GAClB5C,KAAKN,mBAAqBkD,EAsO9B+E,2BAA2BhB,EAAwBiB,GAC/C,IAAIC,EAAyB,GACzBC,EAAkBnB,EAAUoB,QAAO5B,IAC3B0B,EAAc/D,SAASqC,EAAIvB,OAC3BiD,EAAchB,KAAKV,EAAIvB,MAChB,KASnB,OAHY,IAATgD,GACCE,EAAgBE,MAAK,CAACvC,EAAGC,IAAID,EAAE7C,MAAM8C,EAAE9C,QAEpCkF,GArZf,c,qFCpBA,eACA,QAEA,SACA,SAGA,MAAazJ,EAMTe,eAAe6I,GAQX,OA2GJ,KAAArI,MAAQ,IAAIP,KACRW,KAAKkI,WAAa7I,EAAU0H,KAAInE,GAAS,IAAI,EAAAxE,SAASwE,KACtD5C,KAAKmI,eACEnI,MAGX,KAAAoI,eAAiB,IAAIC,KAEjBrI,KAAKkI,WAAa,GAElB,IAAII,EAAI,EACR,KAAOA,EAAID,EAAa7F,OAASxC,KAAKuI,SAAS/F,QAAQ,CACnD,IAAIjC,GAAO,IAAI,EAAApC,SAAUyB,MAAMI,KAAKuI,SAAStB,KAAK,OAAQoB,EAAaG,MAAMF,EAAGA,EAAItI,KAAKuI,SAAS/F,SAC9FhC,EAAQ,IAAI,EAAArC,QAAQkK,EAAaC,EAAItI,KAAKuI,SAAS/F,QAAQiG,YAC3DrC,GAAM,IAAI,EAAAhI,UAAW+B,OAAOI,EAAMC,GACtCR,KAAKkI,WAAWrB,KAAKT,EAAIvF,SAEzByH,EAAIA,EAAItI,KAAKuI,SAAS/F,OAAS,EAEnC,OAAOxC,MAGX,KAAAa,MAAQ,KACG,IAAIxC,GAAeuB,SAASI,KAAKkI,WAAWnB,KAAIX,GAAOA,EAAIvF,WAGtE,KAAA6H,WAAa,IAAIzF,KACbjD,KAAKuI,SAAWtF,EACTjD,MAEH,KAAAmI,aAAe,KAEnB,IAAIZ,EAAY,IAAIrE,IAEpB,IAAK,IAAIkD,KAAOpG,KAAKkI,WACjBX,EAAY,IAAIrE,IAAI,IAAIqE,KAAcnB,EAAImB,YAM9C,OADAvH,KAAKuI,SAAW,IAAIhB,GACbvH,MAMX,KAAA2I,SAAW,IAAIhC,KACX,IAAIiC,EAAyB,GAG7B,IAAK,IAAIjE,KAAKgC,EACO,iBAANhC,EACPiE,EAAW/B,KAAK,IAAI,EAAA9I,SAAS4G,EAAE8D,aAE/BG,EAAW/B,KAAKlC,EAAE9D,SAK1Bb,KAAKkI,WAAa,GAClB,IAAK,IAAII,EAAI,EAAGA,EAAI3B,EAAUnE,OAAQ8F,IAClCtI,KAAKkI,WAAWrB,KAAK7G,KAAK6I,wBAAwBD,IAEtD,OAAO5I,MAEH,KAAA6I,qBAAuB,IAAIlC,KAC/B,IAE4BP,EAFxB0C,EAAkB,GAAIC,GAAsB,IAAI,EAAAhL,UAAWmD,OAC3D+B,EAAoB,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAC/G+F,EAAoB,GACxB,IAAK,IAAIV,EAAI,EAAGA,EAAI3B,EAAUnE,OAAQ8F,IAClCQ,EAAMjC,KAAK,EAAArI,OAAOyK,UAAU,IAC5BF,EAAUzG,IAAIqE,EAAU2B,GAAGzH,QAAQa,SAASoH,EAAMR,KAClDU,GAAa,GAAIF,EAAMR,GAAK,EAAKQ,EAAMR,GAAK,IAAMQ,EAAMR,KAAKrF,EAAQqF,KAWzE,OAJAlC,EAAM,IAAI,EAAAhI,SAAS,GAAG4K,KAAaD,EAAU1B,WACM,GAA/CjB,EAAI5F,MAAMe,OAAO,GAAGkB,YAAY+C,aAChCY,EAAI1E,SAAS,IAAI,EAAA3D,SAASqI,EAAI5F,MAAMe,OAAO,GAAGkB,YAAY+C,YAAa,IAEvExF,KAAKkJ,yBAAyB9C,GACvBA,EAEApG,KAAK6I,wBAAwBlC,IAiB5C,KAAAwC,eAAiB,CAACC,EAAeC,EAAeC,EAAkBC,KAG9D,IAAIC,EAAgBJ,EAAIvI,QAAQa,SAAS,IAAI,EAAA3D,SAASuL,IAClDG,EAAgBJ,EAAIxI,QAAQa,SAAS,IAAI,EAAA3D,SAASwL,IAMtD,OAHAC,EAAcjJ,KAAK+B,IAAImH,EAAclJ,MACrCiJ,EAAchJ,MAAM8B,IAAImH,EAAcjJ,OAE/BgJ,GAOX,KAAArI,QAAU,KACN,IAAK,IAAIuI,KAAK1J,KAAKkI,WACfwB,EAAEvI,UAEN,OAAOnB,MAGX,KAAAmD,MAAQ,KAEJnD,KAAKoD,WAAa,GAClBpD,KAAK2J,iBAAmB,GAGxB3J,KAAKmB,UAGL,IAAIyI,EAAI5J,KAAKuH,UAAUS,OAEvB,IAAK,IAAI/F,KAAU2H,EACf5J,KAAKoD,WAAWnB,GAAUjC,KAAK6J,gBAAgB5H,EAAQ2H,GAI3D,OAAO5J,MAGH,KAAAkJ,yBAA4B9C,IAEzB,EA8CX,KAAArC,IAAM,KACF,IAAI+F,EAAc,GAElB,IAAK,IAAIJ,KAAK1J,KAAKkI,WACf7H,QAAQ0D,IAAI2F,EAAE9E,KACdkF,GAAO,GAAGJ,EAAE9E,UAGhB,OAAOkF,GA7TP9J,KAAKkI,WAAa,GAClBlI,KAAKuI,SAAW,KAAKrI,MAAM,SAEH+D,IAApBgE,GAAiCA,EAAgBzF,OAAS,GAC1DxC,KAAKJ,SAASqI,GAGXjI,KAMPX,gBACA,OAAOW,KAAKkI,WAGZ7I,cAAUuD,GACV5C,KAAKkI,WAAatF,EAGlBK,cACA,OAAOjD,KAAKuI,SAAStB,KAAK,IAG1BhE,YAAQL,GACR5C,KAAKuI,SAAW3F,EAAM1C,MAAM,IAG5B6J,iBAIA,OAHQ/J,KAAKuH,UAGP/E,SAAWxC,KAAKkI,WAAW1F,OASjC+E,gBACA,IAAIqC,EAAc,GAClB,IAAK,IAAIF,KAAK1J,KAAKkI,WACf0B,EAAIA,EAAEpC,OAAOkC,EAAEnC,WAEnB,MAAO,IAAI,IAAIrE,IAAI0G,IAAI5B,OAGvBpD,UAKA,IAEIoF,EAEA1I,EAJA2I,EAAKjK,KAAKa,QAAQM,UAClB8B,EAAUgH,EAAG1C,UAEb2C,EAAqB,GAIzB,IAAK,IAAI9D,KAAO6D,EAAG5K,UAAW,CAC1B2K,EAAS,GACT,IAAK,IAAIG,KAAKlH,EACV3B,EAAI8E,EAAI7F,KAAK6J,cAAcD,GAEL,IAAlBH,EAAOxH,OACPwH,EAAOnD,KAAKvF,EAAEE,SAAW,GAAKF,EAAEsD,KAEhCoF,EAAOnD,KAAKvF,EAAEE,SAAW,IAAgC,IAAzBF,EAAEmB,YAAYhC,OAAgB,IAAM,IAAMa,EAAEsD,KAKpFoF,EAAOnD,KAAK,KAGZmD,EAAOnD,KAAKT,EAAI5F,MAAMoE,KAGtBsF,EAASrD,KAAKmD,EAAO/C,KAAK,MAI9B,MAAO,2BAA2B,IAAIoD,OAAOpH,EAAQT,aAAa0H,EAASjD,KAAK,+BAIhFL,eACA,IAAIhC,EAAgB,QAEIX,IAApBjE,KAAKoD,YACLpD,KAAKmD,QAGT,IAAK,IAAIlB,KAAUjC,KAAKoD,WAAY,CAChC,GAAIpD,KAAKoD,WAAWnB,GAAQiF,OAExB,YADA7G,QAAQ0D,IAAI,wBAAwB9B,MAGxC,GAAIjC,KAAKoD,WAAWnB,GAAQkF,aAExB,YADA9G,QAAQ0D,IAAI,qBAAqB9B,MAIrC2C,EAAIiC,KAAK7G,KAAKoD,WAAWnB,GAAQW,MAAMsD,OAE3C,MAAO,IAAItB,EAAIqC,KAAK,QAqGhBqD,iBAAiBlB,EAAeC,EAAepH,GAGnD,IAAIsI,EAAKnB,EAAI7I,KAAKiE,cAAc,EAAGvC,GAAQQ,YAAY5B,QACnD2J,EAAKnB,EAAI9I,KAAKiE,cAAc,EAAGvC,GAAQQ,YAAY5B,QAAQ0B,UAE/D,OAAOvC,KAAKmJ,eAAeC,EAAKC,EAAKmB,EAAID,GAmDrCV,gBAAgB5H,EAAgB2H,GAEpC,IAAIa,EAAiBzK,KAAKa,QAAQxB,UAC9BqL,EAA+B,GAInC,IAAK,IAAIP,KAAKP,EAEV,GAAIO,IAAMlI,EAAV,CAMA,IAAK,IAAIqG,EAAI,EAAGA,EAAImC,EAAGjI,OAAS,EAAG8F,IAC/BoC,EAAiB7D,KAAK7G,KAAKsK,iBAAiBG,EAAGnC,GAAImC,EAAGnC,EAAI,GAAI6B,IAIlEnK,KAAK2J,iBAAiB9C,MAAK,IAAIxI,GAAeuB,SAAS8K,IAGvDD,EAAKzK,KAAK2J,iBAAiB3J,KAAK2J,iBAAiBnH,OAAS,GAAG3B,QAAQxB,UAGrEqL,EAAmB,GAIvB,IAAIhB,EAAI1J,KAAK2J,iBAAiB3J,KAAK2J,iBAAiBnH,OAAS,GAAGnD,UAAU,GAG1E,OAFAqK,EAAEvG,QAEK,CACHP,MAAO,IAAI,EAAA7E,SAAS2L,EAAE/C,UAAU,GAAG/D,OACnCsE,OAAQwC,EAAExC,OACVC,aAAcuC,EAAEvC,eArT5B,kB,mFCFA,eAKI,mBAQI/H,YAAYwD,GAGR,OAOI,KAAAhD,MAASgD,IAIb5C,KAAK2K,KAAO,IAAI,EAAA/M,YAAY,EAAAgN,gBAAgBC,KAAKjL,MAAMgD,GAAOkI,IAEvD9K,MAfPA,KAAK+K,WAAanI,EAClB5C,KAAKJ,MAAMgD,GACJ5C,KAGPgL,mBACA,OAAO,EAYXpH,SAASqH,EAAyCC,GAC9C,IAEIC,EAFAC,EAA6B,GAGjC,QAAkBnH,IAAdiH,EAAyB,CACzBC,EAAe,IAAIjI,IACnB,IAAK,IAAImI,KAAOJ,EACZE,EAAe,IAAIjI,IAAI,IAAIiI,KAAiBF,EAAUI,UAG1DF,EAAe,IAAIjI,IAAIgI,GAG3B,IAAK,IAAII,KAAStL,KAAK2K,KACnB,GAAwB,aAApBW,EAAMC,eAEyBtH,IAA3BgH,EAAUK,EAAMA,OAChBF,EAASvE,KAAK,IAAI3D,KAElBkI,EAASvE,KAAK,IAAI3D,IAAI+H,EAAUK,EAAMA,cAI1C,OAAQA,EAAMA,OACV,IAAK,IACD,GAAIF,EAAS5I,QAAU,EAAG,CACtB,IAAIgJ,EAASJ,EAASK,MAClBC,EAAQN,EAASK,MAErBL,EAASvE,KAAK,IAAI3D,IAAI,IAAIwI,GAAO3D,QAAOf,GAAKwE,EAAOG,IAAI3E,OAE5D,MACJ,IAAK,IACD,GAAIoE,EAAS5I,QAAU,EAAG,CACtB,IAAIgJ,EAASJ,EAASK,MAClBC,EAAQN,EAASK,MACrBL,EAASvE,KAAK,IAAI3D,IAAI,IAAIwI,KAAUF,KAExC,MACJ,IAAK,IACD,GAAIJ,EAAS5I,QAAU,EAAG,CACtB,IAAIgJ,EAASJ,EAASK,MAClBC,EAAQN,EAASK,MACrBL,EAASvE,KAAK,IAAI3D,IAAI,IAAIwI,GAAO3D,QAAOf,IAAMwE,EAAOG,IAAI3E,OAE7D,MACJ,IAAK,IACD,GAAIoE,EAAS5I,QAAU,EAAG,CACtB,IAAIkJ,EAAQN,EAASK,MAErBL,EAASvE,KAAK,IAAI3D,IAAI,IAAIiI,GAAcpD,QAAOf,IAAM0E,EAAMC,IAAI3E,QAOnF,MAAO,IAAIoE,EAAS,IAAIpD,OAG5B4D,SACI,OAAO5L,KAAK4D,SAAS,CACbiI,EAAG,CAAC,IAAK,MACTC,EAAG,CAAC,IAAK,OAEb,CAAC,IAAK,IAAK,KAAM,MAIzBC,UACI,OAAO/L,KAAK4D,SAAS,CACbiI,EAAG,CAAC,IAAK,KAAM,KAAM,OACrBC,EAAG,CAAC,IAAK,KAAM,KAAM,OACrBE,EAAG,CAAC,IAAK,KAAM,KAAM,QAEzB,CAAC,IAAK,IAAK,IAAK,KAAM,KAAM,KAAM,MAItClB,UACA,OAAO9K,KAAK2K,KAGZ/F,UACA,IAAIwG,EAAoD,GAExD,IAAK,IAAIE,KAAStL,KAAK2K,KACnB,GAAwB,aAApBW,EAAMC,UACNH,EAASvE,KAAKyE,QAEd,OAAQA,EAAMA,OACV,IAAK,IACD,GAAIF,EAAS5I,QAAU,EAAG,CACtB,IAAIgJ,EAASJ,EAASK,MAClBC,EAAQN,EAASK,MAEG,QAApBC,EAAMH,YACNG,EAAMJ,MAAQ,KAAKI,EAAMJ,WAEJ,QAArBE,EAAOD,YACPC,EAAOF,MAAQ,KAAKE,EAAOF,WAE/BF,EAASvE,KAAK,CAACyE,MAAO,GAAGI,EAAMJ,eAAeE,EAAOF,QAASC,UAAW,QAE7E,MACJ,IAAK,IACD,GAAIH,EAAS5I,QAAU,EAAG,CACtB,IAAIgJ,EAASJ,EAASK,MAClBC,EAAQN,EAASK,MAEG,QAApBC,EAAMH,YACNG,EAAMJ,MAAQ,KAAKI,EAAMJ,WAEJ,QAArBE,EAAOD,YACPC,EAAOF,MAAQ,KAAKE,EAAOF,WAE/BF,EAASvE,KAAK,CAACyE,MAAO,GAAGI,EAAMJ,eAAeE,EAAOF,QAASC,UAAW,QAE7E,MACJ,IAAK,IACD,GAAIH,EAAS5I,QAAU,EAAG,CACtB,IAAIgJ,EAASJ,EAASK,MAClBC,EAAQN,EAASK,MAEG,QAApBC,EAAMH,YACNG,EAAMJ,MAAQ,KAAKI,EAAMJ,WAEJ,QAArBE,EAAOD,YACPC,EAAOF,MAAQ,KAAKE,EAAOF,WAE/BF,EAASvE,KAAK,CAACyE,MAAO,GAAGI,EAAMJ,oBAAoBE,EAAOF,QAASC,UAAW,QAElF,MACJ,IAAK,IACD,GAAIH,EAAS5I,QAAU,EAAG,CACtB,IAAIkJ,EAAQN,EAASK,MACrBL,EAASvE,KAAK,CAACyE,MAAO,eAAeI,EAAMJ,UAAWC,UAAW,cAOrF,OAAOH,EAAS,GAAGE,S,8ECjL/B,eACA,SAEA,SAMA,MAAapN,EAUTkB,YAAYwD,GAQR,OA6QJ,KAAAhD,MAASqM,IAEmB,iBAAbA,EACPjM,KAAKkM,2BAA2BD,GACL,iBAAbA,GACdjM,KAAKmM,aAAe,IAAI,EAAApO,SAASkO,GACjCjM,KAAKoM,SAAW,IACTH,aAAoB,EAAAlO,UAC3BiC,KAAKmM,aAAeF,EAASpL,QAC7Bb,KAAKoM,SAAW,IACTH,aAAoB/N,IAC3B8B,KAAKmM,aAAeF,EAASE,aAAatL,QAC1Cb,KAAKoM,SAAWpM,KAAKqM,aAAaJ,EAASK,UAGxCtM,MAwDH,KAAAkM,2BAA8BD,IAElC,MACMnB,GADkB,IAAI,EAAAlN,aAAcgC,MAAMqM,GACOnB,IAEvD,IAAIyB,EAAiB,GAErB,GAAmB,IAAfzB,EAAItI,OAEJ,OADAxC,KAAKkB,OACElB,KACJ,GAAmB,IAAf8K,EAAItI,OAAc,CACzB,MAAMgK,EAAU1B,EAAI,GAQpB,OANA9K,KAAKyM,MACqB,gBAAtBD,EAAQjB,UACRvL,KAAKyC,YAAc,IAAI,EAAA1E,SAASyO,EAAQlB,OACX,aAAtBkB,EAAQjB,WACfvL,KAAK0M,UAAUF,EAAQlB,MAAO,GAE3BtL,KAGP,IAAK,MAAMwM,KAAW1B,EAClB5M,EAAMyO,SAASJ,EAAOC,GAM9B,OAFAxM,KAAKyM,MACLzM,KAAK0B,SAAS6K,EAAM,IACbvM,MAKX,KAAAa,MAAQ,KACJ,IAAIgC,EAAW,IAAI3E,EAEnB2E,EAAEJ,YAAczC,KAAKmM,aAAatL,QAGlC,IAAK,IAAI+L,KAAK5M,KAAKoM,SACfvJ,EAAE6J,UAAUE,EAAG5M,KAAKoM,SAASQ,GAAG/L,SAEpC,OAAOgC,GAGX,KAAAwJ,aAAgBC,IACZ,IAAInC,EAAiB,GAErB,IAAK,IAAIyC,KAAKN,EACVnC,EAAEyC,GAAKN,EAAQM,GAAG/L,QAEtB,OAAOsJ,GAGX,KAAA0C,SAAYC,IAER,IAAK,IAAIF,KAAKE,EAAEV,SACZpM,KAAK0M,UAAUE,EAAGE,EAAEV,SAASQ,GAAG/L,SAEpC,OAAOb,MAMX,KAAAkB,KAAO,KACHlB,KAAKmM,cAAe,IAAI,EAAApO,UAAWmD,OACnClB,KAAKoM,SAAW,GACTpM,MAMX,KAAAyM,IAAM,KACFzM,KAAKmM,cAAe,IAAI,EAAApO,UAAW0O,MACnCzM,KAAKoM,SAAW,GACTpM,MAMX,KAAA+M,MAAQ,KACJ,IAAK,IAAI9K,KAAUjC,KAAKoM,SAChBpM,KAAKoM,SAASnK,GAAQT,iBACfxB,KAAKoM,SAASnK,GAG7B,OAAOjC,MAGX,KAAA8F,OAAS,KACL9F,KAAK+M,QACL/M,KAAKyC,YAAYqD,SACV9F,MAWX,KAAAuC,QAAU,KACNvC,KAAKmM,aAAa5J,UACXvC,MAOX,KAAAsC,IAAM,IAAIwK,KACN,IAAK,IAAIxL,KAAKwL,EACN9M,KAAKgN,SAAS1L,IACVtB,KAAKwB,UACLxB,KAAK6M,SAASvL,GAElBtB,KAAKmM,aAAa7J,IAAIhB,EAAEmB,cAExBpC,QAAQ0D,IAAI,wBAAyBzC,EAAE+F,SAG/C,OAAOrH,MAOX,KAAAiB,SAAW,IAAI6L,KACX,IAAK,IAAIxL,KAAKwL,EACN9M,KAAKgN,SAAS1L,IACVtB,KAAKwB,UACLxB,KAAK6M,SAASvL,GAElBtB,KAAKmM,aAAa7J,IAAIhB,EAAET,QAAQ4B,YAAYF,YAE5ClC,QAAQ0D,IAAI,6BAA8BzC,EAAE+F,SAGpD,OAAOrH,MAOX,KAAA0B,SAAW,IAAIoL,KACX,IAAK,IAAIxL,KAAKwL,EAAG,CAEb9M,KAAKmM,aAAazK,SAASJ,EAAEmB,aAG7B,IAAK,IAAIR,KAAUX,EAAEgL,aACarI,IAA1BjE,KAAKoM,SAASnK,GACdjC,KAAKoM,SAASnK,GAAUX,EAAEgL,QAAQrK,GAAQpB,QAE1Cb,KAAKoM,SAASnK,GAAQK,IAAIhB,EAAEgL,QAAQrK,IAKhD,OAAOjC,MAGX,KAAAiN,iBAAoBpK,IAChB7C,KAAKmM,aAAazK,SAASmB,GACpB7C,MAOX,KAAA6B,OAAS,IAAIiL,KAET,IAAK,IAAIpI,KAAKoI,EAAG,CAEb9M,KAAKmM,aAAatK,OAAO6C,EAAEjC,aAG3B,IAAK,IAAIR,KAAUyC,EAAE4H,QACjBtM,KAAKoM,SAASnK,QAAqCgC,IAA1BjE,KAAKoM,SAASnK,GAAyByC,EAAE4H,QAAQrK,GAAQpB,QAAQ0B,UAAYvC,KAAKoM,SAASnK,GAAQhB,SAASyD,EAAE4H,QAAQrK,IAG3IjC,KAAKoM,SAASnK,GAAQT,iBACfxB,KAAKoM,SAASnK,GAIjC,OAAOjC,MAOX,KAAAkN,IAAOC,IACHnN,KAAKmM,aAAae,IAAIC,GACtB,IAAK,IAAIlL,KAAUjC,KAAKoM,SACpBpM,KAAKoM,SAASnK,GAAQP,SAASyL,GAEnC,OAAOnN,MAOX,KAAAoN,KAAQC,GAEGrN,KAMX,KAAA4F,KAAO,KACH,GAAI5F,KAAKsN,WAAY,CACjBtN,KAAKmM,aAAavG,OAClB,IAAK,IAAI3D,KAAUjC,KAAKoM,SACpBpM,KAAKoM,SAASnK,GAAQpB,QAAQgB,OAAO,GAG7C,OAAO7B,KAAKoN,KAAK,IAMrB,KAAAG,QAAU,CAACT,EAAUrM,KAOjB,YALawD,IAATxD,IACAA,EAAO,KAIHA,GACJ,IAAK,IAED,QAAKT,KAAKuN,QAAQT,EAAG,SAKd9M,KAAKmM,aAAatI,QAAQiJ,EAAErK,aACvC,IAAK,OAED,IAAI+K,EAAexN,KAAKuH,UACpBkG,EAAeX,EAAEvF,UACjBmG,EAAcF,EAAGhG,OAAOiG,EAAG1F,QAAQ4F,GAASH,EAAGpJ,QAAQuJ,GAAQ,KAEnE,GAAe,IAAZH,EAAGhL,QAA0B,IAAZiL,EAAGjL,OAAY,OAAO,EAE1C,IAAKxC,KAAKwB,WAAasL,EAAEtL,SACrB,IAAK,IAAI6J,KAAOqC,EAAG,CAEf,QAA2BzJ,IAAvBjE,KAAKoM,SAASf,SAAyCpH,IAAnB6I,EAAER,QAAQjB,GAC9C,OAAO,EAGX,IAAKrL,KAAKoM,SAASf,GAAKxH,QAAQiJ,EAAER,QAAQjB,IACtC,OAAO,EAMnB,OAAO,EACX,QACI,OAAO,IAsBnB,KAAAxH,QAAWiJ,GACA9M,KAAKuN,QAAQT,EAAG,KAO3B,KAAAE,SAAYF,GACD9M,KAAKuN,QAAQT,EAAG,QAG3B,KAAAQ,SAAW,MACFtN,KAAKyC,YAAY6K,YAGftN,KAAK4N,kBAGhB,KAAAA,gBAAkB,KACd,IAAK,IAAI3L,KAAUjC,KAAKsM,QAAS,CAE7B,GAAItM,KAAKsM,QAAQrK,GAAQ4L,aACrB,OAAO,EAIX,GAAI7N,KAAKsM,QAAQrK,GAAQ6L,SACrB,OAAO,EAIf,OAAO,GAGX,KAAAC,uBAAyB,KACrB,IAAK,IAAI9L,KAAUjC,KAAKoM,SACpB,GAAIpM,KAAKoM,SAASnK,GAAQ4L,aACtB,OAAO,EAIf,OAAO,GASX,KAAAxL,UAAaJ,QAEkDgC,IAAvDjE,KAAKoM,cAAoBnI,IAAXhC,EAAuB,IAAMA,IAKxCjC,KAAKoM,cAAoBnI,IAAXhC,EAAuB,IAAMA,GAAQ+L,YAQ9D,KAAAtB,UAAY,CAACzK,EAAgBiL,KACrBA,aAAe,EAAAnP,UAEXiC,KAAKqC,UAAUJ,IAAWiL,EAAI1L,iBACvBxB,KAAKoM,SAASnK,GAGzBjC,KAAKoM,SAASnK,GAAUiL,EAAIrM,SAE5Bb,KAAK0M,UAAUzK,EAAQ,IAAI,EAAAlE,SAASmP,KAQ5C,KAAAvN,OAAUsC,GACwB,IAA1BjC,KAAKuH,UAAU/E,QACR,IAAI,EAAAzE,UAAWmD,YAEX+C,IAAXhC,EAEOgM,OAAOtK,OAAO3D,KAAKoM,UAAUtG,QAAO,CAACoI,EAAGC,IAAMD,EAAErN,QAAQyB,IAAI6L,UAGlClK,IAA1BjE,KAAKoM,SAASnK,IAAwB,IAAI,EAAAlE,UAAWmD,OAASlB,KAAKoM,SAASnK,GAAQpB,QAQnG,KAAA+C,SAAYD,IACR,IAAIyK,EAAIpO,KAAKyC,YAAY5B,QAEzB,GAAsB,iBAAX8C,GAAuBA,aAAkB,EAAA5F,SAAU,CAC1D,IAAIsQ,EAAyB,GAE7B,OADAA,EAAUrO,KAAKuH,UAAU,IAAM,IAAI,EAAAxJ,SAAS4F,GACrC3D,KAAK4D,SAASyK,GAGzB,GAAsB,iBAAX1K,EACP,IAAK,IAAIwG,KAAKnK,KAAKoM,SAAU,CACzB,QAAkBnI,IAAdN,EAAOwG,GACP,OAAO,IAAI,EAAApM,UAAWmD,OAG1B,IAAI0B,EAAQ,IAAI,EAAA7E,SAAS4F,EAAOwG,IAEhCiE,EAAE1M,SAASkB,EAAMsK,IAAIlN,KAAKoM,SAASjC,KAI3C,OAAOiE,GAOX,KAAAE,WAAcrM,IAMV,QAJegC,IAAXhC,IACAA,EAAS,KAGTjC,KAAKqC,UAAUJ,GAAS,CACxB,IAAIsM,EAAIvO,KAAKoM,SAASnK,GAAQpB,QAC1B2N,EAAKxO,KAAKa,QAOd,OAJA2N,EAAGpC,SAASnK,GAAQhB,SAAS,GAG7BuN,EAAGrC,aAAazK,SAAS,IAAI,EAAA3D,SAASwQ,EAAE1N,UACjC2N,EAEP,OAAO,IAAItQ,GAAQgD,QAI3B,KAAAuN,UAAaxM,SAEMgC,IAAXhC,IACAA,EAAS,KAIb,IAAsBtC,EAAlBmN,EAAI9M,KAAKa,QAgBb,OAdIiM,EAAEzK,UAAUJ,IACZtC,EAASmN,EAAEnN,OAAOsC,GAAQpB,QAAQyB,IAAI,GACtCwK,EAAErK,YAAcqK,EAAErK,YAAY5B,QAAQgB,OAAOlC,GAC7CmN,EAAEJ,UAAUzK,EAAQtC,KAKhBmN,EAAErK,YAAYjB,WACdsL,EAAErK,aAAc,IAAI,EAAA1E,UAAW0O,OAEnCK,EAAEJ,UAAUzK,EAAQ,IAGjB6K,GAoEX,KAAA4B,UAAY,IAAI5B,KAIZ,IAAK,IAAIxE,EAAI,EAAGA,EAAIwE,EAAEtK,OAAQ8F,IAC1B,IAAKtI,KAAKgN,SAASF,EAAExE,IACjB,OAAO,EAKf,OAVsB,GAiB1B,KAAAqG,UAAY,IAAI7B,KAEZ,IAAK9M,KAAK0O,aAAa5B,GACnB,OAAO,EAIX,IAAK,IAAIxL,KAAKwL,EACV,IAAK9M,KAAKmM,aAAatI,QAAQvC,EAAEmB,aAC7B,OAAO,EAKf,OAAO,GAp5BPzC,KAAKkB,YAES+C,IAAVrB,GAEA5C,KAAKJ,MAAMgD,GAGR5C,KAUPyC,kBACA,OAAOzC,KAAKmM,aAOZ1J,gBAAYI,GACZ7C,KAAKmM,aAAe,IAAI,EAAApO,SAAS8E,GAOjCyJ,cACA,OAAOtM,KAAKoM,SAQZwC,kBACA,GAAI5O,KAAK4N,kBAAmB,CACxB,IAAIzD,EAAiB,GACrB,IAAK,IAAIkB,KAAOrL,KAAKoM,SACjBjC,EAAEkB,GAAOrL,KAAKoM,SAASf,GAAKxK,QAAQ+E,OAExC,OAAOuE,EAEP,OAAOnK,KAAKoM,SAQhBE,YAAQnC,GACRnK,KAAKoM,SAAWjC,EAOhB0E,eAAW5C,GAIX,IAAK,MAAMvH,IAAK,IAAIuH,EAAS6C,SAAS,4BAE5BpK,EAAE,KAAM1E,KAAKoM,WACfpM,KAAKoM,SAAS1H,EAAE,KAAM,IAAI,EAAA3G,UAAWmD,QAKzClB,KAAKoM,SAAS1H,EAAE,IAAIpC,KAAKoC,EAAE,IAI/B,IAAK,MAAMA,IAAK,IAAIuH,EAAS6C,SAAS,mBAE5BpK,EAAE,KAAM1E,KAAKoM,WACfpM,KAAKoM,SAAS1H,EAAE,KAAM,IAAI,EAAA3G,UAAWmD,QAIzClB,KAAKoM,SAAS1H,EAAE,IAAIpC,IAAI,GAQ5BiF,gBACA,IAAIuF,EAAI9M,KAAKa,QAAQkM,QACrB,OAAOkB,OAAOc,KAAKjC,EAAER,SAOrBjF,cACA,IAAI8C,EAAY,GACZlH,EAAUgL,OAAOc,KAAK/O,KAAKoM,UAAUpE,OACzC,IAAK,IAAI/F,KAAUgB,EACXjD,KAAKoM,SAASnK,GAAQ+L,cACtB7D,GAAK,GAAGlI,IACJjC,KAAKoM,SAASnK,GAAQ+M,WAAW,KACjC7E,GAAK,IAAInK,KAAKoM,SAASnK,GAAQoF,YAK3C,MAAU,KAAN8C,EAE+B,GAA3BnK,KAAKmM,aAAavJ,MACX,GAAG5C,KAAKmM,aAAa9E,UAErB,GAGqB,IAA5BrH,KAAKmM,aAAavJ,MACXuH,GAC6B,IAA7BnK,KAAKmM,aAAavJ,MAClB,IAAIuH,IACwB,IAA5BnK,KAAKmM,aAAavJ,MAClB,IAEA,GAAG5C,KAAKmM,aAAa9E,UAAU8C,IAK9C8E,eAEA,IAAKjP,KAAKyC,YAAYyM,aAClB,MAAO,CAAClP,KAAKa,SAKjB,GAAIb,KAAK+N,yBACL,MAAO,CAAC/N,KAAKa,SAIjB,GAAIb,KAAKyC,YAAY0M,UAAY,IAC7B,MAAO,CAACnP,KAAKa,SAIjB,MAAMoO,EAAW,EAAApR,QAAQoR,SAAStJ,KAAKyJ,IAAIpP,KAAKyC,YAAY0M,YAG5D,IAAIE,EAA0B,GAC9B,IAAK,IAAIlF,KAAKnK,KAAKsM,QAEf+C,EAAWrP,KAAKsP,oBAAoBD,EAAUlF,GAGlD,MAAMoF,EAAyB,GAC/B,GAAIF,EAAS7M,OAAS,GAAKyM,EAASzM,OAAS,EACzC,IAAK,IAAIgN,KAAKP,EACV,IAAK,IAAI9E,KAAKkF,EAAU,CACpB,IAAIvC,EAAI,IAAI5O,EACZ4O,EAAErK,YAAc,IAAI,EAAA1E,SAASyR,GAC7B1C,EAAER,QAAUnC,EACZoF,EAAc1I,KAAKiG,QAGxB,GAAwB,IAApBmC,EAASzM,OAChB,IAAK,IAAI2H,KAAKkF,EAAU,CACpB,IAAIvC,EAAI,IAAI5O,EACZ4O,EAAErK,aAAc,IAAI,EAAA1E,UAAW0O,MAC/BK,EAAER,QAAUnC,EACZoF,EAAc1I,KAAKiG,QAGvB,IAAK,IAAI0C,KAAKP,EAAU,CACpB,IAAInC,EAAI,IAAI5O,EACZ4O,EAAErK,YAAc,IAAI,EAAA1E,SAASyR,GAC7BD,EAAc1I,KAAKiG,GAI3B,OAAgC,IAAzByC,EAAc/M,OAAe,EAAC,IAAItE,GAAQuO,OAAS8C,EAGtDD,oBAAoBG,EAAoBxN,GAC5C,IAAIyN,EAAyC,GAG7C,IAAK,IAAInB,EAAI,EAAGA,GAAKvO,KAAKsM,QAAQrK,GAAQW,MAAO2L,IAC7C,GAAmB,IAAfkB,EAAIjN,OAAc,CAClB,IAAImN,EAAoB,GACxBA,EAAK1N,GAAU,IAAI,EAAAlE,SAASwQ,GAC5BmB,EAAQ7I,KAAK8I,QAEb,IAAK,IAAIhC,KAAQ8B,EAAK,CAClB,IAAIE,EAAoB,GACxB,IAAK,IAAIC,KAAiBjC,EACtBgC,EAAKC,GAAiBjC,EAAKiC,GAE/BD,EAAK1N,GAAU,IAAI,EAAAlE,SAASwQ,GAC5BmB,EAAQ7I,KAAK8I,GAIzB,OAAOD,EAMPG,sBACA,IAAItB,EAAYvO,KAAKqH,QACrB,OAAiB,MAATkH,EAAE,GAAa,IAAM,IAAMA,EAGnCuB,kBACA,OAAI9P,KAAKyC,YAAYsN,qBACV,IAAM/P,KAAK4E,IAGf5E,KAAK4E,IAMZA,UAEA,IAAIuF,EAAY,GACZlH,EAAUgL,OAAOc,KAAK/O,KAAKoM,UAAUpE,OAEzC,IAAK,IAAI/F,KAAUgB,EACXjD,KAAKoM,SAASnK,GAAQ+L,cACtB7D,GAAK,GAAGlI,IACJjC,KAAKoM,SAASnK,GAAQ+M,WAAW,KACjC7E,GAAK,KAAKnK,KAAKoM,SAASnK,GAAQ+N,WAK5C,MAAU,KAAN7F,EAE+B,GAA3BnK,KAAKmM,aAAavJ,MACX,GAAG5C,KAAKmM,aAAajG,QAErB,IAGqB,IAA5BlG,KAAKmM,aAAavJ,MACXuH,GAC6B,IAA7BnK,KAAKmM,aAAavJ,MAClB,IAAIuH,IACwB,IAA5BnK,KAAKmM,aAAavJ,MAClB,IAEA,GAAG5C,KAAKmM,aAAajG,QAAQiE,IA6WhD3I,SACI,OAAmC,IAA5BxB,KAAKmM,aAAavJ,MAM7BV,QACI,OAAmC,IAA5BlC,KAAKmM,aAAavJ,OAAyC,IAA1B5C,KAAKuH,UAAU/E,QAxoB/D,UAiTW,EAAAmK,SAAW,CAACJ,EAAgBC,KAE/B,IAAIyD,EAAWC,EAAW5O,EAAUW,EAAgBiL,EAEpD,GAAIV,EAAQjB,YAAc,EAAA4E,gBAAgBC,YACtC7D,EAAM1F,KAAK,IAAI3I,EAAM,IAAI,EAAAH,SAASyO,EAAQlB,cAEvC,GAAIkB,EAAQjB,YAAc,EAAA4E,gBAAgBE,SAAU,CACvD,IAAIvD,GAAI,IAAI5O,GAAQuO,MACpBK,EAAEJ,UAAUF,EAAQlB,MAAO,GAC3BiB,EAAM1F,KAAKiG,EAAEjM,cAEV,GAAI2L,EAAQjB,YAAc,EAAA4E,gBAAgBG,UAC7C,OAAQ9D,EAAQlB,OACZ,IAAK,IAED4E,EAAM3D,EAAMd,QAAU,IAAIvN,GAAQgD,OAClC+O,EAAM1D,EAAMd,QAAU,IAAIvN,GAAQgD,OAElCqL,EAAM1F,KAAKoJ,EAAGhP,SAASiP,IAEvB,MACJ,IAAK,IAEDA,EAAM3D,EAAMd,QAAU,IAAIvN,GAAQuO,MAClCwD,EAAM1D,EAAMd,QAAU,IAAIvN,GAAQuO,MAElCF,EAAM1F,KAAKoJ,EAAGvO,SAASwO,IACvB,MACJ,IAAK,IAEDA,EAAM3D,EAAMd,QAAU,IAAIvN,GAAQuO,MAClCwD,EAAM1D,EAAMd,QAAU,IAAIvN,GAAQuO,MAElCF,EAAM1F,KAAKoJ,EAAGpO,OAAOqO,IACrB,MACJ,IAAK,IAEDhD,EAAOX,EAAMd,MAAiB,cAAK,IAAI,EAAA1N,UAAW0O,MAClDnL,EAAKiL,EAAMd,QAAU,IAAIvN,GAAQuO,MAEjCxK,EAASX,EAAEiG,UAAU,QAENtD,IAAXhC,GACAX,EAAEoL,UAAUzK,EAAQiL,GAGxBX,EAAM1F,KAAKvF,KAqepB,EAAAK,IAAM,IAAIJ,KAEb,IAAK,IAAID,KAAKC,EACV,GAAID,EAAEyM,yBACF,OAAO,IAAI7P,GAAQgD,OAK3B,IAAI4L,EAAI,IAAI5O,EACRqS,EAAmBhP,EAAOwF,KAAInE,GAASA,EAAMH,YAAY0M,YACzDqB,EAAmBjP,EAAOwF,KAAInE,GAASA,EAAMH,YAAY+C,cACzD2I,EAAI,EAAAtQ,QAAQiE,OAAOyO,GACnBhC,EAAI,EAAA1Q,QAAQ8D,OAAO6O,GAGvB1D,EAAErK,YAAc,IAAI,EAAA1E,SAASoQ,EAAGI,GAAGzI,SAGnC,IAAK,IAAIxE,KAAKC,EAAQ,CAElB,IAAK,IAAIU,KAAU6K,EAAER,QACXrK,KAAUX,EAAEgL,SACdQ,EAAER,QAAQrK,GAAQf,OAG1B,IAAK,IAAIe,KAAUX,EAAEgL,aACSrI,IAAtB6I,EAAER,QAAQrK,IAAyBX,EAAEgL,QAAQrK,GAAQ8N,qBACrDjD,EAAER,QAAQrK,GAAUX,EAAEgL,QAAQrK,GAAQpB,QAEtCiM,EAAER,QAAQrK,GAAU,IAAI,EAAAlE,SAAS4H,KAAK8K,IAAInP,EAAEgL,QAAQrK,GAAQW,MAAOkK,EAAER,QAAQrK,GAAQW,QAKjG,OAAOkK,GAOJ,EAAA4D,UAAY,IAAInP,KACnB,IAAIuL,GAAI,IAAI5O,GAAQuO,MAEpB,IAAK,IAAInL,KAAKC,EACVuL,EAAEpL,SAASJ,GAGf,OAAOwL,I,+EC93Bf,eACA,SACA,SACA,SACA,SAUA,MAAa3O,EAQTiB,YAAYuR,KAAuChN,GAM/C,OAgLJ,KAAA/D,MAAQ,CAACqM,KAAiCtI,KAKtC,GAHA3D,KAAK4Q,QAAU,GACf5Q,KAAK6Q,SAAW,GAEQ,iBAAb5E,EACP,OAAOjM,KAAK8Q,aAAa7E,KAAatI,GACnC,GAAwB,iBAAbsI,GAAyBA,aAAoB,EAAAlO,UAAYkO,aAAoB,EAAA/N,MAC3F8B,KAAK4Q,QAAQ/J,KAAK,IAAI,EAAA3I,MAAM+N,SACzB,GAAIA,aAAoB9N,EAC3B,IAAK,MAAMmD,KAAK2K,EAAS1K,OACrBvB,KAAK4Q,QAAQ/J,KAAKvF,EAAET,SAI5B,OAAOb,MAUX,KAAAa,MAAQ,KACJ,MAAM8B,EAAI,IAAIxE,EACR2O,EAAa,GAEnB,IAAK,MAAMxL,KAAKtB,KAAK4Q,QACjB9D,EAAEjG,KAAKvF,EAAET,SAIb,OADA8B,EAAEpB,OAASuL,EACJnK,GAOX,KAAAzB,KAAO,KACHlB,KAAK4Q,QAAU,GACf5Q,KAAK4Q,QAAQ/J,MAAK,IAAI,EAAA3I,OAAQgD,QAC9BlB,KAAK+K,WAAa,IACX/K,MAGX,KAAAyM,IAAM,KACFzM,KAAK4Q,QAAU,GACf5Q,KAAK4Q,QAAQ/J,MAAK,IAAI,EAAA3I,OAAQuO,OAC9BzM,KAAK+K,WAAa,IACX/K,MAGX,KAAA+Q,MAAQ,KACJ/Q,KAAK4Q,QAAU,GACf5Q,KAAK+K,WAAa,GACX/K,MAIX,KAAAuC,QAAU,KACNvC,KAAK4Q,QAAU5Q,KAAK4Q,QAAQ7J,KAAIzF,GAAKA,EAAEiB,YAChCvC,MAGX,KAAAsC,IAAM,IAAIqB,KAEN,IAAK,IAAIf,KAASe,EACVf,aAAiBzE,EACjB6B,KAAK4Q,QAAU5Q,KAAK4Q,QAAQpJ,OAAO5E,EAAMrB,QAClCqB,aAAiB,EAAA1E,MACxB8B,KAAK4Q,QAAQ/J,KAAKjE,EAAM/B,SACjBmQ,OAAOC,cAAcrO,GAC5B5C,KAAK4Q,QAAQ/J,KAAK,IAAI,EAAA3I,MAAM0E,EAAM6F,aAElCzI,KAAK4Q,QAAQ/J,KAAK,IAAI,EAAA3I,MAAM0E,IAIpC,OAAO5C,KAAK8F,UAoEhB,KAAA7E,SAAW,IAAI0C,KAEX,IAAK,IAAIf,KAASe,EACVf,aAAiBzE,EACjB6B,KAAK4Q,QAAU5Q,KAAK4Q,QAAQpJ,OAAO5E,EAAM/B,QAAQ0B,UAAUhB,QACpDqB,aAAiB,EAAA1E,MACxB8B,KAAK4Q,QAAQ/J,KAAKjE,EAAM/B,QAAQ0B,WACzByO,OAAOC,cAAcrO,GAC5B5C,KAAK4Q,QAAQ/J,KAAK,IAAI,EAAA3I,MAAM0E,EAAM6F,YAAYlG,WAE9CvC,KAAK4Q,QAAQ/J,KAAK,IAAI,EAAA3I,MAAM0E,GAAOL,WAI3C,OAAOvC,KAAK8F,UAGhB,KAAApE,SAAYkB,GACJA,aAAiBzE,EACV6B,KAAKkR,kBAAkBtO,GACvBA,aAAiB,EAAA7E,SACjBiC,KAAKmR,mBAAmBvO,GACxBA,aAAiB,EAAA1E,MACjB8B,KAAKoR,gBAAgBxO,GACrBoO,OAAOC,cAAcrO,IAA2B,iBAAVA,EACtC5C,KAAKqR,kBAAkBzO,GAI3B5C,KAQX,KAAAsR,UAAa3O,IACT,MAAMV,EAAiBU,EAAE4E,UAAU,GAC7BgK,GAAoB,IAAIpT,GAAU+C,OAClCsQ,EAAoBxR,KAAKa,QAAQM,QAAQc,GAG/C,GAA2B,IAAvBU,EAAE4E,UAAU/E,OACZ,MAAO,CAAC+O,SAAAA,EAAUC,SAAAA,GAKtB,MAAMC,EAAe9O,EAAE6B,mBAAcP,EAAWhC,GAC1CyP,EAAoB/O,EAAEhD,OAAOsC,GAEnC,IAAI0P,EAGAC,EAAe5R,KAAKL,OAAOsC,GAAQpB,QAAQa,SAAS,GACxD,KAAO8P,EAAS7R,OAAOsC,GAAQ4P,IAAIH,IAAYE,EAAaE,eACxDF,EAAa3Q,SAAS,GAGtB0Q,EAAOH,EAAShN,mBAAcP,EAAWhC,GAAQpB,QAAQgB,OAAO4P,IAE5DE,EAAKnQ,WAKT+P,EAASjP,IAAIqP,GACbH,EAASvQ,SAAS0B,EAAE9B,QAAQa,SAASiQ,IAKzC,OAFAJ,EAASzL,SACT0L,EAAS1L,SACF,CAACyL,SAAAA,EAAUC,SAAAA,IAGtB,KAAA3P,OAAUe,GACFA,aAAiB,EAAA7E,SACViC,KAAK+R,iBAAiBnP,GACL,iBAAVA,GAAsBoO,OAAOC,cAAcrO,GAClD5C,KAAKgS,gBAAgBpP,QADzB,EAMX,KAAAsK,IAAOC,IACH,IAAK6D,OAAOC,cAAc9D,GACtB,OAAOnN,KAAKkB,OAEhB,GAAIiM,EAAK,EACL,OAAOnN,KAAKkB,OAEhB,GAAW,IAAPiM,EACA,OAAO,IAAIhP,EAGf,MAAMwE,EAAI3C,KAAKa,QACf,IAAK,IAAIyH,EAAI,EAAGA,EAAI6E,EAAI7E,IACpBtI,KAAK0B,SAASiB,GAElB,OAAO3C,KAAK8F,UAShB,KAAAyH,QAAU,CAAC5K,EAAYlC,UACNwD,IAATxD,IACAA,EAAO,KAIX,MAAMwR,EAAMjS,KAAKa,QAAQiF,SAAS3E,UAC5B+Q,EAAMvP,EAAE9B,QAAQiF,SAAS3E,UAE/B,OAAQV,GACJ,IAAK,IAED,GAAIwR,EAAIzP,SAAW0P,EAAI1P,QAAUyP,EAAItS,SAASqP,WAAWkD,EAAIvS,UACzD,OAAO,EAIX,IAAK,MAAM2I,KAAK2J,EAAI1Q,OAChB,IAAK0Q,EAAI1Q,OAAO+G,GAAGzE,QAAQqO,EAAI3Q,OAAO+G,IAClC,OAAO,EAGf,OAAO,EACX,IAAK,OAED,GAAI2J,EAAIzP,SAAW0P,EAAI1P,QAAUyP,EAAItS,WAAauS,EAAIvS,SAClD,OAAO,EAGX,IAAK,MAAM2I,KAAK2J,EAAI1Q,OAChB,IAAK0Q,EAAI1Q,OAAO+G,GAAG0E,SAASkF,EAAI3Q,OAAO+G,IACnC,OAAO,EAIf,OAAO,EACX,QACI,OAAO,IAYnB,KAAAzE,QAAWlB,GACA3C,KAAKuN,QAAQ5K,EAAG,KAG3B,KAAAqK,SAAYrK,GACD3C,KAAKuN,QAAQ5K,EAAG,QAG3B,KAAAwP,YAAexP,GACJ3C,KAAKuN,QAAQ5K,EAAE9B,QAAQ0B,UAAW,KAG7C,KAAA6P,aAAgBzB,IACZ,IAAIhO,EAGJ,GAAIgO,EAAc0B,MAAM,OAAO7P,SAAWmO,EAAc0B,MAAM,OAAO7P,OACjE,OAAO,EAIX,IACIG,EAAI,IAAIxE,EAAQwS,GAClB,MAAO2B,GACL,OAAO,EAIX,IAAKtS,KAAK6D,QAAQlB,GACd,OAAO,EAKX,IAAI4P,EAA0B5B,EAAc6B,WAAW,IAAK,IACxDC,EAAuB,GAAKF,EAC5BjM,EAAoB,GAExB,IAAK,IAAIU,KAAKuL,EAAwBzD,SAAS,kCAAmC,CAC9E,QAAa7K,IAAT+C,EAAE,GACF,IAAK,IAAIsB,EAAI,EAAGA,GAAKtB,EAAE,GAAG0L,OAAO,GAAIpK,IACjChC,EAAQO,KAAKG,EAAE,SAGnBV,EAAQO,KAAKG,EAAE,IAEnByL,EAAuBA,EAAqBD,WAAWxL,EAAE,GAAI,IAEpC,KAAzByL,GACAnM,EAAQO,KAAK4L,GAEjB,IAAIE,EAAcrM,EAAQS,KAAIC,GAAK,IAAI7I,EAAQ6I,KAG/ChH,KAAKqG,YAGL,IAAI5F,EAAO,EACX,IAAK,IAAImS,KAAK5S,KAAKsG,QACf,IAAK,IAAIgC,EAAI,EAAGA,EAAIqK,EAAYnQ,OAAQ8F,IAAK,CACzC,GAAIsK,EAAE/O,QAAQ8O,EAAYrK,IAAK,CAC3BqK,EAAYE,OAAOvK,EAAG,GACtB,MACG,GAAIsK,EAAET,YAAYQ,EAAYrK,IAAK,CACtCqK,EAAYE,OAAOvK,EAAG,GACtB7H,GAAQA,EACR,OAMZ,OAA+B,IAAvBkS,EAAYnQ,QAAyB,IAAT/B,GAGxC,KAAAqS,YAAenC,IACX,IAAIhO,EAGJ,GAAIgO,EAAc0B,MAAM,OAAO7P,OAASmO,EAAc0B,MAAM,OAAO7P,OAC/D,OAAO,EAIX,IAEIG,EAAI,IAAIxE,EAAQwS,GAClB,MAAO2B,GACL,OAAO,EAIX,QAAKtS,KAAK6D,QAAQlB,IAUYgO,EAAc6B,WAAW,OAAS,MAI7B7P,EAAEmD,SAAS3E,UAAUkG,SAQ5D,KAAAvB,OAAS,KACL,IAAK,IAAIwC,EAAI,EAAGA,EAAItI,KAAK4Q,QAAQpO,OAAQ8F,IACrC,IAAK,IAAIyK,EAAIzK,EAAI,EAAGyK,EAAI/S,KAAK4Q,QAAQpO,OAAQuQ,IACrC/S,KAAK4Q,QAAQtI,GAAG0E,SAAShN,KAAKuB,OAAOwR,MACrC/S,KAAK4Q,QAAQtI,GAAGhG,IAAItC,KAAKuB,OAAOwR,IAChC/S,KAAK4Q,QAAQiC,OAAOE,EAAG,IAMnC/S,KAAK4Q,QAAU5Q,KAAK4Q,QAAQ7I,QAAQzG,GACD,IAAxBA,EAAEmB,YAAYG,QAIzB,IAAK,MAAMtB,KAAKtB,KAAK4Q,QACjBtP,EAAEmB,YAAYqD,SAGlB,OAAoB,IAAhB9F,KAAKwC,QACE,IAAIrE,GAAU+C,OAElBlB,MAGX,KAAAmB,QAAU,CAACc,EAAiB,OAExBjC,KAAK4Q,QAAQ5I,MAAK,SAAUvC,EAAGC,GAC3B,OAAOA,EAAE/F,OAAOsC,GAAQpB,QAAQI,SAASwE,EAAE9F,OAAOsC,IAASW,SAExD5C,KAAK8F,UAGhB,KAAAnG,OAAUsC,IACN,IAAIsM,GAAc,IAAI,EAAAxQ,UAAWmD,OACjC,IAAK,MAAMI,KAAKtB,KAAK4Q,QACjBrC,EAAI,EAAAxQ,SAASiF,IAAI1B,EAAE3B,OAAOsC,GAAQW,MAAO2L,GAE7C,OAAOA,GAGX,KAAAtL,QAAU,KACN,IAAsB+P,EAAI,IAAI9P,IAE9B,IAAK,IAAI5B,KAAKtB,KAAK4Q,QACfoC,EAAI,IAAI9P,IAAI,IAAI8P,KAAM1R,EAAEiG,YAI5B,MAAO,IAAIyL,IAQf,KAAAtQ,UAAY,CAACT,EAAgBU,KACzB,IAAIuK,EACJ,MAAM+F,GAAyB,IAAI9U,GAAU+C,OAE7C,IAAK,MAAMI,KAAKtB,KAAKuB,YACS0C,IAAtB3C,EAAEgL,QAAQrK,IAAyBX,EAAEgL,QAAQrK,GAAQT,SACrDyR,EAAc3Q,IAAIhB,EAAET,UAIpBqM,EAAM5L,EAAEgL,QAAQrK,GAAQpB,eACjBS,EAAEgL,QAAQrK,GAGjBgR,EAAc3Q,IAAIK,EAAE9B,QAAQqM,IAAIvH,KAAKyJ,IAAIlC,EAAIiC,YAAYzN,SAASJ,KAK1E,OADAtB,KAAK4Q,QAAUqC,EAAcnN,SAAS3E,UAAUI,OACzCvB,MAIX,KAAA4D,SAAYD,IACR,MAAMyK,GAAI,IAAI,EAAArQ,UAAWmD,OAOzB,OALAlB,KAAK4Q,QAAQrK,SAAQ2M,IAEjB9E,EAAE9L,IAAI4Q,EAAMtP,SAASD,OAGlByK,GAGX,KAAAE,WAAcrM,IACV,IAAIkR,EAAK,IAAIhV,EAEb,IAAK,IAAImD,KAAKtB,KAAK4Q,QACfuC,EAAG7Q,IAAIhB,EAAEgN,WAAWrM,IAExB,OAAOkR,GAIX,KAAA1E,UAAaxM,IACT,IAAIkR,EAAK,IAAIhV,EAEb,IAAK,IAAImD,KAAKtB,KAAK4Q,QACfuC,EAAG7Q,IAAIhB,EAAEmN,UAAUxM,IAEvB,OAAOkR,GAKX,KAAAC,UAAY,CAAC3N,EAAsBC,EAAsBzD,KACrD,MAAMwM,EAAYzO,KAAKyO,UAAUxM,QAElBgC,IAAXhC,IACAA,EAAS,KAGb,IAAIoR,EAAuB,GACvBC,EAAuB,GAI3B,OAHAD,EAAQpR,GAAU,IAAI,EAAAlE,SAAS0H,GAC/B6N,EAAQrR,GAAU,IAAI,EAAAlE,SAAS2H,GAExB+I,EAAU7K,SAAS0P,GAASrS,SAASwN,EAAU7K,SAASyP,KAQnE,KAAAhN,UAAapE,IACT,IAKIsR,EALAjN,EAAqB,GAGrB3D,EAAI3C,KAAKa,QAAQM,UACjB2L,EAAInK,EAAE6Q,cAIL1G,EAAE5K,UACHqR,EAAc,IAAIpV,EAClBoV,EAAYhS,OAAS,CAACuL,GACtBxG,EAAU,CAACiN,EAAY1S,SACvB8B,EAAIA,EAAE2O,UAAUiC,GAAahC,UAGjC,IACIkC,EADAC,EAAe/Q,EAAEhD,SAASkB,QAAQa,SAAS,GAAGkB,MAIlD,KAAO8Q,GAAgB,GAAG,CAGtB,GAFAA,IAEI/Q,EAAEpB,OAAOiB,OAAS,EAAG,CAChBG,EAAET,SACHoE,EAAQO,KAAKlE,EAAE9B,SAEnB,MACG,CAEH,IAAI0D,EAAK5B,EAAEpB,OAAO,GAAG0N,SACjB0E,EAAKhR,EAAEpB,OAAOoB,EAAEpB,OAAOiB,OAAS,GAAGyM,SAEvC,IAAK,IAAI2E,KAAOrP,EACZ,IAAK,IAAIsP,KAAOF,EAAI,CAEhB,IAAIG,EAAiB,IAAI3V,EAEzB2V,EAAevS,OAAS,CAACqS,EAAI/S,QAASgT,EAAIhT,SAC1C4S,EAAS9Q,EAAE2O,UAAUwC,GAEjBL,EAAOjC,SAAShQ,UAChBmB,EAAI8Q,EAAOlC,SAAS1Q,QACpByF,EAAQO,KAAKiN,KAIjBA,EAAevS,OAAS,CAACqS,EAAI/S,QAASgT,EAAIhT,QAAQ0B,WAClDkR,EAAS9Q,EAAE2O,UAAUwC,GACjBL,EAAOjC,SAAShQ,WAChBmB,EAAI8Q,EAAOlC,SAAS1Q,QACpByF,EAAQO,KAAKiN,OAUjC,OAHInR,EAAET,SAASoE,EAAQO,KAAKlE,EAAE9B,SAE9Bb,KAAKsG,QAAUA,EACRA,GAIX,KAAAyN,UAAY,KACR,IAAI3N,EAAM,IAAI,EAAAhI,SAAS4B,KAAKa,QAAS,GAErC,OADAuF,EAAIjD,QACGiD,EAAIO,WA2Ff,KAAAnC,cAAgB,CAAC7E,EAA4BsC,KACzC,QAAegC,IAAXtE,EAEA,OAAOK,KAAKwE,cAAcxE,KAAKL,OAAOsC,GAASA,GAInD,MAAM6K,EAAI9M,KAAKa,QAAQiF,SACvB,IAAK,MAAMxE,KAAKwL,EAAE8D,QACd,GAAItP,EAAE3B,OAAOsC,GAAQ4B,QAAQlE,GACzB,OAAO2B,EAAET,QAKjB,OAAO,IAAI,EAAA3C,OAAQgD,QAGvB,KAAA8S,eAAiB,CAACrU,EAA4BsC,KAC1C,QAAegC,IAAXtE,EAEA,OAAOK,KAAKgU,eAAehU,KAAKL,OAAOsC,IAI3C,IAAIgS,EAAc,GAElB,MAAMnH,EAAI9M,KAAKa,QAAQiF,SACvB,IAAK,MAAMxE,KAAKwL,EAAE8D,QACVtP,EAAE3B,OAAOsC,KAAYtC,GACrBsU,EAAGpN,KAAKvF,EAAET,SAIlB,OAAOoT,GAKX,KAAA7J,cAAiBnI,IACb,MAAM6K,EAAI9M,KAAKa,QAAQiF,SACvB,IAAK,MAAMxE,KAAKwL,EAAE8D,QACd,GAAItP,EAAEe,UAAUJ,GACZ,OAAOX,EAAET,QAIjB,OAAO,IAAI,EAAA3C,OAAQgD,QAIvB,KAAAU,gBAAkB,KACd,MAAMsS,EAAyB,GAC/B,IAAK,MAAM5S,KAAKtB,KAAK4Q,QACjBsD,EAAarN,KAAKvF,EAAEmB,YAAY+C,aAEpC,OAAO0O,GAGX,KAAAnS,cAAgB,KACZ,MAAMoS,EAAuB,GAC7B,IAAK,MAAM7S,KAAKtB,KAAK4Q,QACjBuD,EAAWtN,KAAKvF,EAAEmB,YAAY0M,WAElC,OAAOgF,GAGX,KAAAC,eAAiB,IACN,EAAAvW,QAAQ8D,OAAO3B,KAAK4B,mBAK/B,KAAAyS,eAAiB,IACN,EAAAxW,QAAQiE,OAAO9B,KAAK4B,mBAG/B,KAAA0S,aAAe,IACJ,EAAAzW,QAAQ8D,OAAO3B,KAAK+B,iBAG/B,KAAAwS,aAAe,IACJ,EAAA1W,QAAQiE,OAAO9B,KAAK+B,iBAM/B,KAAAyR,YAAc,KACV,IAA2BrE,EAAmB3J,EAA1CsH,GAAI,IAAI,EAAA5O,OAAQuO,MAA+C9M,EAASK,KAAKL,SAEjFwP,EAAYnP,KAAKuU,eACjB/O,EAAcxF,KAAKqU,iBAEnBvH,EAAErK,YAAc,IAAI,EAAA1E,SAASoR,EAAW3J,GACxC,IAAK,IAAI2E,KAAKnK,KAAKuH,UAAW,CAE1BuF,EAAEJ,UAAUvC,EAAGxK,GACf,IAAK,IAAI2B,KAAKtB,KAAK4Q,QAEf,GADA9D,EAAEJ,UAAUvC,EAAG,EAAApM,SAAS0S,IAAInP,EAAE3B,OAAOwK,GAAI2C,EAAEnN,OAAOwK,KAC9C2C,EAAEnN,OAAOwK,GAAG3I,SACZ,MAIZ,OAAOsL,GAGX,KAAA0H,gBAAmBvS,IACf,MAAM6K,EAAI9M,KAAKwE,mBAAcP,EAAWhC,GACpCxB,EAAOqM,EAAErK,YAAYhC,OACrBd,EAASmN,EAAEnN,OAAOsC,GAEtB,OAAItC,EAAOoQ,qBACS,IAATtP,GAAa,IAAK,EAAA1C,UAAY0W,YAAa,IAAK,EAAA1W,UAAY0W,WAAWlS,UACvE5C,EAAO6B,SACPsL,EAAErK,aAIN,IAAK,EAAA1E,UAAYmD,QAE5B,KAAAwT,wBAA2BzS,IACvB,MAAM6K,EAAI9M,KAAKwE,mBAAcP,EAAWhC,GACpCxB,EAAOqM,EAAErK,YAAYhC,OACrBd,EAASmN,EAAEnN,OAAOsC,GAEtB,OAAItC,EAAOoQ,sBACU,IAAVtP,GAAc,IAAK,EAAA1C,UAAY0W,YAAa,IAAK,EAAA1W,UAAY0W,WAAWlS,UACxE5C,EAAO6B,SACPsL,EAAErK,aAIN,IAAK,EAAA1E,UAAYmD,QAuDpB,KAAAyT,WAAa,CAACC,EAAiBC,EAAqBC,KACxD,IAAInS,EAAY,GAEhB,IAAK,MAAMiK,KAAK5M,KAAK4Q,QACW,IAAxBhE,EAAEnK,YAAYG,QAIlBD,GAAK,GAA6B,IAAzBiK,EAAEnK,YAAYhC,QAAuB,KAANkC,IAA0B,IAAdkS,EAA6B,GAAN,MAAuB,QAAXD,EAAoBhI,EAAEhI,IAAMgI,EAAEvF,WAczH,OAXwB,IAApByN,GAA4B9U,KAAKwC,OAAS,IAEtCG,EADW,QAAXiS,EACI,WAAWjS,aAEX,IAAIA,MAIN,KAANA,IACAA,EAAI,KAEDA,GAOH,KAAAoS,4BAA+B9I,IAEnC,MACMnB,GADkB,IAAI,EAAAlN,aAAcgC,MAAMqM,GACOnB,IAGvD9K,KAAKkB,OAEL,IAAIqL,EAAmB,GACJ,IAAI,EAAArO,MAGvB,IAAK,MAAMsO,KAAW1B,EAClB3M,EAAQwO,SAASJ,EAAOC,GAO5B,OAJqB,IAAjBD,EAAM/J,QACNxC,KAAKsC,IAAIiK,EAAM,IAGZvM,MAsCH,KAAAkR,kBAAqBvO,IACzB,MAAMmK,EAAa,GACnB,IAAK,MAAMvI,KAAMvE,KAAK4Q,QAClB,IAAK,MAAM+C,KAAMhR,EAAEpB,OACfuL,EAAEjG,KAAK,EAAA3I,MAAMwS,UAAUnM,EAAIoP,IAKnC,OADA3T,KAAK4Q,QAAU9D,EACR9M,KAAK8F,UAGR,KAAAqL,mBAAsBtO,IAC1B,IAAK,MAAMvB,KAAKtB,KAAK4Q,QACjBtP,EAAEmB,YAAYf,SAASmB,GAG3B,OAAO7C,KAAK8F,UAGR,KAAAuL,kBAAqBlE,GAClBnN,KAAKmR,mBAAmB,IAAI,EAAApT,SAASoP,IAGxC,KAAAiE,gBAAmBtE,IACvB,IAAK,MAAMxL,KAAKtB,KAAK4Q,QACjBtP,EAAEI,SAASoL,GAEf,OAAO9M,KAAK8F,UAGR,KAAAkM,gBAAmB7E,IACvB,MAAM6H,EAAM,IAAI,EAAAjX,SAASoP,GACzB,IAAK,MAAM7L,KAAKtB,KAAK4Q,QACjBtP,EAAEmB,YAAYZ,OAAOmT,GAEzB,OAAOhV,MAGH,KAAA+R,iBAAoBlP,IACxB,IAAK,MAAMvB,KAAKtB,KAAK4Q,QACjBtP,EAAEmB,YAAYZ,OAAOgB,GAEzB,OAAO7C,MAGH,KAAAiV,oBAAuBhT,IAC3B,IAAIiT,EAAaC,EACb1P,EAAGC,EAAG0P,EAAGrQ,EAAOsQ,EAAIC,EAAI9O,EAG5B,GAA0B,IAAtBxG,KAAKyH,aAML,OALAhC,EAAIzF,KAAKwE,cAAc,EAAGvC,GAAQQ,YAClCiD,EAAI1F,KAAKwE,cAAc,EAAGvC,GAAQQ,YAClC2S,EAAIpV,KAAKwE,cAAc,EAAGvC,GAAQQ,YAClCsC,EAAQW,EAAE7E,QAAQqM,IAAI,GAAGjM,SAASwE,EAAE5E,QAAQa,SAAS0T,GAAG1T,SAAS,IAE7DqD,EAAMvD,UACN6T,EAAK3P,EAAE7E,QAAQ0B,UAAUV,OAAO4D,EAAE5E,QAAQa,SAAS,IACnDwT,EAAK,IAAI/W,EAAQ8D,GAAQhB,SAASoU,EAAGhO,SAAS3F,SAAS2T,EAAG7P,aAC1D2P,EAAK,IAAIhX,EAAQ8D,GAAQhB,SAASoU,EAAGhO,SAAS3F,SAAS2T,EAAG7P,aAC1DgB,EAASf,EAAE5D,OAAOwT,EAAG7P,aAAa3D,OAAOwT,EAAG7P,aAEvCgB,EAAOtE,QAID,CAACgT,EAAIC,GAFL,CAAC,IAAIhX,EAAQqI,EAAOa,SAAU6N,EAAIC,IAItCpQ,EAAM+M,cAAgB/M,EAAMuI,YACnC+H,EAAK3P,EAAE7E,QAAQ0B,UACVD,IAAIyC,EAAMlE,QAAQ+E,QAClB/D,OAAO4D,EAAE5E,QAAQa,SAAS,IAC/B4T,EAAK5P,EAAE7E,QAAQ0B,UACVtB,SAAS8D,EAAMlE,QAAQ+E,QACvB/D,OAAO4D,EAAE5E,QAAQa,SAAS,IAQ/B8E,EAASf,EAAE5D,OAAOwT,EAAG7P,aAAa3D,OAAOyT,EAAG9P,aACxCgB,EAAOtE,QACA,CACH,IAAI/D,EAAQ8D,GAAQhB,SAASoU,EAAGhO,SAAS3F,SAAS2T,EAAG7P,aACrD,IAAIrH,EAAQ8D,GAAQhB,SAASqU,EAAGjO,SAAS3F,SAAS4T,EAAG9P,cAGlD,CACH,IAAIrH,EAAQqI,EAAOa,SACnB,IAAIlJ,EAAQ8D,GAAQhB,SAASoU,EAAGhO,SAAS3F,SAAS2T,EAAG7P,aACrD,IAAIrH,EAAQ8D,GAAQhB,SAASqU,EAAGjO,SAAS3F,SAAS4T,EAAG9P,eAMtD,CAACxF,KAAKa,SASjB,GALA4E,EAAIzF,KAAKwE,cAAc,EAAGvC,GAC1ByD,EAAI1F,KAAKwE,cAAc,EAAGvC,GAC1BmT,EAAIpV,KAAKwE,cAAc,EAAGvC,GAGtBwD,EAAEmI,mBAAqBwH,EAAExH,mBAErBlI,EAAE7E,QAAQqM,IAAI,GAAGF,SAASvH,EAAE5E,QAAQa,SAAS0T,IAAK,CAMlD,IAGkBG,EAFdC,EADW,IAAIrX,EAAQ,IAAKsH,EAAEhD,YAAaiD,EAAEjD,YAAa2S,EAAE3S,aACxCwS,oBAAoB,KAExC3O,EAAU,GAEd,GAAIkP,EAAShT,QAAU,EAAG,CACtB,IAAK,IAAI6K,KAAKmI,EACNnI,EAAE1N,SAAS6B,SACX8E,EAAQO,KAAKwG,EAAExM,UAEf0U,EAAalI,EAAExM,QACf0U,EAAWhU,OAAO,GAAG+K,QAAU7G,EAAEmJ,YACjC2G,EAAWhU,OAAO,GAAG+K,QAAU8I,EAAExG,YACjCtI,EAAQO,KAAK0O,EAAW1U,UAGhC,OAAOyF,GAKnB,MAAO,CAACtG,KAAKa,UAgCb,KAAA4U,mBAAqB,IAElB,GA7zCPzV,KAAK4Q,QAAU,GACf5Q,KAAK6Q,SAAW,QACM5M,IAAlB0M,GACA3Q,KAAKJ,MAAM+Q,KAAkBhN,GAE1B3D,KAMPuB,aACA,OAAOvB,KAAK4Q,QAGZrP,WAAOuL,GACP9M,KAAK4Q,QAAU9D,EAQfxG,cACA,OAAOtG,KAAK6Q,SAGZvK,YAAQ1D,GACR5C,KAAK6Q,SAAWjO,EAKhB8S,gBACA,OAAO1V,KAAK2V,WAGZC,iBAGA,GAFA5V,KAAKqG,YAEoB,IAAtBrG,KAAKsG,QAAQ9D,OACZ,OAAOxC,KAAK4E,IAEhB,IAAIA,EAAM,GACV,IAAK,IAAIgO,KAAK5S,KAAKsG,QACXsM,EAAErR,OAAOiB,OAAS,EAClBoC,GAAO,IAAIgO,EAAEhO,OAEbA,EAAMgO,EAAEhO,IAAMA,EAGtB,OAAOA,EAGPpC,aAEA,OAAOxC,KAAK4Q,QAAQpO,OAGpB6E,cACA,OAAOrH,KAAK2U,aAGZrN,UACA,OAAOtH,KAAK+K,WAGZnG,UACA,OAAO5E,KAAK2U,WAAW,OAGvBxS,sBAEA,IAAK,MAAMb,KAAKtB,KAAK4Q,QACjB,GAAItP,EAAEiG,UAAU/E,OAAS,EACrB,OAAO,EAGf,OANU,EASV+E,gBACA,IAAIqC,EAAc,GAElB,IAAK,MAAMtI,KAAKtB,KAAK4Q,QACjBhH,EAAIA,EAAEpC,OAAOlG,EAAEiG,WAMnB,OAFAqC,EAAI,IAAI,IAAI1G,IAAI0G,IAETA,EAGPnC,mBACA,OAAOzH,KAAKuH,UAAU/E,OAgY1BhB,SACI,OAAgC,IAAxBxB,KAAK4Q,QAAQpO,QAAgBxC,KAAK4Q,QAAQ,GAAGnO,YAAYjB,UAAqC,IAAxBxB,KAAK4Q,QAAQpO,OAG/FN,QACI,OAA+B,IAAxBlC,KAAK4Q,QAAQpO,QAAgBxC,KAAK4Q,QAAQ,GAAGnO,YAAYP,QAiiB5D4O,aAAa7E,KAAqBtI,GACtC,QAAeM,IAAXN,GAA0C,IAAlBA,EAAOnB,OAAc,CAK7C,GAJAyJ,EAAW,GAAKA,EAChBjM,KAAK+K,WAAakB,EAGD,KAAbA,IAAoB4J,MAAM7E,OAAO/E,IAAY,CAC7CjM,KAAK+Q,QAEL,IAAIzP,EAAI,IAAI,EAAApD,MAAM+N,GAIlB,OADAjM,KAAKsC,IAAIhB,GACFtB,KAIX,OAAOA,KAAK+U,4BAA4B9I,GACrC,GAAI,SAASvI,KAAKuI,GAAW,CAEhCjM,KAAK+Q,QAEL,IAAI+E,EAAYnS,EAAOoD,KAAIC,GAAK,IAAI,EAAAjJ,SAASiJ,KAE7C,GAAIiF,EAASzJ,OAAS,EAAG,CAErB,IAAIS,EAAUgJ,EAAS/L,MAAM,IACzBoI,EAAI,EACR,IAAK,IAAIzF,KAAKiT,EAAW,CACrB,IAAIxU,EAAI,IAAI,EAAApD,MACZoD,EAAEmB,YAAcI,EAAEhC,QAClBS,EAAEuN,WAAa5L,EAAQqF,IAAM,GAC7BtI,KAAKsC,IAAIhB,GACTgH,SAIH,CACD,IAAI6F,EAAI2H,EAAUtT,OAAS,EAC3B,IAAK,IAAIK,KAAKiT,EAAW,CACrB,IAAIxU,EAAI,IAAI,EAAApD,MACZoD,EAAEmB,YAAcI,EAAEhC,QAClBS,EAAEuN,WAAa,GAAG5C,KAAYkC,IAC9BnO,KAAKsC,IAAIhB,GACT6M,KAGR,OAAOnO,KAEP,OAAOA,KAAKkB,QAhkCxB,YA4GW,EAAAyL,SAAW,CAACJ,EAAkBC,KAEjC,OAAQA,EAAQjB,WACZ,KAAK,EAAA4E,gBAAgBC,YACjB7D,EAAM1F,KAAK,IAAI1I,EAAQqO,EAAQlB,QAC/B,MAEJ,KAAK,EAAA6E,gBAAgBE,SACjB9D,EAAM1F,MAAK,IAAI1I,GAAUmE,IAAI,IAAI,EAAApE,MAAMsO,EAAQlB,SAC/C,MAEJ,KAAK,EAAA6E,gBAAgB4F,SAEjB1V,QAAQ0D,IAAI,mDACZ,MAEJ,KAAK,EAAAoM,gBAAgBG,UACjB,GAAI/D,EAAM/J,QAAU,EAAG,CACnB,MAAMkD,EAAI6G,EAAMd,MACZhG,EAAI8G,EAAMd,MAEd,GAAsB,MAAlBe,EAAQlB,MACRiB,EAAM1F,KAAKpB,EAAEnD,IAAIoD,SACd,GAAsB,MAAlB8G,EAAQlB,MACfiB,EAAM1F,KAAKpB,EAAExE,SAASyE,SACnB,GAAsB,MAAlB8G,EAAQlB,MACfiB,EAAM1F,KAAKpB,EAAE/D,SAASgE,SACnB,GAAsB,MAAlB8G,EAAQlB,MACX5F,EAAE/F,SAASoQ,qBACX1P,QAAQ0D,IAAI,6DAEZwI,EAAM1F,KAAKpB,EAAE5D,OAAO6D,EAAEnE,OAAO,GAAGkB,mBAGjC,GAAsB,MAAlB+J,EAAQlB,MACf,GAAI5F,EAAE/F,SAASoQ,qBACX1P,QAAQC,MAAM,wDAEd,GAAIoF,EAAEnE,OAAO,GAAGkB,YAAYyM,aAExB3C,EAAM1F,KAAKpB,EAAEyH,IAAIxH,EAAEnE,OAAO,GAAGkB,YAAYG,aAGzC,GAAwB,IAApB6C,EAAElE,OAAOiB,QAAgBiD,EAAElE,OAAO,GAAGkB,YAAYP,QAAS,CAC1D,IAAK,IAAID,KAAUwD,EAAElE,OAAO,GAAG+K,QAC3B7G,EAAElE,OAAO,GAAG+K,QAAQrK,GAAQP,SAASgE,EAAEnE,OAAO,GAAGkB,aAErD8J,EAAM1F,KAAKpB,QAEXpF,QAAQC,MAAM,wCAM9BD,QAAQ0D,IAAI,eAAgBwI,EAAM/J,QACZ,MAAlBgK,EAAQlB,MACRiB,EAAM1F,KAAK0F,EAAMd,MAAMlJ,WAEvBlC,QAAQ0D,IAAI,+BAAgCyI,EAAQlB,MAAO,KAAMiB,EAAM,GAAG3H,KAGlF,MAEJ,KAAK,EAAAuL,gBAAgB6F,MAEjB3V,QAAQC,MAAM,0CACd,MAEJ,KAAK,EAAA6P,gBAAgB8F,SAEjB5V,QAAQ0D,IAAI,6E,iFChM5B,cACA,SAEA,SAKA,iBAQI3E,YAAY+P,EAAqB3J,GAyBjC,KAAA3E,MAAQ,KACJb,KAAKkW,WAAalW,KAAKkW,WAAWrV,QAClCb,KAAKmW,aAAenW,KAAKmW,aAAatV,QAE/Bb,MAGX,KAAAoW,OAAS,KACL,IAAIC,EAASrW,KAAKmW,aAAapC,YAC/B,OAAsB,IAAlBsC,EAAO7T,QAAgB6T,EAAO,GAAGzR,MAAQ,EAAAzF,oBAAoBM,KACtD,EAAAN,oBAAoBM,KACpB4W,EAAO,GAAGzR,MAAQ,EAAAzF,oBAAoBI,WACtC,EAAAJ,oBAAoBI,WAEpB,+BACH8W,EAAOtP,KAAIC,GAAKA,EAAEpC,MAAKqC,KAAK,KAAO,YAI/C,KAAAqP,QAAW3T,IACP3C,KAAKkW,WAAWxU,SAASiB,GACzB3C,KAAKmW,aAAazU,SAASiB,GAEpB3C,MAGX,KAAAsO,WAAcrM,IACV,IAAIuN,EAAIxP,KAAKkW,WAAWrV,QACpB0V,EAAIvW,KAAKmW,aAAatV,QACtB2V,EAAKhH,EAAE3O,QAAQyN,WAAWrM,GAC1BwU,EAAKF,EAAE1V,QAAQyN,WAAWrM,GAK9B,OAHAjC,KAAKkW,WAAaM,EAAG3V,QAAQa,SAAS6U,GAAGtV,SAASuO,EAAE3O,QAAQa,SAAS+U,IACrEzW,KAAKmW,aAAeI,EAAE1V,QAAQqM,IAAI,GAE3BlN,MAGX,KAAAyB,SAAYkB,IACR,IAAI+T,EAAqB1W,KAAKkW,WAAW5E,UAAU3O,GACnD,IAAK+T,EAAmBlF,SAAShQ,SAC7B,OAAOxB,KAGX,IAAI2W,EAAuB3W,KAAKmW,aAAa7E,UAAU3O,GACvD,OAAKgU,EAAqBnF,SAAShQ,UAInCxB,KAAKkW,WAAaQ,EAAmBnF,SACrCvR,KAAKmW,aAAeQ,EAAqBpF,SAClCvR,MALIA,MAQf,KAAA8F,OAAS,KACL9F,KAAKkW,WAAW7P,YAChB,IAAK,IAAIuM,KAAK5S,KAAKkW,WAAW5P,QAC1BtG,KAAKyB,SAASmR,GAGlB,OAAO5S,MAGX,KAAAuC,QAAU,KACNvC,KAAKkW,WAAW3T,UACTvC,MAEX,KAAAsC,IAAOsU,IAMH,IAAIpR,EAAcxF,KAAKmW,aAAatV,QAQpC,OALAb,KAAKsW,QAAQM,EAAET,cAGfnW,KAAKkW,WAAW5T,IAAIsU,EAAEV,WAAWrV,QAAQa,SAAS8D,IAE3CxF,MAGX,KAAAiB,SAAY2V,GACD5W,KAAKsC,IAAIsU,EAAE/V,QAAQ0B,WAG9B,KAAAsU,OAAS,CAACjU,EAA0BkU,EAAiB7U,KACjD,GAAIW,IAAUmU,EAAAA,GAAYnU,KAAU,IAAW,CAC3C,IAAI,SAAC2O,EAAQ,SAAEC,GAAYxR,KAAKkW,WAAWrV,QAAQyQ,UAAUtR,KAAKmW,cAGlE,OAAI5E,EAAS5R,OAAOsC,GAAQ8N,qBACjBnN,IAAUmU,EAAAA,EAAWxF,EAASiD,gBAAgBvS,GAAUsP,EAASmD,wBAAwBzS,GAGzFsP,EAAS/M,mBAAcP,EAAWhC,GAAQQ,YAElD,CACH,IAEIuU,EACAC,EAHAC,EAA0B,GAC1BC,EAAgC,GAGhCC,EAAKpX,KAAKa,QAAQiF,SAItB,OAFAoR,OAAsBjT,IAAXhC,EAAuB,IAAMA,GAAU,IAAI,EAAAlE,SAAS6E,GAEhD,UAAXkU,GAAiC,UAAXA,GACtBE,EAAWI,EAAGlB,WAAWtS,SAASsT,GAC7BrV,OAAOuV,EAAGjB,aAAavS,SAASsT,IAE9BF,EAASK,aAAeL,EAAS5H,MAAQ4H,IAEjC,UAAXF,EACAK,OAA4BlT,IAAXhC,EAAuB,IAAMA,GAAU,IAAK,EAAAlE,SAAS6E,GAAQN,IAAI,MAChE,UAAXwU,IACPK,OAA4BlT,IAAXhC,EAAuB,IAAMA,GAAU,IAAK,EAAAlE,SAAS6E,GAAQ3B,SAAS,OAG3F+V,EAAWI,EAAGlB,WAAWtS,SAASsT,GAC7BrV,OAAOuV,EAAGjB,aAAavS,SAASsT,IACrCD,EAAUG,EAAGlB,WAAWtS,SAASuT,GAC5BtV,OAAOuV,EAAGjB,aAAavS,SAASuT,IAAmB1W,OAEpDuW,EAASK,aACU,IAAZJ,EAAgBD,EAAS5H,MAAQ4H,EAAS5H,MAAM7M,UAEhDyU,KAMvB,KAAAM,iBAAmB,KAEftX,KAAKkW,WAAW7P,YAChBrG,KAAKmW,aAAa9P,YAElB,IAAIgQ,EAAS,EAAAjY,SAASqF,oBAAoB,IAAIzD,KAAKkW,WAAWnC,eAAgB/T,KAAKmW,aAAapC,cAAc,GAC1GwD,EAAWvX,KAAKkW,WAAW5P,QAC3BkR,EAAWxX,KAAKmW,aAAa7P,QAE7BmR,EAA6B,GAGjCF,EAAShR,SAAQC,IACbiR,EAAa5Q,KAAK7G,KAAK0X,2BAA2BlR,EAAQ6P,EAAQ,SAEtEmB,EAASjR,SAAQC,IACbiR,EAAa5Q,KAAK7G,KAAK0X,2BAA2BlR,EAAQ6P,EAAQ,SAItEoB,EAAa5Q,KAAK,IAGlB,IAAI8Q,EAAuBF,EAAa,GAAG1Q,KAAI,CAACC,EAAG4Q,IACjC,IAAVA,GAGAA,IAAUH,EAAa,GAAGjV,OAAS,EAF5B,GAKPoV,EAAQ,GAAM,EACP,IAEJ,MAGX,IAAK,IAAIC,KAAWJ,EAChB,IAAK,IAAInP,EAAI,EAAGA,EAAIuP,EAAQrV,OAAQ8F,IAChC,GAAIA,EAAI,GAAM,EAAG,CAEb,GAAsB,MAAlBqP,EAAWrP,GACX,SAEe,MAAfuP,EAAQvP,KACRqP,EAAWrP,GAAKuP,EAAQvP,QAIT,MAAfuP,EAAQvP,KACRqP,EAAWrP,GAAuB,MAAlBqP,EAAWrP,GAAa,IAAM,KAS9DmP,EAAa5Q,KAAK8Q,GAElB,IAAIG,EAAM,CACNxR,QAAS,IAAIiR,KAAaC,GAC1BnB,OAAQA,EACR0B,MAAON,EACP7S,IAAK,IAKT,OAFA5E,KAAKgY,yBAAyBF,GAEvBA,GAGH,KAAAE,yBAA4BF,IAEhC,IAAIlT,EAAM,uEAC8BkT,EAAIxR,QAAQS,KAAIC,GAAKA,EAAEpC,MAAKqC,KAAK,wFAAwF6Q,EAAIzB,OAAOtP,KAAIC,GAAKA,EAAEpC,MAAKqC,KAAK,8DAQjM,OAPA6Q,EAAIC,MAAMxR,SAAQ0R,IACdrT,GAAO,kBAAmBqT,EAAKhR,KAAK,WAExCrC,GAAO,uBAEPkT,EAAIlT,IAAMA,EAEHA,GAEH,KAAA8S,2BAA6B,CAAClR,EAAiB6P,EAAqB6B,KACxE,IAAIC,EAAoB,GAEpBC,EAAc5R,EAAOuN,YAAYhN,KAAIC,GAAGA,EAAEpC,MAG9CuT,EAAQtR,KAAK,IACbsR,EAAQtR,KAAqD,IAAhDL,EAAO5C,SAASyS,EAAO,GAAGzT,MAAQ,GAAGnC,OAAe,IAAM,KAEvE,IAAK,IAAI6H,EAAI,EAAGA,EAAI+N,EAAO7T,OAAQ8F,IAE/B6P,EAAQtR,KAAKuR,EAAYtU,SAASuS,EAAO/N,GAAG1D,KAAOsT,EAAW,KAG1D5P,EAAI+N,EAAO7T,OAAS,EACpB2V,EAAQtR,KAA6E,IAAxEL,EAAO5C,UAAUyS,EAAO/N,GAAG1F,MAAQyT,EAAO/N,EAAI,GAAG1F,OAAS,GAAGnC,OAAe,IAAM,KACxF6H,IAAM+N,EAAO7T,OAAS,GAC7B2V,EAAQtR,KAAqD,IAAhDL,EAAO5C,SAASyS,EAAO/N,GAAG1F,MAAQ,GAAGnC,OAAe,IAAM,KAM/E,OAFA0X,EAAQtR,KAAK,IAENsR,GA1QPnY,KAAKkW,WAAa/G,EAAYA,EAAUtO,QAAU,IAAI,EAAA1C,QACtD6B,KAAKmW,aAAe3Q,EAAcA,EAAY3E,QAAU,IAAI,EAAA1C,QAK5DgR,gBACA,OAAOnP,KAAKkW,WAKZ1Q,kBACA,OAAOxF,KAAKmW,aAGZvR,UACA,MAAO,YAAY5E,KAAKkW,WAAWtR,UAAU5E,KAAKmW,aAAavR,QAG/DgR,iBACA,MAAO,YAAY5V,KAAKkW,WAAWN,iBAAiB5V,KAAKmW,aAAaP,kB,iFC3C9E,eAQA,MAAa7X,EAITqB,YAAYwD,EAAiByV,GAQzB,OAsEJ,KAAAzY,MAAQ,CAACgD,EAAgByV,KACrB,IAAIrF,EAGJ,GAAc,OAAVpQ,GAA4B,KAAVA,EAGlB,OAFA5C,KAAKkW,WAAa,EAClBlW,KAAKmW,aAAe,EACbnW,KAGX,cAAe4C,GACX,IAAK,SAKD,GAHAoQ,EAAIpQ,EAAM1C,MAAM,KAGZ8S,EAAExQ,OAAS,EAAG,KAAM,wBACxB,GAAIwQ,EAAEjM,KAAIC,GAAW,KAANA,GAAY6O,MAAM7E,OAAOhK,MAAKlD,UAAS,GAAO,KAAM,eAGnE,GAAiB,IAAbkP,EAAExQ,OAEF,OAAOxC,KAAKJ,OAAOoT,EAAE,IACD,IAAbA,EAAExQ,OAGI,MAATwQ,EAAE,IACFhT,KAAKkW,WAAarR,IAClB7E,KAAKmW,aAAe,IAEpBnW,KAAKkW,YAAclD,EAAE,GACrBhT,KAAKmW,cAAgBnD,EAAE,KAI3BhT,KAAKkW,WAAarR,IAClB7E,KAAKmW,aAAe,GAExB,MACJ,IAAK,SACD,GAAInF,OAAOC,cAAcrO,GAErB5C,KAAKkW,YAActT,OAEWqB,IAA1BoU,GAAwCrH,OAAOC,cAAcoH,GAG7DrY,KAAKmW,cAAgBkC,EAFrBrY,KAAKmW,aAAe,MAIrB,CAIH,IAAI9I,EAAazK,EAAM6F,WAAYvI,MAAM,KAAK,GAAGsC,YAGnByB,IAA1BoU,GACArY,KAAKkW,WAAatT,EAAQ+C,KAAKuH,IAAI,GAAIG,GACvCrN,KAAKmW,aAAexQ,KAAKuH,IAAI,GAAIG,IAC1B2D,OAAOC,cAAcoH,KAC5BrY,KAAKkW,WAAatT,EAAQ+C,KAAKuH,IAAI,GAAIG,GAAK1H,KAAK2S,MAAM1V,EAAQ+C,KAAKuH,IAAI,GAAIG,EAAIgL,IAChFrY,KAAKwF,YAAcG,KAAKuH,IAAI,GAAIG,GAAK1H,KAAKuH,IAAI,GAAIG,EAAIgL,IAE1DrY,KAAK8F,SAET,MACJ,IAAK,SACGlD,aAAiB7E,IACjBiC,KAAKkW,YAActT,EAAMuM,UACzBnP,KAAKmW,cAAgBvT,EAAM4C,aAIvC,OAAOxF,MAGX,KAAAa,MAAQ,KACJ,IAAIgC,EAAI,IAAI9E,EAGZ,OAFA8E,EAAEsM,WAAanP,KAAKkW,WACpBrT,EAAE2C,aAAexF,KAAKmW,aACftT,GAGX,KAAA3B,KAAO,KACHlB,KAAKkW,WAAa,EAClBlW,KAAKmW,aAAe,EACbnW,MAGX,KAAAyM,IAAM,KACFzM,KAAKkW,WAAa,EAClBlW,KAAKmW,aAAe,EACbnW,MAGX,KAAAyU,SAAW,KACPzU,KAAKkW,WAAaa,EAAAA,EAClB/W,KAAKmW,aAAe,EACbnW,MAGX,KAAAuY,QAAU,KACNvY,KAAKkW,WAAarR,IAClB7E,KAAKmW,aAAe,EACbnW,MAMX,KAAAuC,QAAU,KACNvC,KAAKkW,YAAclW,KAAKkW,WACjBlW,MAGX,KAAAsC,IAAOO,IACH,KAAIA,aAAa9E,GAOb,OAAOiC,KAAKsC,IAAI,IAAIvE,EAAS8E,IAPN,CACvB,IAAI2M,EAAYxP,KAAKkW,WACjBK,EAAYvW,KAAKmW,aAErBnW,KAAKkW,WAAa1G,EAAI3M,EAAE2C,YAAc3C,EAAEsM,UAAYoH,EACpDvW,KAAKmW,aAAeI,EAAI1T,EAAE2C,YAK9B,OAAOxF,KAAK8F,UAGhB,KAAA7E,SAAY4B,GACJA,aAAa9E,EACNiC,KAAKsC,IAAIO,EAAEhC,QAAQ0B,WAEnBvC,KAAKsC,KAAKO,GAIzB,KAAAnB,SAAYmB,IAIR,IAAI2V,EAAI,IAAIza,EAAS8E,GAKrB,OAHA7C,KAAKkW,WAAalW,KAAKkW,WAAasC,EAAErJ,UACtCnP,KAAKmW,aAAenW,KAAKmW,aAAeqC,EAAEhT,YAEnCxF,KAAK8F,UAGhB,KAAAjE,OAAUgB,IACN,IAAI2V,EAAI,IAAIza,EAAS8E,GAErB,GAAoB,IAAhB2V,EAAErJ,UACF,OAAO,IAAIpR,GAAW0W,WAG1B,IAAIjF,GAAaxP,KAAKkW,WAClBK,GAAavW,KAAKmW,aAItB,OAFAnW,KAAKkW,WAAa1G,EAAIgJ,EAAEhT,YACxBxF,KAAKmW,aAAeI,EAAIiC,EAAErJ,UACnBnP,KAAK8F,UAGhB,KAAA/C,OAAS,KACL,IAAIoL,GAAKnO,KAAKkW,WAAY3H,GAAKvO,KAAKmW,aAIpC,OAHAnW,KAAKkW,WAAa3H,EAClBvO,KAAKmW,aAAehI,EAEbnO,MAEX,KAAAkN,IAAOG,IAEH,GAAIA,aAAatP,EACb,OAAOiC,KAAKkN,IAAIG,EAAEzK,OAGtB5C,KAAK8F,SACDuH,EAAI,GACJrN,KAAK+C,SAKT,IAAI0V,EAAmB9S,KAAK2S,MAAM3S,KAAKuH,IAAIlN,KAAKkW,WAAYvQ,KAAKyJ,IAAI/B,KAcrE,OAbyB1H,KAAK2S,MAAM3S,KAAKuH,IAAIlN,KAAKmW,aAAcxQ,KAAKyJ,IAAI/B,KAEtEoL,GAAoB9S,KAAKyJ,IAAI/B,KAAOrN,KAAKkW,aAElBvQ,KAAKyJ,IAAI/B,GAAOrN,KAAKmW,cAE3CnW,KAAKkW,WAAalW,KAAKkW,YAAcvQ,KAAKyJ,IAAI/B,GAC9CrN,KAAKmW,aAAenW,KAAKmW,cAAgBxQ,KAAKyJ,IAAI/B,GAM/CrN,MAGX,KAAAoN,KAAQC,IAIM,IAANA,IAKAA,EAAI,GACJrN,KAAK+C,SAGD4C,KAAKuH,IAAIlN,KAAKkW,WAAYvQ,KAAKyJ,IAAI,EAAI/B,IACvC1H,KAAKuH,IAAIlN,KAAKmW,aAAcxQ,KAAKyJ,IAAI,EAAI/B,IAEjDrN,KAAKkW,WAAavQ,KAAKuH,IAAIlN,KAAKkW,WAAYvQ,KAAKyJ,IAAI,EAAI/B,IACzDrN,KAAKmW,aAAexQ,KAAKuH,IAAIlN,KAAKmW,aAAcxQ,KAAKyJ,IAAI,EAAI/B,KAZlDrN,MAgBf,KAAA4F,KAAO,IACI5F,KAAKoN,KAAK,GAGrB,KAAAgC,IAAM,KACFpP,KAAKkW,WAAavQ,KAAKyJ,IAAIpP,KAAKkW,YAChClW,KAAKmW,aAAexQ,KAAKyJ,IAAIpP,KAAKmW,cAC3BnW,MAsEX,KAAA8F,OAAS,KACL,IAAI4S,EAAI,EAAA7a,QAAQiE,IAAI9B,KAAKkW,WAAYlW,KAAKmW,cAQ1C,OAPAnW,KAAKkW,WAAalW,KAAKkW,WAAawC,EACpC1Y,KAAKmW,aAAenW,KAAKmW,aAAeuC,EAEpC1Y,KAAKmW,aAAe,IACpBnW,KAAKmW,cAAgBnW,KAAKmW,aAC1BnW,KAAKkW,YAAclW,KAAKkW,YAErBlW,MAGX,KAAAsW,QAAW1J,IACHoE,OAAOC,cAAcrE,KACrB5M,KAAKkW,YAActJ,EACnB5M,KAAKmW,cAAgBvJ,GAElB5M,MAYX,KAAAuN,QAAU,CAAC1K,EAAYpC,KAKnB,IAAIkY,EAOJ,YAXa1U,IAATxD,IACAA,EAAO,KAKPkY,EADA9V,aAAa9E,EACK8E,EAAEhC,QAEF,IAAI9C,EAAS8E,GAG3BpC,GACJ,IAAK,IACD,OAAOT,KAAK4C,MAAQ+V,EAAgB/V,MACxC,IAAK,KACD,OAAO5C,KAAK4C,OAAS+V,EAAgB/V,MACzC,IAAK,IACD,OAAO5C,KAAK4C,MAAQ+V,EAAgB/V,MACxC,IAAK,KACD,OAAO5C,KAAK4C,OAAS+V,EAAgB/V,MACzC,IAAK,IAID,OAAO5C,KAAK4C,QAAU+V,EAAgB/V,MAC1C,IAAK,KACD,OAAO5C,KAAK4C,QAAU+V,EAAgB/V,MAC1C,QACI,OAAO,IAInB,KAAAgW,OAAUC,GACC7Y,KAAKuN,QAAQsL,EAAM,KAE9B,KAAApS,IAAOoS,GACI7Y,KAAKuN,QAAQsL,EAAM,MAE9B,KAAAC,QAAWD,GACA7Y,KAAKuN,QAAQsL,EAAM,KAE9B,KAAAhH,IAAOgH,GACI7Y,KAAKuN,QAAQsL,EAAM,MAE9B,KAAAhV,QAAWgV,GACA7Y,KAAKuN,QAAQsL,EAAM,KAE9B,KAAA7J,WAAc6J,GACH7Y,KAAKuN,QAAQsL,EAAM,MAE9B,KAAAE,UAAa1L,GACFrN,KAAK6D,QAAQwJ,EAAExM,QAAQ0B,WAElC,KAAAyW,WAAc3L,GACHrN,KAAK6D,SAAQ,IAAI9F,GAAW0O,MAAM5K,OAAOwL,EAAExM,UAEtD,KAAAW,OAAS,IACsB,IAApBxB,KAAKkW,WAEhB,KAAAlI,UAAY,IACmB,IAApBhO,KAAKkW,WAEhB,KAAAhU,MAAQ,IACuB,IAApBlC,KAAKkW,YAA0C,IAAtBlW,KAAKmW,aAEzC,KAAA8C,cAAgB,KACgB,IAArBjZ,KAAKkW,YAA2C,IAAtBlW,KAAKmW,aAE1C,KAAArE,WAAa,IACc,IAAhB9R,KAAKS,OAEhB,KAAAyY,WAAa,KACe,IAAjBlZ,KAAKS,OAEhB,KAAAsP,mBAAqB,IACV/P,KAAK4C,MAAQ,EAExB,KAAAuW,mBAAqB,IACVnZ,KAAK4C,MAAQ,EAExB,KAAAiT,MAAQ,IACGA,MAAM7V,KAAKkW,YAEtB,KAAAmB,WAAa,IACF1R,KAAKyJ,IAAIpP,KAAKkW,cAAgBa,EAAAA,EAEzC,KAAAqC,SAAW,KACCpZ,KAAKqX,eAAiBrX,KAAK6V,QAEvC,KAAAvI,SAAW,IACA3H,KAAKC,KAAK5F,KAAKkW,YAAc,GAAM,GAAKvQ,KAAKC,KAAK5F,KAAKmW,cAAgB,GAAM,EAExF,KAAAkD,UAAY,IAC6D,IAA9D1T,KAAKyJ,IAAI,EAAAvR,QAAQiE,IAAI9B,KAAKkW,WAAYlW,KAAKmW,eAEtD,KAAAmD,UAAY,IACDtZ,KAAKkP,cAAgBlP,KAAK8R,aAErC,KAAA5C,WAAa,IACoC,IAAtClP,KAAKa,QAAQiF,SAASN,YAEjC,KAAAqI,WAAa,KACD7N,KAAKkP,aAEjB,KAAApB,OAAS,IACE9N,KAAKkP,cAAgBlP,KAAK4C,MAAQ,GAAM,EAEnD,KAAA2W,MAAQ,IACGvZ,KAAKkP,cAAgBlP,KAAK4C,MAAQ,GAAM,EAEnD,KAAAnC,KAAO,IACKT,KAAKkW,WAAalW,KAAKmW,cAAgB,EAAK,GAAK,EAQ7D,KAAAxH,UAAY,IAAI9L,KACZ,IAAK,IAAIyF,EAAI,EAAGA,EAAIzF,EAAEL,OAAQ8F,IAC1B,IAAKtI,KAAK6D,QAAQhB,EAAEyF,IAChB,OAAO,EAGf,OAAO,GAnhBPtI,KAAKkW,WAAa,EAClBlW,KAAKmW,aAAe,OAENlS,IAAVrB,GACA5C,KAAKJ,MAAMgD,EAAOyV,GAGfrY,KAOPmP,gBACA,OAAOnP,KAAKkW,WAGZ/G,cAAUvM,GACV5C,KAAKkW,WAAatT,EAGlB4C,kBACA,OAAOxF,KAAKmW,aAGZ3Q,gBAAY5C,GACZ5C,KAAKmW,aAAevT,EAGpBA,YACA,OAAO5C,KAAKkW,WAAalW,KAAKmW,aAI9BvR,UACA,OAAG5E,KAAKqX,cACoB,IAAdrX,KAAKS,OAAW,IAAI,KAAvB,UAGe,IAAtBT,KAAKmW,aACE,GAAGnW,KAAKkW,aACRlW,KAAKkW,WAAa,EAClB,aAAalW,KAAKkW,iBAAiBlW,KAAKmW,iBAExC,WAAWnW,KAAKkW,iBAAiBlW,KAAKmW,iBAIjD9O,cACA,OAA0B,IAAtBrH,KAAKmW,aACE,GAAGnW,KAAKkW,aAER,GAAGlW,KAAKkW,cAAclW,KAAKmW,eAKtCqD,WACA,OAAOxZ,KAAK4E,IAGZsB,YACA,OAAOlG,KAAK4E,IAAIV,QAAQ,SAAU,WAElC8L,YACA,OAAOhQ,KAAK4E,IAAIV,QAAQ,SAAU,YAvE1C,aA2TW,EAAAlB,IAAM,IAAI8S,KACb,IAAIhJ,EAAI,IAAI/O,EAAS+X,EAAU,IAE/B,IAAK,IAAIxU,KAAKwU,EAAW,CACrB,IAAIvI,EAAU,IAAIxP,EAASuD,GACvBiM,EAAQuL,QAAQhM,KAChBA,EAAIS,EAAQ1M,SAIpB,OAAOiM,GAEJ,EAAA2D,IAAM,IAAIqF,KACb,IAAIhJ,EAAI,IAAI/O,EAAS+X,EAAU,IAE/B,IAAK,IAAIxU,KAAKwU,EAAW,CACrB,IAAIvI,EAAU,IAAIxP,EAASuD,GACvBiM,EAAQqL,OAAO9L,KACfA,EAAIS,EAAQ1M,SAIpB,OAAOiM,GAGJ,EAAA2M,QAAU,IAAI3D,KACjB,IAAIhJ,GAAI,IAAI/O,GAAWmD,OAEvB,IAAI,IAAI0R,KAAKkD,EACThJ,EAAExK,IAAIsQ,GAKV,OAFA9F,EAAEjL,OAAOiU,EAAUtT,QAEZsK,GAGJ,EAAA4M,OAAS,CAAC5D,EAAuBlO,KAEpC,IAAI8R,EAAgC,GAChCC,EAAuB,GAQ3B,OAPA7D,EAAUvP,SAAQS,IACV0S,EAAO1S,EAAEnG,QAAQiF,SAASlB,OAC1B+U,EAAS9S,KAAKG,EAAEnG,SAChB6Y,EAAO1S,EAAEpC,MAAK,MAInBgD,EACQ7J,EAASiK,KAAK2R,GAEdA,GAGR,EAAA3R,KAAO,CAAC8N,EAAuB8D,KAElC,IAAIhS,EAASkO,EAAU9N,MAAK,CAACvC,EAAGC,IAAID,EAAE7C,MAAM8C,EAAE9C,QAI9C,OAFGgX,GAAShS,EAAOgS,UAEZhS,I,8EC5Xf,gBAMIxI,eAAeuE,GAyEf,KAAA/D,MAAQ,CAACia,EAAiBC,EAAkBrX,KACxCzC,KAAKmM,kBAAgClI,IAAhBxB,EAA6B,EAAIA,EACtDzC,KAAK+Z,UAAoB9V,IAAZ6V,EAAyB,EAAIA,EAC1C9Z,KAAKga,cAAwB/V,IAAZ4V,EAAyB,EAAIA,EAE3C7Z,KAAK+Z,KAAK,GAAI,GAAK/Z,KAAKga,SAAS,IAChCha,KAAKia,UAAW,GAEbja,MAMX,KAAA8F,OAAS,KAEL,IAAI8D,EAAIjE,KAAK2S,MAAM3S,KAAKuH,IAAIlN,KAAKga,SAAU,EAAIha,KAAK+Z,OACpD,KAAOnQ,EAAI,GACH5J,KAAKga,SAAWrU,KAAKuH,IAAItD,EAAG5J,KAAK+Z,OAAU,EAS/CnQ,KAPI5J,KAAKmM,cAAgBvC,EACrB5J,KAAKga,SAAWha,KAAKga,SAAWrU,KAAKuH,IAAItD,EAAG5J,KAAK+Z,MAGjDnQ,EAAIjE,KAAK2S,MAAM3S,KAAKuH,IAAIlN,KAAKga,SAAU,EAAIha,KAAK+Z,QAKxD,OAAO/Z,MAGX,KAAA0B,SAAY8N,IACRxP,KAAKga,UAAYxK,EAAEqK,QACZ7Z,KAAK8F,UAMhB,KAAAC,WAAa,MACgB,IAAhB/F,KAAKga,UAAgC,IAAhBha,KAAKga,WAAgC,IAAhBha,KAAKia,UAjHxDja,KAAKga,SAAW,EAChBha,KAAKmM,aAAe,EACpBnM,KAAK+Z,KAAO,EACZ/Z,KAAKia,UAAW,OAEFhW,IAAXN,GACC3D,KAAKJ,MAAM+D,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAO5CkW,cACA,OAAO7Z,KAAKga,SAGZH,YAAQjX,GACR5C,KAAKga,SAAWpX,EAGhBsX,UACA,OAAOla,KAAK+Z,KAGZG,QAAItX,GACAoO,OAAOC,cAAcrO,IAAUA,GAAS,EACxC5C,KAAK+Z,KAAOnX,GAGZvC,QAAQ0D,IAAI,8BACZ/D,KAAK+Z,KAAO,GAIhBtX,kBACA,OAAOzC,KAAKmM,aAGZ1J,gBAAYG,GACZ5C,KAAKmM,aAAevJ,EAGpBgC,UACA,IAAIoH,EAUJ,OAPIA,EADsB,IAAtBhM,KAAKmM,aACD,IAC0B,IAAvBnM,KAAKmM,aACR,IAEAnM,KAAKmM,aAAa1D,WAGJ,IAAlBzI,KAAKga,SACE,GAAGha,KAAKmM,eAEG,IAAdnM,KAAK+Z,KACE,GAAG/N,WAAWhM,KAAKga,YAEnB,GAAGhO,WAAWhM,KAAK+Z,SAAS/Z,KAAKga,YAKhDpX,YACA,OAAO5C,KAAKmM,aAAexG,KAAKuH,IAAIlN,KAAKga,SAAU,EAAIha,KAAK+Z,S,+EC5EpE,eACA,SAEA,eAKI3a,YAAYwD,GACR5C,KAAKma,YAAcvX,EACnB5C,KAAK2K,KAAO,IAAI,EAAA/M,YAAY,EAAAgN,gBAAgBwP,SAASxa,MAAMgD,GAAOkI,IAGlEA,UACA,OAAO9K,KAAK2K,KAGZ0P,cAIA,YAHmBpW,IAAhBjE,KAAKia,UACJja,KAAK4D,SAAS,CAACoD,EAAG,IAEfhH,KAAKia,SAGZI,YAAQzX,GACR5C,KAAKia,SAAWrX,EAGhB0X,iBACA,OAAOta,KAAKma,YAGRI,oBAAoB3X,GACxB,IAAI4X,EAAU5X,EAAM6F,WAEpB,OAAK+R,EAAQ1W,SAAS,MAItB0W,EAAUA,EAAQta,MAAM,KAAK,GAEtBsa,EAAQC,UAAU,EAAGD,EAAQhY,OAAS,IALlC,GAQPkY,kBAAkB9X,GAQtB,MAAM+X,EAAU,MAGVH,EAAUxa,KAAKua,oBAAoB3X,GACzC,GAAa,KAAV4X,EAAc,OAAO5X,EAExB,MAAMgY,EAAKJ,EAAQnI,MAAM,QACnBwI,EAAKL,EAAQnI,MAAM,QAEzB,GAAIuI,GAAMA,EAAG,GAAGpY,QARO,EAQqB,CAExC,MACIsY,EADQ9a,KAAKua,oBAAoB3X,EAAQ+X,GAC9BtI,MAAM,QAErB,GAAGyI,GAAQA,EAAK,GAAGtY,QAbA,EAef,QAAUI,EAAM+X,GAASlS,WAAWvI,MAAM4a,EAAK,IAAI,GAI3D,GAAID,GAAMA,EAAG,GAAGrY,QAnBO,EAmBqB,CAExC,MACIuY,EADQ/a,KAAKua,oBAAoB3X,EAAQ+X,GAC9BtI,MAAM,QAErB,GAAG0I,GAAQA,EAAK,GAAGvY,QAxBA,EA0Bf,OAASI,EAAM6F,WAAWvI,MAAM2a,EAAG,IAAI,GAI/C,OAAOjY,EAGHoY,YAAYzO,EAAgB3J,GAChC2J,EAAM1F,KAAK7G,KAAK0a,kBAAkB9X,IAGtCgB,SAASD,GACL,MAAM4I,EAAkB,GAExBvM,KAAKqa,SAAU,EAEf,IAAK,MAAM7N,KAAWxM,KAAK2K,KACvB,GAAI6B,EAAQjB,YAAc,EAAA4E,gBAAgBC,YAEjCyF,OAAOrJ,EAAQlB,OAGhBtL,KAAKgb,YAAYzO,EAAO,IAAI,EAAAxO,SAASyO,EAAQlB,OAAO1I,OAFpD5C,KAAKgb,YAAYzO,GAAQC,EAAQlB,YAIlC,GAAIkB,EAAQjB,YAAc,EAAA4E,gBAAgBE,cACfpM,IAA1BN,EAAO6I,EAAQlB,QACftL,KAAKgb,YAAYzO,GAAQ5I,EAAO6I,EAAQlB,aAEzC,GAAIkB,EAAQjB,YAAc,EAAA4E,gBAAgB4F,SAC7C/V,KAAKgb,YAAYzO,EAAO,EAAA0O,cAAczO,EAAQlB,aAC3C,GAAIkB,EAAQjB,YAAc,EAAA4E,gBAAgBG,WAC7C,GAAsB,MAAlB9D,EAAQlB,MAAe,CACvB,MAAM5F,EAAI6G,EAAMd,MACZhG,EAAI8G,EAAMd,WACLxH,IAANwB,QAAyBxB,IAANyB,IAAiB1F,KAAKqa,SAAU,GACtDra,KAAKgb,YAAYzO,EAAO9G,EAAIC,QACzB,GAAsB,MAAlB8G,EAAQlB,MAAe,CAC9B,MAAM5F,EAAI6G,EAAMd,MACZhG,EAAI8G,EAAMd,WACLxH,IAANwB,QAAyBxB,IAANyB,IAAiB1F,KAAKqa,SAAU,GACtDra,KAAKgb,YAAYzO,EAAO9G,EAAIC,QACzB,GAAsB,MAAlB8G,EAAQlB,MAAe,CAC9B,MAAM5F,EAAI6G,EAAMd,MACZhG,EAAI8G,EAAMd,WACLxH,IAANwB,QAAyBxB,IAANyB,IAAiB1F,KAAKqa,SAAU,GACtDra,KAAKgb,YAAYzO,GAAS9G,IAAOC,QAC9B,GAAsB,MAAlB8G,EAAQlB,MAAe,CAC9B,MAAM5F,EAAI6G,EAAMd,MACZhG,EAAI8G,EAAMd,OAAS,OACdxH,IAANyB,IAAiB1F,KAAKqa,SAAU,GACnCra,KAAKgb,YAAYzO,EAAO9G,EAAIC,QACzB,GAAsB,MAAlB8G,EAAQlB,MAAe,CAC9B,MAAM5F,EAAI6G,EAAMd,MACZhG,EAAI8G,EAAMd,WACLxH,IAANwB,QAAyBxB,IAANyB,IAAiB1F,KAAKqa,SAAU,GACtDra,KAAKgb,YAAYzO,EAAO5G,KAAKuH,IAAIzH,EAAGC,UAErC,GAAI8G,EAAQjB,YAAc,EAAA4E,gBAAgB8F,SAAU,CACvD,MAAMxQ,EAAI8G,EAAMd,WACPxH,IAANwB,IAAiBzF,KAAKqa,SAAU,GACb,QAAlB7N,EAAQlB,MACRtL,KAAKgb,YAAYzO,EAAO5G,KAAKuV,IAAIzV,IACR,QAAlB+G,EAAQlB,MACftL,KAAKgb,YAAYzO,EAAO5G,KAAKwV,IAAI1V,IACR,QAAlB+G,EAAQlB,MACftL,KAAKgb,YAAYzO,EAAO5G,KAAKyV,IAAI3V,IACT,SAAlB+G,EAAQlB,OACdtL,KAAKgb,YAAYzO,EAAO5G,KAAKC,KAAKH,IAK9C,GAAqB,IAAjB8G,EAAM/J,OACN,OAAO+J,EAAM,GAEb,KAAM,gCAAgCvM,KAAKma,iB,4GC1JvD,cACA,SAIA,MAAa1b,EACTW,YAAYic,EAA6B1b,EAA8B2b,GACnEtb,KAAKqD,SAAW,IAAI,EAAAlF,QAAQkd,GAC5Brb,KAAKub,QAAU,IAAI,EAAAxd,cAAoBkG,IAAXtE,EAAuB,EAAIA,GACvDK,KAAKwb,IAAMF,EACXtb,KAAKyb,iBAAkB,EACvBzb,KAAK0b,mBAAoB,EAKzBC,uBACA,OAAO3b,KAAK0b,kBAGZC,qBAAiB/Y,GACjB5C,KAAK0b,kBAAoB9Y,EAKzBgZ,SACA,OAAO5b,KAAKwb,IAGZI,OAAGhZ,GACH5C,KAAKwb,IAAM5Y,EAKXiZ,qBACA,OAAO7b,KAAKyb,gBAGZI,mBAAejZ,GACf5C,KAAKyb,gBAAkB7Y,EAKvByY,cACA,OAAOrb,KAAKqD,SAGZgY,YAAQzY,GACR5C,KAAKqD,SAAWT,EAKhBjD,aACA,OAAOK,KAAKub,QAGZ5b,WAAOiD,GACP5C,KAAKub,QAAU3Y,EAGfgC,UACA,IAAIA,EAsBJ,OAbQA,GAPJ5E,KAAKub,QAAQrZ,cAAyB+B,IAAbjE,KAAKwb,KAAsBxb,KAAK0b,kBAKrD1b,KAAKyb,kBAAoBzb,KAAKub,QAAQrM,aAEhC,SAAsC,IAA7BlP,KAAKub,QAAQ/V,YAAoB,KAAKxF,KAAKub,QAAQ/V,gBAAkB,OAAOxF,KAAKqD,SAASuB,WAAW5E,KAAKub,QAAQpM,cAC1HnP,KAAK8b,eAAiB9b,KAAK+b,iBAAiBzC,YAE7CtZ,KAAKqD,SAASuB,IAAM5E,KAAKgc,WAGzB,WAAWhc,KAAKqD,SAASuB,eAAe5E,KAAKgc,aAXjDhc,KAAKqD,SAASuB,SAePX,IAAbjE,KAAKwb,UAAsCvX,IAAjBjE,KAAKwb,IAAI5W,MACnCA,EAAM,GAAG5E,KAAKwb,IAAI5W,cAAcA,cAE7BA,EAGPkX,oBAEA,OAAO9b,KAAKqD,SAAS1D,SAAS6B,SAI9Bua,uBACA,OAAO/b,KAAKqD,SAASmB,gBAAgB/B,YAG7BuZ,iBACR,OAAIhc,KAAKub,QAAQrZ,QACN,GAEA,MAAMlC,KAAKub,QAAQvL,UAIlCiM,oBAAoBrZ,GAEhB,OADA5C,KAAK0b,uBAA8BzX,IAAVrB,GAAuBA,EACzC5C,KAGXsO,WAAWrM,GACP,OAAIjC,KAAKub,QAAQrZ,QACN,IAAIxD,EACP,IAAID,EAAiBuB,KAAKqD,SAASxC,QAAQyN,WAAWrM,KAGnD,IAAIvD,EACP,IAAID,EAAiBuB,KAAKub,QAAQ1a,SAClC,IAAIpC,EAAiBuB,KAAKqD,SAASxC,QAAQyN,WAAWrM,IACtD,IAAIxD,EAAiBuB,KAAKqD,SAASxC,QAASb,KAAKub,QAAQ1a,QAAQI,SAAS,MArH1F,qBA2HA,MAAavC,EACTU,eAAeuE,GACX3D,KAAK6Q,SAAWlN,GAAU,GAC1B3D,KAAKkc,WAAY,EACjBlc,KAAKmc,mBAAoB,EAKzBP,SACA,OAAO5b,KAAKwb,IAGZI,OAAGhZ,GACH5C,KAAKwb,IAAM5Y,EAKX0D,cACA,OAAOtG,KAAK6Q,SAGZvK,YAAQ1D,GACR5C,KAAK6Q,SAAWjO,EAKhBwZ,eACA,OAAOpc,KAAKkc,UAGZE,aAASxZ,GACT5C,KAAKkc,UAAYtZ,EAKjByZ,uBACA,OAAOrc,KAAKmc,kBAGZE,qBAAiBzZ,GACjB5C,KAAKmc,kBAAoBvZ,EAGzBgC,UACA,IAAI0X,EAActc,KAAK6Q,SAASrO,OAAO,EAEnCoC,EAAM5E,KAAK6Q,SAAS9J,KAAIP,GAAUA,EAAOyV,oBAAoBK,GAAa1X,MAAKqC,KAAK,YAGxF,GAAIjH,KAAKmc,kBAAmB,CACxB,MAAMhI,EAAanU,KAAK6Q,SAAS9I,QAAOf,GAAKA,EAAErH,OAAOmS,eAClDoC,EAAelU,KAAK6Q,SAAS9I,QAAOf,GAAKA,EAAErH,OAAOuZ,eAEtD,IAAIqD,EAAiBC,EAEjBtI,EAAa1R,OAAS,IACI,IAAtB2R,EAAW3R,OACX+Z,EAAkB,CAAC,GACU,IAAtBpI,EAAW3R,OAClB+Z,EAAkB,CAACpI,EAAW,GAAG8H,qBAAoB,GAAOrX,MAE5D0X,EAAcnI,EAAW3R,OAAO,EAChC+Z,EAAkBpI,EAAWpN,KAAIP,GAAUA,EAAOyV,oBAAoBK,GAAa1X,OAIvFsP,EAAanN,KAAIC,GAAKA,EAAErH,OAAO4C,YACH,IAAxB2R,EAAa1R,OACbga,EAAoB,CAACtI,EAAa,GAAG+H,qBAAoB,GAAOrX,MAEhE0X,EAAcpI,EAAa1R,OAAO,EAClCga,EAAoBtI,EAAanN,KAAIP,GAAUA,EAAOyV,oBAAoBK,GAAa1X,OAG3FsP,EAAanN,KAAIC,GAAKA,EAAErH,OAAO4C,YAE/BqC,EAAM,YAAY2X,EAAgBtV,KAAK,kBAAkBuV,EAAkBvV,KAAK,iBAQxF,YAHiBhD,IAAbjE,KAAKwb,UAAuCvX,IAAlBjE,KAAKwb,IAAIiB,MAAwC,KAAlBzc,KAAKwb,IAAIiB,OAClE7X,EAAM,GAAG5E,KAAKwb,IAAI5W,cAAcA,cAE7BA,EAGXkB,SACI,IAAIuC,EAAerI,KAAK6Q,SAAS9I,QAAOvB,GAAUA,EAAOsV,gBACrDY,EAAW1c,KAAK6Q,SAAS9I,QAAOvB,IAAWA,EAAOsV,gBAElDrI,GAAS,IAAI,EAAA1V,UAAW0O,MAE5B,GAAIpE,EAAa7F,OAAS,EACtB,IAAK,MAAMgE,KAAU6B,EACb7B,EAAO7G,OAAOmS,aACd2B,EAAO/R,SAAS8E,EAAO6U,QAAQ9Z,OAAO,GAAGkB,YAAYyK,IAAI1G,EAAO7G,SAEhE8T,EAAO5R,OAAO2E,EAAO6U,QAAQ9Z,OAAO,GAAGkB,YAAYyK,IAAI1G,EAAO7G,OAAOkB,QAAQuO,aAGtD,IAAxB/G,EAAa7F,SACpBiR,EAASpL,EAAa,GAAGgT,QAAQ9Z,OAAO,GAAGkB,aAiB/C,OAdIgR,EAAOvR,QACPlC,KAAK6Q,SAAW,IAAI6L,GACZjJ,EAAOvE,aAOflP,KAAK6Q,SAAW,CACZ,IAAIpS,EAAiBgV,MAClBiJ,GARP1c,KAAK6Q,SAAW,CACZ,IAAIpS,EAAiBgV,EAAOtE,WAC5B,IAAI1Q,EAAiBgV,EAAOjO,aAAc,MACvCkX,GAQJ1c,KAGXoT,UAAUnR,GAKN,GAA6B,IAAzBjC,KAAK6Q,SAASrO,OAAc,CAE5B,IAAIma,EAAK3c,KAAK6Q,SAAS,GAAGwK,QAAQ1b,OAAOsC,GAAQW,MAC7Cga,EAAK5c,KAAK6Q,SAAS,GAAGwK,QAAQ1b,OAAOsC,GAAQW,MAEjD,GAAI+Z,IAAOC,EAAK,EACZ,OAAO5c,KAAK6c,iCAAiC7c,KAAK6Q,SAAS,GAAI7Q,KAAK6Q,SAAS,GAAI5O,GAC9E,GAAI0a,EAAK,IAAMC,EAClB,OAAO5c,KAAK6c,iCAAiC7c,KAAK6Q,SAAS,GAAI7Q,KAAK6Q,SAAS,GAAI5O,IAMtF6a,kBAAkBC,GAErB,OADA/c,KAAKwb,IAAMuB,EACJ/c,KAGH6c,iCAAiCla,EAAqBqa,EAA6B/a,GAEvF,IAAIgb,EAA8Bta,EAAE0Y,QAAQxa,QAAQyN,WAAWrM,IAG3D,SAACsP,EAAQ,SAAEC,GAAYwL,EAAU3B,QAAQxa,QAAQyQ,UAAU2L,GAE/D,GAAIzL,EAAShQ,UAAY+P,EAAS5R,OAAOsC,GAAQT,SAM7C,OAAImB,EAAEhD,OAAOkE,SAAS,GACX,IAAKnF,EACR,IAAID,EAAiB8S,EAAU,GAC/B,IAAI9S,EAAiBkE,EAAE0Y,QAAQxa,QAAS,EAAG,CACvC4b,KAAM,KAAM7X,IAAK,OAAQgX,GAAK5U,GAAcrB,KAAK5B,IAAIiD,MAItD,IAAItI,EACP,IAAID,EAAiBkE,EAAEhD,OAAOkB,QAAQyB,IAAI,GAAGS,SAAU,GACvD,IAAItE,EAAiB8S,EAAU,GAC/B,IAAI9S,EAAiBkE,EAAE0Y,QAAQxa,QAAS8B,EAAEhD,OAAOkB,QAAQyB,IAAI,MA9KjF,uB,+EChIA,eACA,OACA,SACA,SACA,SACA,SACA,SACA,QAGA,MAAatD,EACTI,eAAeuE,GAmFf,KAAAuZ,iBAAoB/S,IAChB,IAAIgT,EAAWhT,EAAEiT,WAAWpd,KAAKqd,QAASC,EAAS3X,KAAKC,KAAK5F,KAAKud,cAAc3a,OAEhF,OAAIua,EAASva,MAAQ0a,EAAS,MACnB,EACA3X,KAAKyJ,IAAI+N,EAASva,MAAQ0a,GAAU,MACpC,EAEA,GAIf,KAAAE,iBAAoBrT,IAChB,IAAsCsT,EAAlCC,EAA8B,GAElC,GAAwB,OAApB1d,KAAK2d,WACL,MAAO,GAEX,MAAMC,EAAO5d,KAAK2d,WAAW9c,QAASgd,EAAQ1T,EAAE2T,SAASjd,QAAQmB,QAAQ,KACrE+b,EAAQ5T,EAAE2T,SAASjd,QAAQmB,QAAQ,KAEvC,GAAI6b,aAAiB,EAAAzf,UAAY2f,aAAiB,EAAA3f,SAAU,CACxDwf,EAAKlb,UAAU,IAAKqb,EAAMvd,OAAOiB,WACjCmc,EAAKza,QAEL,IAAK,IAAI6D,KAAK4W,EAAKjX,WACC,IAAZK,EAAElC,OAAmB+Q,MAAM7O,EAAEpE,SAIjC6a,EAAO,IAAI,EAAA1f,UAAqB,IAAZiJ,EAAElC,MAAkBkC,EAAEpE,MAAQoE,EAAElC,OACpD4Y,EAAmB7W,KAAK,IAAI,EAAAhI,MAAM4e,EAAK5c,QAASkd,EAAMvd,MAAMoD,SAAS6Z,MAI7E,OAAOC,GAGX,KAAAM,SAAYrb,GACJA,aAAa,EAAA5E,SACNiC,KAAKie,mBAAmBtb,GACxB3C,KAAKke,gBAAgBvb,GACrB3C,KAAKme,oCAAoCxb,GACzC3C,KAAKqd,OAAOD,WAAWza,GAAGC,MAAQ5C,KAAKsd,OAAO1a,MAE9C5C,KAAKoe,yCAAyCzb,IAErDtC,QAAQ0D,IAAI,wCAET,IAGX,KAAAma,gBAAmBvb,GACR3C,KAAK2d,WAAWja,KAAK,CAACsD,EAAGrE,EAAEqE,EAAGqX,EAAG1b,EAAE0b,IAG9C,KAAAC,kBAAqBC,SACOta,IAApBsa,IACAA,GAAkB,GAMtB,IAE0BC,EAFtBC,EAAW,EAAA5gB,QAAQ6gB,gCAAgC1e,KAAKud,cAAc3a,OAAO,GAE7E+b,EAAkB,GAiBtB,OAhBAF,EAASlY,SAAQqY,IAKb,IAAK,IAAIhS,IAAK,CAAC,CAAC,EAAG,GAAI,EAAE,EAAG,GAAI,EAAE,GAAI,GAAI,CAAC,GAAI,IAC3C4R,EAAK,IAAI,EAAA3f,MACLmB,KAAKqd,OAAOrW,EAAEnG,QAAQyB,IAAIsK,EAAE,GAAKgS,EAAQ,IACzC5e,KAAKqd,OAAOgB,EAAExd,QAAQyB,IAAIsK,EAAE,GAAKgS,EAAQ,KAGxCJ,EAAGK,iBAAiBF,IACrBA,EAAO9X,KAAK2X,MAIjBG,GAUH,KAAAR,oCAAuCxb,IAC3C,IAAImc,EAAK,IAAI,EAAAlgB,OAAOoB,KAAK+e,QAASpc,GAClC,MAAO,CAAC,IAAI,EAAA7D,KAAK6D,EAAGmc,EAAI,EAAAE,cAAcC,iBAGlC,KAAAb,yCAA4Czb,IAOhD,IAAIuc,EAAQlf,KAAKqd,OAAOrW,EAAEnG,QAAQI,SAAS0B,EAAEqE,GAAImY,EAAQnf,KAAKqd,OAAOgB,EAAExd,QAAQI,SAAS0B,EAAE0b,GACtFe,EAAW,IAAI,EAAAjhB,QAAQ,KAAMkhB,EAAY,IAAI,EAAAlhB,QAAQ,SAEzDihB,EAAS1d,SAASwd,GAAOje,SAASke,GAAOjS,IAAI,GAC7CmS,EAAU3d,SAAS1B,KAAKsf,cAExB,IAAIlZ,EAAM,IAAI,EAAAhI,SAASghB,EAAUC,GAGjC,OAFAjZ,EAAIpF,WAAWS,WAAW0B,QAEnBiD,EAAIO,UAAUI,KAAIZ,IAErB,IAAIoZ,EAAGnZ,EAAM,IAAI,EAAAhI,SAAS,IAAK,KAU/B,OARI+H,EAAIrB,iBAAiB,EAAA/G,UACrBwhB,EAAI5c,EAAEqE,EAAEnG,QAAQ0B,UAAUb,SAASyE,EAAIrB,OAAOxC,IAAIK,EAAE0b,GACpDjY,EAAI5F,MAAMkB,SAASyE,EAAIrB,OAAOxC,IAAIid,KAElCA,EAAI5c,EAAEqE,EAAEnG,QAAQ0B,UAAUb,SAASyE,EAAIvD,OAAON,IAAIK,EAAE0b,GACpDjY,EAAI5F,MAAMkB,SAASyE,EAAIvD,OAAON,IAAIid,IAG/B,IAAI,EAAAzgB,KAAKsH,OAKhB,KAAA6X,mBAAsBuB,IAK1B,MAAM/Z,EAAI+Z,EAAMrQ,UAAWzJ,GAAK8Z,EAAMha,YAAa+E,EAAKvK,KAAK+e,QAAQ/X,EAAEnG,QAAS2J,EAAKxK,KAAK+e,QAAQV,EAAExd,QAC5Fb,KAAKud,cAEb,IAAIkC,EAAKzf,KAAKud,cAAc1c,QAAQa,SAAS8d,EAAMrQ,WAAa,EAAIqQ,EAAMha,aAAe,GACrF6P,EAAK9K,EAAG1J,QAAQa,SAAS+D,GAAGlD,UAAUtB,SAASuJ,EAAG3J,QAAQa,SAASgE,IAAIpD,IAAImd,EAAG5e,QAAQ+E,QACtF0P,EAAK/K,EAAG1J,QAAQa,SAAS+D,GAAGlD,UAAUtB,SAASuJ,EAAG3J,QAAQa,SAASgE,IAAIzE,SAASwe,EAAG5e,QAAQ+E,QAE/F,MAAO,CAAC,IAAI,EAAA9G,KAAK2G,EAAGC,EAAG2P,GAAK,IAAI,EAAAvW,KAAK2G,EAAGC,EAAG4P,KAjO3CtV,KAAK0f,SAAU,OAEAzb,IAAXN,GACA3D,KAAKJ,SAAS+D,GAMlB0Z,aACA,OAAOrd,KAAK+e,QAKZO,mBACA,OAAOtf,KAAKud,cAKZoC,gBACA,OAAO3f,KAAK2d,WAKZiC,aACA,OAAO5f,KAAK0f,QAGZpC,aACA,OAAItd,KAAKud,cAAcjQ,WACZ,CACH1I,IAAK5E,KAAKud,cAAc1c,QAAQ+E,OAAOhB,IACvCyC,QAASrH,KAAKud,cAAc1c,QAAQ+E,OAAOyB,QAC3CzE,MAAO5C,KAAKud,cAAc1c,QAAQ+E,OAAOhD,OAGtC,CACHgC,IAAK,UAAU5E,KAAKud,cAAc3Y,OAClCyC,QAAS,QAAQrH,KAAKud,cAAclW,WACpCzE,MAAO5C,KAAKud,cAAc1c,QAAQ+E,OAAOhD,OAMjDgC,UAEA,GAAI5E,KAAK0f,QAAS,CACd,IAAIG,EAAIC,EAWR,OATID,EADA7f,KAAK+e,QAAQ/X,EAAExF,SACV,MAEA,WAAWxB,KAAK+e,QAAQ/X,EAAEkS,aAAe,IAAM,MAAMlZ,KAAK+e,QAAQ/X,EAAEnG,QAAQuO,MAAMxK,gBAGvFkb,EADA9f,KAAK+e,QAAQV,EAAE7c,SACV,MAEA,WAAWxB,KAAK+e,QAAQV,EAAEnF,aAAe,IAAM,MAAMlZ,KAAK+e,QAAQV,EAAExd,QAAQuO,MAAMxK,gBAEpF,GAAGib,KAAMC,KAAM9f,KAAKud,cAAc3Y,MAEzC,MAAO,kCAIXmb,gBACA,OAAO/f,KAAK2d,WAAW/Y,IAIvByC,cACA,OAAOrH,KAAK2d,WAAWtW,QA8F3BxG,QAII,OAHAb,KAAK+e,QAAU/e,KAAK+e,QAAQle,QAC5Bb,KAAKud,cAAgBvd,KAAKud,cAAc1c,QACxCb,KAAKggB,sBACEhgB,KAwDHigB,SAMJ,OALAjgB,KAAK+e,QAAU,KACf/e,KAAKud,cAAgB,KACrBvd,KAAK2d,WAAa,KAClB3d,KAAK0f,SAAU,EAER1f,KAGHJ,SAAS+D,GAuCb,OA9BA3D,KAAKigB,SAEoB,iBAAdtc,EAAO,GACd3D,KAAKkgB,eAAe,IAAI,EAAA9hB,SAASuF,EAAO,KACjCA,EAAO,aAAc,EAAAvF,SAC5B4B,KAAKkgB,eAAevc,EAAO,IACpBA,EAAO,aAAc3E,EAC5BgB,KAAKmgB,iBAAiBxc,EAAO,IACtBA,EAAO,aAAc,EAAA9E,OAAS8E,EAAOnB,OAAS,IACjDmB,EAAO,aAAc,EAAA9E,MACjB8E,EAAO,aAAc,EAAA9E,MACrBmB,KAAKogB,0BAA0Bzc,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAE5D3D,KAAKqgB,4BAA4B1c,EAAO,GAAIA,EAAO,KAEhDA,EAAO,aAAc,EAAA5F,UAAiC,iBAAd4F,EAAO,KACtD3D,KAAKsgB,sBAAsB3c,EAAO,GAAIA,EAAO,GAA0B,kBAAdA,EAAO,IAAoBA,EAAO,KAK/F3D,KAAK0f,UACL1f,KAAKggB,2BAGsB/b,IAAvBjE,KAAKud,eAA+Bvd,KAAKud,cAAcrE,eACvDlZ,KAAK0f,SAAU,IAIhB1f,KAGHggB,sBACJhgB,KAAK2d,WAAa,IAAK,EAAAvf,SAAS,IAAI,EAAAD,QAAQ,OAAO6B,KAAK+e,QAAQ/X,EAAEK,mBAAmBrH,KAAK+e,QAAQV,EAAEhX,eAAgB,IAAI,EAAAlJ,QAAQ,GAAG6B,KAAKud,cAAclW,YAAarG,WAG/Jmf,iBAAiBI,GAKrB,OAJAvgB,KAAK+e,QAAUwB,EAAOlD,OAAOxc,QAC7Bb,KAAKud,cAAgBgD,EAAOjB,aAAaze,QACzCb,KAAKggB,sBACLhgB,KAAK0f,QAAUa,EAAOX,OACf5f,KAGHsgB,sBAAsBjD,EAAeC,EAA2BkD,GAUpE,OATAxgB,KAAK+e,QAAU1B,EAAOxc,QAGlBb,KAAKud,cADLiD,EACqB,IAAK,EAAAziB,SAASuf,GAEd,IAAI,EAAAvf,SAASuf,GAAQpQ,IAAI,GAGlDlN,KAAK0f,SAAU,EACR1f,KAGHqgB,4BAA4BhD,EAAeoD,GAI/C,OAHAzgB,KAAK+e,QAAU1B,EAAOxc,QACtBb,KAAKud,cAAgB,IAAI,EAAA3e,OAAOoB,KAAK+e,QAAS0B,GAAcC,WAC5D1gB,KAAK0f,SAAU,EACR1f,KAGHkgB,eAAe9Z,GAMnB,GALApG,KAAK0f,SAAU,EAGftZ,EAAIpF,WAE0B,IAA1BoF,EAAIzG,OAAO,KAAKiD,OAAyC,IAA1BwD,EAAIzG,OAAO,KAAKiD,MAAa,CAE5D,IAA8EyS,EAAWsL,EAAWvL,EAAhGE,EAAKlP,EAAI7F,KAAKiE,cAAc,EAAG,KAAMoc,EAAKxa,EAAI7F,KAAKiE,cAAc,EAAG,KAGpE8Q,EAAG7S,YAAYoB,QAAQ+c,EAAGne,cAC1B2D,EAAIvE,OAAOyT,EAAG7S,aAEd4S,EAAKjP,EAAI7F,KAAKiE,cAAc,EAAG,KAC/Bmc,EAAKva,EAAI7F,KAAKiE,cAAc,EAAG,KAE/B4Q,EAAIhP,EAAI7F,KAAKiE,cAAc,GAE3BxE,KAAK+e,QAAU,IAAI,EAAAlgB,MAAMwW,EAAG5S,YAAY5B,QAAQgB,OAAO,GAAGU,UAAWoe,EAAGle,YAAY5B,QAAQgB,OAAO,GAAGU,WAEtGvC,KAAKud,cAAgBnI,EAAE3S,YAAY5B,QAAQ0B,UACtCD,IAAItC,KAAK+e,QAAQ/X,EAAEnG,QAAQqM,IAAI,IAC/B5K,IAAItC,KAAK+e,QAAQV,EAAExd,QAAQqM,IAAI,IAEpClN,KAAKggB,sBACLhgB,KAAK0f,SAAU,IAGf1f,KAAK+e,QAAU,KACf/e,KAAKud,cAAgB,KACrBvd,KAAK0f,SAAU,GAGvB,OAAO1f,KAGHogB,0BAA0BvU,EAAUC,EAAUE,GAClD,IAAI6U,EAAI,IAAI,EAAA9hB,SAAS8M,EAAGC,EAAGE,GAAI8U,EAAMD,EAAEE,aAAaC,UAAUC,GAAGpgB,QAC7DqgB,EAAML,EAAEE,aAAaC,UAAUG,GAAGtgB,QAGtC,OAFAb,KAAKJ,MAAMkhB,EAAIM,aAAaF,GAAKG,MAAOxV,GAEjC7L,MAnWf,Y,2FCNA,eACA,SACA,SACA,SACA,SACA,QAEA,IAAYgf,GAAZ,SAAYA,GACR,mBACA,sBACA,gCACA,oBAJJ,CAAYA,EAAA,EAAAA,gBAAA,EAAAA,cAAa,KAOzB,MAAalgB,EAiBTM,eAAeuE,GAQX,OAoGJ,KAAA/D,MAAQ,IAAI+D,KAIR,GAHA3D,KAAK0f,SAAU,EAGO,IAAlB/b,EAAOnB,OACP,OAAOxC,KAIX,GAAsB,IAAlB2D,EAAOnB,OAAc,CACrB,GAAImB,EAAO,aAAc7E,EAErB,OAAO6E,EAAO,GAAG9C,QACd,GAAI8C,EAAO,aAAc,EAAAvF,SAE5B,OAAO4B,KAAKshB,cAAc3d,EAAO,IAC9B,GAAyB,iBAAdA,EAAO,GAErB,IACI,IAAI+F,EAAI,IAAI,EAAAtL,SAASuF,EAAO,IAC5B,OAAO3D,KAAKJ,MAAM8J,GACpB,MAAO4I,GACL,OAAOtS,MAKnB,GAAsB,IAAlB2D,EAAOnB,OAAc,CACrB,GAAImB,EAAO,aAAc,EAAA9E,OAAS8E,EAAO,aAAc,EAAA/E,OACnD,OAAOoB,KAAKuhB,sBAAsB5d,EAAO,GAAIA,EAAO,IACjD,GAAIA,EAAO,aAAc,EAAA9E,OAAS8E,EAAO,aAAc,EAAA9E,MAC1D,OAAOmB,KAAKuhB,sBAAsB5d,EAAO,GAAI,IAAI,EAAA/E,OAAO+E,EAAO,GAAIA,EAAO,KACvE,GAAIA,EAAO,aAAc,EAAA/E,QAAU+E,EAAO,aAAc,EAAA9E,MAC3D,OAAOmB,KAAKwhB,sBAAsB7d,EAAO,GAAIA,EAAO,IAI5D,GAAsB,IAAlBA,EAAOnB,OAAc,CACrB,IACKmB,EAAO,aAAc,EAAA5F,UAAiC,iBAAd4F,EAAO,MAE/CA,EAAO,aAAc,EAAA5F,UAAiC,iBAAd4F,EAAO,MAE/CA,EAAO,aAAc,EAAA5F,UAAiC,iBAAd4F,EAAO,IAEhD,OAAO3D,KAAKyhB,mBAAmB9d,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC1D,GACFA,EAAO,aAAc,EAAA9E,OAAS8E,EAAO,aAAc,EAAA/E,OACtD,CACG,GAAG+E,EAAO,KAAOqb,EAAcC,cAC3B,OAAOjf,KAAKwhB,sBAAsB7d,EAAO,GAAIA,EAAO,IAClD,GAAIA,EAAO,KAAOqb,EAAc0C,SAClC,OAAO1hB,KAAKuhB,sBAAsB5d,EAAO,GAAIA,EAAO,SAEtD,GAAIA,EAAO,aAAc,EAAA9E,OAAS8E,EAAO,aAAc7E,EACzD,OAAG6E,EAAO,KAAKqb,EAAc0C,UAAwB,OAAZ/d,EAAO,GACrC3D,KAAK2hB,oBAAoBhe,EAAO,GAAIA,EAAO,GAAIqb,EAAc0C,UAE7D1hB,KAAK2hB,oBAAoBhe,EAAO,GAAIA,EAAO,GAAIqb,EAAcC,eAOhF,OADA5e,QAAQ0D,IAAI,kDACL/D,MAGX,KAAAshB,cAAiBlb,IAEbA,EAAIjF,SAAQ,GAGZ,IAAI8B,EAAU,IAAIC,IAAIkD,EAAInD,WAG1B,IAAMA,EAAQ0I,IAAI,OAAQ1I,EAAQ0I,IAAI,KAClC,OAAO3L,KAIX,IAAK,IAAI4hB,IAAQ,CAAC,IAAK,KACf3e,EAAQ0I,IAAIiW,IACZ3e,EAAQ4e,OAAOD,GAIvB,OAAI3e,EAAQ6e,KAAO,EACR9hB,KAIJA,KAAKyhB,mBAAmBrb,EAAI7F,KAAK6J,cAAc,KAAK3H,YAAa2D,EAAI7F,KAAK6J,cAAc,KAAK3H,YAAa2D,EAAI7F,KAAKiE,cAAc,GAAG/B,cAE/I,KAAAgf,mBAAqB,CAAChc,EAAsBC,EAAsB0P,KAC9DpV,KAAK+hB,GAAK,IAAI,EAAAhkB,SAAS0H,GACvBzF,KAAKgiB,GAAK,IAAI,EAAAjkB,SAAS2H,GACvB1F,KAAKiiB,GAAK,IAAI,EAAAlkB,SAASqX,GAEvBpV,KAAKkiB,GAAK,IAAI,EAAAtjB,OAAOoB,KAAKgiB,GAAGnhB,QAASb,KAAK+hB,GAAGlhB,QAAQ0B,WACtDvC,KAAKmiB,IAAM,IAAI,EAAAtjB,OAAM,IAAI,EAAAd,UAAWmD,OAAQlB,KAAKiiB,GAAGphB,SACpDb,KAAKoiB,GAAKpiB,KAAKkiB,GAAGrhB,QAAQwhB,SAE1BriB,KAAK0f,SAAU,EACR1f,MAGX,KAAAuhB,sBAAwB,CAAC5e,EAAU4L,KAU/BvO,KAAKyhB,mBACDlT,EAAE8P,EACF9P,EAAEvH,EAAEnG,QAAQ0B,UACZI,EAAEqE,EAAEnG,QAAQa,SAAS6M,EAAE8P,GAAGpd,SAAS0B,EAAE0b,EAAExd,QAAQa,SAAS6M,EAAEvH,IAAIzE,WAIlEvC,KAAKmiB,IAAMxf,EAAE9B,QACbb,KAAKkiB,GAAK3T,EAAE1N,QACZb,KAAKoiB,GAAKpiB,KAAKkiB,GAAGrhB,QAAQwhB,SAE1BriB,KAAK0f,SAAU,EACR1f,MAGX,KAAAwhB,sBAAwB,CAAC7e,EAAUwL,IACxBnO,KAAKyhB,mBACRtT,EAAEnH,EACFmH,EAAEkQ,EACF1b,EAAEqE,EAAEnG,QAAQa,SAASyM,EAAEnH,GAClB1E,IAAIK,EAAE0b,EAAExd,QAAQa,SAASyM,EAAEkQ,IAAI9b,WAI5C,KAAAof,oBAAsB,CAAChf,EAAUwH,EAASmY,UAElBre,IAAhBqe,IACAA,EAActD,EAAc0C,UAG5BY,IAAgBtD,EAAc0C,SACvB1hB,KAAKwhB,sBAAsB7e,EAAGwH,EAAEkY,QAChCC,IAAgBtD,EAAcC,cAC9Bjf,KAAKwhB,sBAAsB7e,EAAGwH,EAAEoY,WAG3CviB,KAAK0f,SAAU,EACR1f,OAGX,KAAAa,MAAQ,KACJb,KAAK+hB,GAAK/hB,KAAK+hB,GAAGlhB,QAClBb,KAAKgiB,GAAKhiB,KAAKgiB,GAAGnhB,QAClBb,KAAKiiB,GAAKjiB,KAAKiiB,GAAGphB,QAElBb,KAAKkiB,GAAKliB,KAAKkiB,GAAGrhB,QAClBb,KAAKmiB,IAAMniB,KAAKmiB,IAAIthB,QACpBb,KAAKoiB,GAAKpiB,KAAKoiB,GAAGvhB,QAElBb,KAAK0f,QAAU1f,KAAK4f,OACb5f,MAKX,KAAAwiB,aAAgBC,GAELziB,KAAKwf,MAAM3b,QAAQ4e,EAAKjD,QAAUxf,KAAK0iB,OAAO1T,WAAWyT,EAAKC,QAEzE,KAAA1V,SAAYyV,GACDziB,KAAKwf,MAAM3b,QAAQ4e,EAAKjD,QAAUxf,KAAK0iB,OAAO7e,QAAQ4e,EAAKC,QAEtE,KAAAC,WAAa,IACF3iB,KAAKwf,MAAMnI,aAEtB,KAAA5V,SAAW,KACP,IAAIE,EAAM,EAAA9D,QAAQ8D,IAAI3B,KAAK+hB,GAAGvc,YAAaxF,KAAKgiB,GAAGxc,YAAaxF,KAAKiiB,GAAGzc,aACpE1D,EAAM,EAAAjE,QAAQiE,IAAI9B,KAAK+hB,GAAG5S,UAAWnP,KAAKgiB,GAAG7S,UAAWnP,KAAKiiB,GAAG9S,WAQpE,OANAnP,KAAKyhB,mBACDzhB,KAAK+hB,GAAGlhB,QAAQa,SAASC,GAAKE,OAAOC,GACrC9B,KAAKgiB,GAAGnhB,QAAQa,SAASC,GAAKE,OAAOC,GACrC9B,KAAKiiB,GAAGphB,QAAQa,SAASC,GAAKE,OAAOC,IAGlC9B,MAGX,KAAA4iB,kBAAoB,KAChB,IAAIjhB,EAAM,EAAA9D,QAAQ8D,IAAI3B,KAAKkiB,GAAGlb,EAAExB,YAAaxF,KAAKkiB,GAAG7D,EAAE7Y,aACnD1D,EAAM,EAAAjE,QAAQiE,IAAI9B,KAAKkiB,GAAGlb,EAAEmI,UAAWnP,KAAKkiB,GAAG7D,EAAElP,WAIrD,OAFAnP,KAAKkiB,GAAGlb,EAAEtF,SAASC,GAAKE,OAAOC,GAC/B9B,KAAKkiB,GAAG7D,EAAE3c,SAASC,GAAKE,OAAOC,GACxB9B,MAEX,KAAAohB,aAAgBqB,IACZ,IAAII,EAAK,IAAI,EAAAhkB,MAASikB,GAAa,EAAOC,GAAS,EAqCnD,OAnBI/iB,KAAKgiB,GAAGxgB,UAAYihB,EAAK/c,EAAElE,SAI3BxB,KAAKwiB,aAAaC,IAClBI,EAAG7b,EAAI,KACP6b,EAAGxE,EAAI,KACPyE,GAAa,GACN9iB,KAAKgN,SAASyV,IACrBI,EAAG7b,EAAI,KACP6b,EAAGxE,EAAI,KACP0E,GAAS,IAETF,EAAG7b,EAAIhH,KAAKgiB,GAAGnhB,QAAQa,SAAS+gB,EAAKrN,GAAGnU,SAASjB,KAAKiiB,GAAGphB,QAAQa,SAAS+gB,EAAK/c,IAC1E7D,OAAO7B,KAAK+hB,GAAGlhB,QAAQa,SAAS+gB,EAAK/c,GAAGzE,SAASjB,KAAKgiB,GAAGnhB,QAAQa,SAAS+gB,EAAKhd,KACpFod,EAAGxE,EAAIre,KAAK+hB,GAAGlhB,QAAQa,SAAS+gB,EAAKrN,GAAGnU,SAASjB,KAAKiiB,GAAGphB,QAAQa,SAAS+gB,EAAKhd,IAC1E5D,OAAO7B,KAAKgiB,GAAGnhB,QAAQa,SAAS+gB,EAAKhd,GAAGxE,SAASjB,KAAK+hB,GAAGlhB,QAAQa,SAAS+gB,EAAK/c,MAGjF,CACH2b,MAAOwB,EACPG,kBAAmBF,GAAcC,GACjCD,WAAAA,EACAC,OAAAA,IAqDR,KAAAE,YAAergB,IAEX,MAAMwD,EAAMpG,KAAK8d,SAASjd,QAAQmB,QAAQ,KACtCa,EAAI,IAAI,EAAA9E,SAAS6E,GAErB,GAAGwD,aAAe,EAAAhI,SACd,OAAOgI,EAAI5F,MAAMoD,SAAS,CAACoD,EAAGnE,KAItC,KAAAqgB,YAAetgB,IACX,MAAMwD,EAAMpG,KAAK8d,SAASjd,QAAQmB,QAAQ,KACtCa,EAAI,IAAI,EAAA9E,SAAS6E,GAErB,GAAGwD,aAAe,EAAAhI,SACd,OAAOgI,EAAI5F,MAAMoD,SAAS,CAACya,EAAGxb,KAnalC7C,KAAK0f,SAAU,EAEX/b,EAAOnB,OAAS,GAChBxC,KAAKJ,SAAS+D,GAGX3D,KAGP4f,aACA,OAAO5f,KAAK0f,QAMZ5B,eACA,OAAO,IAAI,EAAA1f,UAAS,IAAI,EAAAD,SAAUyB,MAAM,KAAMI,KAAK+hB,GAAI/hB,KAAKgiB,GAAIhiB,KAAKiiB,IAAK,IAAI,EAAA9jB,QAAQ,MAAMsD,WAG5FmD,UAKA,IAAIue,EAAYnjB,KAAK8d,SAMrB,OAJI9d,KAAK+hB,GAAG7I,cACRiK,EAAUzhB,UAAU,GAGjB,CACHyhB,UAAWA,EAAUve,IACrBwe,IAAKpjB,KAAKwf,MAAMnI,aAAe,KAAOrX,KAAKqjB,GAAGrc,EAAEpC,IAAM,MAAO,IAAI,EAAAzG,SAAUyB,MAAM,IAAKI,KAAKwf,MAAOxf,KAAK0iB,QAAQ9d,IAC/G0e,WAAY,GAAG,EAAAzkB,MAAM0kB,QAAQ,IAAK,UAAU,EAAA1kB,MAAM0kB,QAAQvjB,KAAKmiB,IAAInb,EAAGhH,KAAKmiB,IAAI9D,gBAAgB,EAAAxf,MAAM0kB,QAAQvjB,KAAKkiB,GAAGlb,EAAGhH,KAAKkiB,GAAG7D,MAIpI5Y,QACA,OAAOzF,KAAK+hB,GAGZtc,MAAE7C,GACF5C,KAAK+hB,GAAKnf,EAGV8C,QACA,OAAO1F,KAAKgiB,GAGZtc,MAAE9C,GACF5C,KAAKgiB,GAAKpf,EAGVwS,QACA,OAAOpV,KAAKiiB,GAGZ7M,MAAExS,GACF5C,KAAKiiB,GAAKrf,EAGVygB,SACA,OAAOrjB,KAAKmiB,IAGZkB,OAAGzgB,GACH5C,KAAKmiB,IAAMvf,EAGX2L,QACA,OAAOvO,KAAKkiB,GAGZ/T,QACA,OAAOnO,KAAKoiB,GAGZC,aACA,OAAO,IAAI,EAAAzjB,OAAOoB,KAAK+hB,GAAI/hB,KAAKgiB,IAGhCO,eACA,OAAOviB,KAAKkiB,GAAGrhB,QAGf0N,MAAE3L,GACF5C,KAAKkiB,GAAKtf,EAGV4c,YACA,OAAOxf,KAAK+hB,GAAGlhB,QAAQ0B,UAAUV,OAAO7B,KAAKgiB,IAG7CU,aACA,OAAO1iB,KAAKiiB,GAAGphB,QAAQ0B,UAAUV,OAAO7B,KAAKgiB,IAoQjD5E,WAAWoB,GACP,IAAIrP,EAAYqP,EAAGxX,EAAEnG,QAAQa,SAAS1B,KAAK+hB,IAClCzf,IAAIkc,EAAGH,EAAExd,QAAQa,SAAS1B,KAAKgiB,KAC/B1f,IAAItC,KAAKiiB,IAAI7S,MAClBwN,EAAK5c,KAAKqiB,OAAO3B,WAGrB,GAAI9D,EAAGpb,SACH,MAAO,CACHoB,MAAOiC,IACPD,IAAK,aACL4e,UAAU,IAAI,EAAAzlB,UAAW0W,YAIjC,IAAI7R,EAAQuM,EAAUvM,MAAQ+C,KAAKC,KAAKgX,EAAGha,OACvCC,EAAIsM,EAAUtO,QAAQgB,OAAO+a,EAAG/b,QAAQ+E,QAG5C,OAAIgX,EAAGtP,WACI,CACH1K,MAAAA,EACAgC,IAAK/B,EAAE+B,IACP4e,SAAU3gB,GAIX,CACHD,MAAAA,EACAgC,IAAK,UAAUuK,EAAUvK,eAAegY,EAAGhY,QAC3C4e,SAAU3gB,GAIlB4gB,WAAW5X,EAAUC,GACjB,IAAI4X,EAAM1jB,KAAKohB,aACX,IAAItiB,EAAK+M,EAAGC,IAIhB,QAAI4X,EAAIV,iBACGU,EAAIrC,MAAMra,EAAEpE,OAAS+C,KAAK8K,IAAI5E,EAAE7E,EAAEpE,MAAOkJ,EAAE9E,EAAEpE,QAC7C8gB,EAAIrC,MAAMra,EAAEpE,OAAS+C,KAAK3C,IAAI6I,EAAE7E,EAAEpE,MAAOkJ,EAAE9E,EAAEpE,QAC7C8gB,EAAIrC,MAAMhD,EAAEzb,OAAS+C,KAAK8K,IAAI5E,EAAEwS,EAAEzb,MAAOkJ,EAAEuS,EAAEzb,QAC7C8gB,EAAIrC,MAAMhD,EAAEzb,OAAS+C,KAAK3C,IAAI6I,EAAEwS,EAAEzb,MAAOkJ,EAAEuS,EAAEzb,OA4B5D+gB,4BAA4BC,QACP3f,IAAb2f,IACAA,EAAW,GAGN5jB,KAAK+hB,GAAGnf,MACR5C,KAAKgiB,GAAGpf,MACR5C,KAAKiiB,GAAGrf,MAFjB,IAGIugB,EAAY,GA2BhB,OAzBKnjB,KAAK+hB,GAAGvgB,WAEL2hB,EADAnjB,KAAK+hB,GAAG7f,QACI,IACLlC,KAAK+hB,GAAGlhB,QAAQ0B,UAAUL,QACrB,KAEAlC,KAAK+hB,GAAGnf,MAAMiD,QAAQ+d,GAAY,KAIjD5jB,KAAKgiB,GAAGxgB,WACLxB,KAAKgiB,GAAGlQ,eACRqR,GAAa,KAEjBA,GAAanjB,KAAKgiB,GAAGpf,MAAMiD,QAAQ+d,GAAY,KAG9C5jB,KAAKiiB,GAAGzgB,WACLxB,KAAKiiB,GAAGnQ,eACRqR,GAAa,KAEjBA,GAAanjB,KAAKiiB,GAAGrf,MAAMiD,QAAQ+d,IAIhCT,EAAY,MAje3B,SAcW,EAAAU,cAAgB7E,EAAcC,cAC9B,EAAA6E,SAAW9E,EAAc0C,U,8EC7BpC,aACA,SACA,SAUA,MAAa7iB,EAKTO,eAAeuE,GAQX,OA2CJ,KAAA/D,MAAQ,IAAI+D,KAKR,GAHA3D,KAAKkB,OAGiB,IAAlByC,EAAOnB,OACP,OAAOxC,KAIX,GAAsB,IAAlB2D,EAAOnB,OAAc,CAErB,GAAImB,EAAO,aAAc9E,EAGrB,OAFAmB,KAAK+jB,GAAKpgB,EAAO,GAAGqD,EAAEnG,QACtBb,KAAKgkB,GAAKrgB,EAAO,GAAG0a,EAAExd,QACfb,KAIX,GAAyB,iBAAd2D,EAAO,GAAiB,CAC/B,IAAIsgB,EAAKtgB,EAAO,GAAGzD,MAAM,KACzB,GAAkB,IAAd+jB,EAAGzhB,OAGH,OAFAxC,KAAK+jB,GAAK,IAAI,EAAAhmB,SAASkmB,EAAG,IAAIne,SAC9B9F,KAAKgkB,GAAK,IAAI,EAAAjmB,SAASkmB,EAAG,IAAIne,SACvB9F,KAKf,OAAG2D,EAAO,aA1FtB,SA2FoB3D,KAAK+jB,GAAK,IAAI,EAAAhmB,SAAS4F,EAAO,GAAGqD,GAAGlB,SACpC9F,KAAKgkB,GAAK,IAAI,EAAAjmB,SAAS4F,EAAO,GAAG0a,GAAGvY,SACjC9F,MAEAA,KAAKkB,OAIpB,OAAsB,IAAlByC,EAAOnB,QACPxC,KAAK+jB,GAAK,IAAI,EAAAhmB,SAAS4F,EAAO,IAAImC,SAClC9F,KAAKgkB,GAAK,IAAI,EAAAjmB,SAAS4F,EAAO,IAAImC,SAC3B9F,MAGJA,MAGX,KAAAa,MAAQ,KACJb,KAAK+jB,GAAK/jB,KAAK+jB,GAAGljB,QAClBb,KAAKgkB,GAAKhkB,KAAKgkB,GAAGnjB,QAEXb,MAGX,KAAAkB,KAAO,KACHlB,KAAK+jB,GAAK,IAAI,EAAAhmB,SAAS,MACvBiC,KAAKgkB,GAAK,IAAI,EAAAjmB,SAAS,MAChBiC,MAGX,KAAAkkB,OAAS,KACLlkB,KAAKkB,OACElB,MAGX,KAAAmkB,SAAW,CAACjP,EAAWC,KACnBnV,KAAK+jB,GAAK7O,EAAGlO,EAAEnG,QAAQyB,IAAI6S,EAAGnO,GAAGnF,OAAO,GACxC7B,KAAKgkB,GAAK9O,EAAGmJ,EAAExd,QAAQyB,IAAI6S,EAAGkJ,GAAGxc,OAAO,GAEjC7B,MAKX,KAAAokB,UAAaC,IACT,IAAIC,EAAM,GAKV,OAHAA,EAAIzd,KAAK7G,KAAK+jB,GAAGnhB,MAAMiD,aAA2B5B,IAAnBogB,EAA+B,EAAIA,IAClEC,EAAIzd,KAAK7G,KAAKgkB,GAAGphB,MAAMiD,aAA2B5B,IAAnBogB,EAA+B,EAAIA,IAE3D,UAAUC,EAAIrd,KAAK,gBAqB9B,KAAAmW,WAAczP,IACV,IAAI/K,EAAQ,EAAG4gB,EAAW,IAAI,EAAAzlB,SAAY6G,EAAM,GAEhD,GAAG+I,aAAgB,EAAA7O,KACf,OAAO6O,EAAKyP,WAAWpd,MACrB,GAAG2N,aAAgB9O,EAAM,CAC3B,IAAI+K,EAAI,IAAI,EAAAhL,OAAOoB,KAAM2N,GAEzB/K,EAAQgH,EAAE2a,KACVf,EAAW5Z,EAAE8W,WAAW9a,OACxBhB,EAAMgF,EAAE8W,WAAWpT,WAAWkW,EAAS5e,IAAI,mBAAmBgF,EAAE8W,WAAWvR,gBAAgBvF,EAAE8W,WAAWlb,iBAE5G,MAAO,CAAE5C,MAAAA,EAAO4gB,SAAAA,EAAU5e,IAAAA,IAM9B,KAAAia,iBAAoB5G,GACAA,EAAKlR,KAAIC,GAAGA,EAAEqE,MAEfvH,SAAS9D,KAAKqL,KA5K7BrL,KAAK+jB,IAAK,IAAI,EAAAhmB,UAAWmD,OACzBlB,KAAKgkB,IAAK,IAAI,EAAAjmB,UAAWmD,YAEV+C,IAAXN,GACA3D,KAAKJ,SAAS+D,GAGX3D,KAMPgH,QACA,OAAOhH,KAAK+jB,GAGZ/c,MAAEpE,GACF5C,KAAK+jB,GAAKnhB,EAGVyb,QACA,OAAOre,KAAKgkB,GAGZ3F,MAAEzb,GACF5C,KAAKgkB,GAAKphB,EAGVgC,UACA,IAAI0f,EAAM,GAKV,OAHAA,EAAIzd,KAAK7G,KAAK+jB,GAAGnf,KACjB0f,EAAIzd,KAAK7G,KAAKgkB,GAAGpf,KAEV,UAAU0f,EAAIrd,KAAK,eAG1BI,cACA,IAAIid,EAAM,GAKV,OAHAA,EAAIzd,KAAK7G,KAAK+jB,GAAGnf,KACjB0f,EAAIzd,KAAK7G,KAAKgkB,GAAGpf,KAEV,IAAI0f,EAAIrd,KAAK,QA0HpBoE,UACF,MAAO,GAAGrL,KAAKgH,EAAEK,WAAWrH,KAAKqe,EAAEhX,WA7KzC,UAqJW,EAAAkc,QAAU,CAAC9d,EAAQC,EAAQ0P,SACpBnR,IAANmR,EACO,oBAAoB3P,EAAEb,IAAMa,EAAEb,IAAMa,UAAUC,EAAEd,IAAMc,EAAEd,IAAMc,mBAE9D,oBAAoBD,EAAEb,IAAMa,EAAEb,IAAMa,UAAUC,EAAEd,IAAMc,EAAEd,IAAMc,UAAU0P,EAAExQ,IAAMwQ,EAAExQ,IAAMwQ,oB,iFCzK3G,eACA,SACA,SACA,OACA,SA6BA,MAAarW,EAiBTK,eAAeuE,GAKX,OAuFJ,KAAA/D,MAAQ,IAAI+D,KACR,GAAsB,IAAlBA,EAAOnB,OAAc,CAErB,IAAIkC,EAAIf,EAAOoD,KAAKC,GAAW,IAAI,EAAAjJ,SAASiJ,KAC5C,OAAOhH,KAAKJ,MACR,IAAI,EAAAf,MAAM6F,EAAE,GAAIA,EAAE,IAClB,IAAI,EAAA7F,MAAM6F,EAAE,GAAIA,EAAE,IAClB,IAAI,EAAA7F,MAAM6F,EAAE,GAAIA,EAAE,KAEnB,GAAsB,IAAlBf,EAAOnB,OAAc,CAK5B,GAA4D,IAAzDmB,EAAOoE,QAAQf,GAAuB,iBAANA,IAAgBxE,OAC/C,OAAOxC,KAAKJ,SAAU+D,EAAOoD,KAAKC,GAAa,IAAI,EAAAlI,KAAKkI,MACtD,GAAwD,IAArDrD,EAAOoE,QAAQf,GAAUA,aAAa,EAAAlI,OAAM0D,OAAY,CAE7DxC,KAAKwkB,OAAS,CACV,GAAM7gB,EAAO,GACb,GAAMA,EAAO,GACb,GAAMA,EAAO,IAIjB,IAAI8gB,EAAY9gB,EAAO,GAAGyd,aAAazd,EAAO,IAC9C,IAAI8gB,EAAUzB,gBAGV,OAAOhjB,KAGX,GALIA,KAAK0kB,GAAKD,EAAUpD,MAAMxgB,QAI9B4jB,EAAY9gB,EAAO,GAAGyd,aAAazd,EAAO,KACtC8gB,EAAUzB,gBAGV,OAAOhjB,KAGX,GALIA,KAAK2kB,GAAKF,EAAUpD,MAAMxgB,QAI9B4jB,EAAY9gB,EAAO,GAAGyd,aAAazd,EAAO,KACtC8gB,EAAUzB,gBAGV,OAAOhjB,KAFPA,KAAK4kB,GAAKH,EAAUpD,MAAMxgB,YAI5B,CAEF,GAAI8C,EAAOoE,QAAQf,GAAYA,aAAa,EAAAnI,QAAQ2D,OAAS,EACzD,OAAOxC,KAAKJ,MACR,IAAI,EAAAf,MAAM8E,EAAO,IACjB,IAAI,EAAA9E,MAAM8E,EAAO,IACjB,IAAI,EAAA9E,MAAM8E,EAAO,KAKzB3D,KAAK4kB,GAAKjhB,EAAO,GAAG9C,QACpBb,KAAK0kB,GAAK/gB,EAAO,GAAG9C,QACpBb,KAAK2kB,GAAKhhB,EAAO,GAAG9C,QAEpBb,KAAKwkB,OAAS,CACV,GAAM,IAAI,EAAA1lB,KAAKkB,KAAK4kB,GAAI5kB,KAAK0kB,IAC7B,GAAM,IAAI,EAAA5lB,KAAKkB,KAAK0kB,GAAI1kB,KAAK2kB,IAC7B,GAAM,IAAI,EAAA7lB,KAAKkB,KAAK4kB,GAAI5kB,KAAK2kB,WAGlC,GAAsB,IAAlBhhB,EAAOnB,QACVmB,EAAO,aAAc5E,EACrB,OAAO4E,EAAO,GAAG9C,QAKzB,OADAb,KAAK6kB,kBACE7kB,MAMX,KAAAa,MAAQ,KACJb,KAAK4kB,GAAK5kB,KAAK4kB,GAAG/jB,QAClBb,KAAK0kB,GAAK1kB,KAAK0kB,GAAG7jB,QAClBb,KAAK2kB,GAAK3kB,KAAK2kB,GAAG9jB,QAElBb,KAAKwkB,OAAS,CACV,GAAMxkB,KAAKwkB,OAAOvD,GAAGpgB,QACrB,GAAMb,KAAKwkB,OAAOM,GAAGjkB,QACrB,GAAMb,KAAKwkB,OAAOrD,GAAGtgB,SAGzBb,KAAK6kB,kBACE7kB,MAWH,KAAA6kB,gBAAkB,KACtB7kB,KAAK+kB,SAAW,CACZ,IAAM,IAAI,EAAAlmB,OAAQslB,SAASnkB,KAAK4kB,GAAI5kB,KAAK0kB,IACzC,IAAM,IAAI,EAAA7lB,OAAQslB,SAASnkB,KAAK4kB,GAAI5kB,KAAK2kB,IACzC,IAAM,IAAI,EAAA9lB,OAAQslB,SAASnkB,KAAK0kB,GAAI1kB,KAAK2kB,KAG7C3kB,KAAKglB,cAAgBhlB,KAAKilB,8BAQtB,KAAAC,eAAkBC,IACtB,OAAQA,EAAOC,eACX,IAAK,IACD,OAAOplB,KAAK4kB,GAChB,IAAK,IACD,OAAO5kB,KAAK0kB,GAChB,IAAK,IACD,OAAO1kB,KAAK2kB,GAIpB,OAAO3kB,KAAK4kB,IAOR,KAAAS,WAAa,CAACC,EAAiBC,IAC5B,IAAI,EAAA3mB,OACPoB,KAAKklB,eAAeI,GACpBtlB,KAAKklB,eAAeK,IAIpB,KAAAN,2BAA6B,KACjC,IAAIlE,EAAiC,CACjC,QAAW,CACP,EAAK,IAAI,EAAAjiB,KAAKkB,KAAK4kB,GAAI5kB,KAAK+kB,SAASD,IACrC,EAAK,IAAI,EAAAhmB,KAAKkB,KAAK0kB,GAAI1kB,KAAK+kB,SAAS5D,IACrC,EAAK,IAAI,EAAAriB,KAAKkB,KAAK2kB,GAAI3kB,KAAK+kB,SAAS9D,IACrC,aAAgB,MAEpB,UAAa,CACT,GAAM,IAAI,EAAAniB,KAAKkB,KAAK+kB,SAAS9D,GAAI,IAAI,EAAAriB,OAAOoB,KAAK4kB,GAAI5kB,KAAK0kB,IAAIrC,UAC9D,GAAM,IAAI,EAAAvjB,KAAKkB,KAAK+kB,SAAS5D,GAAI,IAAI,EAAAviB,OAAOoB,KAAK4kB,GAAI5kB,KAAK2kB,IAAItC,UAC9D,GAAM,IAAI,EAAAvjB,KAAKkB,KAAK+kB,SAASD,GAAI,IAAI,EAAAlmB,OAAOoB,KAAK0kB,GAAI1kB,KAAK2kB,IAAItC,UAC9D,aAAgB,MAEpB,QAAW,CACP,EAAK,IAAI,EAAAvjB,KAAKkB,KAAK4kB,GAAI,IAAI,EAAAhmB,OAAOoB,KAAK0kB,GAAI1kB,KAAK2kB,IAAItC,UACpD,EAAK,IAAI,EAAAvjB,KAAKkB,KAAK0kB,GAAI,IAAI,EAAA9lB,OAAOoB,KAAK4kB,GAAI5kB,KAAK2kB,IAAItC,UACpD,EAAK,IAAI,EAAAvjB,KAAKkB,KAAK2kB,GAAI,IAAI,EAAA/lB,OAAOoB,KAAK4kB,GAAI5kB,KAAK0kB,IAAIrC,UACpD,aAAgB,MAEpB,UAAa,CACT,EAAKriB,KAAKwlB,oBAAoB,KAC9B,EAAKxlB,KAAKwlB,oBAAoB,KAC9B,EAAKxlB,KAAKwlB,oBAAoB,KAC9B,aAAgB,OAWxB,OANAzE,EAAa0E,QAAQrE,aAAeL,EAAa0E,QAAQ5Z,EAAEuV,aAAaL,EAAa0E,QAAQ3Z,GAAGuV,MAChGN,EAAaC,UAAUI,aAAeL,EAAaC,UAAUC,GAAGG,aAAaL,EAAaC,UAAU8D,IAAIzD,MACxGN,EAAa2E,QAAQtE,aAAeL,EAAa2E,QAAQ7Z,EAAEuV,aAAaL,EAAa2E,QAAQ5Z,GAAGuV,MAChGN,EAAa4E,UAAUvE,aAAeL,EAAa4E,UAAU9Z,EAAEuV,aAAaL,EAAa4E,UAAU7Z,GAAGuV,MAG/FN,GAGH,KAAAyE,oBAAuBhH,IAC3B,IAAyB7B,EAAIC,EAAzBgJ,EAAS5lB,KAAK6lB,MAEV,MAALrH,GACC7B,EAAKiJ,EAAO3E,GACZrE,EAAKgJ,EAAOzE,IACF,MAAL3C,GACL7B,EAAKiJ,EAAO3E,GACZrE,EAAKgJ,EAAOd,IACF,MAALtG,IACL7B,EAAKiJ,EAAOd,GACZlI,EAAKgJ,EAAOzE,IAGhB,IAAI2E,EAAK,IAAI,EAAAhnB,KAAK,IAAI,EAAAV,SAASue,EAAGmB,SAASvd,KAAKM,QAAQa,SAASkb,EAAGzO,EAAE1M,WAAW8iB,MAAO3H,EAAGkB,SAASvd,KAAKM,QAAQa,SAASib,EAAGxO,EAAE1M,WAAW8iB,OAAOpjB,SAAQ,GAAMM,YAC3JskB,EAAK,IAAI,EAAAjnB,KAAK,IAAI,EAAAV,SAASue,EAAGmB,SAASvd,KAAKM,QAAQa,SAASkb,EAAGzO,EAAE1M,WAAW8iB,MAAO3H,EAAGkB,SAASvd,KAAKM,QAAQa,SAASib,EAAGxO,EAAE1M,WAAW8iB,MAAMhiB,WAAWpB,SAAQ,GAAMM,YAGzK,MAAQ,MAAL+c,EACQsH,EAAGrC,WAAWzjB,KAAK8L,EAAG9L,KAAKgM,GAAG8Z,EAAGC,EAEpC,MAALvH,EACQsH,EAAGrC,WAAWzjB,KAAK6L,EAAG7L,KAAKgM,GAAG8Z,EAAGC,EAEpC,MAALvH,EACQsH,EAAGrC,WAAWzjB,KAAK8L,EAAG9L,KAAK6L,GAAGia,EAAGC,EAIrCD,GAzSHniB,EAAOnB,OAAS,GAChBxC,KAAKJ,SAAS+D,GAEX3D,KAOP6L,QACA,OAAO7L,KAAK4kB,GAGZ9Y,QACA,OAAO9L,KAAK0kB,GAGZ1Y,QACA,OAAOhM,KAAK2kB,GAGZ1D,SACA,OAAOjhB,KAAKqlB,WAAW,IAAK,KAG5BW,SACA,OAAOhmB,KAAKqlB,WAAW,IAAK,KAG5BP,SACA,OAAO9kB,KAAKqlB,WAAW,IAAK,KAG5BY,SACA,OAAOjmB,KAAKqlB,WAAW,IAAK,KAG5BlE,SACA,OAAOnhB,KAAKqlB,WAAW,IAAK,KAG5Ba,SACA,OAAOlmB,KAAKqlB,WAAW,IAAK,KAG5Bc,kBACA,QAAInmB,KAAKihB,GAAGmF,WAAWpmB,KAAK8kB,OAGxB9kB,KAAKihB,GAAGmF,WAAWpmB,KAAKmhB,OAGxBnhB,KAAK8kB,GAAGsB,WAAWpmB,KAAKmhB,IAO5BkF,oBACA,OAAOrmB,KAAKihB,GAAGP,WAAW7c,QAAQ7D,KAAK8kB,GAAGpE,aACtC1gB,KAAKihB,GAAGP,WAAW7c,QAAQ7D,KAAKmhB,GAAGT,YAGvC4F,gBACA,OAAOtmB,KAAKihB,GAAGP,WAAW7c,QAAQ7D,KAAK8kB,GAAGpE,aACtC1gB,KAAKihB,GAAGP,WAAW7c,QAAQ7D,KAAKmhB,GAAGT,aACnC1gB,KAAK8kB,GAAGpE,WAAW7c,QAAQ7D,KAAKmhB,GAAGT,YAGvCmF,YACA,OAAO7lB,KAAKwkB,OAGZzD,mBACA,OAAO/gB,KAAKglB,eA/FpB,c,+EC7BA,eACA,SACA,SAEA,MAAapmB,EAITQ,eAAeuE,GA4Cf,KAAA/D,MAAQ,IAAI+D,KAMR,GAFA3D,KAAKkB,OAEiB,IAAlByC,EAAOnB,OACP,OAAOxC,KAGX,GAAsB,IAAlB2D,EAAOnB,OACP,OAAImB,EAAO,aAAc/E,EACd+E,EAAO,GAAG9C,QAEVb,KAAK8Q,aAAanN,EAAO,IAIxC,GAAIA,EAAOnB,QAAU,EAAG,CAEpB,GAAImB,EAAO,aAAc,EAAA9E,OAAS8E,EAAO,aAAc,EAAA9E,MAGnD,OAFAmB,KAAK+jB,GAAKpgB,EAAO,GAAGqD,EAAEnG,QAAQI,SAAS0C,EAAO,GAAGqD,GACjDhH,KAAKgkB,GAAKrgB,EAAO,GAAG0a,EAAExd,QAAQI,SAAS0C,EAAO,GAAG0a,GAC1Cre,MAIP2D,EAAO,aAAc,EAAA5F,WAAa8X,MAAMlS,EAAO,OAC/C3D,KAAK+jB,GAAK,IAAI,EAAAhmB,SAAS4F,EAAO,MAE9BA,EAAO,aAAc,EAAA5F,WAAa8X,MAAMlS,EAAO,OAC/C3D,KAAKgkB,GAAK,IAAI,EAAAjmB,SAAS4F,EAAO,KAIR,iBAAdA,EAAO,IAAoBkS,MAAMlS,EAAO,GAAGqD,IAAO6O,MAAMlS,EAAO,GAAGqD,IACpD,iBAAdrD,EAAO,IAAoBkS,MAAMlS,EAAO,GAAGqD,IAAO6O,MAAMlS,EAAO,GAAGqD,KAE1EhH,KAAK+jB,GAAK,IAAI,EAAAhmB,UAAU4F,EAAO,GAAGqD,EAAErD,EAAO,GAAGqD,GAC9ChH,KAAKgkB,GAAK,IAAI,EAAAjmB,UAAU4F,EAAO,GAAG0a,EAAE1a,EAAO,GAAG0a,IAItD,OAAOre,MAGX,KAAAa,MAAQ,KACJ,IAAI+I,EAAI,IAAIhL,EAQZ,OANgB,OAAZoB,KAAK+jB,KACLna,EAAE5C,EAAIhH,KAAK+jB,GAAGljB,SAEF,OAAZb,KAAKgkB,KACLpa,EAAEyU,EAAIre,KAAKgkB,GAAGnjB,SAEX+I,GAGX,KAAA2c,MAAQ,KACJvmB,KAAK+jB,GAAK,KACV/jB,KAAKgkB,GAAK,KACHhkB,MAGX,KAAAkB,KAAO,KACHlB,KAAKumB,QACLvmB,KAAK+jB,GAAK,IAAI,EAAAhmB,SAAS,MACvBiC,KAAKgkB,GAAK,IAAI,EAAAjmB,SAAS,MAChBiC,MAGX,KAAAyM,IAAM,KACFzM,KAAK+jB,GAAK,IAAI,EAAAhmB,SACdiC,KAAKgkB,GAAK,IAAI,EAAAjmB,SACPiC,MAGH,KAAA8Q,aAAgBlO,IAEpB,IAAI4jB,EAAa5jB,EAAM1C,MAAM,WAK7B,OAFAF,KAAKgH,EAAI,IAAI,EAAAjJ,SAASyoB,EAAW,IAAM,MACvCxmB,KAAKqe,EAAI,IAAI,EAAAtgB,SAASyoB,EAAW,IAAM,MAChCxmB,MAMX,KAAAuC,QAAU,KACNvC,KAAK+jB,GAAGxhB,UACRvC,KAAKgkB,GAAGzhB,UACDvC,MAGX,KAAAsC,IAAOsH,IACH5J,KAAK+jB,GAAGzhB,IAAIsH,EAAE5C,GACdhH,KAAKgkB,GAAG1hB,IAAIsH,EAAEyU,GAEPre,MAGX,KAAAiB,SAAY2I,GACD5J,KAAKsC,IAAIsH,EAAE/I,QAAQ0B,WAG9B,KAAAkkB,wBAA2B7c,GAEhB5J,KAAK+jB,GAAGljB,QAAQa,SAASkI,EAAE5C,GAAG1E,IAAItC,KAAKgkB,GAAGnjB,QAAQa,SAASkI,EAAEyU,IAQxE,KAAAgE,OAAS,KACL,IAAIrb,EAAIhH,KAAKgH,EAAEnG,QAAQ0B,UAAW8b,EAAIre,KAAKqe,EAAExd,QAG7C,OAFAb,KAAK+jB,GAAK1F,EACVre,KAAKgkB,GAAKhd,EACHhH,MAGX,KAAAomB,WAAc1hB,GACH1E,KAAKymB,wBAAwB/hB,GAAGlD,SAG3C,KAAAklB,iBAAoB9Z,IAChB,IAAI+Z,EAAS,IAAI,EAAA5oB,SAAS6O,GAG1B,OAFA5M,KAAK+jB,GAAGriB,SAASilB,GACjB3mB,KAAKgkB,GAAGtiB,SAASilB,GACV3mB,MAGX,KAAA4mB,eAAkBha,GACP5M,KAAK0mB,iBAAiB,IAAI,EAAA3oB,SAAS6O,GAAG7J,UAMjD,KAAAtB,SAAW,IAEAzB,KAAK0mB,iBAAiB,EAAA7oB,QAAQ8D,IAAI3B,KAAK+jB,GAAGve,YAAaxF,KAAKgkB,GAAGxe,cACjEohB,eAAe,EAAA/oB,QAAQiE,IAAI9B,KAAK+jB,GAAG5U,UAAWnP,KAAKgkB,GAAG7U,YAG/D,KAAA0X,UAAY,CAACjd,EAAWkd,EAAiBC,KACrC,IAAIJ,EAAS3mB,KAAKymB,wBAAwB7c,GAAGhH,MACzCokB,EAAWD,EAAS,EAAI,IAAMphB,KAAKshB,GAKvC,OAJIH,IACAH,EAAShhB,KAAKyJ,IAAIuX,IAGfK,EAAWrhB,KAAKuhB,KAAKP,GAAU3mB,KAAKukB,KAAO3a,EAAE2a,QAtMpDvkB,KAAK+jB,IAAK,IAAI,EAAAhmB,UAAWmD,OACzBlB,KAAKgkB,IAAK,IAAI,EAAAjmB,UAAWmD,YAEV+C,IAAXN,GACA3D,KAAKJ,SAAS+D,GAOlBqD,QACA,OAAOhH,KAAK+jB,GAGZ/c,MAAEpE,GACF5C,KAAK+jB,GAAKnhB,EAGVyb,QACA,OAAOre,KAAKgkB,GAGZ3F,MAAEzb,GACF5C,KAAKgkB,GAAKphB,EAGV8d,iBACA,OAAO1gB,KAAK+jB,GAAGljB,QAAQqM,IAAI,GAAG5K,IAAItC,KAAKgkB,GAAGnjB,QAAQqM,IAAI,IAGtDqX,WACA,OAAO5e,KAAKC,KAAK5F,KAAK0gB,WAAW9d,OAGjCgC,UACA,MAAO,mBAAmB5E,KAAK+jB,GAAGnf,YAAa5E,KAAKgkB,GAAGpf,sBAzC/D,WAgKW,EAAAuiB,cAAgB,CAACC,EAAYC,IAEzBD,EAAGpgB,EAAEpE,MAAQykB,EAAGrgB,EAAEpE,MAAQwkB,EAAG/I,EAAEzb,MAAQykB,EAAGhJ,EAAEzb,O,8EC1K3D,MAAa/E,EACT8J,aAAa/E,EAAcghB,EAAgB,GACvC,OAAO5S,OAAOrL,KAAK2hB,MAAMtW,OAAOpO,EAAM,IAAIghB,IAAW,KAAKA,GAO9Djc,aAAawF,GACT,IAAIoa,EAAkB,CAAC,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM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","sources":["webpack://pimath/./src/index.ts","webpack://pimath/./src/maths/algebra/equation.ts","webpack://pimath/./src/maths/algebra/linearSystem.ts","webpack://pimath/./src/maths/algebra/logicalset.ts","webpack://pimath/./src/maths/algebra/monom.ts","webpack://pimath/./src/maths/algebra/polynom.ts","webpack://pimath/./src/maths/algebra/rational.ts","webpack://pimath/./src/maths/coefficients/fraction.ts","webpack://pimath/./src/maths/coefficients/nthRoot.ts","webpack://pimath/./src/maths/expressions/numexp.ts","webpack://pimath/./src/maths/expressions/polynomexp.ts","webpack://pimath/./src/maths/geometry/circle.ts","webpack://pimath/./src/maths/geometry/line.ts","webpack://pimath/./src/maths/geometry/point.ts","webpack://pimath/./src/maths/geometry/triangle.ts","webpack://pimath/./src/maths/geometry/vector.ts","webpack://pimath/./src/maths/numeric.ts","webpack://pimath/./src/maths/randomization/random.ts","webpack://pimath/./src/maths/randomization/randomCore.ts","webpack://pimath/./src/maths/randomization/rndFraction.ts","webpack://pimath/./src/maths/randomization/rndHelpers.ts","webpack://pimath/./src/maths/randomization/rndMonom.ts","webpack://pimath/./src/maths/randomization/rndPolynom.ts","webpack://pimath/./src/maths/shutingyard.ts","webpack://pimath/webpack/bootstrap","webpack://pimath/webpack/startup"],"sourcesContent":["import {Numeric} from \"./maths/numeric\";\r\nimport {NumExp} from \"./maths/expressions/numexp\";\r\nimport {Shutingyard} from \"./maths/shutingyard\";\r\nimport {Random} from \"./maths/randomization/random\";\r\nimport {Fraction} from \"./maths/coefficients/fraction\";\r\nimport {NthRoot} from \"./maths/coefficients/nthRoot\";\r\nimport {Monom} from \"./maths/algebra/monom\";\r\nimport {Polynom} from \"./maths/algebra/polynom\";\r\nimport {Equation} from \"./maths/algebra/equation\";\r\nimport {LinearSystem} from \"./maths/algebra/linearSystem\";\r\nimport {Rational} from \"./maths/algebra/rational\";\r\nimport {Logicalset} from \"./maths/algebra/logicalset\";\r\nimport {PolynomExpFactor, PolynomExpProduct} from \"./maths/expressions/polynomexp\";\r\nimport {Vector} from \"./maths/geometry/vector\";\r\nimport {Line} from \"./maths/geometry/line\";\r\nimport {Triangle} from \"./maths/geometry/triangle\";\r\nimport {Circle} from \"./maths/geometry/circle\";\r\nimport {Point} from \"./maths/geometry/point\";\r\n\r\n// Expose as global\r\nexport const PiMath = {\r\n    ShutingYard: Shutingyard,\r\n    Numeric: Numeric,\r\n    NumExp: NumExp,\r\n    Fraction: Fraction,\r\n    Root: NthRoot,\r\n    Monom: Monom,\r\n    Polynom: Polynom,\r\n    Equation: Equation,\r\n    LinearSystem: LinearSystem,\r\n    Rational: Rational,\r\n    Logicalset: Logicalset,\r\n    Random: Random,\r\n    PolynomExpFactor: PolynomExpFactor,\r\n    PolynomExpProduct: PolynomExpProduct,\r\n    Geometry: {\r\n        Vector: Vector,\r\n        Point: Point,\r\n        Line: Line,\r\n        Triangle: Triangle,\r\n        Circle: Circle\r\n    }\r\n};\r\n(<any>window).Pi = PiMath\r\n","import {Polynom} from \"./polynom\";\r\nimport {literalType, Monom} from \"./monom\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {NthRoot} from \"../coefficients/nthRoot\";\r\n\r\n/**\r\n * Equation is a class to manage equations...\r\n */\r\nexport interface ISolution {\r\n    tex: string,\r\n    value: number,\r\n    exact: unknown\r\n}\r\n\r\nexport enum PARTICULAR_SOLUTION {\r\n    real=\"\\\\mathbb{R}\",\r\n    varnothing=\"\\\\varnothing\"\r\n}\r\n\r\nexport class Equation {\r\n    private _polynom: Polynom;  // Used to solve the equation // TODO: remove the private value ?\r\n\r\n    // Undetermined texSolutions.\r\n    private _varnothing: string = PARTICULAR_SOLUTION.varnothing;\r\n    private _real: string = PARTICULAR_SOLUTION.real;\r\n\r\n    /**\r\n     * Create an Equation using two polynoms.\r\n     * Markdown *support* is cool\r\n     * @param equations\r\n     */\r\n    constructor(...equations: unknown[]) {\r\n        // Default equation\r\n        this._left = new Polynom().zero();\r\n        this._right = new Polynom().zero();\r\n        this._sign = '=';\r\n\r\n        if (equations.length === 1) {\r\n            if (equations[0] instanceof Equation) {\r\n                return equations[0].clone();\r\n            } else if (typeof equations[0] === 'string') {\r\n                this.parse(equations[0]);\r\n            }\r\n        } else if (equations.length === 2) {\r\n            if (equations[0] instanceof Polynom) {\r\n                this.left = equations[0].clone()\r\n            } else if (typeof equations[0] === 'string') {\r\n                this.left = new Polynom(equations[0])\r\n            }\r\n\r\n            if (equations[1] instanceof Polynom) {\r\n                this.right = equations[1].clone()\r\n            } else if (typeof equations[1] === 'string') {\r\n                this.right = new Polynom(equations[1])\r\n            }\r\n        } else {\r\n            // Return default empty equation\r\n            return this;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _left: Polynom;  // Left part of the equation\r\n\r\n    get left(): Polynom {\r\n        return this._left;\r\n    }\r\n\r\n    set left(value: Polynom) {\r\n        this._left = value;\r\n    }\r\n\r\n    private _right: Polynom; // Right part of the equation\r\n\r\n    get right(): Polynom {\r\n        return this._right;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n\r\n    set right(value: Polynom) {\r\n        this._right = value;\r\n    }\r\n\r\n    private _sign: string;   // Signe of the equation, by default =\r\n\r\n    get sign(): string {\r\n        return this._sign;\r\n    }\r\n\r\n    set sign(value: string) {\r\n        // Set the sign value as formatted.\r\n        this._sign = this._formatSign(value);\r\n    }\r\n\r\n    private _solutions: ISolution[]\r\n\r\n    // ------------------------------------------\r\n    get solutions(): ISolution[] {\r\n        return this._solutions\r\n    }\r\n\r\n    get isEquation() {\r\n        return true;\r\n    }\r\n\r\n    get solution(): string {\r\n        if (this._solutions.length === 1\r\n            &&\r\n            (\r\n                this._solutions[0].tex === this._real\r\n                || this._solutions[0].tex === this._varnothing\r\n                || this._solutions[0].tex.includes('\\\\left')\r\n            )\r\n        ) {\r\n            return `S = ${this._solutions[0]}`;\r\n        }\r\n        return `S = \\\\left{ ${this._solutions.map(x => x.tex).join(';')} \\\\right}`;\r\n    }\r\n\r\n    get isReal(): boolean {\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n        return this._solutions[0].tex === this._real;\r\n    }\r\n\r\n    get isVarnothing(): boolean {\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n        return this._solutions[0].tex === this._varnothing;\r\n    }\r\n\r\n    get signAsTex(): string {\r\n        if (this._sign === '>=' || this._sign === '=>' || this._sign === 'geq') {\r\n            return '\\\\geq';\r\n        }\r\n        if (this._sign === '<=' || this._sign === '=<' || this._sign === 'leq') {\r\n            return '\\\\leq';\r\n        }\r\n        return this._sign;\r\n    }\r\n\r\n    get tex(): string {\r\n        return `${this._left.tex}${this.signAsTex}${this._right.tex}`;\r\n    }\r\n\r\n    get display(): string {\r\n        return `${this._left.display}${this.signAsTex}${this._right.display}`;\r\n    }\r\n\r\n    get raw(): string {\r\n        return `${this._left.raw}${this.signAsTex}${this._right.raw}`;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        return [...new Set(this._right.variables.concat(this._left.variables))];\r\n    }\r\n\r\n    get numberOfVars(): number {\r\n        return this.variables.length;\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n\r\n    // -----------------------------------------------\r\n    private _randomizeDefaults: { [key: string]: number | string | boolean } = {\r\n        degree: 2\r\n    };\r\n\r\n    get randomizeDefaults(): { [key: string]: number | string | boolean } {\r\n        return this._randomizeDefaults;\r\n    }\r\n\r\n    set randomizeDefaults(value) {\r\n        this._randomizeDefaults = value;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    parse = (equationString: string): Equation => {\r\n        let pStr: string[], strSign: string | false;\r\n        // Find the string separator\r\n        strSign = this._findSign(equationString);\r\n\r\n        if (strSign === false) {\r\n            console.error('The equation is not valid (no sign found)');\r\n            return;\r\n        }\r\n\r\n        // The StrSign is found\r\n        pStr = equationString.split(strSign);\r\n\r\n        return this.create(new Polynom(pStr[0]), new Polynom(pStr[1]), this._formatSign(strSign));\r\n    };\r\n\r\n    create = (left: Polynom, right: Polynom, sign?: string): Equation => {\r\n        this._left = left;\r\n        this._right = right;\r\n        this._sign = this._formatSign(sign);\r\n        return this;\r\n    };\r\n\r\n    clone = (): Equation => {\r\n        return new Equation().create(this._left.clone(), this._right.clone(), this._sign + '');\r\n    };\r\n\r\n    // -----------------------------------------------\r\n    // Equations generators and randomizers\r\n\r\n    randomize = (opts?: {}, sign?: string): Equation => {\r\n        // TODO: Generate equations randomly, using config.\r\n        return new Equation().create(new Polynom(), new Polynom(), sign);\r\n    };\r\n\r\n    // -----------------------------------------------\r\n    /**\r\n     * Reorder will move all monoms containing a letter on the left, all the other on the right.\r\n     */\r\n    moveLeft = (): Equation => {\r\n        this._left = this._left.clone().subtract(this._right)\r\n        this._right.zero()\r\n        return this;\r\n    }\r\n\r\n    reorder = (allLeft?: boolean): Equation => {\r\n        // Move all monoms of degree greater than 0 to the left.\r\n        // and all zero degree monoms to the right.\r\n        this._left.subtract(this._right);\r\n        this._right.zero();\r\n\r\n        if (allLeft) {\r\n            return this.moveLeft()\r\n        }\r\n        let mMove: Monom;\r\n        for (let m of this._left.monoms) {\r\n            if (m.degree().isZero()) {\r\n                mMove = m.clone();\r\n                this._left.subtract(mMove);\r\n                this._right.subtract(mMove);\r\n            }\r\n        }\r\n\r\n        // Reorder the left and right polynoms\r\n        this._left.reorder();\r\n        this._right.reorder();\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Multiply by the lcm denominator and divide by the gcm numerators.\r\n     */\r\n    simplify = (): Equation => {\r\n        this.multiply(Numeric.lcm(...this._left.getDenominators(), ...this._right.getDenominators()));\r\n        this.divide(Numeric.gcd(...this._left.getNumerators(), ...this._right.getNumerators()));\r\n        return this;\r\n    }\r\n\r\n\r\n    // -----------------------------------------------\r\n    // Equations operations\r\n\r\n    /**\r\n     * Reorder the polynom to have only one letter on the left, the rest on the right.\r\n     * @param letter\r\n     */\r\n    isolate = (letter?: string): Equation | false => {\r\n        // Determine if we can isolate the variables.\r\n\r\n        // Both part of the equations must be of the first degree.\r\n        //TODO: handle equations of degree two or more ?\r\n        if (!this.degree(letter).isOne()) {\r\n            return false;\r\n        }\r\n\r\n        // Modify the equation to isolate the asked variable.\r\n        // TODO: must handle equations like 3xy+5y=4 => y = 4/(3x-5)\r\n        if (this.isMultiVariable()) {\r\n            return false;\r\n        }\r\n\r\n        // Isolate the letter.\r\n        let mMove: Monom, cMove: Fraction;\r\n        // Start by moving everything to the left.\r\n        this._left.subtract(this._right);\r\n        this._right.zero();\r\n        for (let m of this._left.monoms) {\r\n            if (!m.hasLetter(letter)) {\r\n                mMove = m.clone();\r\n                this._left.add(mMove.clone().opposed());\r\n                this._right.add(mMove.clone().opposed());\r\n            }\r\n        }\r\n\r\n        // In theory, we should have only one item on the left.\r\n        if (this._left.length !== 1) {\r\n            return false;\r\n        }\r\n        cMove = this._left.monoms[0].coefficient.clone();\r\n        this._left.divide(cMove);\r\n        this._right.divide(cMove);\r\n        return this;\r\n    };\r\n\r\n    replaceBy = (letter: string, P: Polynom): Equation => {\r\n        this._left.replaceBy(letter, P)\r\n        this._right.replaceBy(letter, P)\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiple an equation by a fraction value.\r\n     * @param value\r\n     */\r\n    multiply = (value: unknown): Equation => {\r\n\r\n        // Make sure we have a fraction.\r\n        let F: Fraction = new Fraction(value);\r\n\r\n        // Multiply each part of the equation by the fraction\r\n        this._left.multiply(F);\r\n        this._right.multiply(F);\r\n\r\n        // The sign of the inequation must be changed.\r\n        if (this._sign !== '=' && F.sign() === -1) {\r\n            this._reverseSign();\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * divide an equation by a given value (transformed as a fraction)\r\n     *\r\n     * ```\r\n     * 8x+10=6x \\vert 2\r\n     * 4x+5=3x\r\n     * ```\r\n     *\r\n     * |>Alternatively with $3x-4$ maybe it's working ?\r\n     * $$\\frac{3x}{5}$$\r\n     *\r\n     * @param value\r\n     * @returns {Equation}\r\n     */\r\n    divide = (value: unknown): Equation => {\r\n        // Make sure we have a fraction.\r\n        let F: Fraction = new Fraction(value);\r\n\r\n        if (F.isZero()) {\r\n            return this;\r\n        } else {\r\n            return this.multiply(F.invert());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the degree of the equation\r\n     * @param letter\r\n     */\r\n    degree = (letter?: string): Fraction => {\r\n        return Fraction.max(this._left.degree(letter), this._right.degree(letter));\r\n    };\r\n\r\n    /**\r\n     * Determine if the equation contains more than one letter/variable.\r\n     */\r\n    isMultiVariable = (): boolean => {\r\n        return this._left.isMultiVariable || this._right.isMultiVariable;\r\n    };\r\n\r\n    letters = (): string[] => {\r\n        // @ts-ignore\r\n        return [...new Set([...this._left.letters(), ...this._right.letters()])];\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations helpers\r\n    // -----------------------------------------------\r\n\r\n    // -----------------------------------------------\r\n    solve = (): Equation => {\r\n        // Initialise the variables:\r\n        this._solutions = [];\r\n\r\n        // TODO: consolidate solving equations (inequations vs equations)\r\n        // TODO: work with not natural degrees ?\r\n        this._polynom = this._left.clone().subtract(this._right);\r\n\r\n        switch (this._polynom.degree().value) {\r\n            case 0:\r\n            case 1:\r\n                this._solveDegree1();\r\n                break;\r\n            case 2:\r\n                this._solveDegree2();\r\n                break;\r\n            default:\r\n                this._solveDegree3plus();\r\n        }\r\n\r\n        // cleanup the solutions.\r\n        this._solutions = Equation.makeSolutionsUnique(this._solutions)\r\n        return this;\r\n    };\r\n\r\n    static makeSolutionsUnique(solutions: ISolution[], sorted?: boolean):ISolution[] {\r\n        let solutionAsTex:string[] = [],\r\n            uniqueSolutions = solutions.filter(sol=>{\r\n                if(!solutionAsTex.includes(sol.tex)){\r\n                    solutionAsTex.push(sol.tex)\r\n                    return true\r\n                }else{\r\n                    return false\r\n                }\r\n            })\r\n\r\n        if(sorted===true){\r\n            uniqueSolutions.sort((a, b)=>a.value-b.value)\r\n        }\r\n        return uniqueSolutions\r\n    }\r\n\r\n    test = (values: literalType): Boolean => {\r\n        return this.left.evaluate(values).isEqual(this.right.evaluate(values))\r\n    }\r\n\r\n    private _findSign = (equationString: string): string | false => {\r\n        let strSign: string = '';\r\n\r\n        if (equationString.includes('geq')) {\r\n            return (equationString.includes('\\\\geq')) ? '\\\\geq' : 'geq';\r\n        } else if (equationString.includes('leq')) {\r\n            return (equationString.includes('\\\\leq')) ? '\\\\leq' : 'leq';\r\n        } else if (equationString.includes('>=')) {\r\n            return '>=';\r\n        } else if (equationString.includes('=>')) {\r\n            return '=>';\r\n        } else if (equationString.includes('>')) {\r\n            return '>';\r\n        } else if (equationString.includes('<=')) {\r\n            return '<=';\r\n        } else if (equationString.includes('=<')) {\r\n            return '=<';\r\n        } else if (equationString.includes('<')) {\r\n            return '<';\r\n        } else if (equationString.includes('=')) {\r\n            return '='\r\n        }\r\n        if (strSign === '') {\r\n            console.log('Equation: parse string : sign not found');\r\n            return false;\r\n        }\r\n    };\r\n\r\n    // -----------------------------------------------\r\n    // Equations solving algorithms\r\n\r\n    private _formatSign = (signStr: string): string => {\r\n        if (signStr === undefined) {\r\n            return '=';\r\n        }\r\n\r\n        if (signStr.includes('geq')) {\r\n            return '>=';\r\n        } else if (signStr.includes('>=')) {\r\n            return '>=';\r\n        } else if (signStr.includes('=>')) {\r\n            return '>=';\r\n        } else if (signStr.includes('>')) {\r\n            return '>';\r\n        } else if (signStr.includes('leq')) {\r\n            return '<=';\r\n        } else if (signStr.includes('<=')) {\r\n            return '<=';\r\n        } else if (signStr.includes('=<')) {\r\n            return '<=';\r\n        } else if (signStr.includes('<')) {\r\n            return '<';\r\n        } else {\r\n            return '='\r\n        }\r\n    };\r\n\r\n    private _reverseSign = (): Equation => {\r\n        if (this._sign === '=') {\r\n            return this;\r\n        }\r\n\r\n        if (this._sign.includes('<')) {\r\n            this._sign.replace('<', '>');\r\n            return this;\r\n        }\r\n        if (this._sign.includes('>')) {\r\n            this._sign.replace('>', '<');\r\n            return this;\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    private isGreater = (): boolean => {\r\n        if (this._sign.indexOf('>') !== -1) {\r\n            return true;\r\n        }\r\n        return this._sign.indexOf('geq') !== -1;\r\n\r\n    };\r\n\r\n    private isStrictEqual = (): boolean => {\r\n        return this._sign === '=';\r\n    };\r\n\r\n    private isAlsoEqual = (): boolean => {\r\n        if (this._sign.indexOf('=') !== -1) {\r\n            return true;\r\n        }\r\n        if (this._sign.indexOf('geq') !== -1) {\r\n            return true;\r\n        }\r\n        if (this._sign.indexOf('leq') !== -1) {\r\n            return true;\r\n        }\r\n    };\r\n\r\n    private _solveDegree1 = (letter?: string): ISolution[] => {\r\n        const m1 = this._polynom.monomByDegree(1, letter).coefficient,\r\n            m0 = this._polynom.monomByDegree(0, letter).coefficient,\r\n            v = m0.clone().opposed().divide(m1);\r\n        let s: string;\r\n\r\n        if (this.isStrictEqual()) {\r\n            if (m1.value === 0) {\r\n                // In this case, the coefficient of the x variable is zero.\r\n                if (m0.value === 0) {\r\n                    this._solutions = [{\r\n                        tex: this._real,\r\n                        value: NaN,\r\n                        exact: false\r\n                    }];\r\n                } else {\r\n                    this._solutions = [{\r\n                        tex: this._varnothing,\r\n                        value: NaN,\r\n                        exact: false\r\n                    }];\r\n                }\r\n            } else {\r\n                this._solutions = [{\r\n                    tex: v.tex,\r\n                    value: v.value,\r\n                    exact: v\r\n                }]\r\n            }\r\n        }\r\n        else {\r\n            if (m1.value === 0) {\r\n                // In this case, the coefficient of the x variable is zero.\r\n                if (m0.value === 0 && this.isAlsoEqual()) {\r\n                    s = '\\\\mathbb{R}';\r\n                } else {\r\n                    if (m0.value > 0) {\r\n                        s = this.isGreater() ? this._real : this._varnothing;\r\n                    } else {\r\n                        s = !this.isGreater() ? this._real : this._varnothing;\r\n                    }\r\n                }\r\n            } else {\r\n                // Must handle the case if the m1 monom is negative.\r\n                if ((this.isGreater() && m1.sign() === 1) || (!this.isGreater() && m1.sign() === -1)) {\r\n                    s = `\\\\left${this.isAlsoEqual() ? '\\\\[' : '\\\\]'}${v};+\\\\infty\\\\right\\\\[`;\r\n                } else {\r\n                    s = `\\\\left\\\\]-\\\\infty;${v} \\\\right\\\\${this.isAlsoEqual() ? '\\\\]' : '\\\\['}`;\r\n                }\r\n            }\r\n            this._solutions = [{\r\n                tex: s,\r\n                value: NaN,\r\n                exact: false\r\n            }];\r\n        }\r\n\r\n        return this._solutions;\r\n    };\r\n\r\n    private _solveDegree2 = (letter?: string): ISolution[] => {\r\n        let aF = this._polynom.monomByDegree(2, letter).coefficient,\r\n            bF = this._polynom.monomByDegree(1, letter).coefficient,\r\n            cF = this._polynom.monomByDegree(0, letter).coefficient,\r\n            delta: number, nthDelta: NthRoot,\r\n            lcm = Numeric.lcm(aF.denominator, bF.denominator, cF.denominator),\r\n            a = aF.multiply(lcm).value,\r\n            b = bF.multiply(lcm).value,\r\n            c = cF.multiply(lcm).value,\r\n            realX1: number, realX2: number,\r\n            sX1: string, sX2: string;\r\n\r\n        delta = b * b - 4 * a * c;\r\n\r\n        if (delta > 0) {\r\n            realX1 = (-b - Math.sqrt(delta)) / (2 * a);\r\n            realX2 = (-b + Math.sqrt(delta)) / (2 * a);\r\n\r\n            if (delta > 1.0e5) {\r\n                // The delta is too big to be parsed !\r\n                this._solutions = [\r\n                    {\r\n                        tex: ((-b - Math.sqrt(delta)) / (2 * a)).toFixed(5),\r\n                        value: realX1,\r\n                        exact: false\r\n                    },\r\n                    {\r\n                        tex: ((-b + Math.sqrt(delta)) / (2 * a)).toFixed(5),\r\n                        value: realX2,\r\n                        exact: false\r\n                    }\r\n                ]\r\n            } else {\r\n                nthDelta = new NthRoot(delta).reduce();\r\n                if (nthDelta.hasRadical()) {\r\n                    // -b +- coeff\\sqrt{radical}\r\n                    // -------------------------\r\n                    //           2a\r\n                    let gcd = Numeric.gcd(b, 2 * a, nthDelta.coefficient);\r\n                    nthDelta.coefficient = nthDelta.coefficient / gcd;\r\n\r\n                    // TODO: Can i delete the next line ?\r\n                    // let deltaC = nthDelta.coefficient, deltaR = nthDelta.radical;\r\n                    if (b !== 0) {\r\n                        if (2 * a / gcd === 1) {\r\n                            this._solutions = [\r\n                                {\r\n                                    tex: `${-b / gcd} - ${nthDelta.tex}`,\r\n                                    value: realX1,\r\n                                    exact: false // TODO: implement exact value with nthroot\r\n                                },\r\n                                {\r\n                                    tex: `${-b / gcd} + ${nthDelta.tex}`,\r\n                                    value: realX2,\r\n                                    exact: false\r\n                                },\r\n\r\n                            ]\r\n                        } else {\r\n                            this._solutions = [\r\n                                {\r\n                                    tex: `\\\\dfrac{${-b / gcd} - ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                                    value: realX1,\r\n                                    exact: false\r\n                                },\r\n                                {\r\n                                    tex: `\\\\dfrac{${-b / gcd} + ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                                    value: realX2,\r\n                                    exact: false\r\n                                },\r\n                            ]\r\n                        }\r\n                    } else {\r\n                        if (2 * a / gcd === 1) {\r\n                            this._solutions = [\r\n                                {\r\n                                    tex: `- ${nthDelta.tex}`,\r\n                                    value: realX1,\r\n                                    exact: false\r\n                                },\r\n                                {\r\n                                    tex: `${nthDelta.tex}`,\r\n                                    value: realX2,\r\n                                    exact: false\r\n                                },\r\n                            ]\r\n                        } else {\r\n                            this._solutions = [\r\n                                {\r\n                                    tex: `\\\\dfrac{- ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                                    value: realX1,\r\n                                    exact: false\r\n                                },\r\n                                {\r\n                                    tex: `\\\\dfrac{${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                                    value: realX2,\r\n                                    exact: false\r\n                                },\r\n                            ]\r\n                        }\r\n                    }\r\n                } else {\r\n                    // -b +- d / 2a\r\n                    const S1 = new Fraction(-b - nthDelta.coefficient, 2 * a).reduce(),\r\n                        S2 = new Fraction(-b + nthDelta.coefficient, 2 * a).reduce()\r\n                    this._solutions = [\r\n                        {\r\n                            tex: S1.dfrac,\r\n                            value: realX1,\r\n                            exact: S1\r\n                        },\r\n                        {\r\n                            tex: S2.dfrac,\r\n                            value: realX2,\r\n                            exact: S2\r\n                        }\r\n                    ]\r\n                }\r\n            }\r\n\r\n        } else if (delta === 0) {\r\n            const sol = new Fraction(-b, 2 * a).reduce()\r\n            this._solutions = [{\r\n                tex: sol.dfrac,\r\n                value: sol.value,\r\n                exact: sol\r\n            }];\r\n        } else {\r\n            this._solutions = [{\r\n                tex: this._varnothing,\r\n                value: NaN,\r\n                exact: false\r\n            }];\r\n        }\r\n\r\n        // Handle now the inequations.\r\n        if (!this.isStrictEqual()) {\r\n            if (this._solutions.length === 2) {\r\n                sX1 = (realX1 < realX2) ? this._solutions[0].tex : this._solutions[1].tex;\r\n                sX2 = (realX1 < realX2) ? this._solutions[1].tex : this._solutions[0].tex;\r\n\r\n                if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                    this._solutions = [{\r\n                        tex: `\\\\left]-\\\\infty ; ${sX1}\\\\right${this.isAlsoEqual() ? ']' : '['} \\\\cup \\\\left${this.isAlsoEqual() ? '[' : ']'}${sX2};+\\\\infty\\\\right[`,\r\n                        value: NaN,\r\n                        exact: false\r\n                    }\r\n                    ];\r\n                } else {\r\n                    this._solutions = [{\r\n                        tex: `\\\\left${this.isAlsoEqual() ? '[' : ']'}${sX1} ; ${sX2}\\\\right${this.isAlsoEqual() ? ']' : '['}`,\r\n                        value: NaN,\r\n                        exact: false\r\n                    }]\r\n                }\r\n            } else if (this._solutions.length === 1 && this._solutions[0].tex !== this._varnothing) {\r\n                if (!this.isAlsoEqual()) {\r\n                    if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                        this._solutions = [{\r\n                            tex: `\\\\left]-\\\\infty ; ${this._solutions[0].tex}\\\\right[ \\\\cup \\\\left]${this._solutions[0].tex};+\\\\infty\\\\right[`,\r\n                            value: NaN,\r\n                            exact: false\r\n                        }\r\n                        ];\r\n                    } else {\r\n                        this._solutions = [{\r\n                            tex: this._varnothing,\r\n                            value: NaN,\r\n                            exact: false\r\n                        }];\r\n                    }\r\n                } else {\r\n                    if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                        this._solutions = [{\r\n                            tex: this._real,\r\n                            value: NaN,\r\n                            exact: false\r\n                        }];\r\n                    } else {\r\n                        // this._texSolutions = [ this._texSolutions[0] ];\r\n                    }\r\n                }\r\n            } else {\r\n                if (this.isGreater()) {\r\n                    this._solutions = [{\r\n                        tex: aF.sign() === 1 ? this._real : this._varnothing,\r\n                        value: NaN,\r\n                        exact: false\r\n                    }];\r\n                } else {\r\n                    this._solutions = [{\r\n                        tex: aF.sign() === -1 ? this._real : this._varnothing,\r\n                        value: NaN,\r\n                        exact: false\r\n                    }];\r\n                }\r\n            }\r\n        }\r\n        return this._solutions;\r\n    };\r\n\r\n    private _solveDegree3plus = (letter?: string): ISolution[] => {\r\n        // Push everything to the left\r\n        // factorize\r\n        // solve each factors.\r\n        let equ = this.clone().moveLeft()\r\n        equ.left.factorize()\r\n\r\n        this._solutions = []\r\n\r\n        equ.left.factors.forEach(factor=>{\r\n            if(factor.degree(letter).leq(2)) {\r\n                let factorAsEquation = new Equation(factor, 0)\r\n                factorAsEquation.solve()\r\n                factorAsEquation.solutions.forEach(solution => {\r\n                    this._solutions.push(solution)\r\n                })\r\n            }else{\r\n                console.log(factor.tex, ': cannot actually get the solution of this equation')\r\n            }\r\n        })\r\n\r\n        // TODO: check equation resolution for more than degree 2\r\n        // this._solutions = [{tex: 'solve x - not yet handled', value: NaN, exact: false}];  // ESLint remove system :(\r\n        return this._solutions;\r\n    };\r\n}","import {Equation} from \"./equation\";\r\nimport {Polynom} from \"./polynom\";\r\nimport {Monom} from \"./monom\";\r\nimport {Random} from \"../randomization/random\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\n// TODO: Must check and rework\r\nexport class LinearSystem {\r\n    private _solutions: { [letter: string]: { value: Fraction, isReal: boolean, isVarnothing: boolean } };\r\n    private _resolutionSteps: LinearSystem[];\r\n    private _equations: Equation[];\r\n    private _letters: string[];\r\n\r\n    constructor(...equationStrings: string[]) {\r\n        this._equations = [];\r\n        this._letters = 'xy'.split('');\r\n\r\n        if (equationStrings !== undefined && equationStrings.length > 0) {\r\n            this.parse(...equationStrings);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get equations(): Equation[] {\r\n        return this._equations;\r\n    }\r\n\r\n    set equations(value) {\r\n        this._equations = value;\r\n    }\r\n\r\n    get letters(): string {\r\n        return this._letters.join('')\r\n    }\r\n\r\n    set letters(value: string) {\r\n        this._letters = value.split('');\r\n    }\r\n\r\n    get isSolvable(): boolean {\r\n        let V = this.variables;\r\n\r\n        // TODO: in some case, it is possible to resolve systems if there isn't the isSame number of vars and equations\r\n        if (V.length !== this._equations.length) {\r\n            return false;\r\n        }\r\n\r\n        //TODO: Must check if two equations isn't a linear combination of the others ?\r\n\r\n        return true;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        let V: string[] = [];\r\n        for (let E of this._equations) {\r\n            V = V.concat(E.variables);\r\n        }\r\n        return [...new Set(V)].sort();\r\n    }\r\n\r\n    get tex(): string {\r\n        // Build the array of values.\r\n        // Reorder\r\n        // This clone the system :!!!\r\n        //TODO: Avoid cloning this linear system\r\n        let LS = this.clone().reorder(),\r\n            letters = LS.variables,\r\n            equStr: string[],\r\n            equArray: string[] = [],\r\n            m: Monom;\r\n\r\n        // TODO: Manage tex output of linear equations\r\n        for (let equ of LS.equations) {\r\n            equStr = [];\r\n            for (let L of letters) {\r\n                m = equ.left.monomByLetter(L);\r\n\r\n                if (equStr.length === 0) {\r\n                    equStr.push(m.isZero() ? '' : m.tex);\r\n                } else {\r\n                    equStr.push(m.isZero() ? '' : ((m.coefficient.sign() === 1) ? '+' : '') + m.tex);\r\n                }\r\n            }\r\n\r\n            // Add the equal sign\r\n            equStr.push('=');\r\n\r\n            // Add the right hand part of the equation (should be only a number, because it has been reordered)\r\n            equStr.push(equ.right.tex);\r\n\r\n            // Add to the list.\r\n            equArray.push(equStr.join('&'));\r\n        }\r\n\r\n\r\n        return `\\\\left\\\\{\\\\begin{array}{${\"r\".repeat(letters.length)}cl}${equArray.join('\\\\\\\\\\ ')}\\\\end{array}\\\\right.`;\r\n        //return `\\\\left\\\\{\\\\begin{array}{rrrcl}${this._equations.map(equ => `${equ.tex}`).join('\\\\\\\\\\ \\n')}\\\\end{array}\\\\right.`;\r\n    }\r\n\r\n    get solution(): string {\r\n        let tex: string[] = [];\r\n\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n\r\n        for (let letter in this._solutions) {\r\n            if (this._solutions[letter].isReal) {\r\n                console.log(`Undetermined (letter ${letter})`);\r\n                return;\r\n            }\r\n            if (this._solutions[letter].isVarnothing) {\r\n                console.log(`Undefined (letter ${letter})`);\r\n                return;\r\n            }\r\n\r\n            tex.push(this._solutions[letter].value.dfrac);\r\n        }\r\n        return `(${tex.join(';')})`;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (...equations: unknown[]): LinearSystem => {\r\n        this._equations = equations.map(value => new Equation(value));\r\n        this._findLetters();\r\n        return this;\r\n    };\r\n\r\n    setCoefficient = (...coefficients: string[]): LinearSystem => {\r\n        // Reset the equations list\r\n        this._equations = [];\r\n\r\n        let i = 0;\r\n        while (i < coefficients.length - this._letters.length) {\r\n            let left = new Polynom().parse(this._letters.join(''), ...coefficients.slice(i, i + this._letters.length)),\r\n                right = new Polynom(coefficients[i + this._letters.length].toString()),\r\n                equ = new Equation().create(left, right);\r\n            this._equations.push(equ.clone());\r\n\r\n            i = i + this._letters.length + 1;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    clone = (): LinearSystem => {\r\n        return new LinearSystem().parse(...this._equations.map(equ => equ.clone()));\r\n    };\r\n\r\n    setLetters = (...letters: string[]): LinearSystem => {\r\n        this._letters = letters;\r\n        return this\r\n    }\r\n    private _findLetters = (): LinearSystem => {\r\n        // Find all letters used.\r\n        let variables = new Set();\r\n\r\n        for (let equ of this._equations) {\r\n            variables = new Set([...variables, ...equ.variables]);\r\n        }\r\n\r\n        // TODO: How to transform (Set of string) to string[]\r\n        // @ts-ignore\r\n        this._letters = [...variables];\r\n        return this;\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations generators and randomizers\r\n    // -----------------------------------------------\r\n    generate = (...solutions: Fraction[] | number[]): LinearSystem => {\r\n        let solutionsF: Fraction[] = [];\r\n\r\n        // Convert the numbers to fractions if necessary\r\n        for (let s of solutions) {\r\n            if (typeof s === \"number\") {\r\n                solutionsF.push(new Fraction(s.toString()));\r\n            } else {\r\n                solutionsF.push(s.clone());\r\n            }\r\n        }\r\n\r\n        // Create the equations and make sure they are not linear combined.\r\n        this._equations = [];\r\n        for (let i = 0; i < solutions.length; i++) {\r\n            this._equations.push(this._generateOneEquation(...solutionsF));\r\n        }\r\n        return this;\r\n    };\r\n    private _generateOneEquation = (...solutions: Fraction[]): Equation => {\r\n        let coeff: number[] = [], leftValue: Fraction = new Fraction().zero(),\r\n            letters: string[] = ['x', 'y', 'z', 't', 'u', 'v', 'w', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l'],\r\n            equString: string = '', equ: Equation;\r\n        for (let i = 0; i < solutions.length; i++) {\r\n            coeff.push(Random.numberSym(5));\r\n            leftValue.add(solutions[i].clone().multiply(coeff[i]));\r\n            equString += `${(coeff[i] < 0) ? coeff[i] : '+' + coeff[i]}${letters[i]}`\r\n        }\r\n\r\n        // LeftValue contains the left part oof the equation - and is then the isSame as the right part.\r\n        // It might be a Fraction.\r\n\r\n        // Must check if it's not a linear combination\r\n        equ = new Equation(`${equString}=${leftValue.display}`);\r\n        if (equ.right.monoms[0].coefficient.denominator != 1) {\r\n            equ.multiply(new Fraction(equ.right.monoms[0].coefficient.denominator, 1));\r\n        }\r\n        if (this._checkIfLinerCombination(equ)) {\r\n            return equ;\r\n        } else {\r\n            return this._generateOneEquation(...solutions);\r\n        }\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    private _linearReduction(eq1: Equation, eq2: Equation, letter: string): Equation {\r\n        // TODO: handle other signs for equations ?\r\n        // Get the monom for the particular letter.\r\n        let c1 = eq1.left.monomByDegree(1, letter).coefficient.clone(),\r\n            c2 = eq2.left.monomByDegree(1, letter).coefficient.clone().opposed();\r\n\r\n        return this.mergeEquations(eq1, eq2, c2, c1);\r\n    }\r\n\r\n    mergeEquations = (eq1: Equation, eq2: Equation, factor1: unknown, factor2: unknown): Equation => {\r\n        // Set and clone the equations.\r\n\r\n        let eq1multiplied = eq1.clone().multiply(new Fraction(factor1)),\r\n            eq2multiplied = eq2.clone().multiply(new Fraction(factor2));\r\n\r\n        // Add both equations together.\r\n        eq1multiplied.left.add(eq2multiplied.left);\r\n        eq1multiplied.right.add(eq2multiplied.right);\r\n\r\n        return eq1multiplied;\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Solvers algorithm\r\n    // ------------------------------------------\r\n    reorder = (): LinearSystem => {\r\n        for (let E of this._equations) {\r\n            E.reorder();\r\n        }\r\n        return this;\r\n    };\r\n\r\n    solve = (): LinearSystem => {\r\n        // Solve it by linear\r\n        this._solutions = {};\r\n        this._resolutionSteps = [];\r\n\r\n        // Reorder all equations.\r\n        this.reorder();\r\n\r\n        // Get all variables in the linear system\r\n        let V = this.variables.sort();\r\n\r\n        for (let letter of V) {\r\n            this._solutions[letter] = this._solveOneLetter(letter, V)\r\n        }\r\n\r\n        // TODO: LinearSystem - solve: optimization and handle undetermined and undefined systems.\r\n        return this;\r\n    };\r\n\r\n    private _checkIfLinerCombination = (equ: Equation): boolean => {\r\n\r\n        return true;\r\n    };\r\n\r\n    private _solveOneLetter(letter: string, V: string[]): { value: Fraction, isReal: boolean, isVarnothing: boolean } {\r\n        // list of equations.\r\n        let LE: Equation[] = this.clone().equations,\r\n            reducedEquations: Equation[] = [];\r\n\r\n        // Reduce the equations.\r\n        // Do it as long as there is more than one step, but no more than the number of equations.\r\n        for (let L of V) {\r\n            // remove the setLetter from all equations using linear combinations\r\n            if (L === letter) {\r\n                continue;\r\n            }\r\n\r\n            // Linear reduction.\r\n            // TODO: Search for better association\r\n            for (let i = 0; i < LE.length - 1; i++) {\r\n                reducedEquations.push(this._linearReduction(LE[i], LE[i + 1], L));\r\n            }\r\n\r\n            // Keep track of each steps.\r\n            this._resolutionSteps.push(new LinearSystem().parse(...reducedEquations));\r\n\r\n            // Set the list of equations to the new version.\r\n            LE = this._resolutionSteps[this._resolutionSteps.length - 1].clone().equations;\r\n\r\n            // Reset the stack\r\n            reducedEquations = [];\r\n        }\r\n\r\n        // Solve the equations\r\n        let E = this._resolutionSteps[this._resolutionSteps.length - 1].equations[0];\r\n        E.solve();\r\n\r\n        return {\r\n            value: new Fraction(E.solutions[0].value),\r\n            isReal: E.isReal,\r\n            isVarnothing: E.isVarnothing\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Helpers\r\n    // ------------------------------------------\r\n    log = (): string => {\r\n        let str: string = '';\r\n\r\n        for (let E of this._equations) {\r\n            console.log(E.tex);\r\n            str += `${E.tex}\\\\n}`;\r\n        }\r\n\r\n        return str;\r\n    };\r\n}\r\n","/**\r\n * Polynom module contains everything necessary to handle polynoms.\r\n * @module Logicalset\r\n */\r\n\r\nimport {Shutingyard, ShutingyardMode} from '../shutingyard';\r\n\r\n/**\r\n * Polynom class can handle polynoms, reorder, resolve, ...\r\n */\r\n    export class Logicalset {\r\n        private _rawString: string;\r\n        private _rpn: { token: string, tokenType: string }[]\r\n\r\n        /**\r\n         *\r\n         * @param {string} value (optional) Default polynom to parse on class creation\r\n         */\r\n        constructor(value: string) {\r\n            this._rawString = value\r\n            this.parse(value)\r\n            return this;\r\n        }\r\n\r\n        get isLogicalset() {\r\n            return true;\r\n        };\r\n\r\n        private parse = (value: string): Logicalset => {\r\n            // TODO: Must format the value string to convert some items...\r\n\r\n            // Parse the updated value to the shutingyard algorithm\r\n            this._rpn = new Shutingyard(ShutingyardMode.SET).parse(value).rpn;\r\n\r\n            return this;\r\n        }\r\n\r\n        evaluate(tokenSets: { [key: string]: unknown[] }, reference?: unknown[]): unknown[] {\r\n            let varStack: (Set<unknown>)[] = []\r\n\r\n            let referenceSet: Set<unknown>\r\n            if (reference === undefined) {\r\n                referenceSet = new Set()\r\n                for (let key in tokenSets) {\r\n                    referenceSet = new Set([...referenceSet, ...tokenSets[key]])\r\n                }\r\n            } else {\r\n                referenceSet = new Set(reference)\r\n            }\r\n\r\n            for (let token of this._rpn) {\r\n                if (token.tokenType === 'variable') {\r\n                    // The variable has no token - assume it's empty.\r\n                    if (tokenSets[token.token] === undefined) {\r\n                        varStack.push(new Set())\r\n                    } else {\r\n                        varStack.push(new Set(tokenSets[token.token]));\r\n                    }\r\n\r\n                } else {\r\n                    switch (token.token) {\r\n                        case '&':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                varStack.push(new Set([...first].filter(x => second.has(x))))\r\n                            }\r\n                            break\r\n                        case '|':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n                                varStack.push(new Set([...first, ...second]))\r\n                            }\r\n                            break\r\n                        case '-':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n                                varStack.push(new Set([...first].filter(x => !second.has(x))))\r\n                            }\r\n                            break\r\n                        case '!':\r\n                            if (varStack.length >= 1) {\r\n                                let first = varStack.pop()\r\n\r\n                                varStack.push(new Set([...referenceSet].filter(x => !first.has(x))))\r\n                            }\r\n                            break\r\n                    }\r\n                }\r\n            }\r\n\r\n            return [...varStack[0]].sort();\r\n        }\r\n\r\n        vennAB(): any[] {\r\n            return this.evaluate({\r\n                    A: ['A', 'AB'],\r\n                    B: ['B', 'AB']\r\n                },\r\n                ['A', 'B', 'AB', 'E']\r\n            )\r\n        }\r\n\r\n        vennABC(): any[] {\r\n            return this.evaluate({\r\n                    A: ['A', 'AB', 'AC', 'ABC'],\r\n                    B: ['B', 'AB', 'BC', 'ABC'],\r\n                    C: ['C', 'AC', 'BC', 'ABC']\r\n                },\r\n                ['A', 'B', 'C', 'AB', 'AC', 'BC', 'E']\r\n            )\r\n        }\r\n\r\n        get rpn(): { token: string, tokenType: string }[] {\r\n            return this._rpn\r\n        }\r\n\r\n        get tex(): string {\r\n            let varStack: { token: string, tokenType: string } [] = []\r\n\r\n            for (let token of this._rpn) {\r\n                if (token.tokenType === 'variable') {\r\n                    varStack.push(token);\r\n                } else {\r\n                    switch (token.token) {\r\n                        case '&':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\cap ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                            break\r\n                        case '|':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\cup ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                            break\r\n                        case '-':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\setminus ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                            break\r\n                        case '!':\r\n                            if (varStack.length >= 1) {\r\n                                let first = varStack.pop()\r\n                                varStack.push({token: `\\\\overline{ ${first.token} }`, tokenType: 'variable'})\r\n                            }\r\n                            break\r\n                    }\r\n                }\r\n            }\r\n\r\n            return varStack[0].token\r\n        }\r\n    }","/***\r\n * Monom class\r\n */\r\nimport {Numeric} from \"../numeric\";\r\nimport {Shutingyard, ShutingyardType, Token, tokenType} from \"../shutingyard\";\r\nimport {log} from \"util\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\nexport type literalType = {\r\n    [Key: string]: Fraction\r\n}\r\n\r\nexport class Monom {\r\n    private _coefficient: Fraction;\r\n    private _literal: literalType;\r\n\r\n    /**\r\n     * Create a Monom\r\n     * Defined as \\\\(k \\\\cdot x^{n}\\\\), where \\\\( k,n \\in \\\\mathbb{Q}\\\\).\r\n     * Examples: \\\\(3x^2\\\\) or \\\\(3/5x^2\\\\)\r\n     * @param value (optional) string The value that should be parse. Can be a Monom, a Fraction, a string or a number. If nothing is provided, it will return the trivial monom (0).\r\n     */\r\n    constructor(value?: unknown) {\r\n        this.zero();\r\n\r\n        if (value !== undefined) {\r\n            // A string is given - try to parse the value.\r\n            this.parse(value);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    /**\r\n     * Get the coefficient \\\\(k\\\\) of the Monom \\\\(k\\\\cdot x^{n}\\\\)\r\n     * @returns {Fraction}\r\n     */\r\n    get coefficient(): Fraction {\r\n        return this._coefficient;\r\n    }\r\n\r\n    /**\r\n     * Set the coefficient \\\\(k\\\\) value of the monom\r\n     * @param {Fraction | number | string} F\r\n     */\r\n    set coefficient(F: Fraction | number | string) {\r\n        this._coefficient = new Fraction(F);\r\n    }\r\n\r\n    /**\r\n     * Get the literal part of \\\\(x^{n_1}y^{n_2}\\\\) as dictionary \\\\[\\\\begin{array}{ll}x&=n_1\\\\\\\\y&=n_2\\\\end{array}\\\\]\r\n     * @returns {literalType}\r\n     */\r\n    get literal(): literalType {\r\n        return this._literal;\r\n    }\r\n\r\n    /**\r\n     * Get the literal square roots of the Monom.\r\n     * TODO: remove this getter ? Is it used and is it correct ?\r\n     * @returns {literalType}\r\n     */\r\n    get literalSqrt(): literalType {\r\n        if (this.isLiteralSquare()) {\r\n            let L: literalType = {}\r\n            for (let key in this._literal) {\r\n                L[key] = this._literal[key].clone().sqrt()\r\n            }\r\n            return L;\r\n        } else {\r\n            return this._literal;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom. Must be a dictionary {x: Fraction, y: Fraction, ...}\r\n     * @param {literalType} L\r\n     */\r\n    set literal(L: literalType) {\r\n        this._literal = L;\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom from a string\r\n     * @param inputStr  String like x^2y^3\r\n     */\r\n    set literalStr(inputStr: string) {\r\n        // TODO : parse using shutingyard tree !\r\n\r\n        // Match all x^n\r\n        for (const v of [...inputStr.matchAll(/([a-z])\\^([+-]?[0-9]+)/g)]) {\r\n            // Create the default letter entry if necessary.\r\n            if (!(v[1] in this._literal)) {\r\n                this._literal[v[1]] = new Fraction().zero();\r\n            }\r\n\r\n            // Add the new value.\r\n            // TODO: actually, it adds only numeric value\r\n            this._literal[v[1]].add(+v[2]);\r\n        }\r\n\r\n        // Match all x\r\n        for (const v of [...inputStr.matchAll(/([a-z](?!\\^))/g)]) {\r\n            // Match all single letters\r\n            if (!(v[1] in this._literal)) {\r\n                this._literal[v[1]] = new Fraction().zero();\r\n            }\r\n\r\n            // Add one to the value.\r\n            this._literal[v[1]].add(1)\r\n        }\r\n    }\r\n\r\n    // Getter helpers.\r\n    /**\r\n     * Get the variables letters\r\n     */\r\n    get variables(): string[] {\r\n        let M = this.clone().clean();\r\n        return Object.keys(M.literal)\r\n    }\r\n\r\n    // Display getter\r\n    /**\r\n     * This display getter is to be used in the polynom display getter\r\n     */\r\n    get display(): string {\r\n        let L: string = '',\r\n            letters = Object.keys(this._literal).sort()\r\n        for (let letter of letters) {\r\n            if (this._literal[letter].isNotZero()) {\r\n                L += `${letter}`;\r\n                if (this._literal[letter].isNotEqual(1)) {\r\n                    L += `^${this._literal[letter].display}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.display}`;\r\n            } else {\r\n                return '';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.display}${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    get dividers(): Monom[] {\r\n        // Decompose only if the coefficient is a natural number\r\n        if (!this.coefficient.isRelative()) {\r\n            return [this.clone()]\r\n        }\r\n\r\n\r\n        // Decompose only if the power values are natural numbers.\r\n        if (this.hasFractionCoefficient()) {\r\n            return [this.clone()]\r\n        }\r\n\r\n        // Security : do not do this if greater than 10000\r\n        if (this.coefficient.numerator > 10000) {\r\n            return [this.clone()]\r\n        }\r\n\r\n\r\n        const dividers = Numeric.dividers(Math.abs(this.coefficient.numerator))\r\n\r\n        // Decompose the literals parts.\r\n        let literals: literalType[] = [];\r\n        for (let L in this.literal) {\r\n            // L is the letter.\r\n            literals = this._getLiteralDividers(literals, L)\r\n        }\r\n\r\n        const monomDividers: Monom[] = [];\r\n        if (literals.length > 0 && dividers.length > 0) {\r\n            for (let N of dividers) {\r\n                for (let L of literals) {\r\n                    let M = new Monom();\r\n                    M.coefficient = new Fraction(N)\r\n                    M.literal = L\r\n                    monomDividers.push(M)\r\n                }\r\n            }\r\n        } else if (dividers.length === 0) {\r\n            for (let L of literals) {\r\n                let M = new Monom();\r\n                M.coefficient = new Fraction().one()\r\n                M.literal = L\r\n                monomDividers.push(M)\r\n            }\r\n        } else {\r\n            for (let N of dividers) {\r\n                let M = new Monom();\r\n                M.coefficient = new Fraction(N)\r\n                monomDividers.push(M)\r\n            }\r\n        }\r\n\r\n        return monomDividers.length === 0 ? [new Monom().one()] : monomDividers;\r\n    }\r\n\r\n    private _getLiteralDividers(arr: literalType[], letter: string): literalType[] {\r\n        let tmpList: { [key: string]: Fraction }[] = [];\r\n\r\n        // Be default, this.literal[letter] should be a rational number.\r\n        for (let d = 0; d <= this.literal[letter].value; d++) {\r\n            if (arr.length === 0) {\r\n                let litt: literalType = {}\r\n                litt[letter] = new Fraction(d)\r\n                tmpList.push(litt)\r\n            } else {\r\n                for (let item of arr) {\r\n                    let litt: literalType = {}\r\n                    for (let currentLetter in item) {\r\n                        litt[currentLetter] = item[currentLetter]\r\n                    }\r\n                    litt[letter] = new Fraction(d)\r\n                    tmpList.push(litt)\r\n                }\r\n            }\r\n        }\r\n        return tmpList;\r\n    }\r\n\r\n    /**\r\n     * Display the monom, forcing the '+' sign to appear\r\n     */\r\n    get displayWithSign(): string {\r\n        let d: String = this.display;\r\n        return (d[0] !== '-' ? '+' : '') + d;\r\n    }\r\n\r\n    get texWithSign(): string {\r\n        if (this.coefficient.isStrictlyPositive()) {\r\n            return '+' + this.tex\r\n        }\r\n\r\n        return this.tex\r\n    }\r\n\r\n    /**\r\n     * Get the tex output of the monom\r\n     */\r\n    get tex(): string {\r\n        // TODO: display with square root !\r\n        let L: string = '',\r\n            letters = Object.keys(this._literal).sort()\r\n\r\n        for (let letter of letters) {\r\n            if (this._literal[letter].isNotZero()) {\r\n                L += `${letter}`;\r\n                if (this._literal[letter].isNotEqual(1)) {\r\n                    L += `^{${this._literal[letter].tfrac}}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.dfrac}`;\r\n            } else {\r\n                return '0';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.dfrac}${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // -----------------------------------------\r\n    /**\r\n     * Parse a string to a monom. The string may include fraction.\r\n     * @param inputStr\r\n     */\r\n    parse = (inputStr: unknown): Monom => {\r\n\r\n        if (typeof inputStr === 'string') {\r\n            this._shutingYardToReducedMonom(inputStr)\r\n        } else if (typeof inputStr === 'number') {\r\n            this._coefficient = new Fraction(inputStr)\r\n            this._literal = {}\r\n        } else if (inputStr instanceof Fraction) {\r\n            this._coefficient = inputStr.clone()\r\n            this._literal = {}\r\n        } else if (inputStr instanceof Monom) {\r\n            this._coefficient = inputStr._coefficient.clone()\r\n            this._literal = this.copyLiterals(inputStr.literal)\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    static addToken = (stack: Monom[], element: Token): void => {\r\n\r\n        let q1: Monom, q2: Monom, m: Monom, letter: string, pow: Fraction\r\n\r\n        if (element.tokenType === ShutingyardType.COEFFICIENT) {\r\n            stack.push(new Monom(new Fraction(element.token)))\r\n\r\n        } else if (element.tokenType === ShutingyardType.VARIABLE) {\r\n            let M = new Monom().one()\r\n            M.setLetter(element.token, 1)\r\n            stack.push(M.clone())\r\n\r\n        } else if (element.tokenType === ShutingyardType.OPERATION) {\r\n            switch (element.token) {\r\n                case '-':\r\n                    // this should only happen for negative powers or for negative coefficient.\r\n                    q2 = (stack.pop()) || new Monom().zero()\r\n                    q1 = (stack.pop()) || new Monom().zero()\r\n\r\n                    stack.push(q1.subtract(q2))\r\n\r\n                    break;\r\n                case '*':\r\n                    // Get the last element in the stack\r\n                    q2 = (stack.pop()) || new Monom().one()\r\n                    q1 = (stack.pop()) || new Monom().one()\r\n\r\n                    stack.push(q1.multiply(q2))\r\n                    break\r\n                case '/':\r\n                    // Get the last element in the stack\r\n                    q2 = (stack.pop()) || new Monom().one()\r\n                    q1 = (stack.pop()) || new Monom().one()\r\n\r\n                    stack.push(q1.divide(q2))\r\n                    break\r\n                case '^':\r\n                    // get the two last elements in the stack\r\n                    pow = (stack.pop().coefficient) || new Fraction().one()\r\n                    m = (stack.pop()) || new Monom().one()\r\n\r\n                    letter = m.variables[0]\r\n\r\n                    if (letter !== undefined) {\r\n                        m.setLetter(letter, pow)\r\n                    }\r\n\r\n                    stack.push(m)\r\n                    // this.multiply(m.clone())\r\n                    break\r\n            }\r\n        }\r\n    }\r\n    private _shutingYardToReducedMonom = (inputStr: string): Monom => {\r\n        // Get the RPN array of the current expression\r\n        const SY: Shutingyard = new Shutingyard().parse(inputStr);\r\n        const rpn: { token: string, tokenType: string }[] = SY.rpn;\r\n\r\n        let stack: Monom[] = [], m, pow, letter, q1, q2\r\n\r\n        if (rpn.length === 0) {\r\n            this.zero()\r\n            return this\r\n        } else if (rpn.length === 1) {\r\n            const element = rpn[0]\r\n\r\n            this.one()\r\n            if (element.tokenType === 'coefficient') {\r\n                this.coefficient = new Fraction(element.token)\r\n            } else if (element.tokenType === 'variable') {\r\n                this.setLetter(element.token, 1)\r\n            }\r\n            return this\r\n        } else {\r\n            // Reset the monom\r\n            for (const element of rpn) {\r\n                Monom.addToken(stack, element)\r\n            }\r\n        }\r\n\r\n        this.one()\r\n        this.multiply(stack[0])\r\n        return this\r\n    }\r\n    /**\r\n     * Clone the current Monom.\r\n     */\r\n    clone = (): Monom => {\r\n        let F: Monom = new Monom();\r\n\r\n        F.coefficient = this._coefficient.clone();\r\n\r\n        // Copy the literal parts.\r\n        for (let k in this._literal) {\r\n            F.setLetter(k, this._literal[k].clone());\r\n        }\r\n        return F;\r\n    };\r\n\r\n    copyLiterals = (literal: literalType): literalType => {\r\n        let L: literalType = {}\r\n\r\n        for (let k in literal) {\r\n            L[k] = literal[k].clone()\r\n        }\r\n        return L\r\n    }\r\n\r\n    makeSame = (M: Monom): Monom => {\r\n        // Copy the literal parts.\r\n        for (let k in M._literal) {\r\n            this.setLetter(k, M._literal[k].clone());\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Create a zero value monom\r\n     */\r\n    zero = (): Monom => {\r\n        this._coefficient = new Fraction().zero();\r\n        this._literal = {};\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Create a one value monom\r\n     */\r\n    one = (): Monom => {\r\n        this._coefficient = new Fraction().one();\r\n        this._literal = {};\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Clean the monom by removing each letters with a power of zero.\r\n     */\r\n    clean = (): Monom => {\r\n        for (let letter in this._literal) {\r\n            if (this._literal[letter].isZero()) {\r\n                delete this._literal[letter];\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    reduce = (): Monom => {\r\n        this.clean()\r\n        this.coefficient.reduce()\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Get the opposed\r\n     * Returns a monom.\r\n     */\r\n    opposed = (): Monom => {\r\n        this._coefficient.opposed();\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Add all similar monoms. If they aren't similar, they are simply skipped.\r\n     * @param M (Monom[]) The monoms to add.\r\n     */\r\n    add = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            if (this.isSameAs(m)) {\r\n                if (this.isZero()) {\r\n                    this.makeSame(m)\r\n                }\r\n                this._coefficient.add(m.coefficient);\r\n            } else {\r\n                console.log('Add: Is not similar: ', m.display);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Subtract multiple monoms\r\n     * @param M (Monom[]) The monoms to subtract\r\n     */\r\n    subtract = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            if (this.isSameAs(m)) {\r\n                if (this.isZero()) {\r\n                    this.makeSame(m)\r\n                }\r\n                this._coefficient.add(m.clone().coefficient.opposed());\r\n            } else {\r\n                console.log('Subtract: Is not similar: ', m.display);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Multiple multiple monoms to the current monom\r\n     * @param M (Monom[]) The monoms to multiply to.\r\n     */\r\n    multiply = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            // Multiply the coefficient.\r\n            this._coefficient.multiply(m.coefficient);\r\n\r\n            // Multiply the literal parts.\r\n            for (let letter in m.literal) {\r\n                if (this._literal[letter] === undefined) {\r\n                    this._literal[letter] = m.literal[letter].clone()\r\n                } else {\r\n                    this._literal[letter].add(m.literal[letter])\r\n                }\r\n\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    multiplyByNumber = (F: Fraction | number): Monom => {\r\n        this._coefficient.multiply(F);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Divide the current monoms by multiple monoms\r\n     * @param M (Monom[])\r\n     */\r\n    divide = (...M: Monom[]): Monom => {\r\n        // Depending on the given value, choose the current item\r\n        for (let v of M) {\r\n            // Divide the coefficient\r\n            this._coefficient.divide(v.coefficient);\r\n\r\n            // Subtract the power values\r\n            for (let letter in v.literal) {\r\n                this._literal[letter] = (this._literal[letter] === undefined) ? v.literal[letter].clone().opposed() : this._literal[letter].subtract(v.literal[letter])\r\n\r\n                // If the power of a particular setLetter is zero, delete it from the literal part..\r\n                if (this._literal[letter].isZero()) {\r\n                    delete this._literal[letter];\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Get the pow of a monom.\r\n     * @param nb (number) : Mathematical pow\r\n     */\r\n    pow = (nb: number|Fraction): Monom => {\r\n        this._coefficient.pow(nb);\r\n        for (let letter in this._literal) {\r\n            this._literal[letter].multiply(nb)\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Get the nth-root of the monom\r\n     * @param p\r\n     */\r\n    root = (p: number): Monom => {\r\n        // TODO: determiner the nth root of a monom\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Return the square root of a monom\r\n     */\r\n    sqrt = (): Monom => {\r\n        if (this.isSquare()) {\r\n            this._coefficient.sqrt();\r\n            for (let letter in this._literal) {\r\n                this._literal[letter].clone().divide(2)\r\n            }\r\n        }\r\n        return this.root(2);\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n    // ------------------------------------------\r\n    compare = (M: Monom, sign?: string): boolean => {\r\n        // TODO: Build the compare systems.\r\n        if (sign === undefined) {\r\n            sign = '=';\r\n        }\r\n\r\n\r\n        switch (sign) {\r\n            case '=':\r\n                // To be equal, they must be the isSame\r\n                if (!this.compare(M, 'same')) {\r\n                    return false;\r\n                }\r\n\r\n                // The literal parts are the isSame. The coefficient must be equal\r\n                return this._coefficient.isEqual(M.coefficient);\r\n            case 'same':\r\n                // Get the list of all variables from both monoms.\r\n                let M1: string[] = this.variables,\r\n                    M2: string[] = M.variables,\r\n                    K: string[] = M1.concat(M2.filter((item) => M1.indexOf(item) < 0));\r\n\r\n                if(M1.length===0 && M2.length===0){return true}\r\n                // To compare, both must be different than zero.\r\n                if (!this.isZero() && !M.isZero()) {\r\n                    for (let key of K) {\r\n                        // The setLetter is not available in one of the monom\r\n                        if (this._literal[key] === undefined || M.literal[key] === undefined) {\r\n                            return false;\r\n                        }\r\n                        // The setLetter does not have the isSame power in each monoms.\r\n                        if (!this._literal[key].isEqual(M.literal[key])) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // All are positive check - the monoms are the sames.\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is null\r\n     */\r\n    isZero(): boolean {\r\n        return this._coefficient.value === 0;\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is one\r\n     */\r\n    isOne(): boolean {\r\n        return this._coefficient.value === 1 && this.variables.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Determine if two monoms are equals\r\n     * @param M\r\n     */\r\n    isEqual = (M: Monom): boolean => {\r\n        return this.compare(M, '=');\r\n    };\r\n\r\n    /**\r\n     * Determine if two monoms are similar\r\n     * @param M\r\n     */\r\n    isSameAs = (M: Monom): boolean => {\r\n        return this.compare(M, 'same');\r\n    };\r\n\r\n    isSquare = (): boolean => {\r\n        if (!this.coefficient.isSquare()) {\r\n            return false;\r\n        }\r\n        return this.isLiteralSquare();\r\n    }\r\n\r\n    isLiteralSquare = (): boolean => {\r\n        for (let letter in this.literal) {\r\n            // A literal square must have a natural power\r\n            if (this.literal[letter].isRational()) {\r\n                return false\r\n            }\r\n\r\n            // The natural power must be be even\r\n            if (this.literal[letter].isEven()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    hasFractionCoefficient = (): boolean => {\r\n        for (let letter in this._literal) {\r\n            if (this._literal[letter].isRational()) {\r\n                return true\r\n            }\r\n        }\r\n\r\n        return false\r\n    }\r\n    // ------------------------------------------\r\n    // Misc monoms functions\r\n    // -------------------------------------\r\n    /**\r\n     * Determine if a monom contains a setLetter in it's literal part\r\n     * @param letter\r\n     */\r\n    hasLetter = (letter?: string): boolean => {\r\n        // The letter was not found\r\n        if (this._literal[letter === undefined ? 'x' : letter] === undefined) {\r\n            return false\r\n        }\r\n\r\n        // The letter is found and is not zero !\r\n        return this._literal[letter === undefined ? 'x' : letter].isNotZero();\r\n    };\r\n\r\n    /**\r\n     * Set the power of a particular setLetter\r\n     * @param letter (string) Letter to change\r\n     * @param pow (number) Power of the setLetter (must be positive integer.\r\n     */\r\n    setLetter = (letter: string, pow: Fraction | number): void => {\r\n        if (pow instanceof Fraction) {\r\n            // Set the power of the letter to zero => remove it\r\n            if (this.hasLetter(letter) && pow.isZero()) {\r\n                delete this._literal[letter]\r\n            }\r\n\r\n            this._literal[letter] = pow.clone()\r\n        } else {\r\n            this.setLetter(letter, new Fraction(pow))\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Get the degree of a monom. If no setLetter is given, the result will be the global degree.\r\n     * @param letter (string) Letter to get to degree (power)\r\n     */\r\n    degree = (letter?: string): Fraction => {\r\n        if (this.variables.length === 0) {\r\n            return new Fraction().zero();\r\n        }\r\n        if (letter === undefined) {\r\n            // Not setLetter given -> we get the global monom degree (sum of all the letters).\r\n            return Object.values(this._literal).reduce((t, n) => t.clone().add(n));\r\n        } else {\r\n            // A setLetter is given -> get the corresponding power.\r\n            return this._literal[letter] === undefined ? new Fraction().zero() : this._literal[letter].clone();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Evaluate a monom. Each setLetter must be assigned to a Fraction.\r\n     * @param values    Dictionary of <setLetter: Fraction>\r\n     */\r\n    evaluate = (values: literalType | Fraction | number): Fraction => {\r\n        let r = this.coefficient.clone();\r\n\r\n        if (typeof values === 'number' || values instanceof Fraction) {\r\n            let tmpValues: literalType = {}\r\n            tmpValues[this.variables[0]] = new Fraction(values)\r\n            return this.evaluate(tmpValues);\r\n        }\r\n\r\n        if (typeof values === 'object') {\r\n            for (let L in this._literal) {\r\n                if (values[L] === undefined) {\r\n                    return new Fraction().zero();\r\n                }\r\n\r\n                let value = new Fraction(values[L])\r\n\r\n                r.multiply(value.pow(this._literal[L]))\r\n            }\r\n        }\r\n\r\n        return r;\r\n    };\r\n\r\n    /**\r\n     * Derivative the monom\r\n     * @param letter\r\n     */\r\n    derivative = (letter?: string): Monom => {\r\n        // No setLetter given - assume it's the setLetter 'x'\r\n        if (letter === undefined) {\r\n            letter = 'x';\r\n        }\r\n\r\n        if (this.hasLetter(letter)) {\r\n            let d = this._literal[letter].clone(),\r\n                dM = this.clone();\r\n\r\n            // Subtract one to the degree.\r\n            dM._literal[letter].subtract(1)\r\n\r\n            // Multiply the coefficient by the previous degree\r\n            dM._coefficient.multiply(new Fraction(d.clone()));\r\n            return dM;\r\n        } else {\r\n            return new Monom().zero();\r\n        }\r\n    };\r\n\r\n    primitive = (letter?: string): Monom => {\r\n        // TODO: derivative including the ln value => implies creating different monom system ?\r\n        if (letter === undefined) {\r\n            letter = 'x'\r\n        }\r\n\r\n        // Zero monom\r\n        let M = this.clone(), degree\r\n\r\n        if (M.hasLetter(letter)) {\r\n            degree = M.degree(letter).clone().add(1)\r\n            M.coefficient = M.coefficient.clone().divide(degree)\r\n            M.setLetter(letter, degree)\r\n        } else {\r\n            // There is no letter.\r\n\r\n            // The coefficient might be zero (=> x) or a number a (=> ax)\r\n            if (M.coefficient.isZero()) {\r\n                M.coefficient = new Fraction().one()\r\n            }\r\n            M.setLetter(letter, 1)\r\n        }\r\n\r\n        return M\r\n    }\r\n    // ----------------------------------------\r\n    // Static functions\r\n    // ----------------------------------------\r\n\r\n    /**\r\n     * Get the least common multiple of monoms\r\n     * @param monoms    Array of monoms\r\n     */\r\n    static lcm = (...monoms: Monom[]): Monom => {\r\n        // All the monoms must be with natural powers...\r\n        for (let m of monoms) {\r\n            if (m.hasFractionCoefficient()) {\r\n                return new Monom().zero()\r\n            }\r\n        }\r\n\r\n\r\n        let M = new Monom(),\r\n            coeffN: number[] = monoms.map(value => value.coefficient.numerator),\r\n            coeffD: number[] = monoms.map(value => value.coefficient.denominator),\r\n            n = Numeric.gcd(...coeffN),\r\n            d = Numeric.lcm(...coeffD);\r\n\r\n        // Get the coefficient.\r\n        M.coefficient = new Fraction(n, d).reduce();\r\n\r\n        // Set the literal parts - go through each monoms literal parts and get only the lowest degree of each letters.\r\n        for (let m of monoms) {\r\n            // Remove the inexistant letters from the resulting monom\r\n            for (let letter in M.literal) {\r\n                if (!(letter in m.literal)) {\r\n                    M.literal[letter].zero();\r\n                }\r\n            }\r\n            for (let letter in m.literal) {\r\n                if (M.literal[letter] === undefined && m.literal[letter].isStrictlyPositive()) {\r\n                    M.literal[letter] = m.literal[letter].clone();\r\n                } else {\r\n                    M.literal[letter] = new Fraction(Math.min(m.literal[letter].value, M.literal[letter].value))\r\n                }\r\n            }\r\n        }\r\n\r\n        return M;\r\n    };\r\n\r\n    /**\r\n     * Multiply two monoms and return a NEW monom.\r\n     * @param monoms\r\n     */\r\n    static xmultiply = (...monoms: Monom[]): Monom => {\r\n        let M = new Monom().one();\r\n\r\n        for (let m of monoms) {\r\n            M.multiply(m);\r\n        }\r\n\r\n        return M;\r\n    };\r\n\r\n\r\n    // TODO: The rest of the functions are not used or unnecessary ?\r\n    /**\r\n     * Determine if multiple monoms are similar\r\n     * @param M\r\n     */\r\n    areSameAs = (...M: Monom[]): boolean => {\r\n        let result: boolean = true;\r\n\r\n        // Check all monoms if they are the isSame as the \"this\" one.\r\n        for (let i = 0; i < M.length; i++) {\r\n            if (!this.isSameAs(M[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // All check passed -> all the monoms are similar.\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Determine if multiple monoms are equals\r\n     * @param M\r\n     */\r\n    areEquals = (...M: Monom[]): boolean => {\r\n        // They are not similar.\r\n        if (!this.areSameAs(...M)) {\r\n            return false;\r\n        }\r\n\r\n        // Check all coefficient. They must be equals.\r\n        for (let m of M) {\r\n            if (!this._coefficient.isEqual(m.coefficient)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // All checks passed.\r\n        return true;\r\n    };\r\n\r\n}\r\n","/**\r\n * Polynom module contains everything necessary to handle polynoms.*\r\n */\r\n\r\nimport {literalType, Monom} from './monom';\r\nimport {Shutingyard, ShutingyardType, Token} from '../shutingyard';\r\nimport {Numeric} from '../numeric';\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Equation, ISolution} from \"./equation\";\r\n\r\nexport type PolynomParsingType = string | Polynom | number | Fraction | Monom\r\n\r\n/**\r\n * Polynom class can handle polynoms, reorder, resolve, ...\r\n * ```\r\n * let P = new Polynom('3x-4')\r\n * ```\r\n */\r\nexport class Polynom {\r\n    private _rawString: string;\r\n\r\n    /**\r\n     *\r\n     * @param {string} polynomString (optional) Default polynom to parse on class creation\r\n     * @param values\r\n     */\r\n    constructor(polynomString?: PolynomParsingType, ...values: unknown[]) {\r\n        this._monoms = [];\r\n        this._factors = [];\r\n        if (polynomString !== undefined) {\r\n            this.parse(polynomString, ...values);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    private _monoms: Monom[];\r\n\r\n    // ------------------------------------------\r\n    get monoms() {\r\n        return this._monoms;\r\n    }\r\n\r\n    set monoms(M: Monom[]) {\r\n        this._monoms = M;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n\r\n    private _factors: Polynom[];\r\n\r\n    get factors(): Polynom[] {\r\n        return this._factors;\r\n    }\r\n\r\n    set factors(value: Polynom[]) {\r\n        this._factors = value;\r\n    }\r\n\r\n    private _texString: string;\r\n\r\n    get texString(): string {\r\n        return this._texString;\r\n    }\r\n\r\n    get texFactors(): string {\r\n        this.factorize()\r\n\r\n        if(this.factors.length===0){\r\n            return this.tex\r\n        }\r\n        let tex = ''\r\n        for (let f of this.factors) {\r\n            if (f.monoms.length > 1) {\r\n                tex += `(${f.tex})`\r\n            } else {\r\n                tex = f.tex + tex;\r\n            }\r\n        }\r\n        return tex;\r\n    }\r\n\r\n    get length() {\r\n        // TODO: Must reduce the monoms list to remove the zero coefficient.\r\n        return this._monoms.length;\r\n    }\r\n\r\n    get display(): string {\r\n        return this.genDisplay();\r\n    }\r\n\r\n    get raw(): string {\r\n        return this._rawString\r\n    }\r\n\r\n    get tex(): string {\r\n        return this.genDisplay('tex');\r\n    }\r\n\r\n    get isMultiVariable(): boolean {\r\n        const B = false;\r\n        for (const m of this._monoms) {\r\n            if (m.variables.length > 1) {\r\n                return true;\r\n            }\r\n        }\r\n        return B;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        let V: string[] = [];\r\n\r\n        for (const m of this._monoms) {\r\n            V = V.concat(m.variables);\r\n        }\r\n\r\n        // Remove duplicates.\r\n        V = [...new Set(V)];\r\n\r\n        return V;\r\n    }\r\n\r\n    get numberOfVars(): number {\r\n        return this.variables.length;\r\n    }\r\n\r\n    static addToken = (stack: Polynom[], element: Token): void => {\r\n\r\n        switch (element.tokenType) {\r\n            case ShutingyardType.COEFFICIENT:\r\n                stack.push(new Polynom(element.token))\r\n                break\r\n\r\n            case ShutingyardType.VARIABLE:\r\n                stack.push(new Polynom().add(new Monom(element.token)))\r\n                break\r\n\r\n            case ShutingyardType.CONSTANT:\r\n                // TODO: add constant support to Polynom parsing.\r\n                console.log('Actually, not supported - will be added later !')\r\n                break\r\n\r\n            case ShutingyardType.OPERATION:\r\n                if (stack.length >= 2) {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop()\r\n\r\n                    if (element.token === '+') {\r\n                        stack.push(a.add(b))\r\n                    } else if (element.token === '-') {\r\n                        stack.push(a.subtract(b))\r\n                    } else if (element.token === '*') {\r\n                        stack.push(a.multiply(b))\r\n                    } else if (element.token === '/') {\r\n                        if (b.degree().isStrictlyPositive()) {\r\n                            console.log('divide by a polynom -> should create a rational polynom !')\r\n                        } else {\r\n                            stack.push(a.divide(b.monoms[0].coefficient))\r\n\r\n                        }\r\n                    } else if (element.token === '^') {\r\n                        if (b.degree().isStrictlyPositive()) {\r\n                            console.error('Cannot elevate a polynom with another polynom !')\r\n                        } else {\r\n                            if (b.monoms[0].coefficient.isRelative()) {\r\n                                // Integer power\r\n                                stack.push(a.pow(b.monoms[0].coefficient.value))\r\n                            } else {\r\n                                // Only allow power if the previous polynom is only a monom, without coefficient.\r\n                                if (a.monoms.length === 1 && a.monoms[0].coefficient.isOne()) {\r\n                                    for (let letter in a.monoms[0].literal) {\r\n                                        a.monoms[0].literal[letter].multiply(b.monoms[0].coefficient)\r\n                                    }\r\n                                    stack.push(a)\r\n                                } else {\r\n                                    console.error('Cannot have power with fraction')\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    console.log('Stack size: ', stack.length)\r\n                    if (element.token === '-') {\r\n                        stack.push(stack.pop().opposed())\r\n                    } else {\r\n                        console.log('While parsing, cannot apply ', element.token, 'to', stack[0].tex)\r\n                    }\r\n                }\r\n                break\r\n\r\n            case ShutingyardType.MONOM:\r\n                // Should never appear.\r\n                console.error('The monom token should not appear here')\r\n                break;\r\n\r\n            case ShutingyardType.FUNCTION:\r\n                // Should never appear.\r\n                console.log('The function token should not appear here - might be introduced later.')\r\n                break;\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse a string to a polynom.\r\n     * @param inputStr\r\n     * @param values: as string, numbers or fractions\r\n     */\r\n    parse = (inputStr: PolynomParsingType, ...values: unknown[]): Polynom => {\r\n        // Reset the main variables.\r\n        this._monoms = []\r\n        this._factors = []\r\n\r\n        if (typeof inputStr === 'string') {\r\n            return this._parseString(inputStr, ...values)\r\n        } else if (typeof inputStr === 'number' || inputStr instanceof Fraction || inputStr instanceof Monom) {\r\n            this._monoms.push(new Monom(inputStr))\r\n        } else if (inputStr instanceof Polynom) {\r\n            for (const m of inputStr.monoms) {\r\n                this._monoms.push(m.clone())\r\n            }\r\n        }\r\n\r\n        return this\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n\r\n    /**\r\n     * Clone the polynom\r\n     */\r\n    clone = (): Polynom => {\r\n        const P = new Polynom();\r\n        const M: Monom[] = [];\r\n\r\n        for (const m of this._monoms) {\r\n            M.push(m.clone());\r\n        }\r\n\r\n        P.monoms = M;\r\n        return P;\r\n    };\r\n\r\n    /**\r\n     * Set the polynom to zero.\r\n     * @returns {this}\r\n     */\r\n    zero = (): Polynom => {\r\n        this._monoms = [];\r\n        this._monoms.push(new Monom().zero());\r\n        this._rawString = '0';\r\n        return this;\r\n    };\r\n\r\n    one = (): Polynom => {\r\n        this._monoms = [];\r\n        this._monoms.push(new Monom().one());\r\n        this._rawString = '1';\r\n        return this;\r\n    }\r\n\r\n    empty = (): Polynom => {\r\n        this._monoms = [];\r\n        this._rawString = '';\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    opposed = (): Polynom => {\r\n        this._monoms = this._monoms.map(m => m.opposed());\r\n        return this;\r\n    };\r\n\r\n    add = (...values: unknown[]): Polynom => {\r\n\r\n        for (let value of values) {\r\n            if (value instanceof Polynom) {\r\n                this._monoms = this._monoms.concat(value.monoms);\r\n            } else if (value instanceof Monom) {\r\n                this._monoms.push(value.clone());\r\n            } else if (Number.isSafeInteger(value)) {\r\n                this._monoms.push(new Monom(value.toString()));\r\n            } else {\r\n                this._monoms.push(new Monom(value));\r\n            }\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    // // -----------------------------------------------\r\n    // // Polynom generators and randomizers\r\n    // // -----------------------------------------------\r\n    // random(config?: randomPolynomConfig) {\r\n    //     return Random.polynom(config);\r\n    // }\r\n    //\r\n    // private _randomizeDefaults: { [key: string]: number | string | boolean } = {\r\n    //     degree: 2,\r\n    //     unit: true,\r\n    //     fractions: false,\r\n    //     factorable: false,\r\n    //     letters: 'x',\r\n    //     allowNullMonom: false,\r\n    //     numberOfMonoms: false\r\n    // };\r\n    // get randomizeDefaults(): { [key: string]: number | string | boolean } {\r\n    //     return this._randomizeDefaults;\r\n    // }\r\n    //\r\n    // set randomizeDefaults(value) {\r\n    //     this._randomizeDefaults = value;\r\n    // }\r\n    //\r\n    // randomize = (config: { [key: string]: number | string | boolean }): Polynom => {\r\n    //     let P = new Polynom();\r\n    //\r\n    //     // Check the config file and use the default values.\r\n    //     if (config === undefined) {\r\n    //         config = {};\r\n    //     }\r\n    //     for (let k in this._randomizeDefaults) {\r\n    //         if (config[k] === undefined) {\r\n    //             config[k] = this._randomizeDefaults[k];\r\n    //         }\r\n    //     }\r\n    //\r\n    //     // TODO: Build a more robust randomize function\r\n    //     return P;\r\n    // }\r\n    //\r\n    // rndFactorable = (degree: number = 2, unit: boolean | number = false, letters: string = 'x'): Polynom => {\r\n    //     // TODO: Make rndFactorable polynom generator more user friendly\r\n    //     this._factors = [];\r\n    //     for (let i = 0; i < degree; i++) {\r\n    //         let factorUnit = unit === true || i >= unit,\r\n    //             p = Random.polynom({\r\n    //                 degree: 1,\r\n    //                 unit: factorUnit,\r\n    //                 fraction: false,\r\n    //                 letters\r\n    //             });\r\n    //         this._factors.push(p);\r\n    //     }\r\n    //\r\n    //     this.empty().monoms = this._factors[0].monoms;\r\n    //     for (let i = 1; i < this._factors.length; i++) {\r\n    //         this.multiply(this._factors[i]);\r\n    //     }\r\n    //     return this;\r\n    // };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n\r\n    subtract = (...values: unknown[]): Polynom => {\r\n\r\n        for (let value of values) {\r\n            if (value instanceof Polynom) {\r\n                this._monoms = this._monoms.concat(value.clone().opposed().monoms);\r\n            } else if (value instanceof Monom) {\r\n                this._monoms.push(value.clone().opposed());\r\n            } else if (Number.isSafeInteger(value)) {\r\n                this._monoms.push(new Monom(value.toString()).opposed());\r\n            } else {\r\n                this._monoms.push(new Monom(value).opposed());\r\n            }\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    multiply = (value: unknown): Polynom => {\r\n        if (value instanceof Polynom) {\r\n            return this.multiplyByPolynom(value);\r\n        } else if (value instanceof Fraction) {\r\n            return this.multiplyByFraction(value);\r\n        } else if (value instanceof Monom) {\r\n            return this.multiplyByMonom(value);\r\n        } else if (Number.isSafeInteger(value) && typeof value === 'number') {\r\n            return this.multiplyByInteger(value);\r\n        }\r\n\r\n        // Something went wrong...\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Divide the current polynom by another polynom.\r\n     * @param P\r\n     * returns {quotient: Polynom, reminder: Polynom}\r\n     */\r\n    euclidian = (P: Polynom): { quotient: Polynom, reminder: Polynom } => {\r\n        const letter: string = P.variables[0];\r\n        const quotient: Polynom = new Polynom().zero();\r\n        const reminder: Polynom = this.clone().reorder(letter);\r\n\r\n        // There is no variable !\r\n        if (P.variables.length === 0) {\r\n            return {quotient, reminder}\r\n        }\r\n\r\n        // Get at least a letter\r\n\r\n        const maxMP: Monom = P.monomByDegree(undefined, letter);\r\n        const degreeP: Fraction = P.degree(letter);\r\n\r\n        let newM: Monom;\r\n\r\n        // Make the euclidian division of the two polynoms.\r\n        let MaxIteration = this.degree(letter).clone().multiply(2);\r\n        while (reminder.degree(letter).geq(degreeP) && MaxIteration.isPositive()) {\r\n            MaxIteration.subtract(1)\r\n\r\n            // Get the greatest monom divided by the max monom of the divider\r\n            newM = reminder.monomByDegree(undefined, letter).clone().divide(maxMP);\r\n\r\n            if (newM.isZero()) {\r\n                break;\r\n            }\r\n\r\n            // Get the new quotient and reminder.\r\n            quotient.add(newM);\r\n            reminder.subtract(P.clone().multiply(newM));\r\n        }\r\n\r\n        quotient.reduce()\r\n        reminder.reduce()\r\n        return {quotient, reminder};\r\n    };\r\n\r\n    divide = (value: unknown): Polynom => {\r\n        if (value instanceof Fraction) {\r\n            return this.divideByFraction(value);\r\n        } else if (typeof value === 'number' && Number.isSafeInteger(value)) {\r\n            return this.divideByInteger(value);\r\n        }\r\n\r\n    }\r\n\r\n    pow = (nb: number): Polynom => {\r\n        if (!Number.isSafeInteger(nb)) {\r\n            return this.zero();\r\n        }\r\n        if (nb < 0) {\r\n            return this.zero();\r\n        }\r\n        if (nb === 0) {\r\n            return new Polynom();\r\n        }\r\n\r\n        const P = this.clone();\r\n        for (let i = 1; i < nb; i++) {\r\n            this.multiply(P);\r\n        }\r\n        return this.reduce();\r\n    };\r\n\r\n    // ------------------------------------------\r\n    /**\r\n     * Compare the current coefficient with another coefficient\r\n     * @param P\r\n     * @param sign (string| default is =): authorized values: =, <, <=, >, >= with some variations.\r\n     */\r\n    compare = (P: Polynom, sign?: string): boolean => {\r\n        if (sign === undefined) {\r\n            sign = '='\r\n        }\r\n\r\n        // Create clone version to reduce them without altering the original polynoms.\r\n        const cP1 = this.clone().reduce().reorder();\r\n        const cP2 = P.clone().reduce().reorder();\r\n\r\n        switch (sign) {\r\n            case '=':\r\n                // They must have the isSame length and the isSame degree\r\n                if (cP1.length !== cP2.length || cP1.degree().isNotEqual(cP2.degree())) {\r\n                    return false;\r\n                }\r\n\r\n                // Check if the coefficients are the isSame.\r\n                for (const i in cP1.monoms) {\r\n                    if (!cP1.monoms[i].isEqual(cP2.monoms[i])) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            case 'same':\r\n                // They must have the isSame length and the isSame degree\r\n                if (cP1.length !== cP2.length || cP1.degree() !== cP2.degree()) {\r\n                    return false;\r\n                }\r\n\r\n                for (const i in cP1.monoms) {\r\n                    if (!cP1.monoms[i].isSameAs(cP2.monoms[i])) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n\r\n    isZero(): boolean {\r\n        return (this._monoms.length === 1 && this._monoms[0].coefficient.isZero()) || this._monoms.length === 0;\r\n    }\r\n\r\n    isOne(): boolean {\r\n        return this._monoms.length === 1 && this._monoms[0].coefficient.isOne();\r\n    }\r\n\r\n    isEqual = (P: Polynom): boolean => {\r\n        return this.compare(P, '=');\r\n    };\r\n\r\n    isSameAs = (P: Polynom): boolean => {\r\n        return this.compare(P, 'same');\r\n    };\r\n\r\n    isOpposedAt = (P: Polynom): boolean => {\r\n        return this.compare(P.clone().opposed(), '=');\r\n    };\r\n\r\n    isFactorized = (polynomString: string): boolean => {\r\n        let P;\r\n\r\n        // Check if polynom is complete...\r\n        if (polynomString.match(/\\(/g).length !== polynomString.match(/\\)/g).length) {\r\n            return false\r\n        }\r\n\r\n        // Try to build the polynom\r\n        try {\r\n            P = new Polynom(polynomString);\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n\r\n        // Both polynom aren't the same (once developed and reduced => they cannot be equivalent)\r\n        if (!this.isEqual(P)) {\r\n            return false;\r\n        }\r\n\r\n        // Check if the provided (string) version is fully factorized.\r\n        // Run a regex on the string.\r\n        let polynomStringNormalized = polynomString.replaceAll('*', ''),\r\n            polynomStringReduced = '' + polynomStringNormalized,\r\n            factors: string[] = [];\r\n\r\n        for (let x of polynomStringNormalized.matchAll(/\\(([a-z0-9+\\-]+)\\)(\\^[0-9]*)?/g)) {\r\n            if (x[2] !== undefined) {\r\n                for (let i = 0; i < +x[2].substr(1); i++) {\r\n                    factors.push(x[1])\r\n                }\r\n            } else {\r\n                factors.push(x[1]);\r\n            }\r\n            polynomStringReduced = polynomStringReduced.replaceAll(x[0], '');\r\n        }\r\n        if (polynomStringReduced !== '') {\r\n            factors.push(polynomStringReduced);\r\n        }\r\n        let polyFactors = factors.map(x => new Polynom(x));\r\n\r\n        // Factorize the current polynom.\r\n        this.factorize();\r\n\r\n        // Compare the given factors with the generated factors\r\n        let sign = 1;\r\n        for (let f of this.factors) {\r\n            for (let i = 0; i < polyFactors.length; i++) {\r\n                if (f.isEqual(polyFactors[i])) {\r\n                    polyFactors.splice(i, 1);\r\n                    break;\r\n                } else if (f.isOpposedAt(polyFactors[i])) {\r\n                    polyFactors.splice(i, 1);\r\n                    sign = -sign;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // The polyfactors must be empty and the cumulative opposite factors must be 1.\r\n        return (polyFactors.length === 0 && sign === 1);\r\n    }\r\n\r\n    isDeveloped = (polynomString: string): Boolean => {\r\n        let P: Polynom;\r\n\r\n        // There is at least one parenthese - it is not developed.\r\n        if (polynomString.match(/\\(/g).length + polynomString.match(/\\)/g).length) {\r\n            return false\r\n        }\r\n\r\n        // Try to build the polynom\r\n        try {\r\n            // Build the polynom\r\n            P = new Polynom(polynomString);\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n\r\n        // Both polynom aren't the same (once developed and reduced => they cannot be equivalent)\r\n        if (!this.isEqual(P)) {\r\n            return false;\r\n        }\r\n\r\n        // Check that everything is completely developed. Actually, there are no parentheses... so it is fully developed\r\n\r\n        // maybe it wasn't reduced and not ordered...\r\n        // compare polynom string.\r\n\r\n        // normalize the string\r\n        let polynomStringNormalized = polynomString.replaceAll('[*\\s]', '')\r\n\r\n        // Determine if it's the exact same string.\r\n        // TODO: Maybe it's enough to just make this test !\r\n        return polynomStringNormalized === P.reduce().reorder().display\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n\r\n    // -------------------------------------\r\n    reduce = (): Polynom => {\r\n        for (let i = 0; i < this._monoms.length; i++) {\r\n            for (let j = i + 1; j < this._monoms.length; j++) {\r\n                if (this._monoms[i].isSameAs(this.monoms[j])) {\r\n                    this._monoms[i].add(this.monoms[j]);\r\n                    this._monoms.splice(j, 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Remove all null monoms\r\n        this._monoms = this._monoms.filter((m) => {\r\n            return m.coefficient.value !== 0\r\n        });\r\n\r\n        // Reduce all monoms coefficient.\r\n        for (const m of this._monoms) {\r\n            m.coefficient.reduce();\r\n        }\r\n\r\n        if (this.length === 0) {\r\n            return new Polynom().zero();\r\n        }\r\n        return this;\r\n    };\r\n\r\n    reorder = (letter: string = 'x'): Polynom => {\r\n        // TODO: Must handle multiple setLetter reorder system\r\n        this._monoms.sort(function (a, b) {\r\n            return b.degree(letter).clone().subtract(a.degree(letter)).value\r\n        });\r\n        return this.reduce();\r\n    };\r\n\r\n    degree = (letter?: string): Fraction => {\r\n        let d: Fraction = new Fraction().zero();\r\n        for (const m of this._monoms) {\r\n            d = Fraction.max(m.degree(letter).value, d);\r\n        }\r\n        return d;\r\n    };\r\n\r\n    letters = (): string[] => {\r\n        let L: string[] = [], S = new Set();\r\n\r\n        for (let m of this._monoms) {\r\n            S = new Set([...S, ...m.variables]);\r\n        }\r\n\r\n        // @ts-ignore\r\n        return [...S];\r\n    }\r\n\r\n    /**\r\n     * Replace a variable (letter) by a polynom.\r\n     * @param letter\r\n     * @param P\r\n     */\r\n    replaceBy = (letter: string, P: Polynom): Polynom => {\r\n        let pow: Fraction;\r\n        const resultPolynom: Polynom = new Polynom().zero();\r\n\r\n        for (const m of this.monoms) {\r\n            if (m.literal[letter] === undefined || m.literal[letter].isZero()) {\r\n                resultPolynom.add(m.clone());\r\n            } else {\r\n                // We have found a setLetter.\r\n                // Get the power and reset it.\r\n                pow = m.literal[letter].clone();\r\n                delete m.literal[letter];\r\n\r\n                // TODO: replaceBy works only with positive and natural pow\r\n                resultPolynom.add(P.clone().pow(Math.abs(pow.numerator)).multiply(m));\r\n            }\r\n        }\r\n\r\n        this._monoms = resultPolynom.reduce().reorder().monoms;\r\n        return this;\r\n    };\r\n\r\n    // Evaluate a polynom.\r\n    evaluate = (values: literalType | Fraction | number): Fraction => {\r\n        const r = new Fraction().zero();\r\n\r\n        this._monoms.forEach(monom => {\r\n            //console.log('Evaluate polynom: ', monom.display, values, monom.evaluate(values).display);\r\n            r.add(monom.evaluate(values));\r\n        });\r\n\r\n        return r;\r\n    };\r\n\r\n    derivative = (letter?: string): Polynom => {\r\n        let dP = new Polynom();\r\n\r\n        for (let m of this._monoms) {\r\n            dP.add(m.derivative(letter));\r\n        }\r\n        return dP;\r\n\r\n    }\r\n\r\n    primitive = (letter?: string): Polynom => {\r\n        let dP = new Polynom();\r\n\r\n        for (let m of this._monoms) {\r\n            dP.add(m.primitive(letter))\r\n        }\r\n        return dP\r\n    }\r\n    // ------------------------------------------\r\n    // Misc polynoms functions\r\n\r\n    integrate = (a: Fraction | number, b: Fraction | number, letter?: string): Fraction => {\r\n        const primitive = this.primitive(letter)\r\n\r\n        if (letter === undefined) {\r\n            letter = 'x'\r\n        }\r\n\r\n        let valuesA: literalType = {},\r\n            valuesB: literalType = {}\r\n        valuesA[letter] = new Fraction(a);\r\n        valuesB[letter] = new Fraction(b);\r\n\r\n        return primitive.evaluate(valuesB).subtract(primitive.evaluate(valuesA))\r\n    }\r\n\r\n    // -------------------------------------\r\n    /**\r\n     * Factorize a polynom and store the best results in factors.\r\n     * @param maxValue Defines the greatest value to search to (default is 20).\r\n     */\r\n    factorize = (letter?: string): Polynom[] => {\r\n        let factors: Polynom[] = [];\r\n\r\n        // Extract the common monom\r\n        let P = this.clone().reorder(),\r\n            M = P.commonMonom(),\r\n            tempPolynom: Polynom\r\n\r\n        // It has a common monom.\r\n        if (!M.isOne()) {\r\n            tempPolynom = new Polynom()\r\n            tempPolynom.monoms = [M]\r\n            factors = [tempPolynom.clone()]\r\n            P = P.euclidian(tempPolynom).quotient;\r\n        }\r\n\r\n        let securityLoop = P.degree().clone().multiply(2).value\r\n        let result\r\n        // securityLoop = 0\r\n\r\n        while (securityLoop >= 0) {\r\n            securityLoop--\r\n\r\n            if (P.monoms.length < 2) {\r\n                if (!P.isOne()) {\r\n                    factors.push(P.clone());\r\n                }\r\n                break;\r\n            } else {\r\n                // Get the first and last monom.\r\n                let m1 = P.monoms[0].dividers,\r\n                    m2 = P.monoms[P.monoms.length - 1].dividers\r\n\r\n                for (let m1d of m1) {\r\n                    for (let m2d of m2) {\r\n                        // if(m1d.degree()===m2d.degree()){continue}\r\n                        let dividerPolynom = new Polynom()\r\n\r\n                        dividerPolynom.monoms = [m1d.clone(), m2d.clone()]\r\n                        result = P.euclidian(dividerPolynom)\r\n\r\n                        if (result.reminder.isZero()) {\r\n                            P = result.quotient.clone();\r\n                            factors.push(dividerPolynom)\r\n                            continue;\r\n                        }\r\n\r\n                        dividerPolynom.monoms = [m1d.clone(), m2d.clone().opposed()]\r\n                        result = P.euclidian(dividerPolynom)\r\n                        if (result.reminder.isZero()) {\r\n                            P = result.quotient.clone();\r\n                            factors.push(dividerPolynom)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(!P.isOne()){factors.push(P.clone())}\r\n\r\n        this.factors = factors\r\n        return factors;\r\n    }\r\n\r\n    // TODO: get zeroes for more than first degree and for more than natural degrees\r\n    getZeroes = (): ISolution[] => {\r\n        let equ = new Equation(this.clone(), 0)\r\n        equ.solve()\r\n        return equ.solutions\r\n\r\n        //\r\n        // const Z: Fraction[] = [];\r\n        //\r\n        // // ISolution: {tex: string, value: number, exact: boolean|Fraction|...}\r\n        //\r\n        // switch (this.degree().value) {\r\n        //     case 0:\r\n        //         if (this._monoms[0].coefficient.value === 0) {\r\n        //             return [{\r\n        //                 tex: '\\\\mathbb{R}',\r\n        //                 value: NaN,\r\n        //                 exact: false\r\n        //             }];\r\n        //         } else {\r\n        //             return [{\r\n        //                 tex: '\\\\varnothing',\r\n        //                 value: NaN,\r\n        //                 exact: false\r\n        //             }];\r\n        //         }\r\n        //     case 1:\r\n        //         // There is only one monoms,\r\n        //         if (this._monoms.length === 1) {\r\n        //             return [{\r\n        //                 tex: '0',\r\n        //                 value: 0,\r\n        //                 exact: new Fraction().zero()\r\n        //             }];\r\n        //         } else {\r\n        //             const P = this.clone().reduce().reorder();\r\n        //             const coeff = P.monoms[1].coefficient.opposed().divide(P.monoms[0].coefficient)\r\n        //             return [{\r\n        //                 tex: coeff.tex,\r\n        //                 value: coeff.value,\r\n        //                 exact: coeff\r\n        //             }];\r\n        //         }\r\n        //     // TODO: Determine the zeros of an equation of second degree.\r\n        //     //case 2:\r\n        //     default:\r\n        //         // Make sure the polynom is factorized.\r\n        //         if (this._factors.length === 0) {\r\n        //             this.factorize()\r\n        //         }\r\n        //\r\n        //         let zeroes:Fraction[] = [], zeroesAsTex = [];\r\n        //         for (let P of this._factors) {\r\n        //             if (P.degree().greater(2)) {\r\n        //                 // TODO: get zeroes of polynom with a degree greater than 2.\r\n        //\r\n        //             } else if (P.degree().value === 2) {\r\n        //                 let A = P.monomByDegree(2).coefficient,\r\n        //                     B = P.monomByDegree(1).coefficient,\r\n        //                     C = P.monomByDegree(0).coefficient,\r\n        //                     D = B.clone().pow(2).subtract(A.clone().multiply(C).multiply(4));\r\n        //\r\n        //                 if (D.value > 0) {\r\n        //                     /*console.log('Two zeroes for ', P.tex); */\r\n        //                     let x1 = (-(B.value) + Math.sqrt(D.value)) / (2 * A.value),\r\n        //                         x2 = (-(B.value) - Math.sqrt(D.value)) / (2 * A.value);\r\n        //\r\n        //                     zeroes.push(new Fraction(x1.toFixed(3)).reduce());\r\n        //                     zeroes.push(new Fraction(x2.toFixed(3)).reduce());\r\n        //                 } else if (D.value === 0) {\r\n        //                     /*console.log('One zero for ', P.tex); */\r\n        //                 } else {\r\n        //                     console.log('No zero for ', P.tex);\r\n        //                 }\r\n        //             } else {\r\n        //                 for (let z of P.getZeroes()) {\r\n        //                     // Check if the zero is already in the list.\r\n        //                     // if (z === false || z === true) {\r\n        //                     //     continue;\r\n        //                     // }\r\n        //                     if (zeroesAsTex.indexOf(z.frac) === -1) {\r\n        //                         zeroes.push(z);\r\n        //                         zeroesAsTex.push(z.frac);\r\n        //                     }\r\n        //                 }\r\n        //             }\r\n        //         }\r\n        //\r\n        //\r\n        //         return zeroes;\r\n        // }\r\n        // return Z;\r\n    };\r\n\r\n    // TODO: analyse the next functions to determine if they are useful or not...\r\n    monomByDegree = (degree?: Fraction | number, letter?: string): Monom => {\r\n        if (degree === undefined) {\r\n            // return the highest degree monom.\r\n            return this.monomByDegree(this.degree(letter), letter);\r\n        }\r\n\r\n        // Reduce the polynom.\r\n        const M = this.clone().reduce();\r\n        for (const m of M._monoms) {\r\n            if (m.degree(letter).isEqual(degree)) {\r\n                return m.clone();\r\n            }\r\n        }\r\n\r\n        // Nothing was found - return the null monom.\r\n        return new Monom().zero();\r\n    };\r\n\r\n    monomsByDegree = (degree?: number | Fraction, letter?: string): Monom[] => {\r\n        if (degree === undefined) {\r\n            // return the highest degree monom.\r\n            return this.monomsByDegree(this.degree(letter));\r\n        }\r\n\r\n        // Reduce the polynom.\r\n        let Ms: Monom[] = [];\r\n\r\n        const M = this.clone().reduce();\r\n        for (const m of M._monoms) {\r\n            if (m.degree(letter) === degree) {\r\n                Ms.push(m.clone())\r\n            }\r\n        }\r\n\r\n        return Ms\r\n        // Nothing was found - retur\r\n    }\r\n\r\n    // Used in LinearSystem.tex\r\n    monomByLetter = (letter: string): Monom => {\r\n        const M = this.clone().reduce();\r\n        for (const m of M._monoms) {\r\n            if (m.hasLetter(letter)) {\r\n                return m.clone();\r\n            }\r\n        }\r\n\r\n        return new Monom().zero();\r\n    };\r\n\r\n    // Next functions are used for for commonMonom, which is used in the factorize method.\r\n    getDenominators = (): number[] => {\r\n        const denominators: number[] = [];\r\n        for (const m of this._monoms) {\r\n            denominators.push(m.coefficient.denominator);\r\n        }\r\n        return denominators;\r\n    };\r\n\r\n    getNumerators = (): number[] => {\r\n        const numerators: number[] = [];\r\n        for (const m of this._monoms) {\r\n            numerators.push(m.coefficient.numerator);\r\n        }\r\n        return numerators;\r\n    };\r\n\r\n    lcmDenominator = (): number => {\r\n        return Numeric.lcm(...this.getDenominators());\r\n    };\r\n    // ------------------------------------------\r\n    // Polynoms factorization functions\r\n\r\n    gcdDenominator = (): number => {\r\n        return Numeric.gcd(...this.getDenominators());\r\n    };\r\n\r\n    lcmNumerator = (): number => {\r\n        return Numeric.lcm(...this.getNumerators());\r\n    };\r\n\r\n    gcdNumerator = (): number => {\r\n        return Numeric.gcd(...this.getNumerators());\r\n    };\r\n    // ------------------------------------------\r\n    // Polynoms helpers functions\r\n    // -------------------------------------\r\n\r\n    commonMonom = (): Monom => {\r\n        let M = new Monom().one(), numerator: number, denominator: number, degree = this.degree();\r\n\r\n        numerator = this.gcdNumerator();\r\n        denominator = this.gcdDenominator();\r\n\r\n        M.coefficient = new Fraction(numerator, denominator);\r\n        for (let L of this.variables) {\r\n            // Initialize the setLetter with the max degree\r\n            M.setLetter(L, degree);\r\n            for (let m of this._monoms) {\r\n                M.setLetter(L, Fraction.min(m.degree(L), M.degree(L)));\r\n                if (M.degree(L).isZero()) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return M;\r\n    }\r\n\r\n    limitToInfinity = (letter?: string): Fraction => {\r\n        const M = this.monomByDegree(undefined, letter),\r\n            sign = M.coefficient.sign(),\r\n            degree = M.degree(letter)\r\n\r\n        if (degree.isStrictlyPositive()) {\r\n            return sign === 1 ? (new Fraction()).infinite() : (new Fraction()).infinite().opposed()\r\n        } else if (degree.isZero()) {\r\n            return M.coefficient\r\n        }\r\n\r\n        // Any other cases\r\n        return (new Fraction()).zero()\r\n    }\r\n    limitToNegativeInfinity = (letter?: string): Fraction => {\r\n        const M = this.monomByDegree(undefined, letter),\r\n            sign = M.coefficient.sign(),\r\n            degree = M.degree(letter)\r\n\r\n        if (degree.isStrictlyPositive()) {\r\n            return sign === -1 ? (new Fraction()).infinite() : (new Fraction()).infinite().opposed()\r\n        } else if (degree.isZero()) {\r\n            return M.coefficient\r\n        }\r\n\r\n        // Any other cases\r\n        return (new Fraction()).zero()\r\n    }\r\n    private _parseString(inputStr: string, ...values: unknown[]): Polynom {\r\n        if (values === undefined || values.length === 0) {\r\n            inputStr = '' + inputStr;\r\n            this._rawString = inputStr;\r\n\r\n            // Parse the polynom using the shutting yard algorithm\r\n            if (inputStr !== '' && !isNaN(Number(inputStr))) {\r\n                this.empty();\r\n                // It's a simple number.\r\n                let m = new Monom(inputStr);\r\n                // m.coefficient = new Fraction(inputStr);\r\n                // m.literalStr = '';\r\n                this.add(m);\r\n                return this;\r\n            }\r\n\r\n            // Parse the string.\r\n            return this.shutingYardToReducedPolynom(inputStr);\r\n        } else if (/^[a-z]/.test(inputStr)) {\r\n            // We assume the inputStr contains only letters.\r\n            this.empty();\r\n\r\n            let fractions = values.map(x => new Fraction(x));\r\n            // Multiple setLetter version\r\n            if (inputStr.length > 1) {\r\n                // TODO: check that the number of values given correspond to the letters (+1 eventually)\r\n                let letters = inputStr.split(''),\r\n                    i = 0;\r\n                for (let F of fractions) {\r\n                    let m = new Monom();\r\n                    m.coefficient = F.clone();\r\n                    m.literalStr = letters[i] || '';\r\n                    this.add(m);\r\n                    i++;\r\n                }\r\n            }\r\n            // Single setLetter version\r\n            else {\r\n                let n = fractions.length - 1;\r\n                for (let F of fractions) {\r\n                    let m = new Monom()\r\n                    m.coefficient = F.clone();\r\n                    m.literalStr = `${inputStr}^${n}`\r\n                    this.add(m);\r\n                    n--;\r\n                }\r\n            }\r\n            return this;\r\n        } else {\r\n            return this.zero();\r\n        }\r\n    }\r\n\r\n    private genDisplay = (output?: string, forceSign?: boolean, wrapParentheses?: boolean): string => {\r\n        let P: string = '';\r\n\r\n        for (const k of this._monoms) {\r\n            if (k.coefficient.value === 0) {\r\n                continue;\r\n            }\r\n\r\n            P += `${(k.coefficient.sign() === 1 && (P !== '' || forceSign === true)) ? '+' : ''}${(output === 'tex') ? k.tex : k.display}`;\r\n        }\r\n\r\n        if (wrapParentheses === true && this.length > 1) {\r\n            if (output === 'tex') {\r\n                P = `\\\\left( ${P} \\\\right)`;\r\n            } else {\r\n                P = `(${P})`;\r\n            }\r\n        }\r\n\r\n        if (P === '') {\r\n            P = '0';\r\n        }\r\n        return P;\r\n    };\r\n\r\n    /**\r\n     * Main parse using a shutting yard class\r\n     * @param inputStr\r\n     */\r\n    private shutingYardToReducedPolynom = (inputStr: string): Polynom => {\r\n        // Get the RPN array of the current expression\r\n        const SY: Shutingyard = new Shutingyard().parse(inputStr);\r\n        const rpn: { token: string, tokenType: string }[] = SY.rpn;\r\n\r\n        // New version for reducing shuting yard.\r\n        this.zero()\r\n\r\n        let stack: Polynom[] = [],\r\n            monom: Monom = new Monom()\r\n\r\n        // Loop through the\r\n        for (const element of rpn) {\r\n            Polynom.addToken(stack, element);\r\n        }\r\n\r\n        if (stack.length === 1) {\r\n            this.add(stack[0])\r\n        }\r\n\r\n        return this\r\n        /**\r\n         let m1: Polynom;\r\n         let m2: Polynom;\r\n\r\n         let stack: Polynom[] = [],\r\n         previousToken: string = null,\r\n         tempPolynom\r\n\r\n         for (const element of rpn) {\r\n            if (element.tokenType === 'coefficient' || element.tokenType === 'variable') {\r\n                tempPolynom = new Polynom().zero();\r\n                tempPolynom.monoms = [new Monom(element.token)]\r\n                stack.push(tempPolynom.clone())\r\n            } else if (element.tokenType === 'operation') {\r\n                m2 = (stack.pop()) || new Polynom().zero();\r\n                m1 = (stack.pop()) || new Polynom().zero();\r\n                switch (element.token) {\r\n                    case '+':\r\n                        stack.push(m1.add(m2))\r\n                        break;\r\n                    case '-':\r\n                        stack.push(m1.subtract(m2))\r\n                        break;\r\n                    case '*':\r\n                        stack.push(m1.multiply(m2))\r\n                        break;\r\n                    case '^':\r\n                        stack.push(m1.pow(+previousToken))\r\n                }\r\n            }\r\n            previousToken = element.token;\r\n        }\r\n\r\n         this._monoms = stack[0].monoms;\r\n         return this;*/\r\n    }\r\n\r\n    private multiplyByPolynom = (P: Polynom): Polynom => {\r\n        const M: Monom[] = [];\r\n        for (const m1 of this._monoms) {\r\n            for (const m2 of P.monoms) {\r\n                M.push(Monom.xmultiply(m1, m2));\r\n            }\r\n        }\r\n\r\n        this._monoms = M;\r\n        return this.reduce();\r\n    };\r\n\r\n    private multiplyByFraction = (F: Fraction): Polynom => {\r\n        for (const m of this._monoms) {\r\n            m.coefficient.multiply(F);\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    private multiplyByInteger = (nb: number): Polynom => {\r\n        return this.multiplyByFraction(new Fraction(nb));\r\n    };\r\n\r\n    private multiplyByMonom = (M: Monom): Polynom => {\r\n        for (const m of this._monoms) {\r\n            m.multiply(M)\r\n        }\r\n        return this.reduce();\r\n    };\r\n\r\n    private divideByInteger = (nb: number): Polynom => {\r\n        const nbF = new Fraction(nb);\r\n        for (const m of this._monoms) {\r\n            m.coefficient.divide(nbF);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    private divideByFraction = (F: Fraction): Polynom => {\r\n        for (const m of this._monoms) {\r\n            m.coefficient.divide(F);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    private _factorize2ndDegree = (letter: string): Polynom[] => {\r\n        let P1: Polynom, P2: Polynom,\r\n            a, b, c, delta, x1, x2, factor;\r\n\r\n        // One variable only\r\n        if (this.numberOfVars === 1) {\r\n            a = this.monomByDegree(2, letter).coefficient;\r\n            b = this.monomByDegree(1, letter).coefficient;\r\n            c = this.monomByDegree(0, letter).coefficient;\r\n            delta = b.clone().pow(2).subtract(a.clone().multiply(c).multiply(4));\r\n\r\n            if (delta.isZero()) {\r\n                x1 = b.clone().opposed().divide(a.clone().multiply(2))\r\n                P1 = new Polynom(letter).subtract(x1.display).multiply(x1.denominator)\r\n                P2 = new Polynom(letter).subtract(x1.display).multiply(x1.denominator)\r\n                factor = a.divide(x1.denominator).divide(x1.denominator);\r\n\r\n                if (!factor.isOne()) {\r\n                    // TODO: Update new Polynom to accept anything...\r\n                    return [new Polynom(factor.display), P1, P2]\r\n                } else {\r\n                    return [P1, P2]\r\n                }\r\n            } else if (delta.isPositive() && delta.isSquare()) {\r\n                x1 = b.clone().opposed()\r\n                    .add(delta.clone().sqrt())\r\n                    .divide(a.clone().multiply(2))\r\n                x2 = b.clone().opposed()\r\n                    .subtract(delta.clone().sqrt())\r\n                    .divide(a.clone().multiply(2))\r\n\r\n                // (2x+5)(3x-2)\r\n                // 6x^2+11x-10\r\n                // a = 6, b = 11, c = -10\r\n                // delta = 121-4*6*(-10) = 361= 19^2\r\n                // x1 = (-11 + 19)  / 12 = 8/12 = 2/3\r\n                // x2 = (-11 - 19)  / 12 = -30/12 = -5/2\r\n                factor = a.divide(x1.denominator).divide(x2.denominator);\r\n                if (factor.isOne()) {\r\n                    return [\r\n                        new Polynom(letter).subtract(x1.display).multiply(x1.denominator),\r\n                        new Polynom(letter).subtract(x2.display).multiply(x2.denominator),\r\n                    ]\r\n                } else {\r\n                    return [\r\n                        new Polynom(factor.display),\r\n                        new Polynom(letter).subtract(x1.display).multiply(x1.denominator),\r\n                        new Polynom(letter).subtract(x2.display).multiply(x2.denominator),\r\n                    ]\r\n\r\n                }\r\n            } else {\r\n                // No solution possible - return the complete value.\r\n                return [this.clone()]\r\n            }\r\n        } else {\r\n            // If multiple variables, only handle perfect squares...\r\n            a = this.monomByDegree(2, letter);\r\n            b = this.monomByDegree(1, letter);\r\n            c = this.monomByDegree(0, letter);\r\n\r\n\r\n            if (a.isLiteralSquare() && c.isLiteralSquare()) {\r\n                // Check the middle item is same as...\r\n                if (b.clone().pow(2).isSameAs(a.clone().multiply(c))) {\r\n                    // Determine if the coefficient values matches.\r\n\r\n                    // Search 4 values (r, s, t, u) that matches:\r\n                    // (r X + s Y)(t X + u Y) = rt X^2 + (ru + st) XY + su Y^2\r\n\r\n                    let xPolynom = new Polynom('x', a.coefficient, b.coefficient, c.coefficient);\r\n                    let xFactors = xPolynom._factorize2ndDegree('x');\r\n\r\n                    let factors = [], xyzPolynom: Polynom;\r\n\r\n                    if (xFactors.length >= 2) {\r\n                        for (let p of xFactors) {\r\n                            if (p.degree().isZero()) {\r\n                                factors.push(p.clone())\r\n                            } else {\r\n                                xyzPolynom = p.clone();\r\n                                xyzPolynom.monoms[0].literal = a.literalSqrt\r\n                                xyzPolynom.monoms[1].literal = c.literalSqrt\r\n                                factors.push(xyzPolynom.clone())\r\n                            }\r\n                        }\r\n                        return factors\r\n                    }\r\n                }\r\n            }\r\n\r\n            return [this.clone()]\r\n            //\r\n            // console.log(a.tex, b.tex, c.tex)\r\n            // if (a.isSquare() && c.isSquare()) {\r\n            //     console.log('A C squares')\r\n            //     if (a.clone().sqrt().multiply(c.clone().sqrt()).multiplyByNumber(2).isSameAs(b)) {\r\n            //         console.log('HERE')\r\n            //         if (a.coefficient.sign() === b.coefficient.sign()) {\r\n            //             return []\r\n            //         }else{\r\n            //             return []\r\n            //         }\r\n            //     }\r\n            // } else if(a.isLiteralSquare() && c.isLiteralSquare()) {\r\n            //     console.log('A C litteral SQUARES')\r\n            //     // Check that the middle element is the product of a and c.\r\n            //\r\n            //     if(b.clone().pow(2).isSameAs(a.clone().multiply(c))){\r\n            //         console.log('SAME')\r\n            //\r\n            //     }else{\r\n            //         console.log('NOT SAME')\r\n            //     }\r\n            //\r\n            //     return [this.clone()]\r\n            // } else {\r\n            //     console.log('NOT SQUARES AT ALL !!!!')\r\n            // }\r\n\r\n        }\r\n    }\r\n\r\n    private _factorizeByGroups = (): Polynom[] => {\r\n        // TODO: Factorize by groups.\r\n        return [];\r\n    }\r\n}\r\n","/**\r\n * Rational polynom module contains everything necessary to handle rational polynoms.\r\n * @module Polynom\r\n */\r\n\r\nimport {Polynom} from \"./polynom\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {literalType} from \"./monom\";\r\nimport {Equation, ISolution, PARTICULAR_SOLUTION} from \"./equation\";\r\n\r\n/**\r\n * Rational class can handle rational polynoms\r\n */\r\nexport class Rational {\r\n    private _rawString: string;\r\n\r\n    /**\r\n     *\r\n     * @param numerator\r\n     * @param denominator\r\n     */\r\n    constructor(numerator?: Polynom, denominator?: Polynom) {\r\n        this._numerator = numerator ? numerator.clone() : new Polynom();\r\n        this._denominator = denominator ? denominator.clone() : new Polynom();\r\n    }\r\n\r\n    private _numerator: Polynom;\r\n\r\n    get numerator(): Polynom {\r\n        return this._numerator\r\n    }\r\n\r\n    private _denominator: Polynom;\r\n\r\n    get denominator(): Polynom {\r\n        return this._denominator\r\n    }\r\n\r\n    get tex(): string {\r\n        return `\\\\dfrac{ ${this._numerator.tex} }{ ${this._denominator.tex} }`;\r\n    }\r\n\r\n    get texFactors(): string {\r\n        return `\\\\dfrac{ ${this._numerator.texFactors} }{ ${this._denominator.texFactors} }`\r\n    }\r\n\r\n    clone = (): Rational => {\r\n        this._numerator = this._numerator.clone()\r\n        this._denominator = this._denominator.clone()\r\n\r\n        return this;\r\n    }\r\n\r\n    domain = (): string => {\r\n        let zeroes = this._denominator.getZeroes();\r\n        if (zeroes.length === 0 || zeroes[0].tex === PARTICULAR_SOLUTION.real) {\r\n            return PARTICULAR_SOLUTION.real\r\n        } else if (zeroes[0].tex === PARTICULAR_SOLUTION.varnothing) {\r\n            return PARTICULAR_SOLUTION.varnothing\r\n        } else {\r\n            return '\\\\mathbb{R}\\\\setminus\\\\left{' +\r\n                zeroes.map(x => x.tex).join(';') + '\\\\right}'\r\n        }\r\n    }\r\n\r\n    amplify = (P: Polynom): Rational => {\r\n        this._numerator.multiply(P);\r\n        this._denominator.multiply(P);\r\n\r\n        return this;\r\n    }\r\n\r\n    derivative = (letter?: string): Rational => {\r\n        let N = this._numerator.clone(),\r\n            D = this._denominator.clone(),\r\n            dN = N.clone().derivative(letter),\r\n            dD = D.clone().derivative(letter)\r\n\r\n        this._numerator = dN.clone().multiply(D).subtract(N.clone().multiply(dD))\r\n        this._denominator = D.clone().pow(2)\r\n\r\n        return this\r\n    }\r\n\r\n    simplify = (P: Polynom): Rational => {\r\n        let NumeratorEuclidien = this._numerator.euclidian(P);\r\n        if (!NumeratorEuclidien.reminder.isZero()) {\r\n            return this;\r\n        }\r\n\r\n        let DenominatorEuclidien = this._denominator.euclidian(P);\r\n        if (!DenominatorEuclidien.reminder.isZero()) {\r\n            return this;\r\n        }\r\n\r\n        this._numerator = NumeratorEuclidien.quotient;\r\n        this._denominator = DenominatorEuclidien.quotient;\r\n        return this;\r\n    }\r\n\r\n    reduce = (): Rational => {\r\n        this._numerator.factorize();\r\n        for (let f of this._numerator.factors) {\r\n            this.simplify(f);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    opposed = (): Rational => {\r\n        this._numerator.opposed();\r\n        return this;\r\n    }\r\n    add = (R: Rational): Rational => {\r\n        // 1. Make sure both rational are at the same denominator\r\n        // 2. Add the numerators.\r\n        // 3. Simplify\r\n\r\n        // Store the adding denominator\r\n        let denominator = this._denominator.clone()\r\n\r\n        // Amplif the main rational polynom by the adding denominator\r\n        this.amplify(R._denominator)\r\n\r\n        // Add to the numerator the adding value...\r\n        this._numerator.add(R._numerator.clone().multiply(denominator));\r\n\r\n        return this;\r\n    }\r\n\r\n    subtract = (R: Rational): Rational => {\r\n        return this.add(R.clone().opposed())\r\n    }\r\n\r\n    limits = (value: Fraction | number, offset?: string, letter?: string): Fraction => {\r\n        if (value === Infinity || value === -Infinity) {\r\n            let {quotient, reminder} = this._numerator.clone().euclidian(this._denominator)\r\n\r\n            // quotient is positive => it will be infinite.\r\n            if (quotient.degree(letter).isStrictlyPositive()) {\r\n                return value === Infinity ? quotient.limitToInfinity(letter) : quotient.limitToNegativeInfinity(letter)\r\n                // return quotient.monomByDegree(undefined, letter).coefficient.sign()===1?(new Fraction()).infinite():(new Fraction()).infinite().opposed()\r\n            } else {\r\n                return quotient.monomByDegree(undefined, letter).coefficient\r\n            }\r\n        } else {\r\n            let evalValues: literalType = {},\r\n                evalValuesOffset: literalType = {},\r\n                theLimit: Fraction | number,\r\n                theSign: number,\r\n                FR = this.clone().reduce()\r\n\r\n            evalValues[letter === undefined ? 'x' : letter] = new Fraction(value)\r\n\r\n            if (offset !== 'above' && offset !== 'below') {\r\n                theLimit = FR._numerator.evaluate(evalValues)\r\n                    .divide(FR._denominator.evaluate(evalValues))\r\n\r\n                return theLimit.isInfinity() ? theLimit.abs() : theLimit\r\n            } else {\r\n                if (offset === 'above') {\r\n                    evalValuesOffset[letter === undefined ? 'x' : letter] = (new Fraction(value)).add(0.000001)\r\n                } else if (offset === 'below') {\r\n                    evalValuesOffset[letter === undefined ? 'x' : letter] = (new Fraction(value)).subtract(0.000001)\r\n                }\r\n\r\n                theLimit = FR._numerator.evaluate(evalValues)\r\n                    .divide(FR._denominator.evaluate(evalValues))\r\n                theSign = FR._numerator.evaluate(evalValuesOffset)\r\n                    .divide(FR._denominator.evaluate(evalValuesOffset)).sign()\r\n\r\n                if (theLimit.isInfinity()) {\r\n                    return theSign === 1 ? theLimit.abs() : theLimit.abs().opposed()\r\n                } else {\r\n                    return theLimit\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    makeTableOfSigns = (): { factors: Polynom[], zeroes: ISolution[], signs: (string[])[], tex: string } => {\r\n        // Factorize the numerator and the denominator\r\n        this._numerator.factorize()\r\n        this._denominator.factorize()\r\n\r\n        let zeroes = Equation.makeSolutionsUnique([...this._numerator.getZeroes(), ...this._denominator.getZeroes()], true),\r\n            NFactors = this._numerator.factors,\r\n            DFactors = this._denominator.factors\r\n\r\n        let tableOfSigns: (string[])[] = [],\r\n            result: string[] = []\r\n\r\n        NFactors.forEach(factor => {\r\n            tableOfSigns.push(this._makeOneLineOfTableOfSigns(factor, zeroes, 'z'))\r\n        })\r\n        DFactors.forEach(factor => {\r\n            tableOfSigns.push(this._makeOneLineOfTableOfSigns(factor, zeroes, 'd'))\r\n        })\r\n\r\n        // Empty line\r\n        tableOfSigns.push([])\r\n\r\n        // Add the final row as cumulative\r\n        let resultLine: string[] = tableOfSigns[0].map((x, index) => {\r\n            if (index === 0) {\r\n                return ''\r\n            }\r\n            if (index === tableOfSigns[0].length - 1) {\r\n                return ''\r\n            }\r\n            if (index % 2 === 0) {\r\n                return 't'\r\n            }\r\n            return '+'\r\n        })\r\n\r\n        for (let current of tableOfSigns) {\r\n            for (let i = 0; i < current.length; i++) {\r\n                if (i % 2 === 0) {\r\n                    // t, z or d\r\n                    if (resultLine[i] === 'd') {\r\n                        continue\r\n                    }\r\n                    if (current[i] !== 't') {\r\n                        resultLine[i] = current[i]\r\n                    }\r\n                } else {\r\n                    // + or -\r\n                    if (current[i] === '-') {\r\n                        resultLine[i] = resultLine[i] === '+' ? '-' : '+'\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Add the variation line.\r\n        // TODO: add the variation line.\r\n\r\n        tableOfSigns.push(resultLine)\r\n\r\n        let tos = {\r\n            factors: [...NFactors, ...DFactors],\r\n            zeroes: zeroes,\r\n            signs: tableOfSigns,\r\n            tex: ''\r\n        }\r\n\r\n        this._makeTexFromTableOfSigns(tos)\r\n\r\n        return tos\r\n    }\r\n\r\n    private _makeTexFromTableOfSigns = (tos: { factors: Polynom[], zeroes: ISolution[], signs: (string[])[], tex: string }): string => {\r\n\r\n        let tex = `\\\\begin{tikzpicture}\r\n\\\\tkzTabInit[lgt=3,espcl=2,deltacl=0]{/1.2,\\\\(${tos.factors.map(x => x.tex).join('\\\\)/1,\\\\(')}\\\\)/1,/.1,\\\\(f(x)\\\\)/1.2}{{\\\\scriptsize \\\\hspace{1cm} \\\\(-\\\\infty\\\\)},\\\\(${tos.zeroes.map(x => x.tex).join('\\\\),\\\\(')}\\\\),{\\\\scriptsize \\\\hspace{-1cm} \\\\(+\\\\infty\\\\)}}`\r\n        tos.signs.forEach(list => {\r\n            tex += (`\\n\\\\tkzTabLine{${list.join(',')}}`)\r\n        })\r\n        tex += `\\n\\\\end{tikzpicture}`\r\n\r\n        tos.tex = tex\r\n\r\n        return tex\r\n    }\r\n    private _makeOneLineOfTableOfSigns = (factor: Polynom, zeroes: ISolution[], zeroSign: string): string[] => {\r\n        let oneLine: string[] = [],\r\n            // TODO : check if there is no zero ?\r\n            currentZero = factor.getZeroes().map(x=>x.tex)\r\n\r\n        // First +/- sign, before the first zero\r\n        oneLine.push('')\r\n        oneLine.push(factor.evaluate(zeroes[0].value - 1).sign() === 1 ? '+' : '-')\r\n\r\n        for (let i = 0; i < zeroes.length; i++) {\r\n            // Add the zero if it's the current one\r\n            oneLine.push(currentZero.includes(zeroes[i].tex) ? zeroSign : 't')\r\n\r\n            // + / - sign after the current zero\r\n            if (i < zeroes.length - 1) {\r\n                oneLine.push(factor.evaluate((zeroes[i].value + zeroes[i + 1].value) / 2).sign() === 1 ? '+' : '-')\r\n            } else if (i === zeroes.length - 1) {\r\n                oneLine.push(factor.evaluate(zeroes[i].value + 1).sign() === 1 ? '+' : '-')\r\n            }\r\n\r\n        }\r\n        oneLine.push('')\r\n\r\n        return oneLine\r\n    }\r\n}\r\n","import {Numeric} from \"../numeric\";\r\n\r\nexport type FractionParsingType = number|string|Fraction\r\n/**\r\n * The fraction class make possible to handle\r\n * TODO: Write the documentation correctly.\r\n * \\\\(\\frac{a}{b}\\\\) or \\\\[\\frac{a}{b}\\\\]  values.\r\n */\r\nexport class Fraction {\r\n    private _numerator: number;\r\n    private _denominator: number;\r\n\r\n    constructor(value?: unknown, denominatorOrPeriodic?: number) {\r\n        this._numerator = 1;\r\n        this._denominator = 1;\r\n\r\n        if (value !== undefined) {\r\n            this.parse(value, denominatorOrPeriodic);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n\r\n    get numerator(): number {\r\n        return this._numerator;\r\n    }\r\n\r\n    set numerator(value: number) {\r\n        this._numerator = value;\r\n    }\r\n\r\n    get denominator(): number {\r\n        return this._denominator;\r\n    }\r\n\r\n    set denominator(value: number) {\r\n        this._denominator = value;\r\n    }\r\n\r\n    get value(): number {\r\n        return this._numerator / this._denominator;\r\n    }\r\n\r\n    // Display getter\r\n    get tex(): string {\r\n        if(this.isInfinity()){\r\n            return `${this.sign()===1?'+':'-'}\\\\infty`\r\n        }\r\n\r\n        if (this._denominator === 1) {\r\n            return `${this._numerator}`;\r\n        } else if (this._numerator < 0) {\r\n            return `-\\\\frac{ ${-this._numerator} }{ ${this._denominator} }`;\r\n        } else {\r\n            return `\\\\frac{ ${this._numerator} }{ ${this._denominator} }`;\r\n        }\r\n    }\r\n\r\n    get display(): string {\r\n        if (this._denominator === 1) {\r\n            return `${this._numerator}`;\r\n        } else {\r\n            return `${this._numerator}/${this._denominator}`;\r\n        }\r\n    }\r\n\r\n    // Helper function to display fractions\r\n    get frac(): string {\r\n        return this.tex;\r\n    }\r\n\r\n    get dfrac(): string {\r\n        return this.tex.replace('\\\\frac', '\\\\dfrac');\r\n    }\r\n    get tfrac(): string {\r\n        return this.tex.replace('\\\\frac', '\\\\tfrac')\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse the value to get the numerator and denominator\r\n     * @param value : number or string to parse to get the fraction\r\n     * @param denominatorOrPeriodic (optional|number) : length of the periodic part: 2.333333 => 1 or denominator value\r\n     */\r\n    parse = (value: unknown, denominatorOrPeriodic?: number): Fraction => {\r\n        let S: string[];\r\n\r\n        // A null value means a zero fraction.\r\n        if (value === null || value === \"\") {\r\n            this._numerator = 0;\r\n            this._denominator = 1;\r\n            return this;\r\n        }\r\n\r\n        switch (typeof value) {\r\n            case \"string\":\r\n                // Split the sting value in two parts: Numerator/Denominator\r\n                S = value.split('/');\r\n\r\n                // Security checks\r\n                if (S.length > 2) throw \"Two many divide signs\";\r\n                if (S.map(x => x === '' || isNaN(Number(x))).includes(true)) throw \"Not a number\"\r\n\r\n\r\n                if (S.length === 1) {\r\n                    // No divide sign\r\n                    return this.parse(+S[0]);\r\n                } else if (S.length === 2) {\r\n                    // One divide signe\r\n                    // We check if the denominator is zero\r\n                    if (S[1] === '0') {\r\n                        this._numerator = NaN;\r\n                        this._denominator = 1;\r\n                    } else {\r\n                        this._numerator = +S[0];\r\n                        this._denominator = +S[1];\r\n                    }\r\n                } else {\r\n                    // More than one divide sign ?\r\n                    this._numerator = NaN;\r\n                    this._denominator = 1;\r\n                }\r\n                break;\r\n            case \"number\":\r\n                if (Number.isSafeInteger(value)) {\r\n                    // The given value is an integer\r\n                    this._numerator = +value;\r\n\r\n                    if (denominatorOrPeriodic === undefined || !Number.isSafeInteger(denominatorOrPeriodic)) {\r\n                        this._denominator = 1;\r\n                    } else {\r\n                        this._denominator = +denominatorOrPeriodic;\r\n                    }\r\n                } else {\r\n                    // The given value is a float number\r\n\r\n                    // Get the number of decimals after the float sign\r\n                    let p: number = (value.toString()).split('.')[1].length;\r\n\r\n                    // Transform the float number in two integer\r\n                    if (denominatorOrPeriodic === undefined) {\r\n                        this._numerator = value * Math.pow(10, p);\r\n                        this._denominator = Math.pow(10, p);\r\n                    } else if (Number.isSafeInteger(denominatorOrPeriodic)) {\r\n                        this._numerator = value * Math.pow(10, p) - Math.floor(value * Math.pow(10, p - denominatorOrPeriodic));\r\n                        this.denominator = Math.pow(10, p) - Math.pow(10, p - denominatorOrPeriodic)\r\n                    }\r\n                    this.reduce()\r\n                }\r\n                break;\r\n            case \"object\":\r\n                if (value instanceof Fraction) {\r\n                    this._numerator = +value.numerator;\r\n                    this._denominator = +value.denominator;\r\n                }\r\n                break;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    clone = (): Fraction => {\r\n        let F = new Fraction();\r\n        F.numerator = +this._numerator;\r\n        F.denominator = +this._denominator;\r\n        return F;\r\n    };\r\n\r\n    zero = (): Fraction => {\r\n        this._numerator = 0;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    one = (): Fraction => {\r\n        this._numerator = 1;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    infinite = (): Fraction => {\r\n        this._numerator = Infinity;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    invalid = (): Fraction => {\r\n        this._numerator = NaN;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    opposed = (): Fraction => {\r\n        this._numerator = -this._numerator;\r\n        return this;\r\n    };\r\n\r\n    add = (F: Fraction | number): Fraction => {\r\n        if (F instanceof Fraction) {\r\n            let N: number = this._numerator,\r\n                D: number = this._denominator;\r\n\r\n            this._numerator = N * F.denominator + F.numerator * D;\r\n            this._denominator = D * F.denominator;\r\n        } else {\r\n            return this.add(new Fraction(F))\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    subtract = (F: Fraction | number): Fraction => {\r\n        if (F instanceof Fraction) {\r\n            return this.add(F.clone().opposed());\r\n        } else {\r\n            return this.add(-F)\r\n        }\r\n    };\r\n\r\n    multiply = (F: Fraction | number): Fraction => {\r\n        // Parse the value.\r\n        // If it's a fraction, return a clone of it\r\n        // If it's an integer, return the fraction F/1\r\n        let Q = new Fraction(F);\r\n\r\n        this._numerator = this._numerator * Q.numerator;\r\n        this._denominator = this._denominator * Q.denominator;\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    divide = (F: Fraction | number): Fraction => {\r\n        let Q = new Fraction(F);\r\n\r\n        if (Q.numerator === 0) {\r\n            return new Fraction().infinite();\r\n        }\r\n\r\n        let N: number = +this._numerator,\r\n            D: number = +this._denominator;\r\n\r\n        this._numerator = N * Q.denominator;\r\n        this._denominator = D * Q.numerator;\r\n        return this.reduce();\r\n    };\r\n\r\n    invert = (): Fraction => {\r\n        let n = +this._numerator, d = +this._denominator;\r\n        this._numerator = d;\r\n        this._denominator = n;\r\n\r\n        return this;\r\n    }\r\n    pow = (p: number | Fraction): Fraction => {\r\n        // TODO: Fraction.pow with a value different than a safe integer !\r\n        if (p instanceof Fraction) {\r\n            return this.pow(p.value)\r\n        }\r\n\r\n        this.reduce();\r\n        if (p < 0) {\r\n            this.invert()\r\n        }\r\n\r\n        // Check if numerator and denominator are roots of...\r\n        // othervise, convert to numeric.\r\n        let controlNumerator = Math.floor(Math.pow(this._numerator, Math.abs(p))),\r\n            controlDenominator = Math.floor(Math.pow(this._denominator, Math.abs(p)))\r\n\r\n        if(controlNumerator ** Math.abs(p) === this._numerator\r\n            &&\r\n            controlDenominator ** Math.abs(p) === this._denominator){\r\n\r\n            this._numerator = this._numerator ** Math.abs(p);\r\n            this._denominator = this._denominator ** Math.abs(p);\r\n        }else{\r\n            this._numerator = this._numerator ** Math.abs(p);\r\n            this._denominator = this._denominator ** Math.abs(p);\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    root = (p: number): Fraction => {\r\n        // TODO: nth - root of a fraction => this will return another type of coefficient.\r\n\r\n        // Check if they are perfect roots..\r\n        if (p === 0) {\r\n            return this;\r\n        }\r\n\r\n        // If negative, invert the fraction\r\n        if (p < 0) {\r\n            this.invert()\r\n        }\r\n\r\n        let n = Math.pow(this._numerator, Math.abs(1 / p)),\r\n            d = Math.pow(this._denominator, Math.abs(1 / p));\r\n\r\n        this._numerator = Math.pow(this._numerator, Math.abs(1 / p));\r\n        this._denominator = Math.pow(this._denominator, Math.abs(1 / p));\r\n        return this;\r\n    }\r\n\r\n    sqrt = (): Fraction => {\r\n        return this.root(2);\r\n    }\r\n\r\n    abs = (): Fraction => {\r\n        this._numerator = Math.abs(this._numerator);\r\n        this._denominator = Math.abs(this._denominator);\r\n        return this;\r\n    };\r\n\r\n\r\n    static max = (...fractions: (Fraction | number)[]): Fraction => {\r\n        let M = new Fraction(fractions[0])\r\n\r\n        for (let m of fractions) {\r\n            let compare = new Fraction(m)\r\n            if (compare.greater(M)) {\r\n                M = compare.clone()\r\n            }\r\n        }\r\n\r\n        return M\r\n    }\r\n    static min = (...fractions: (Fraction | number)[]): Fraction => {\r\n        let M = new Fraction(fractions[0])\r\n\r\n        for (let m of fractions) {\r\n            let compare = new Fraction(m)\r\n            if (compare.lesser(M)) {\r\n                M = compare.clone()\r\n            }\r\n        }\r\n\r\n        return M\r\n    }\r\n\r\n    static average = (...fractions: (Fraction|number)[]): Fraction => {\r\n        let M = new Fraction().zero()\r\n\r\n        for(let f of fractions){\r\n            M.add(f)\r\n        }\r\n\r\n        M.divide(fractions.length)\r\n\r\n        return M\r\n    }\r\n\r\n    static unique = (fractions: Fraction[], sorted?: boolean): Fraction[] => {\r\n        // TODO: make sure it's wokring -> test !\r\n        let unique:{[Key:string]:boolean} = {},\r\n            distinct: Fraction[] = []\r\n        fractions.forEach(x => {\r\n            if(!unique[x.clone().reduce().tex]){\r\n                distinct.push(x.clone())\r\n                unique[x.tex]=true\r\n            }\r\n        })\r\n\r\n        if(sorted) {\r\n            return Fraction.sort(distinct)\r\n        }else{\r\n            return distinct\r\n        }\r\n    }\r\n    static sort = (fractions: Fraction[], reverse?:boolean): Fraction[] => {\r\n        // Todo make sure it's the correct order, not reverse -> make a test\r\n        let sorted = fractions.sort((a, b)=>a.value-b.value)\r\n\r\n        if(reverse){sorted.reverse()}\r\n\r\n        return sorted\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations specific to fractions\r\n    // ------------------------------------------\r\n    reduce = (): Fraction => {\r\n        let g = Numeric.gcd(this._numerator, this._denominator);\r\n        this._numerator = this._numerator / g;\r\n        this._denominator = this._denominator / g;\r\n\r\n        if (this._denominator < 0) {\r\n            this._denominator = -this._denominator;\r\n            this._numerator = -this._numerator;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    amplify = (k: number): Fraction => {\r\n        if (Number.isSafeInteger(k)) {\r\n            this._numerator *= k;\r\n            this._denominator *= k;\r\n        }\r\n        return this;\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Compare the current coefficient with another coefficient\r\n     * @param F (Coefficient) The coefficient to compare\r\n     * @param sign (string| default is =): authorized values: =, <, <=, >, >= with some variations.\r\n     */\r\n    compare = (F: unknown, sign?: string): boolean => {\r\n        if (sign === undefined) {\r\n            sign = '=';\r\n        }\r\n\r\n        let compareFraction: Fraction\r\n        if (F instanceof Fraction) {\r\n            compareFraction = F.clone()\r\n        } else {\r\n            compareFraction = new Fraction(F)\r\n        }\r\n\r\n        switch (sign) {\r\n            case '>':\r\n                return this.value > compareFraction.value;\r\n            case \">=\" || \"=>\" || \"geq\":\r\n                return this.value >= compareFraction.value;\r\n            case \"<\":\r\n                return this.value < compareFraction.value;\r\n            case \"<=\" || \"=>\" || \"leq\":\r\n                return this.value <= compareFraction.value;\r\n            case \"=\":\r\n                // let F2: Fraction = compareFraction.clone().reduce(),\r\n                //     F1: Fraction = this.clone().reduce();\r\n                // return (F1.numerator === F2.numerator && F1.denominator === F2.denominator);\r\n                return this.value === compareFraction.value;\r\n            case \"<>\":\r\n                return this.value !== compareFraction.value;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /* Compare shortcuts */\r\n    lesser = (than: Fraction | number): Boolean => {\r\n        return this.compare(than, '<');\r\n    };\r\n    leq = (than: Fraction | number): Boolean => {\r\n        return this.compare(than, '<=');\r\n    };\r\n    greater = (than: Fraction | number): Boolean => {\r\n        return this.compare(than, '>');\r\n    };\r\n    geq = (than: Fraction | number): Boolean => {\r\n        return this.compare(than, '>=');\r\n    };\r\n    isEqual = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '=');\r\n    }\r\n    isNotEqual = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '<>');\r\n    }\r\n    isOpposed = (p: Fraction): boolean => {\r\n        return this.isEqual(p.clone().opposed());\r\n    }\r\n    isInverted = (p: Fraction): boolean => {\r\n        return this.isEqual(new Fraction().one().divide(p.clone()));\r\n    }\r\n    isZero = (): boolean => {\r\n        return this._numerator === 0;\r\n    }\r\n    isNotZero = (): boolean => {\r\n        return this._numerator !== 0;\r\n    }\r\n    isOne = (): boolean => {\r\n        return this._numerator === 1 && this._denominator === 1;\r\n    }\r\n    isNegativeOne = (): boolean => {\r\n        return this._numerator === -1 && this._denominator === 1;\r\n    }\r\n    isPositive = (): boolean => {\r\n        return this.sign() === 1;\r\n    }\r\n    isNegative = (): boolean => {\r\n        return this.sign() === -1;\r\n    }\r\n    isStrictlyPositive = (): boolean => {\r\n        return this.value > 0\r\n    }\r\n    isStrictlyNegative = (): Boolean => {\r\n        return this.value < 0\r\n    }\r\n    isNaN = (): boolean => {\r\n        return isNaN(this._numerator);\r\n    }\r\n    isInfinity = (): boolean => {\r\n        return Math.abs(this._numerator) === Infinity;\r\n    }\r\n    isFinite = (): boolean => {\r\n        return !this.isInfinity() && !this.isNaN();\r\n    }\r\n    isSquare = (): boolean => {\r\n        return Math.sqrt(this._numerator) % 1 === 0 && Math.sqrt(this._denominator) % 1 === 0\r\n    }\r\n    isReduced = (): boolean => {\r\n        return Math.abs(Numeric.gcd(this._numerator, this._denominator)) === 1\r\n    }\r\n    isNatural = (): boolean => {\r\n        return this.isRelative() && this.isPositive()\r\n    }\r\n    isRelative = (): boolean => {\r\n        return this.clone().reduce().denominator === 1\r\n    }\r\n    isRational = (): boolean => {\r\n        return !this.isRelative()\r\n    }\r\n    isEven = (): boolean => {\r\n        return this.isRelative() && this.value % 2 === 0\r\n    }\r\n    isOdd = (): boolean => {\r\n        return this.isRelative() && this.value % 2 === 1\r\n    }\r\n    sign = (): number => {\r\n        return (this._numerator * this._denominator >= 0) ? 1 : -1;\r\n    };\r\n\r\n\r\n    // TODO: The rest of the functions are not used or unnecessary ?\r\n    /**\r\n     * Simple function to determine if it's a fraction\r\n     */\r\n    areEquals = (...F: Fraction[]): boolean => {\r\n        for (let i = 0; i < F.length; i++) {\r\n            if (!this.isEqual(F[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n}","/**\r\n * NthRoot is something like \"a+b\\sqrt{3}\r\n */\r\nexport class NthRoot {\r\n    private _radical: number;\r\n    private _nth: number;\r\n    private _coefficient: number;\r\n    private _isValid:boolean;\r\n\r\n    constructor(...values: number[]) {\r\n        this._radical = 1;\r\n        this._coefficient = 1;\r\n        this._nth = 2;\r\n        this._isValid = true;\r\n\r\n        if(values !== undefined){\r\n            this.parse(values[0], values[1], values[2])\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get radical(): number {\r\n        return this._radical;\r\n    }\r\n\r\n    set radical(value: number) {\r\n        this._radical = value;\r\n    }\r\n\r\n    get nth(): number {\r\n        return this._nth;\r\n    }\r\n\r\n    set nth(value: number) {\r\n        if (Number.isSafeInteger(value) && value >= 2) {\r\n            this._nth = value;\r\n        } else {\r\n            // Error setting the nth root.\r\n            console.log('Error setting the nth root');\r\n            this._nth = 2;\r\n        }\r\n    }\r\n\r\n    get coefficient(): number {\r\n        return this._coefficient;\r\n    }\r\n\r\n    set coefficient(value: number) {\r\n        this._coefficient = value;\r\n    }\r\n\r\n    get tex(): string {\r\n        let C: string;\r\n\r\n        if (this._coefficient === 1) {\r\n            C = '';\r\n        } else if (this._coefficient === -1) {\r\n            C = '-';\r\n        } else {\r\n            C = this._coefficient.toString();\r\n        }\r\n\r\n        if (this._radical === 1) {\r\n            return `${this._coefficient}`;\r\n        } else {\r\n            if (this._nth === 2) {\r\n                return `${C}\\\\sqrt{${this._radical}}`\r\n            } else {\r\n                return `${C}\\\\sqrt[${this._nth}]{${this._radical}}`\r\n            }\r\n        }\r\n    }\r\n\r\n    get value(): number {\r\n        return this._coefficient * Math.pow(this._radical, 1 / this._nth);\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (radical: number, nthroot?: number, coefficient?: number): NthRoot => {\r\n        this._coefficient = (coefficient === undefined) ? 1 : coefficient;\r\n        this._nth = (nthroot === undefined) ? 2 : nthroot;\r\n        this._radical = (radical === undefined) ? 1 : radical;\r\n\r\n        if(this._nth%2===0 && this._radical<0){\r\n            this._isValid = false;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    reduce = (): NthRoot => {\r\n        // Max value to test.\r\n        let V = Math.floor(Math.pow(this._radical, 1 / this._nth));\r\n        while (V > 1) {\r\n            if (this._radical % Math.pow(V, this._nth) === 0) {\r\n                // It's dividable by V^n\r\n                this._coefficient *= V;\r\n                this._radical = this._radical / Math.pow(V, this._nth);\r\n\r\n                // Redifine the new testing value (this is optimization)\r\n                V = Math.floor(Math.pow(this._radical, 1 / this._nth));\r\n                continue;\r\n            }\r\n            V--;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    multiply = (N: NthRoot): NthRoot => {\r\n        this._radical *= N.radical;\r\n        return this.reduce();\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Help functions\r\n    // ------------------------------------------\r\n    hasRadical = ():boolean => {\r\n        return !(this._radical===1 || this._radical===0 || this._isValid===false)\r\n    };\r\n}","import {Shutingyard, ShutingyardMode, ShutingyardType, tokenConstant} from \"../shutingyard\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\nexport class NumExp {\r\n    private _rpn: { token: string, tokenType: string }[]\r\n    private _expression: string\r\n    private _isValid: boolean\r\n\r\n    constructor(value: string) {\r\n        this._expression = value\r\n        this._rpn = new Shutingyard(ShutingyardMode.NUMERIC).parse(value).rpn\r\n    }\r\n\r\n    get rpn(): { token: string; tokenType: string }[] {\r\n        return this._rpn;\r\n    }\r\n\r\n    get isValid(): boolean {\r\n        if(this._isValid===undefined){\r\n            this.evaluate({x: 0})\r\n        }\r\n        return this._isValid\r\n    }\r\n\r\n    set isValid(value: boolean){\r\n        this._isValid = value\r\n    }\r\n\r\n    get expression(): string {\r\n        return this._expression;\r\n    }\r\n\r\n    private _extractDecimalPart(value: number): string {\r\n        let decimal = value.toString()\r\n\r\n        if (!decimal.includes('.')) {\r\n            return ''\r\n        }\r\n\r\n        decimal = decimal.split('.')[1]\r\n\r\n        return decimal.substring(0, decimal.length - 2)\r\n    }\r\n\r\n    private _numberCorrection(value: number): number {\r\n        // Must modify the number if it's like:\r\n        // a: 3.0000000000000003\r\n        // b: 3.9999999999999994\r\n        // remove the last character\r\n        // check if around n last characters are either 0 or 9\r\n        // if it is, 'round' the number.\r\n\r\n        const epsilon = 0.00000000000001,\r\n            number_of_digits = 6\r\n\r\n        const decimal = this._extractDecimalPart(value)\r\n        if(decimal===''){return value}\r\n\r\n        const n9 = decimal.match(/9+$/g)\r\n        const n0 = decimal.match(/0+$/g)\r\n\r\n        if (n9 && n9[0].length >= number_of_digits) {\r\n            // New tested values.\r\n            const mod = this._extractDecimalPart(value + epsilon),\r\n                mod0 = mod.match(/0+$/g)\r\n\r\n            if(mod0 && mod0[0].length>= number_of_digits){\r\n                // The value can be changed. Remove all zeros!\r\n                return +((value+epsilon).toString().split(mod0[0])[0])\r\n            }\r\n        }\r\n\r\n        if (n0 && n0[0].length >= number_of_digits) {\r\n            // New tested values.\r\n            const mod = this._extractDecimalPart(value - epsilon),\r\n                mod9 = mod.match(/9+$/g)\r\n\r\n            if(mod9 && mod9[0].length>= number_of_digits){\r\n                // The value can be changed. Remove all nines!\r\n                return +(value.toString().split(n0[0])[0])\r\n            }\r\n        }\r\n\r\n        return value\r\n    }\r\n\r\n    private _addToStack(stack:number[], value: number): void {\r\n        stack.push(this._numberCorrection(value))\r\n    }\r\n\r\n    evaluate(values: { [Key: string]: number }): number {\r\n        const stack: number[] = []\r\n\r\n        this.isValid = true\r\n\r\n        for (const element of this._rpn) {\r\n            if (element.tokenType === ShutingyardType.COEFFICIENT) {\r\n                // May be a numeric value or a Fraction.\r\n                if (!isNaN(+element.token)) {\r\n                    this._addToStack(stack, +element.token)\r\n                } else {\r\n                    this._addToStack(stack, new Fraction(element.token).value)\r\n                }\r\n            } else if (element.tokenType === ShutingyardType.VARIABLE) {\r\n                if (values[element.token] !== undefined) {\r\n                    this._addToStack(stack, +values[element.token])\r\n                }\r\n            } else if (element.tokenType === ShutingyardType.CONSTANT) {\r\n                this._addToStack(stack, tokenConstant[element.token])\r\n            } else if (element.tokenType === ShutingyardType.OPERATION) {\r\n                if (element.token === '*') {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop()\r\n                    if(a === undefined || b === undefined){this.isValid = false}\r\n                    this._addToStack(stack, a * b)\r\n                } else if (element.token === '/') {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop()\r\n                    if(a === undefined || b === undefined){this.isValid = false}\r\n                    this._addToStack(stack, a / b)\r\n                } else if (element.token === '+') {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop()\r\n                    if(a === undefined || b === undefined){this.isValid = false}\r\n                    this._addToStack(stack, (+a) + (+b))\r\n                } else if (element.token === '-') {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop() || 0\r\n                    if(b === undefined){this.isValid = false}\r\n                    this._addToStack(stack, a - b)\r\n                } else if (element.token === '^') {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop()\r\n                    if(a === undefined || b === undefined){this.isValid = false}\r\n                    this._addToStack(stack, Math.pow(a, b))\r\n                }\r\n            } else if (element.tokenType === ShutingyardType.FUNCTION) {\r\n                const a = stack.pop()\r\n                if(a === undefined){this.isValid = false}\r\n                if (element.token === 'sin') {\r\n                    this._addToStack(stack, Math.sin(a))\r\n                } else if (element.token === 'cos') {\r\n                    this._addToStack(stack, Math.cos(a))\r\n                } else if (element.token === 'tan') {\r\n                    this._addToStack(stack, Math.tan(a))\r\n                } else if(element.token === 'sqrt') {\r\n                    this._addToStack(stack, Math.sqrt(a))\r\n                }\r\n            }\r\n        }\r\n\r\n        if (stack.length === 1) {\r\n            return stack[0]\r\n        } else {\r\n            throw `There was a problem parsing: ${this._expression}`\r\n        }\r\n    }\r\n}\r\n","import {Polynom, PolynomParsingType} from \"../algebra/polynom\";\r\nimport {Fraction, FractionParsingType} from \"../coefficients/fraction\";\r\n\r\ntype PolynomExpMathFunctionType = { name: string; fn: Function, tex: string }\r\n\r\nexport class PolynomExpFactor {\r\n    constructor(polynom: PolynomParsingType, degree?: FractionParsingType, mathFunction?: PolynomExpMathFunctionType) {\r\n        this._polynom = new Polynom(polynom)\r\n        this._degree = new Fraction(degree === undefined ? 1 : degree)\r\n        this._fn = mathFunction\r\n        this._powerAsInteger = true\r\n        this._forceParenthesis = true\r\n    }\r\n\r\n    private _forceParenthesis: boolean\r\n\r\n    get forceParenthesis(): boolean {\r\n        return this._forceParenthesis;\r\n    }\r\n\r\n    set forceParenthesis(value: boolean) {\r\n        this._forceParenthesis = value;\r\n    }\r\n\r\n    private _fn: PolynomExpMathFunctionType\r\n\r\n    get fn(): PolynomExpMathFunctionType {\r\n        return this._fn;\r\n    }\r\n\r\n    set fn(value: PolynomExpMathFunctionType) {\r\n        this._fn = value;\r\n    }\r\n\r\n    private _powerAsInteger: boolean\r\n\r\n    get powerAsInteger(): boolean {\r\n        return this._powerAsInteger;\r\n    }\r\n\r\n    set powerAsInteger(value: boolean) {\r\n        this._powerAsInteger = value;\r\n    }\r\n\r\n    private _polynom: Polynom\r\n\r\n    get polynom(): Polynom {\r\n        return this._polynom;\r\n    }\r\n\r\n    set polynom(value: Polynom) {\r\n        this._polynom = value;\r\n    }\r\n\r\n    private _degree: Fraction\r\n\r\n    get degree(): Fraction {\r\n        return this._degree;\r\n    }\r\n\r\n    set degree(value: Fraction) {\r\n        this._degree = value;\r\n    }\r\n\r\n    get tex(): string {\r\n        let tex\r\n\r\n        if (this._degree.isOne() && (this._fn !== undefined || !this._forceParenthesis)) {\r\n            // If degree is one, no need to add the parenthesis.\r\n            tex = this._polynom.tex\r\n        } else {\r\n            // the degree is not one, add the parenthesis.\r\n            if (this._powerAsInteger && !this._degree.isRelative()) {\r\n                // the degree is a fraction and we want natural powers => use sqrt.\r\n                tex = `\\\\sqrt${this._degree.denominator !== 2 ? `[ ${this._degree.denominator} ]` : ''}{ ${this._polynom.tex} }^{ ${this._degree.numerator} }`\r\n            } else if (this.isCoefficient && this.firstCoefficient.isNatural()) {\r\n                // the value is a natural number (eg 3, 7, ...)\r\n                tex = this._polynom.tex + this._texDegree\r\n            } else {\r\n                // In any other case, add the parenthesis by default\r\n                tex = `\\\\left( ${this._polynom.tex} \\\\right)${this._texDegree}`\r\n            }\r\n        }\r\n\r\n        if (this._fn !== undefined && this._fn.tex !== undefined) {\r\n            tex = `${this._fn.tex}\\\\left( ${tex} \\\\right)`\r\n        }\r\n        return tex\r\n    }\r\n\r\n    get isCoefficient(): boolean {\r\n        // TODO: Maybe reduce the coefficient if it isn't of degree one.\r\n        return this._polynom.degree().isZero();\r\n\r\n    }\r\n\r\n    get firstCoefficient(): Fraction {\r\n        return this._polynom.monomByDegree().coefficient\r\n    }\r\n\r\n    private get _texDegree(): string {\r\n        if (this._degree.isOne()) {\r\n            return ''\r\n        } else {\r\n            return `^{ ${this._degree.tfrac} }`\r\n        }\r\n    }\r\n\r\n    setForceParenthesis(value?: boolean): PolynomExpFactor {\r\n        this._forceParenthesis = value === undefined || value\r\n        return this\r\n    }\r\n\r\n    derivative(letter?: string): PolynomExpProduct {\r\n        if (this._degree.isOne()) {\r\n            return new PolynomExpProduct(\r\n                new PolynomExpFactor(this._polynom.clone().derivative(letter))\r\n            )\r\n        } else {\r\n            return new PolynomExpProduct(\r\n                new PolynomExpFactor(this._degree.clone()),\r\n                new PolynomExpFactor(this._polynom.clone().derivative(letter)),\r\n                new PolynomExpFactor(this._polynom.clone(), this._degree.clone().subtract(1))\r\n            )\r\n        }\r\n    }\r\n}\r\n\r\nexport class PolynomExpProduct {\r\n    constructor(...values: PolynomExpFactor[]) {\r\n        this._factors = values || []\r\n        this._positive = true\r\n        this._asPositiveDegree = true\r\n    }\r\n\r\n    private _fn: PolynomExpMathFunctionType\r\n\r\n    get fn(): PolynomExpMathFunctionType {\r\n        return this._fn;\r\n    }\r\n\r\n    set fn(value: PolynomExpMathFunctionType) {\r\n        this._fn = value;\r\n    }\r\n\r\n    private _factors: PolynomExpFactor[]\r\n\r\n    get factors(): PolynomExpFactor[] {\r\n        return this._factors;\r\n    }\r\n\r\n    set factors(value: PolynomExpFactor[]) {\r\n        this._factors = value;\r\n    }\r\n\r\n    private _positive: boolean\r\n\r\n    get positive(): boolean {\r\n        return this._positive;\r\n    }\r\n\r\n    set positive(value: boolean) {\r\n        this._positive = value;\r\n    }\r\n\r\n    private _asPositiveDegree: boolean\r\n\r\n    get asPositiveDegree(): boolean {\r\n        return this._asPositiveDegree;\r\n    }\r\n\r\n    set asPositiveDegree(value: boolean) {\r\n        this._asPositiveDegree = value;\r\n    }\r\n\r\n    get tex(): string {\r\n        let parenthesis = this._factors.length>1\r\n        // Default value\r\n        let tex = this._factors.map(factor => factor.setForceParenthesis(parenthesis).tex).join(' \\\\cdot ')\r\n\r\n        // Change the value in some cases...\r\n        if (this._asPositiveDegree) {\r\n            const numerators = this._factors.filter(x => x.degree.isPositive()),\r\n                denominators = this._factors.filter(x => x.degree.isNegative())\r\n\r\n            let numeratorsAsTex, denominatorsAsTex\r\n\r\n            if (denominators.length > 0) {\r\n                if (numerators.length === 0) {\r\n                    numeratorsAsTex = [1]\r\n                } else if (numerators.length === 1) {\r\n                    numeratorsAsTex = [numerators[0].setForceParenthesis(false).tex]\r\n                } else {\r\n                    parenthesis = numerators.length>1\r\n                    numeratorsAsTex = numerators.map(factor => factor.setForceParenthesis(parenthesis).tex)\r\n                }\r\n\r\n                // Change all denominators degrees to positive.\r\n                denominators.map(x => x.degree.opposed())\r\n                if (denominators.length === 1) {\r\n                    denominatorsAsTex = [denominators[0].setForceParenthesis(false).tex]\r\n                } else {\r\n                    parenthesis = denominators.length>1\r\n                    denominatorsAsTex = denominators.map(factor => factor.setForceParenthesis(parenthesis).tex)\r\n                }\r\n                // restore all degrees to negative again.\r\n                denominators.map(x => x.degree.opposed())\r\n\r\n                tex = `\\\\dfrac{ ${numeratorsAsTex.join(' \\\\cdot ')} }{ ${denominatorsAsTex.join(' \\\\cdot ')} }`\r\n            }\r\n        }\r\n\r\n        // Apply the modification\r\n        if (this._fn !== undefined && this._fn.name !== undefined && this._fn.name !== '') {\r\n            tex = `${this._fn.tex}\\\\left( ${tex} \\\\right)`\r\n        }\r\n        return tex\r\n    }\r\n\r\n    reduce(): PolynomExpProduct {\r\n        let coefficients = this._factors.filter(factor => factor.isCoefficient),\r\n            polynoms = this._factors.filter(factor => !factor.isCoefficient)\r\n\r\n        let result = new Fraction().one()\r\n\r\n        if (coefficients.length > 1) {\r\n            for (const factor of coefficients) {\r\n                if (factor.degree.isPositive()) {\r\n                    result.multiply(factor.polynom.monoms[0].coefficient.pow(factor.degree))\r\n                } else {\r\n                    result.divide(factor.polynom.monoms[0].coefficient.pow(factor.degree.clone().abs()))\r\n                }\r\n            }\r\n        } else if (coefficients.length === 1) {\r\n            result = coefficients[0].polynom.monoms[0].coefficient\r\n        }\r\n\r\n        if (result.isOne()) {\r\n            this._factors = [...polynoms]\r\n        } else if (!result.isRelative()) {\r\n            this._factors = [\r\n                new PolynomExpFactor(result.numerator),\r\n                new PolynomExpFactor(result.denominator, -1),\r\n                ...polynoms\r\n            ]\r\n        } else {\r\n            this._factors = [\r\n                new PolynomExpFactor(result),\r\n                ...polynoms\r\n            ]\r\n        }\r\n        return this\r\n    }\r\n\r\n    integrate(letter?: string): PolynomExpProduct {\r\n        // Handle this kind of case:\r\n        // A * f' * F^n\r\n        // A * f' / F^n, n != 1\r\n        // A * f_1 * f_2 * f_3, where (f_1 * f_2)' = f_3\r\n        if (this._factors.length === 2) {\r\n            // Check polynoms degree: one must of one degree less than the other.\r\n            let d1 = this._factors[0].polynom.degree(letter).value,\r\n                d2 = this._factors[1].polynom.degree(letter).value\r\n\r\n            if (d1 === d2 + 1) {\r\n                return this._integrateWithInternalDerivative(this._factors[0], this._factors[1], letter)\r\n            } else if (d1 + 1 === d2) {\r\n                return this._integrateWithInternalDerivative(this._factors[1], this._factors[0], letter)\r\n            }\r\n        }\r\n        return\r\n    }\r\n\r\n    public applyMathFunction(mathFn: PolynomExpMathFunctionType): PolynomExpProduct {\r\n        this._fn = mathFn\r\n        return this\r\n    }\r\n\r\n    private _integrateWithInternalDerivative(P: PolynomExpFactor, Pinternal: PolynomExpFactor, letter?: string): PolynomExpProduct {\r\n        // Get the internal derivative\r\n        let internalDerivative: Polynom = P.polynom.clone().derivative(letter)\r\n\r\n        // Get the factor.\r\n        let {quotient, reminder} = Pinternal.polynom.clone().euclidian(internalDerivative)\r\n\r\n        if (reminder.isZero() && quotient.degree(letter).isZero()) {\r\n            // All the conditions are done. Actual situation is\r\n            // (4x-10)(x^2-5x+7)^9\r\n            // P1 = (x^2-5x+7), P2 = (2x-5)\r\n            // => 1/10 * quotient * (x^2-5x+7)^10\r\n\r\n            if (P.degree.isEqual(-1)) {\r\n                return (new PolynomExpProduct(\r\n                    new PolynomExpFactor(quotient, 1),\r\n                    new PolynomExpFactor(P.polynom.clone(), 1, {\r\n                        name: 'ln', tex: '\\\\ln', fn: (x: number) => Math.log(x)\r\n                    })\r\n                ))\r\n            } else {\r\n                return new PolynomExpProduct(\r\n                    new PolynomExpFactor(P.degree.clone().add(1).invert(), 1),\r\n                    new PolynomExpFactor(quotient, 1),\r\n                    new PolynomExpFactor(P.polynom.clone(), P.degree.clone().add(1))\r\n                )\r\n            }\r\n        }\r\n        return\r\n    }\r\n}","import {Point} from \"./point\";\r\nimport {Line, LinePropriety} from \"./line\";\r\nimport {Vector} from \"./vector\";\r\nimport {Triangle} from \"./triangle\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Equation} from \"../algebra/equation\";\r\nimport {Polynom} from \"../algebra/polynom\";\r\nimport {Monom} from \"../algebra/monom\";\r\n\r\nexport class Circle {\r\n    constructor(...values: unknown[]) {\r\n        this._exists = false\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values)\r\n        }\r\n    }\r\n\r\n    private _center: Point;\r\n\r\n    get center(): Point {\r\n        return this._center;\r\n    }\r\n\r\n    private _squareRadius: Fraction;\r\n\r\n    get squareRadius(): Fraction {\r\n        return this._squareRadius\r\n    }\r\n\r\n    private _cartesian: Equation;\r\n\r\n    get cartesian(): Equation {\r\n        return this._cartesian\r\n    }\r\n\r\n    private _exists: boolean;\r\n\r\n    get exists(): boolean {\r\n        return this._exists;\r\n    }\r\n\r\n    get radius(): { tex: string, display: string, value: number } {\r\n        if (this._squareRadius.isSquare()) {\r\n            return {\r\n                tex: this._squareRadius.clone().sqrt().tex,\r\n                display: this._squareRadius.clone().sqrt().display,\r\n                value: this._squareRadius.clone().sqrt().value\r\n            }\r\n        } else {\r\n            return {\r\n                tex: `\\\\sqrt{${this._squareRadius.tex}}`,\r\n                display: `sqrt(${this._squareRadius.display})`,\r\n                value: this._squareRadius.clone().sqrt().value\r\n            }\r\n        }\r\n        return this._squareRadius\r\n    }\r\n\r\n    get tex(): string {\r\n\r\n        if (this._exists) {\r\n            let cx, cy\r\n            if (this._center.x.isZero()) {\r\n                cx = 'x^2'\r\n            } else {\r\n                cx = `\\\\left(x${this._center.x.isNegative() ? '+' : '-'}${this._center.x.clone().abs().tex}\\\\right)^2`\r\n            }\r\n            if (this._center.y.isZero()) {\r\n                cy = 'y^2'\r\n            } else {\r\n                cy = `\\\\left(y${this._center.y.isNegative() ? '+' : '-'}${this._center.y.clone().abs().tex}\\\\right)^2`\r\n            }\r\n            return `${cx}+${cy}=${this._squareRadius.tex}`\r\n        } else {\r\n            return `\\\\text{le cercle n'existe pas.}`\r\n        }\r\n    }\r\n\r\n    get developed(): string {\r\n        return this._cartesian.tex\r\n    }\r\n\r\n    // TODO: reformat code for better display.\r\n    get display(): string {\r\n        return this._cartesian.display\r\n    }\r\n\r\n    /**\r\n     * Get the relative position between circle and line. It corresponds to the number of intersection.\r\n     * @param {Line} L\r\n     * @returns {number}\r\n     */\r\n    relativePosition = (L: Line): number => {\r\n        let distance = L.distanceTo(this.center), radius = Math.sqrt(this._squareRadius.value)\r\n\r\n        if (distance.value - radius > 0.0000000001) {\r\n            return 0 // external\r\n        } else if (Math.abs(distance.value - radius) < 0.0000000001) {\r\n            return 1 // tangent\r\n        } else {\r\n            return 2 // external\r\n        }\r\n    }\r\n\r\n    lineIntersection = (L: Line): Point[] => {\r\n        let intersectionPoints: Point[] = [], solX: Fraction\r\n\r\n        if (this._cartesian === null) {\r\n            return []\r\n        }\r\n        const equX = this._cartesian.clone(), lineX = L.equation.clone().isolate('x'),\r\n            lineY = L.equation.clone().isolate('y')\r\n\r\n        if (lineX instanceof Equation && lineY instanceof Equation) {\r\n            equX.replaceBy('y', lineY.right).simplify()\r\n            equX.solve()\r\n\r\n            for (let x of equX.solutions) {\r\n                if (x.exact === false && isNaN(x.value)) {\r\n                    continue\r\n                }\r\n\r\n                solX = new Fraction(x.exact === false ? x.value : x.exact)\r\n                intersectionPoints.push(new Point(solX.clone(), lineY.right.evaluate(solX)))\r\n            }\r\n        }\r\n\r\n        return intersectionPoints\r\n    }\r\n\r\n    tangents = (P: Point | Fraction): Line[] => {\r\n        if (P instanceof Fraction) {\r\n            return this._tangentsWithSlope(P)\r\n        } else if (this.isPointOnCircle(P)) {\r\n            return this._tangentsThroughOnePointOnTheCircle(P)\r\n        } else if (this.center.distanceTo(P).value > this.radius.value) {\r\n            //TODO:  Must check it's outside the circle\r\n            return this._tangentsThroughOnePointOutsideTheCircle(P)\r\n        } else {\r\n            console.log('No tangents as the point is inside !')\r\n        }\r\n        return []\r\n    }\r\n\r\n    isPointOnCircle = (P: Point): Boolean => {\r\n        return this._cartesian.test({x: P.x, y: P.y})\r\n    }\r\n\r\n    getPointsOnCircle = (numberIsInteger?: boolean): Point[] => {\r\n        if (numberIsInteger === undefined) {\r\n            numberIsInteger = false\r\n        }\r\n\r\n        // It means searching for pythagorician triples that make a perfect square.\r\n        // (x-4)^2 + (y+3)^2 = 15\r\n\r\n        let triplets = Numeric.pythagoricianTripletsWithTarget(this._squareRadius.value, true)\r\n\r\n        let points: Point[] = [], pt\r\n        triplets.forEach(triplet => {\r\n            // Allow positive / negative values\r\n            // x-a = t  => x = a + t\r\n            // x-a = -t => x = a - t\r\n\r\n            for (let k of [[1, 1], [-1, 1], [-1, -1], [1, -1]]) {\r\n                pt = new Point(\r\n                    this.center.x.clone().add(k[0] * triplet[0]),\r\n                    this.center.y.clone().add(k[1] * triplet[1])\r\n                )\r\n                // Check if the point is not already in points.\r\n                if (!pt.isInListOfPoints(points)) {\r\n                    points.push(pt)\r\n                }\r\n            }\r\n        })\r\n        return points\r\n    }\r\n\r\n    clone(): Circle {\r\n        this._center = this._center.clone()\r\n        this._squareRadius = this._squareRadius.clone()\r\n        this._calculateCartesian()\r\n        return this\r\n    }\r\n\r\n    private _tangentsThroughOnePointOnTheCircle = (P: Point): Line[] => {\r\n        let CT = new Vector(this._center, P)\r\n        return [new Line(P, CT, LinePropriety.Perpendicular)]\r\n    }\r\n\r\n    private _tangentsThroughOnePointOutsideTheCircle = (P: Point): Line[] => {\r\n        // y = mx + h\r\n        // px, py => h = -m px + py => mx - y -m.px + py = 0 =>\r\n        // Centre: cx, cy, radius: r\r\n        // (m.cx - cy -m.px + py)^2 = r^2  * (m^2  + 1)\r\n        // (m(cx-py) - (cy - py))^2 = r^2  * (m^2  + 1)\r\n\r\n        let cx_px = this.center.x.clone().subtract(P.x), cy_py = this.center.y.clone().subtract(P.y),\r\n            polyLeft = new Polynom('x'), polyRight = new Polynom('x^2+1')\r\n\r\n        polyLeft.multiply(cx_px).subtract(cy_py).pow(2)\r\n        polyRight.multiply(this.squareRadius)\r\n\r\n        let equ = new Equation(polyLeft, polyRight)\r\n        equ.moveLeft().simplify().solve()\r\n\r\n        return equ.solutions.map(sol => {\r\n            //  h = -m px + py\r\n            let h, equ = new Equation('y', 'x')\r\n\r\n            if (sol.exact instanceof Fraction) {\r\n                h = P.x.clone().opposed().multiply(sol.exact).add(P.y)\r\n                equ.right.multiply(sol.exact).add(h)\r\n            } else {\r\n                h = P.x.clone().opposed().multiply(sol.value).add(P.y)\r\n                equ.right.multiply(sol.value).add(h)\r\n            }\r\n\r\n            return new Line(equ)\r\n        })\r\n\r\n    }\r\n\r\n    private _tangentsWithSlope = (slope: Fraction): Line[] => {\r\n        // d(C;t)=r => ac1+bc2 + x = +- sqrt(a^2 + b^2)*r\r\n        // x = -ac1-bc2  +-  sqrt(a^2 + b^2)*r\r\n        // y = a/bx + h => ax-by + H = 0\r\n\r\n        const a = slope.numerator, b = -slope.denominator, c1 = this._center.x.clone(), c2 = this._center.y.clone(),\r\n            r = this._squareRadius\r\n\r\n        let sq = this._squareRadius.clone().multiply(slope.numerator ** 2 + slope.denominator ** 2),\r\n            x1 = c1.clone().multiply(a).opposed().subtract(c2.clone().multiply(b)).add(sq.clone().sqrt()),\r\n            x2 = c1.clone().multiply(a).opposed().subtract(c2.clone().multiply(b)).subtract(sq.clone().sqrt())\r\n\r\n        return [new Line(a, b, x1), new Line(a, b, x2)]\r\n    }\r\n\r\n    private _reset(): Circle {\r\n        this._center = null\r\n        this._squareRadius = null\r\n        this._cartesian = null\r\n        this._exists = false\r\n\r\n        return this\r\n    }\r\n\r\n    private parse(...values: unknown[]): Circle {\r\n        // Data can be given in these formats:\r\n        // one value, a string -> make it an Equation\r\n        // one value, an Equation\r\n        // one value, a circle -> clone it\r\n        // two values: two points (center and pointThrough)\r\n        // two values: point and Fraction (center and radius)\r\n        // three values: Point, Fraction, Boolean (center, square radius, true)\r\n\r\n        this._reset()\r\n\r\n        if (typeof values[0] === 'string') {\r\n            this._parseEquation(new Equation(values[0]))\r\n        } else if (values[0] instanceof Equation) {\r\n            this._parseEquation(values[0])\r\n        } else if (values[0] instanceof Circle) {\r\n            this._parseCopyCircle(values[0])\r\n        } else if (values[0] instanceof Point && values.length > 1) {\r\n            if (values[1] instanceof Point) {\r\n                if (values[2] instanceof Point) {\r\n                    this._parseThroughtThreePoints(values[0], values[1], values[2])\r\n                } else {\r\n                    this._parseCenterAndPointThrough(values[0], values[1])\r\n                }\r\n            } else if (values[1] instanceof Fraction || typeof values[1] === 'number') {\r\n                this._parseCenterAndRadius(values[0], values[1], (typeof values[2] === \"boolean\") ? values[2] : false)\r\n            }\r\n        }\r\n\r\n        // Calculate once the different values.\r\n        if (this._exists) {\r\n            this._calculateCartesian()\r\n\r\n            // If the square radius is zero or positive, the circle exists.\r\n            if (this._squareRadius !== undefined && this._squareRadius.isNegative()) {\r\n                this._exists = false\r\n            }\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    private _calculateCartesian() {\r\n        this._cartesian = (new Equation(new Polynom(`(x-(${this._center.x.display}))^2+(y-(${this._center.y.display}))^2`), new Polynom(`${this._squareRadius.display}`))).moveLeft()\r\n    }\r\n\r\n    private _parseCopyCircle(circle: Circle): Circle {\r\n        this._center = circle.center.clone()\r\n        this._squareRadius = circle.squareRadius.clone()\r\n        this._calculateCartesian()\r\n        this._exists = circle.exists\r\n        return this\r\n    }\r\n\r\n    private _parseCenterAndRadius(center: Point, radius: Fraction | number, square?: boolean): Circle {\r\n        this._center = center.clone()\r\n\r\n        if (square) {\r\n            this._squareRadius = (new Fraction(radius))\r\n        } else {\r\n            this._squareRadius = new Fraction(radius).pow(2)\r\n        }\r\n\r\n        this._exists = true\r\n        return this\r\n    }\r\n\r\n    private _parseCenterAndPointThrough(center: Point, pointThrough: Point): Circle {\r\n        this._center = center.clone()\r\n        this._squareRadius = new Vector(this._center, pointThrough).normSquare\r\n        this._exists = true\r\n        return this\r\n    }\r\n\r\n    private _parseEquation(equ: Equation): Circle {\r\n        this._exists = false\r\n\r\n        // Move everything to the left.\r\n        equ.moveLeft()\r\n\r\n        if (equ.degree('x').value === 2 && equ.degree('y').value === 2) {\r\n            // Both must be of degree 2.\r\n            let x2 = equ.left.monomByDegree(2, 'x'), y2 = equ.left.monomByDegree(2, 'y'), x1: Monom, y1: Monom, c: Monom\r\n\r\n            // Both square monoms must have the same coefficient.\r\n            if (x2.coefficient.isEqual(y2.coefficient)) {\r\n                equ.divide(x2.coefficient)\r\n\r\n                x1 = equ.left.monomByDegree(1, 'x')\r\n                y1 = equ.left.monomByDegree(1, 'y')\r\n\r\n                c = equ.left.monomByDegree(0)\r\n\r\n                this._center = new Point(x1.coefficient.clone().divide(2).opposed(), y1.coefficient.clone().divide(2).opposed())\r\n\r\n                this._squareRadius = c.coefficient.clone().opposed()\r\n                    .add(this._center.x.clone().pow(2))\r\n                    .add(this._center.y.clone().pow(2))\r\n\r\n                this._calculateCartesian()\r\n                this._exists = true\r\n            } else {\r\n                // The circle is not a valid circle\r\n                this._center = null\r\n                this._squareRadius = null\r\n                this._exists = false\r\n            }\r\n        }\r\n        return this\r\n    }\r\n\r\n    private _parseThroughtThreePoints(A: Point, B: Point, C: Point): Circle {\r\n        let T = new Triangle(A, B, C), mAB = T.remarquables.mediators.AB.clone(),\r\n            mAC = T.remarquables.mediators.AC.clone()\r\n        this.parse(mAB.intersection(mAC).point, A)\r\n\r\n        return this\r\n    }\r\n\r\n}","/**\r\n * This class works for 2d line in a plane.\r\n */\r\n\r\nimport {Vector} from \"./vector\";\r\nimport {Point} from \"./point\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Equation} from \"../algebra/equation\";\r\nimport {Polynom} from \"../algebra/polynom\";\r\n\r\nexport enum LinePropriety {\r\n    None,\r\n    Parallel='parallel',\r\n    Perpendicular = 'perpendicular',\r\n    Tangent = 'tangent'\r\n}\r\n\r\nexport class Line {\r\n    // A line is defined as the canonical form\r\n    // ax + by + c = 0\r\n    private _a: Fraction;\r\n    private _b: Fraction;\r\n    private _c: Fraction;\r\n    private _OA: Point;\r\n    private _d: Vector;\r\n    private _n: Vector;\r\n    private _exists: boolean\r\n\r\n    private _referencePropriety: LinePropriety\r\n    private _referenceLine: Line\r\n\r\n    static PERPENDICULAR = LinePropriety.Perpendicular\r\n    static PARALLEL = LinePropriety.Parallel\r\n\r\n    constructor(...values: unknown[]) {\r\n\r\n        this._exists = false;\r\n\r\n        if (values.length > 0) {\r\n            this.parse(...values);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    get exists(): boolean {\r\n        return this._exists;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get equation(): Equation {\r\n        return new Equation(new Polynom().parse('xy', this._a, this._b, this._c), new Polynom('0')).simplify();\r\n    }\r\n\r\n    get tex(): { canonical: string, mxh: string, parametric: string } {\r\n        // canonical    =>  ax + by + c = 0\r\n        // mxh          =>  y = -a/b x - c/b\r\n        // parametric   =>  (xy) = OA + k*d\r\n\r\n        let canonical = this.equation;\r\n        // Make sur the first item is positive.\r\n        if (this._a.isNegative()) {\r\n            canonical.multiply(-1);\r\n        }\r\n\r\n        return {\r\n            canonical: canonical.tex,\r\n            mxh: this.slope.isInfinity() ? 'x=' + this.OA.x.tex : 'y=' + new Polynom().parse('x', this.slope, this.height).tex,\r\n            parametric: `${Point.pmatrix('x', 'y')} = ${Point.pmatrix(this._OA.x, this._OA.y)} + k\\\\cdot ${Point.pmatrix(this._d.x, this._d.y)}`\r\n        }\r\n    }\r\n\r\n    get a(): Fraction {\r\n        return this._a;\r\n    }\r\n\r\n    set a(value: Fraction) {\r\n        this._a = value;\r\n    }\r\n\r\n    get b(): Fraction {\r\n        return this._b;\r\n    }\r\n\r\n    set b(value: Fraction) {\r\n        this._b = value;\r\n    }\r\n\r\n    get c(): Fraction {\r\n        return this._c;\r\n    }\r\n\r\n    set c(value: Fraction) {\r\n        this._c = value;\r\n    }\r\n\r\n    get OA(): Point {\r\n        return this._OA;\r\n    }\r\n\r\n    set OA(value: Point) {\r\n        this._OA = value;\r\n    }\r\n\r\n    get d(): Vector {\r\n        return this._d;\r\n    }\r\n\r\n    get n(): Vector {\r\n        return this._n;\r\n    }\r\n\r\n    get normal(): Vector {\r\n        return new Vector(this._a, this._b);\r\n    }\r\n\r\n    get director(): Vector {\r\n        return this._d.clone()\r\n    }\r\n\r\n    set d(value: Vector) {\r\n        this._d = value;\r\n    }\r\n\r\n    get slope(): Fraction {\r\n        return this._a.clone().opposed().divide(this._b);\r\n    }\r\n\r\n    get height(): Fraction {\r\n        return this._c.clone().opposed().divide(this._b);\r\n    }\r\n\r\n// ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse data to a line\r\n     * @param {any} values\r\n     * @returns {Line}\r\n     */\r\n    parse = (...values: unknown[]): Line => {\r\n        this._exists = false;\r\n\r\n        // Nothing is given...\r\n        if (values.length === 0) {\r\n            return this\r\n        }\r\n\r\n        // One value only: already a line (clone it), an Equation, a string (as Equation)\r\n        if (values.length === 1) {\r\n            if (values[0] instanceof Line) {\r\n                // Already a Line\r\n                return values[0].clone()\r\n            } else if (values[0] instanceof Equation) {\r\n                // It's an Equation\r\n                return this.parseEquation(values[0])\r\n            } else if (typeof values[0] === \"string\") {\r\n                // It's a string - create an Equation from it.\r\n                try {\r\n                    let E = new Equation(values[0])\r\n                    return this.parse(E)\r\n                } catch (e) {\r\n                    return this\r\n                }\r\n            }\r\n        }\r\n\r\n        if (values.length === 2) {\r\n            if (values[0] instanceof Point && values[1] instanceof Vector) {\r\n                return this.parseByPointAndVector(values[0], values[1]);\r\n            } else if (values[0] instanceof Point && values[1] instanceof Point) {\r\n                return this.parseByPointAndVector(values[0], new Vector(values[0], values[1]));\r\n            } else if (values[0] instanceof Vector && values[1] instanceof Point) {\r\n                return this.parseByPointAndNormal(values[1], values[0])\r\n            }\r\n        }\r\n\r\n        if (values.length === 3) {\r\n            if (\r\n                (values[0] instanceof Fraction || typeof values[0] === 'number')\r\n                &&\r\n                (values[1] instanceof Fraction || typeof values[1] === 'number')\r\n                &&\r\n                (values[2] instanceof Fraction || typeof values[2] === 'number')\r\n            ) {\r\n                return this.parseByCoefficient(values[0], values[1], values[2]);\r\n            }else if (\r\n                values[0] instanceof Point && values[1] instanceof Vector\r\n            ){\r\n                if(values[2] === LinePropriety.Perpendicular){\r\n                    return this.parseByPointAndNormal(values[0], values[1])\r\n                }else if (values[2] === LinePropriety.Parallel){\r\n                    return this.parseByPointAndVector(values[0], values[1])\r\n                }\r\n            }else if (values[0] instanceof Point && values[1] instanceof Line ) {\r\n                if(values[2]===LinePropriety.Parallel || values[2]===null) {\r\n                    return this.parseByPointAndLine(values[0], values[1], LinePropriety.Parallel)\r\n                }else{\r\n                    return this.parseByPointAndLine(values[0], values[1], LinePropriety.Perpendicular)\r\n                }\r\n            }\r\n        }\r\n\r\n        // TODO: Add the ability to create line from a normal vector\r\n        console.log('Someting wrong happend while creating the line')\r\n        return this;\r\n    }\r\n\r\n    parseEquation = (equ: Equation): Line => {\r\n        // Reorder the eequation\r\n        equ.reorder(true)\r\n\r\n        // It must contain either x, y or both.\r\n        let letters = new Set(equ.letters());\r\n\r\n        // No 'x', no 'y' in the equations\r\n        if (!(letters.has('x') || letters.has('y'))) {\r\n            return this\r\n        }\r\n\r\n        // Another letter in the equation ?\r\n        for (let elem of ['x', 'y']) {\r\n            if (letters.has(elem)) {\r\n                letters.delete(elem)\r\n            }\r\n        }\r\n\r\n        if (letters.size > 0) {\r\n            return this\r\n        }\r\n\r\n        // Everything should be ok now...\r\n        return this.parseByCoefficient(equ.left.monomByLetter('x').coefficient, equ.left.monomByLetter('y').coefficient, equ.left.monomByDegree(0).coefficient)\r\n    }\r\n    parseByCoefficient = (a: Fraction | number, b: Fraction | number, c: Fraction | number): Line => {\r\n        this._a = new Fraction(a);\r\n        this._b = new Fraction(b);\r\n        this._c = new Fraction(c);\r\n\r\n        this._d = new Vector(this._b.clone(), this._a.clone().opposed());\r\n        this._OA = new Point(new Fraction().zero(), this._c.clone());\r\n        this._n = this._d.clone().normal();\r\n\r\n        this._exists = true;\r\n        return this;\r\n    }\r\n\r\n    parseByPointAndVector = (P: Point, d: Vector): Line => {\r\n        // OX = OP + k*d\r\n        // x = px + kdx     * dy\r\n        // y = py + kdy     * dx\r\n        // ------------------\r\n        // dy * x = px * dy + kdxdy\r\n        // dx * y = py * dx + kdxdy\r\n        // ------------------\r\n        // dy * x - dx * y = px * dy - py * dx\r\n        // dy * x - dx * y - (px * dy - py * dx) = 0\r\n        this.parseByCoefficient(\r\n            d.y,\r\n            d.x.clone().opposed(),\r\n            P.x.clone().multiply(d.y).subtract(P.y.clone().multiply(d.x)).opposed()\r\n        )\r\n\r\n        // Choose the current values as point and direction vector instead of the automatic version.\r\n        this._OA = P.clone();\r\n        this._d = d.clone();\r\n        this._n = this._d.clone().normal();\r\n\r\n        this._exists = true;\r\n        return this;\r\n    }\r\n\r\n    parseByPointAndNormal = (P: Point, n: Vector): Line => {\r\n        return this.parseByCoefficient(\r\n            n.x,\r\n            n.y,\r\n            P.x.clone().multiply(n.x)\r\n                .add(P.y.clone().multiply(n.y)).opposed()\r\n        )\r\n    }\r\n\r\n    parseByPointAndLine = (P: Point, L: Line, orientation?: LinePropriety): Line => {\r\n\r\n        if (orientation === undefined) {\r\n            orientation = LinePropriety.Parallel\r\n        }\r\n\r\n        if (orientation === LinePropriety.Parallel) {\r\n            return this.parseByPointAndNormal(P, L.normal)\r\n        } else if (orientation === LinePropriety.Perpendicular) {\r\n            return this.parseByPointAndNormal(P, L.director)\r\n        }\r\n\r\n        this._exists = false\r\n        return this\r\n    }\r\n\r\n    clone = (): Line => {\r\n        this._a = this._a.clone();\r\n        this._b = this._b.clone();\r\n        this._c = this._c.clone();\r\n\r\n        this._d = this._d.clone();\r\n        this._OA = this._OA.clone();\r\n        this._n = this._n.clone();\r\n\r\n        this._exists = this.exists\r\n        return this;\r\n    }\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    isParellelTo = (line: Line): Boolean => {\r\n        // Do they have the isSame direction ?\r\n        return this.slope.isEqual(line.slope) && this.height.isNotEqual(line.height);\r\n    }\r\n    isSameAs = (line: Line): Boolean => {\r\n        return this.slope.isEqual(line.slope) && this.height.isEqual(line.height);\r\n    }\r\n    isVertical = (): Boolean => {\r\n        return this.slope.isInfinity()\r\n    }\r\n    simplify = (): Line => {\r\n        let lcm = Numeric.lcm(this._a.denominator, this._b.denominator, this._c.denominator),\r\n            gcd = Numeric.gcd(this._a.numerator, this._b.numerator, this._c.numerator);\r\n\r\n        this.parseByCoefficient(\r\n            this._a.clone().multiply(lcm).divide(gcd),\r\n            this._b.clone().multiply(lcm).divide(gcd),\r\n            this._c.clone().multiply(lcm).divide(gcd),\r\n        )\r\n\r\n        return this\r\n    }\r\n\r\n    simplifyDirection = (): Line => {\r\n        let lcm = Numeric.lcm(this._d.x.denominator, this._d.y.denominator),\r\n            gcd = Numeric.gcd(this._d.x.numerator, this._d.y.numerator);\r\n\r\n        this._d.x.multiply(lcm).divide(gcd);\r\n        this._d.y.multiply(lcm).divide(gcd);\r\n        return this;\r\n    }\r\n    intersection = (line: Line): { point: Point, hasIntersection: boolean, isParallel: boolean, isSame: boolean } => {\r\n        let Pt = new Point(), isParallel = false, isSame = false, hasIntersection = true;\r\n\r\n        // this         => ax+by+c = 0\r\n        // line         => dx+ey+f = 0\r\n        //\r\n        //  aex + bey + ce = 0\r\n        //  dbx + bey + bf = 0\r\n        // (ae-db)x + ce-bf = 0\r\n        //\r\n        //  adx + bdy + cd = 0\r\n        //  adx + aey + af = 0\r\n        // (bd-ae)y + (cd-af)\r\n        //\r\n        // x = (bf-ce)/(ae-db)\r\n        // y = (af-cd)/(bd-ae)\r\n\r\n\r\n        // Theres is no 'y'\r\n        if (this._b.isZero() || line.b.isZero()) {\r\n            // TODO : handle no y in the line canonical form\r\n        }\r\n\r\n        if (this.isParellelTo(line)) {\r\n            Pt.x = null;\r\n            Pt.y = null;\r\n            isParallel = true;\r\n        } else if (this.isSameAs(line)) {\r\n            Pt.x = null;\r\n            Pt.y = null;\r\n            isSame = true;\r\n        } else {\r\n            Pt.x = this._b.clone().multiply(line.c).subtract(this._c.clone().multiply(line.b))\r\n                .divide(this._a.clone().multiply(line.b).subtract(this._b.clone().multiply(line.a)));\r\n            Pt.y = this._a.clone().multiply(line.c).subtract(this._c.clone().multiply(line.a))\r\n                .divide(this._b.clone().multiply(line.a).subtract(this._a.clone().multiply(line.b)));\r\n        }\r\n\r\n        return {\r\n            point: Pt,\r\n            hasIntersection: !(isParallel || isSame),\r\n            isParallel,\r\n            isSame\r\n        };\r\n    }\r\n\r\n    distanceTo(pt: Point): { value: number, fraction: Fraction, tex: string } {\r\n        let numerator = pt.x.clone().multiply(this._a)\r\n                .add(pt.y.clone().multiply(this._b))\r\n                .add(this._c).abs(),\r\n            d2 = this.normal.normSquare;\r\n\r\n        // The denominator is null - shouldn't be possible\r\n        if (d2.isZero()) {\r\n            return {\r\n                value: NaN,\r\n                tex: 'Not a line',\r\n                fraction: new Fraction().infinite()\r\n            }\r\n        }\r\n        // The denominator is a perfect square - simplify the tex result\r\n        let value = numerator.value / Math.sqrt(d2.value),\r\n            F = numerator.clone().divide(d2.clone().sqrt());\r\n\r\n        // The denominator is a perfect square.\r\n        if (d2.isSquare()) {\r\n            return {\r\n                value,\r\n                tex: F.tex,\r\n                fraction: F\r\n            }\r\n        }\r\n        // Complete answer...\r\n        return {\r\n            value,\r\n            tex: `\\\\frac{${numerator.tex}}{\\\\sqrt{${d2.tex}}}`,\r\n            fraction: F\r\n        };\r\n    }\r\n\r\n    hitSegment(A: Point, B: Point): boolean {\r\n        let iPt = this.intersection(\r\n            new Line(A, B)\r\n        )\r\n\r\n        // There is an intersection point\r\n        if (iPt.hasIntersection) {\r\n            return iPt.point.x.value >= Math.min(A.x.value, B.x.value)\r\n                && iPt.point.x.value <= Math.max(A.x.value, B.x.value)\r\n                && iPt.point.y.value >= Math.min(A.y.value, B.y.value)\r\n                && iPt.point.y.value <= Math.max(A.y.value, B.y.value)\r\n        }\r\n        return false;\r\n    }\r\n\r\n    getValueAtX = (value: Fraction|number): Fraction => {\r\n\r\n        const equ = this.equation.clone().isolate('y'),\r\n            F = new Fraction(value)\r\n\r\n        if(equ instanceof Equation){\r\n            return equ.right.evaluate({x: F})\r\n        }\r\n        return\r\n    }\r\n    getValueAtY = (value: Fraction|number): Fraction => {\r\n        const equ = this.equation.clone().isolate('x'),\r\n            F = new Fraction(value)\r\n\r\n        if(equ instanceof Equation){\r\n            return equ.right.evaluate({y: F})\r\n        }\r\n        return\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Special functions\r\n    // ------------------------------------------\r\n    canonicalAsFloatCoefficient(decimals: number): string {\r\n        if (decimals === undefined) {\r\n            decimals = 2;\r\n        }\r\n\r\n        let ca = this._a.value,\r\n            cb = this._b.value,\r\n            cc = this._c.value,\r\n            canonical = '';\r\n\r\n        if (!this._a.isZero()) {\r\n            if (this._a.isOne()) {\r\n                canonical = 'x'\r\n            } else if (this._a.clone().opposed().isOne()) {\r\n                canonical = '-x'\r\n            } else {\r\n                canonical = this._a.value.toFixed(decimals) + 'x'\r\n            }\r\n        }\r\n\r\n        if (!this._b.isZero()) {\r\n            if (this._b.isPositive()) {\r\n                canonical += '+'\r\n            }\r\n            canonical += this._b.value.toFixed(decimals) + 'y'\r\n        }\r\n\r\n        if (!this._c.isZero()) {\r\n            if (this._c.isPositive()) {\r\n                canonical += '+'\r\n            }\r\n            canonical += this._c.value.toFixed(decimals)\r\n        }\r\n\r\n\r\n        return canonical + '=0';\r\n    }\r\n}","/**\r\n * Vector module contains everything necessary to handle 2d or 3d vectors.\r\n * @module Vector\r\n */\r\nimport {Line} from \"./line\";\r\nimport {Vector} from \"./vector\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\n/**\r\n * Helper class - a way to identify an object {x: number, y: number}\r\n */\r\nclass PointXY {\r\n    x: number\r\n    y: number\r\n}\r\n\r\nexport class Point {\r\n    private _x: Fraction;   // 1st component\r\n    private _y: Fraction;   // 2nd component\r\n    private _exist: Boolean;\r\n\r\n    constructor(...values: unknown[]) {\r\n        this._x = new Fraction().zero();\r\n        this._y = new Fraction().zero();\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values);\r\n        }\r\n\r\n        return this\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get x(): Fraction {\r\n        return this._x;\r\n    }\r\n\r\n    set x(value: Fraction) {\r\n        this._x = value;\r\n    }\r\n\r\n    get y(): Fraction {\r\n        return this._y;\r\n    }\r\n\r\n    set y(value: Fraction) {\r\n        this._y = value;\r\n    }\r\n\r\n    get tex(): string {\r\n        let pts = [];\r\n\r\n        pts.push(this._x.tex);\r\n        pts.push(this._y.tex);\r\n\r\n        return `\\\\left(${pts.join(';')}\\\\right)`\r\n    }\r\n\r\n    get display(): string {\r\n        let pts = [];\r\n\r\n        pts.push(this._x.tex);\r\n        pts.push(this._y.tex);\r\n\r\n        return `(${pts.join(';')})`\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (...values: unknown[]): Point => {\r\n        // Initialize the value.\r\n        this.zero();\r\n\r\n        // Nothing is given\r\n        if (values.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        // One element is given - might be already a point !\r\n        if (values.length === 1) {\r\n            // it's already a point - clone it\r\n            if (values[0] instanceof Point) {\r\n                this._x = values[0].x.clone()\r\n                this._y = values[0].y.clone()\r\n                return this\r\n            }\r\n\r\n            // Value is given as string, comma separated.\r\n            if (typeof values[0] === 'string') {\r\n                let xy = values[0].split(',')\r\n                if (xy.length === 2) {\r\n                    this._x = new Fraction(xy[0]).reduce()\r\n                    this._y = new Fraction(xy[1]).reduce()\r\n                    return this\r\n                }\r\n            }\r\n\r\n            // Value given as an object with {x: value, y: value}\r\n            if(values[0] instanceof PointXY){\r\n                    this._x = new Fraction(values[0].x).reduce()\r\n                    this._y = new Fraction(values[0].y).reduce()\r\n                return this\r\n            } else {\r\n                return this.zero()\r\n            }\r\n        }\r\n\r\n        if (values.length === 2) {\r\n            this._x = new Fraction(values[0]).reduce()\r\n            this._y = new Fraction(values[1]).reduce()\r\n            return this\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    clone = (): Point => {\r\n        this._x = this._x.clone()\r\n        this._y = this._y.clone()\r\n\r\n        return this\r\n    }\r\n\r\n    zero = (): Point => {\r\n        this._x = new Fraction(null);\r\n        this._y = new Fraction(null);\r\n        return this;\r\n    }\r\n\r\n    origin = (): Point => {\r\n        this.zero();\r\n        return this;\r\n    }\r\n\r\n    middleOf = (P1: Point, P2: Point): Point => {\r\n        this._x = P1.x.clone().add(P2.x).divide(2);\r\n        this._y = P1.y.clone().add(P2.y).divide(2);\r\n\r\n        return this;\r\n    }\r\n    // ------------------------------------------\r\n    // Display functions\r\n    // ------------------------------------------\r\n    texValues = (numberOfDigits: number): string => {\r\n        let pts = [];\r\n\r\n        pts.push(this._x.value.toFixed(numberOfDigits === undefined ? 2 : numberOfDigits));\r\n        pts.push(this._y.value.toFixed(numberOfDigits === undefined ? 2 : numberOfDigits));\r\n\r\n        return `\\\\left(${pts.join(';')}\\\\right)`\r\n    }\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n\r\n    // ------------------------------------------\r\n    // Vector functions\r\n    // ------------------------------------------\r\n\r\n    // ------------------------------------------\r\n    // Static functions\r\n    // ------------------------------------------\r\n    static pmatrix = (a: any, b: any, c?: any): string => {\r\n        if (c === undefined) {\r\n            return `\\\\begin{pmatrix} ${a.tex ? a.tex : a} \\\\\\\\ ${b.tex ? b.tex : b} \\\\end{pmatrix}`;\r\n        } else {\r\n            return `\\\\begin{pmatrix} ${a.tex ? a.tex : a} \\\\\\\\ ${b.tex ? b.tex : b} \\\\\\\\ ${c.tex ? c.tex : c} \\\\end{pmatrix}`;\r\n        }\r\n    };\r\n\r\n    distanceTo = (item:Point|Line): { value: number, fraction: Fraction, tex: string } => {\r\n        let value = 0, fraction = new Fraction(), tex = ''\r\n\r\n        if(item instanceof Line){\r\n            return item.distanceTo(this)\r\n        }else if(item instanceof Point){\r\n            let V = new Vector(this, item)\r\n\r\n            value = V.norm\r\n            fraction = V.normSquare.sqrt()\r\n            tex = V.normSquare.isSquare()?fraction.tex:`\\\\sqrt{\\\\dfrac{ ${V.normSquare.numerator} }{ ${V.normSquare.denominator} }}`\r\n        }\r\n        return { value, fraction, tex }\r\n    }\r\n\r\n    get key(): string {\r\n      return `${this.x.display};${this.y.display}`\r\n}\r\n    isInListOfPoints = (list: Point[]): boolean => {\r\n        const keyList = list.map(x=>x.key)\r\n\r\n        return keyList.includes(this.key)\r\n    }\r\n}\r\n","import {Point} from \"./point\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Vector} from \"./vector\";\r\nimport {Line} from \"./line\";\r\nimport {Equation} from \"../algebra/equation\";\r\n\r\nexport interface remarquableLines {\r\n    'medians': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    },\r\n    'mediators': {\r\n        'AB': Line,\r\n        'AC': Line,\r\n        'BC': Line,\r\n        'intersection': Point\r\n    },\r\n    'heights': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    },\r\n    'bisectors': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    }\r\n}\r\n\r\nexport class Triangle {\r\n    private _A: Point;\r\n    private _B: Point;\r\n    private _C: Point;\r\n    private _lines: {\r\n        'AB': Line,\r\n        'AC': Line,\r\n        'BC': Line\r\n    };\r\n    private _middles: {\r\n        'AB': Point,\r\n        'AC': Point,\r\n        'BC': Point\r\n    };\r\n    private _remarquables: remarquableLines;\r\n\r\n\r\n    constructor(...values: unknown[]) {\r\n\r\n        if (values.length > 0) {\r\n            this.parse(...values);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setters\r\n    // ------------------------------------------\r\n\r\n    get A(): Point {\r\n        return this._A;\r\n    }\r\n\r\n    get B(): Point {\r\n        return this._B;\r\n    }\r\n\r\n    get C(): Point {\r\n        return this._C;\r\n    }\r\n\r\n    get AB(): Vector {\r\n        return this.getSegment('A', 'B');\r\n    }\r\n\r\n    get BA(): Vector {\r\n        return this.getSegment('B', 'A');\r\n    }\r\n\r\n    get BC(): Vector {\r\n        return this.getSegment('B', 'C');\r\n    }\r\n\r\n    get CB(): Vector {\r\n        return this.getSegment('C', 'B');\r\n    }\r\n\r\n    get AC(): Vector {\r\n        return this.getSegment('A', 'C');\r\n    }\r\n\r\n    get CA(): Vector {\r\n        return this.getSegment('C', 'A');\r\n    }\r\n\r\n    get isRectangle(): boolean {\r\n        if (this.AB.isNormalTo(this.BC)) {\r\n            return true;\r\n        }\r\n        if (this.AB.isNormalTo(this.AC)) {\r\n            return true;\r\n        }\r\n        if (this.BC.isNormalTo(this.AC)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    get isEquilateral(): boolean {\r\n        return this.AB.normSquare.isEqual(this.BC.normSquare) &&\r\n            this.AB.normSquare.isEqual(this.AC.normSquare);\r\n    }\r\n\r\n    get isIsocele(): boolean {\r\n        return this.AB.normSquare.isEqual(this.BC.normSquare) ||\r\n            this.AB.normSquare.isEqual(this.AC.normSquare) ||\r\n            this.BC.normSquare.isEqual(this.AC.normSquare)\r\n    }\r\n\r\n    get lines(): { 'AB': Line, 'BC': Line, 'AC': Line } {\r\n        return this._lines;\r\n    }\r\n\r\n    get remarquables(): remarquableLines {\r\n        return this._remarquables;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Parse values to a triangle. Supported formats:\r\n     * Point, Point, Point\r\n     * x1, y1, x2, y2, x3, y3\r\n     * TODO: Something else ?\r\n     * @param values\r\n     */\r\n    parse = (...values: any): Triangle => {\r\n        if (values.length === 6) {\r\n            // Check if all values are number or fractions.\r\n            let v = values.map((x: any) => new Fraction(x));\r\n            return this.parse(\r\n                new Point(v[0], v[1]),\r\n                new Point(v[2], v[3]),\r\n                new Point(v[4], v[5]),\r\n            )\r\n        } else if (values.length === 3) {\r\n            // Possibilities:\r\n            // - Three points (or part of points, only dict for example, or array (TODO: Add the array syntax for point)\r\n            // - Three lines\r\n            // - Three lines as text.\r\n            if(values.filter((x:any) => typeof x === 'string').length===3) {\r\n                return this.parse( ...values.map((x:string) => new Line(x)) )\r\n            }else if(values.filter((x:any) => x instanceof Line).length===3) {\r\n                // We have three lines\r\n                this._lines = {\r\n                    'AB': values[0],\r\n                    'BC': values[1],\r\n                    'AC': values[2]\r\n                };\r\n\r\n                // Get the intersection points -> build the triangle using these intersection points.\r\n                let intersect = values[0].intersection(values[1]);\r\n                if (intersect.hasIntersection) {\r\n                    this._B = intersect.point.clone();\r\n                } else {\r\n                    return this;\r\n                }\r\n                intersect = values[1].intersection(values[2]);\r\n                if (intersect.hasIntersection) {\r\n                    this._C = intersect.point.clone();\r\n                } else {\r\n                    return this;\r\n                }\r\n                intersect = values[2].intersection(values[0]);\r\n                if (intersect.hasIntersection) {\r\n                    this._A = intersect.point.clone();\r\n                } else {\r\n                    return this;\r\n                }\r\n            }else {\r\n                // At least, one of the value is not a point.\r\n                if (values.filter((x: any) => (x instanceof Point)).length < 3) {\r\n                    return this.parse(\r\n                        new Point(values[0]),\r\n                        new Point(values[1]),\r\n                        new Point(values[2])\r\n                    )\r\n                }\r\n\r\n                // We have three points.\r\n                this._A = values[0].clone();\r\n                this._B = values[1].clone();\r\n                this._C = values[2].clone();\r\n\r\n                this._lines = {\r\n                    'AB': new Line(this._A, this._B),\r\n                    'BC': new Line(this._B, this._C),\r\n                    'AC': new Line(this._A, this._C)\r\n                };\r\n            }\r\n        } else if (values.length === 1) {\r\n            if (values[0] instanceof Triangle) {\r\n                return values[0].clone();\r\n            }\r\n        }\r\n\r\n        this._updateTriangle();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clone the Triangle class\r\n     */\r\n    clone = (): Triangle => {\r\n        this._A = this._A.clone();\r\n        this._B = this._B.clone();\r\n        this._C = this._C.clone();\r\n\r\n        this._lines = {\r\n            'AB': this._lines.AB.clone(),\r\n            'BC': this._lines.BC.clone(),\r\n            'AC': this._lines.AC.clone()\r\n        }\r\n\r\n        this._updateTriangle();\r\n        return this;\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Triangle operations and properties\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Generate the Line object for the three segments of the triangle\r\n     */\r\n    private _updateTriangle = () => {\r\n        this._middles = {\r\n            'AB': new Point().middleOf(this._A, this._B),\r\n            'AC': new Point().middleOf(this._A, this._C),\r\n            'BC': new Point().middleOf(this._B, this._C)\r\n        }\r\n\r\n        this._remarquables = this._calculateRemarquableLines();\r\n    }\r\n\r\n\r\n    /**\r\n     * Get the Point class for the given name\r\n     * @param ptName\r\n     */\r\n    private getPointByName = (ptName: string): Point => {\r\n        switch (ptName.toUpperCase()) {\r\n            case 'A':\r\n                return this._A;\r\n            case 'B':\r\n                return this._B;\r\n            case 'C':\r\n                return this._C;\r\n        }\r\n\r\n        // Something went wrong ! Return the first point\r\n        return this._A;\r\n    }\r\n    /**\r\n     * Get the vector for the segment given by name.\r\n     * @param ptName1\r\n     * @param ptName2\r\n     */\r\n    private getSegment = (ptName1: string, ptName2: string): Vector => {\r\n        return new Vector(\r\n            this.getPointByName(ptName1),\r\n            this.getPointByName(ptName2)\r\n        );\r\n    }\r\n\r\n    private _calculateRemarquableLines = (): remarquableLines => {\r\n        let remarquables: remarquableLines = {\r\n            'medians': {\r\n                'A': new Line(this._A, this._middles.BC),\r\n                'B': new Line(this._B, this._middles.AC),\r\n                'C': new Line(this._C, this._middles.AB),\r\n                'intersection': null\r\n            },\r\n            'mediators': {\r\n                'AB': new Line(this._middles.AB, new Vector(this._A, this._B).normal()),\r\n                'AC': new Line(this._middles.AC, new Vector(this._A, this._C).normal()),\r\n                'BC': new Line(this._middles.BC, new Vector(this._B, this._C).normal()),\r\n                'intersection': null\r\n            },\r\n            'heights': {\r\n                'A': new Line(this._A, new Vector(this._B, this._C).normal()),\r\n                'B': new Line(this._B, new Vector(this._A, this._C).normal()),\r\n                'C': new Line(this._C, new Vector(this._A, this._B).normal()),\r\n                'intersection': null\r\n            },\r\n            'bisectors': {\r\n                'A': this._calculateBisectors('A'),\r\n                'B': this._calculateBisectors('B'),\r\n                'C': this._calculateBisectors('C'),\r\n                'intersection': null\r\n            }\r\n        }\r\n\r\n        // As it's a triangle, we assume the lines are intersecting and aren't parallel or superposed.\r\n        remarquables.medians.intersection = remarquables.medians.A.intersection(remarquables.medians.B).point;\r\n        remarquables.mediators.intersection = remarquables.mediators.AB.intersection(remarquables.mediators.BC).point;\r\n        remarquables.heights.intersection = remarquables.heights.A.intersection(remarquables.heights.B).point;\r\n        remarquables.bisectors.intersection = remarquables.bisectors.A.intersection(remarquables.bisectors.B).point;\r\n\r\n        // Everything was calculated for the remarquable lines.\r\n        return remarquables;\r\n    }\r\n\r\n    private _calculateBisectors = (pt: string): Line => {\r\n        let tlines = this.lines, d1, d2;\r\n\r\n        if(pt==='A'){\r\n            d1 = tlines.AB;\r\n            d2 = tlines.AC;\r\n        }else if(pt==='B'){\r\n            d1 = tlines.AB;\r\n            d2 = tlines.BC;\r\n        }else if(pt==='C'){\r\n            d1 = tlines.BC;\r\n            d2 = tlines.AC;\r\n        }\r\n\r\n        let b1 = new Line(new Equation(d1.equation.left.clone().multiply(d2.n.simplify().norm), d2.equation.left.clone().multiply(d1.n.simplify().norm)).reorder(true).simplify()),\r\n            b2 = new Line(new Equation(d1.equation.left.clone().multiply(d2.n.simplify().norm), d2.equation.left.clone().multiply(d1.n.simplify().norm).opposed()).reorder(true).simplify());\r\n\r\n        // Must determine which bisectors is in the triangle\r\n        if(pt==='A'){\r\n            return b1.hitSegment(this.B, this.C)?b1:b2;\r\n        }\r\n        if(pt==='B'){\r\n            return b1.hitSegment(this.A, this.C)?b1:b2;\r\n        }\r\n        if(pt==='C'){\r\n            return b1.hitSegment(this.B, this.A)?b1:b2;\r\n        }\r\n\r\n        // Default returns the first bisector\r\n        return b1;\r\n    }\r\n}","/**\r\n * Vector module contains everything necessary to handle 2d or 3d vectors.\r\n * @module Vector\r\n */\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Point} from \"./point\";\r\n\r\nexport class Vector {\r\n    private _x: Fraction;   // 1st component\r\n    private _y: Fraction;   // 2nd component\r\n\r\n    constructor(...values: unknown[]) {\r\n        this._x = new Fraction().zero();\r\n        this._y = new Fraction().zero();\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values);\r\n        }\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get x(): Fraction {\r\n        return this._x;\r\n    }\r\n\r\n    set x(value: Fraction) {\r\n        this._x = value;\r\n    }\r\n\r\n    get y(): Fraction {\r\n        return this._y;\r\n    }\r\n\r\n    set y(value: Fraction) {\r\n        this._y = value;\r\n    }\r\n\r\n    get normSquare(): Fraction {\r\n        return this._x.clone().pow(2).add(this._y.clone().pow(2));\r\n    }\r\n\r\n    get norm(): number {\r\n        return Math.sqrt(this.normSquare.value);\r\n    }\r\n\r\n    get tex(): string {\r\n        return `\\\\begin{pmatrix}${this._x.tex} \\\\\\\\\\ ${this._y.tex} \\\\end{pmatrix}`\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n    parse = (...values: any): Vector => {\r\n        // TODO: Must be more strict about what is given and limit to two dimensional vectors.p\r\n        // Maybe more than one value was given...\r\n        // Initialize the vector\r\n        this.zero();\r\n\r\n        if (values.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        if (values.length === 1) {\r\n            if (values[0] instanceof Vector) {\r\n                return values[0].clone()\r\n            } else {\r\n                return this._parseString(values[0])\r\n            }\r\n        }\r\n\r\n        if (values.length >= 2) {\r\n            // Two points are given - skip the third value.\r\n            if (values[0] instanceof Point && values[1] instanceof Point) {\r\n                this._x = values[1].x.clone().subtract(values[0].x)\r\n                this._y = values[1].y.clone().subtract(values[0].y)\r\n                return this;\r\n            }\r\n\r\n            // Fractions or a number are give\r\n            if (values[0] instanceof Fraction || !isNaN(values[0])) {\r\n                this._x = new Fraction(values[0])\r\n            }\r\n            if (values[1] instanceof Fraction || !isNaN(values[1])) {\r\n                this._y = new Fraction(values[1])\r\n            }\r\n\r\n            if(\r\n                (typeof values[0] === 'object' && !isNaN(values[0].x) && !isNaN(values[0].x)) &&\r\n                (typeof values[1] === 'object' && !isNaN(values[1].x) && !isNaN(values[1].x))\r\n            ){\r\n                this._x = new Fraction(+values[1].x-values[0].x)\r\n                this._y = new Fraction(+values[1].y-values[0].y)\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    clone = (): Vector => {\r\n        let V = new Vector();\r\n\r\n        if (this._x !== null) {\r\n            V.x = this._x.clone();\r\n        }\r\n        if (this._y !== null) {\r\n            V.y = this._y.clone();\r\n        }\r\n        return V;\r\n    }\r\n\r\n    reset = (): Vector => {\r\n        this._x = null;\r\n        this._y = null;\r\n        return this;\r\n    }\r\n\r\n    zero = (): Vector => {\r\n        this.reset();\r\n        this._x = new Fraction(null);\r\n        this._y = new Fraction(null);\r\n        return this;\r\n    }\r\n\r\n    one = (): Vector => {\r\n        this._x = new Fraction();\r\n        this._y = new Fraction();\r\n        return this;\r\n    }\r\n\r\n    private _parseString = (value: string): Vector => {\r\n        // Split comma, semi colon or single space.\r\n        let components = value.split(/[,;\\s]/g);\r\n\r\n        // Validate the fraction values.\r\n        this.x = new Fraction(components[0] || null);\r\n        this.y = new Fraction(components[1] || null);\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    opposed = (): Vector => {\r\n        this._x.opposed();\r\n        this._y.opposed();\r\n        return this;\r\n    }\r\n\r\n    add = (V: Vector): Vector => {\r\n        this._x.add(V.x);\r\n        this._y.add(V.y);\r\n\r\n        return this;\r\n    }\r\n\r\n    subtract = (V: Vector): Vector => {\r\n        return this.add(V.clone().opposed());\r\n    }\r\n\r\n    scalarProductWithVector = (V: Vector): Fraction => {\r\n        // TODO: Add the scalar factor !!!!\r\n        return this._x.clone().multiply(V.x).add(this._y.clone().multiply(V.y));\r\n    }\r\n\r\n    static scalarProduct = (v1: Vector, v2: Vector): number => {\r\n        // TODO: Transform to fraction with nthroot.\r\n        return v1.x.value * v2.x.value + v1.y.value * v2.y.value;\r\n    };\r\n\r\n    normal = (): Vector => {\r\n        let x = this.x.clone().opposed(), y = this.y.clone();\r\n        this._x = y;\r\n        this._y = x;\r\n        return this;\r\n    }\r\n\r\n    isNormalTo = (v: Vector): boolean => {\r\n        return this.scalarProductWithVector(v).isZero()\r\n    }\r\n\r\n    multiplyByScalar = (k: any): Vector => {\r\n        let scalar = new Fraction(k);\r\n        this._x.multiply(scalar);\r\n        this._y.multiply(scalar);\r\n        return this;\r\n    }\r\n\r\n    divideByScalar = (k: any): Vector => {\r\n        return this.multiplyByScalar(new Fraction(k).invert());\r\n    }\r\n    // ------------------------------------------\r\n    // Vector functions\r\n    // ------------------------------------------\r\n\r\n    simplify = (): Vector => {\r\n        // Multiply by the lcm of denominators.\r\n        return this.multiplyByScalar(Numeric.lcm(this._x.denominator, this._y.denominator))\r\n            .divideByScalar(Numeric.gcd(this._x.numerator, this._y.numerator));\r\n    }\r\n\r\n    angleWith = (V: Vector, sharp?: Boolean, radian?: Boolean): number => {\r\n        let scalar = this.scalarProductWithVector(V).value,\r\n            toDegree = radian ? 1 : 180 / Math.PI;\r\n        if (sharp) {\r\n            scalar = Math.abs(scalar);\r\n        }\r\n\r\n        return toDegree * Math.acos(scalar / (this.norm * V.norm));\r\n    }\r\n}\r\n","export class Numeric{\r\n    static round(value:number, decimals:number=2):number {\r\n        return Number(Math.round(Number(value+'e'+decimals))+'e-'+decimals);\r\n    }\r\n\r\n    /**\r\n     * Get the list of the nth first prime numbers.\r\n     * @param nb : number of primes to choose from\r\n     */\r\n    static prime(nb?:number):number[]{\r\n        let primes:number[] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973];\r\n        if(nb === undefined){\r\n            return primes;\r\n        }else{\r\n            return primes.slice(0,Math.max(primes.length,nb));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the list of all dividers of a number.\r\n     * @param value\r\n     */\r\n    static dividers(value:number):number[]{\r\n        let D: number[];\r\n        const maxV = Math.sqrt(Math.abs(value));\r\n\r\n        // Initialize the list of dividers.\r\n        D = [];\r\n\r\n        for(let i=1; i<=maxV; i++){\r\n            if(value%i===0){\r\n                D.push(i);\r\n                D.push(value/i);\r\n            }\r\n        }\r\n\r\n        // Order numbers.\r\n        D.sort(function(a, b){return a-b;});\r\n\r\n        // Make sure the array of value is unique.\r\n        return [...new Set(D)];\r\n    }\r\n    /**\r\n     * Great Common Divisor\r\n     * @param values : number values\r\n     */\r\n    static gcd(...values:number[]):number{\r\n        // Define the gcd for two number\r\n        let gcd2 = function(a:number,b:number):number{\r\n            if(b===0){return a;}\r\n            return gcd2(b, a%b);\r\n        };\r\n\r\n        let g:number = 1,\r\n            i:number = 2;\r\n\r\n        // Nothing is given\r\n        if(values.length===0){return 1;}\r\n        // Only one number is given\r\n        if(values.length===1){\r\n            // The first number is zero\r\n            if(values[0]===0){return 1;}\r\n            // Return the number\r\n            return values[0];\r\n        }\r\n\r\n        // We have at least 2 numbers.\r\n        g = gcd2(values[0],values[1]);\r\n\r\n        // The gcd of the two first value is one ? It's already finished.\r\n        if(g===1){return 1;}\r\n\r\n        // The current gcd isn't one. Continue with all next values.\r\n        for(i=2; i<values.length; i++){\r\n            g = gcd2(g, values[i]);\r\n            // Escape if gcd is already one.\r\n            if(g===1){break;}\r\n        }\r\n\r\n        return Math.abs(g);\r\n    }\r\n\r\n    /**\r\n     * Least Common Multiple\r\n     * @param values: list of numbers\r\n     */\r\n    static lcm(...values:number[]):number{\r\n        return values.reduce(function(a,b){\r\n            return Math.abs(a * b / Numeric.gcd(a, b));\r\n        });\r\n    }\r\n\r\n    static pythagoricianTripletsWithTarget(target: number, targetIsSquare?:boolean): number[][] {\r\n        // mthode inverse,  partir du triplet.\r\n        const triplets = [],\r\n            targetValue = targetIsSquare===true?+target:target**2\r\n        for(let u = 0; u <= target; u++){\r\n            for(let v = 0; v <=target; v++){\r\n                if(u**2+v**2===targetValue){\r\n                    triplets.push([u, v, target])\r\n                }\r\n            }\r\n        }\r\n\r\n        return triplets\r\n    }\r\n}","import {rndPolynom} from \"./rndPolynom\";\r\nimport {rndMonom} from \"./rndMonom\";\r\nimport {rndHelpers} from \"./rndHelpers\";\r\nimport {randomCoefficientConfig, randomMonomConfig, randomPolynomConfig} from \"./rndTypes\";\r\nimport {rndFraction} from \"./rndFraction\";\r\nimport {Polynom} from \"../algebra/polynom\";\r\nimport {Monom} from \"../algebra/monom\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\nexport * from \"./rndTypes\"\r\n\r\nexport namespace Random {\r\n    export function polynom(config?: randomPolynomConfig): Polynom {\r\n        return (new rndPolynom(config)).generate()\r\n    }\r\n\r\n    export function monom(config?: randomMonomConfig): Monom {\r\n        return (new rndMonom(config)).generate()\r\n    }\r\n\r\n    export function fraction(config?: randomCoefficientConfig): Fraction {\r\n        return (new rndFraction(config)).generate()\r\n    }\r\n\r\n    export function number(from: number, to: number): number {\r\n        return rndHelpers.randomInt(from, to)\r\n    }\r\n\r\n    export function numberSym(max: number, allowZero?: boolean): number {\r\n        return rndHelpers.randomIntSym(max, allowZero)\r\n    }\r\n\r\n    export function bool(percent?: number): boolean {\r\n        return rndHelpers.randomBool(percent)\r\n    }\r\n\r\n    export function array(arr: any[], number?: number): any[] {\r\n        return rndHelpers.randomArray(arr, number)\r\n    }\r\n\r\n    export function item(arr: any[]): any {\r\n        return rndHelpers.randomItem(arr)\r\n    }\r\n\r\n    export function shuffle(arr: any[]): any {\r\n        rndHelpers.shuffleArray(arr)\r\n    }\r\n}","export class randomCore {\r\n    protected _config: Object\r\n    protected _defaultConfig: Object\r\n    mergeConfig = (config: Object, defaultConfig: Object): Object => {\r\n        if (config !== undefined) {\r\n            return {...defaultConfig, ...config}\r\n        }\r\n        return defaultConfig\r\n    }\r\n\r\n    generate = (): unknown => {\r\n        return undefined\r\n    }\r\n\r\n    config = (config: Object): randomCore => {\r\n        this._config = this.mergeConfig(config, this._defaultConfig)\r\n        return this\r\n    }\r\n}","import {randomCore} from \"./randomCore\";\r\nimport {randomCoefficientConfig, randomMonomConfig, randomPolynomConfig} from \"./rndTypes\";\r\nimport {Random} from \"./random\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\n/**\r\n * Create a random monom based on a based configuration\r\n */\r\nexport class rndFraction extends randomCore {\r\n    declare protected _config: randomCoefficientConfig\r\n    declare protected _defaultConfig: randomCoefficientConfig\r\n\r\n    constructor(userConfig?: randomCoefficientConfig) {\r\n        super();\r\n\r\n        this._defaultConfig = {\r\n            negative: true,\r\n            max: 10,\r\n            reduced: true,\r\n            zero: true,\r\n            natural: false\r\n        }\r\n\r\n        this._config = this.mergeConfig(userConfig, this._defaultConfig)\r\n    }\r\n\r\n    generate = (): Fraction => {\r\n        let Q = new Fraction()\r\n\r\n        if(this._config.negative){\r\n            Q.numerator = Random.numberSym(this._config.max, this._config.zero)\r\n        }else {\r\n            Q.numerator = Random.number(this._config.zero ? 0 : 1, this._config.max)\r\n        }\r\n        if(this._config.natural){\r\n            Q.denominator = 1\r\n        }else {\r\n            Q.denominator = Random.number(1, this._config.max)\r\n        }\r\n\r\n        return this._config.reduced?Q.reduce():Q\r\n    }\r\n}\r\n","/**\r\n * Random helpers\r\n */\r\nexport class rndHelpers {\r\n\r\n    /**\r\n     * Random boolean with a percent ratio\r\n     * @param percent\r\n     */\r\n    static randomBool(percent:number=0.5):boolean{\r\n        return Math.random()<percent;\r\n    }\r\n\r\n    /**\r\n     * Random integer between two values.\r\n     * @param a (number) : From this value to the second value. If the second is ommited, this value is the max value.\r\n     * @param b (number) : To this value. If this is ommited.\r\n     */\r\n    static randomInt(a:number, b?:number):number{\r\n        if(b===undefined){return this.randomInt(0,a);}\r\n\r\n        return Math.floor(Math.random() * (b - a + 1) + a);\r\n    }\r\n\r\n    /**\r\n     * Random integer between -max and max value.\r\n     * @param max (number) : determine the limits.\r\n     * @param zero (bool) : determine if zero is allowed or not.\r\n     */\r\n    static randomIntSym(max:number, zero?:boolean):number{\r\n        if(zero===false){\r\n            return this.randomBool()?this.randomInt(1,max):-this.randomInt(1,max);\r\n        }else{\r\n            return this.randomInt(-max, max);\r\n        }\r\n    }\r\n\r\n    static randomArray(arr: any[], number?:number):any[]{\r\n        if(number===undefined){number = 1}\r\n\r\n        // Return a clone array\r\n        if(arr.length<=0){return Object.values(arr)}\r\n\r\n        // Randomize the array and return the n first elements.\r\n        return rndHelpers.shuffleArray(arr).slice(0,number);\r\n    }\r\n\r\n    static randomItem(arr: any[]): any{\r\n        if(arr.length===0){return ''}\r\n        return this.randomArray(arr, 1)[0]\r\n    }\r\n\r\n    static shuffleArray(arr: any[]): any[] {\r\n        // The Fisher-Yates algorithm\r\n        let shuffleArray = Object.values(arr)\r\n        for (let i = shuffleArray.length - 1; i > 0; i--) {\r\n            const j = Math.floor(Math.random() * (i + 1));\r\n            const temp = shuffleArray[i];\r\n            shuffleArray[i] = shuffleArray[j];\r\n            shuffleArray[j] = temp;\r\n        }\r\n\r\n        return shuffleArray;\r\n    }\r\n\r\n}","import {randomCore} from \"./randomCore\";\r\nimport {randomMonomConfig} from \"./rndTypes\";\r\nimport {Random} from \"./random\";\r\nimport {Monom} from \"../algebra/monom\";\r\n\r\n/**\r\n * Create a random monom based on a based configuration\r\n */\r\nexport class rndMonom extends randomCore {\r\n    declare protected _config: randomMonomConfig\r\n    declare protected _defaultConfig: randomMonomConfig\r\n\r\n    constructor(userConfig?: randomMonomConfig) {\r\n        super();\r\n\r\n        this._defaultConfig = {\r\n            letters: 'x',\r\n            degree: 2,\r\n            fraction: true,\r\n            zero: false\r\n        }\r\n\r\n        this._config = this.mergeConfig(userConfig, this._defaultConfig)\r\n    }\r\n\r\n    generate = (): Monom => {\r\n        // Create a monom instance\r\n        let M = new Monom()\r\n\r\n        // Generate the coefficient\r\n        if (typeof this._config.fraction === \"boolean\") {\r\n            M.coefficient = Random.fraction({\r\n                zero: this._config.zero,\r\n                reduced: true,\r\n                natural: !this._config.fraction\r\n            })\r\n        } else {\r\n            M.coefficient = Random.fraction(this._config.fraction)\r\n        }\r\n\r\n        // Calculate the degree of the monom\r\n        if (this._config.letters.length > 1) {\r\n            // Initialise each items...\r\n            for (let L of this._config.letters.split('')) {\r\n                M.setLetter(L, 0);\r\n            }\r\n            for (let i = 0; i < this._config.degree; i++) {\r\n                const L = Random.item(this._config.letters.split(\"\"))\r\n                M.setLetter(L, M.degree(L).clone().add(1))\r\n            }\r\n        } else {\r\n            M.setLetter(this._config.letters, this._config.degree)\r\n        }\r\n\r\n        return M\r\n    }\r\n}\r\n","import {randomCore} from \"./randomCore\";\r\nimport {randomPolynomConfig} from \"./rndTypes\";\r\nimport {rndMonom} from \"./rndMonom\";\r\nimport {Random} from \"./random\";\r\nimport {Polynom} from \"../algebra/polynom\";\r\nimport {Monom} from \"../algebra/monom\";\r\n\r\n/**\r\n * Random polynoms\r\n */\r\nexport class rndPolynom extends randomCore {\r\n    declare protected _config: randomPolynomConfig\r\n    declare protected _defaultConfig: randomPolynomConfig\r\n\r\n    constructor(userConfig?: randomPolynomConfig) {\r\n        super();\r\n\r\n        // Default config for a random polynom\r\n        this._defaultConfig = {\r\n            letters: 'x',\r\n            degree: 2,\r\n            fraction: false,\r\n            zero: false,\r\n            unit: false,\r\n            factorable: false,\r\n            allowNullMonom: true,\r\n            numberOfMonoms: 0,\r\n            positive: true\r\n        }\r\n\r\n        // Merge config with initialiser\r\n        this._config = this.mergeConfig(userConfig, this._defaultConfig)\r\n    }\r\n\r\n    generate = (): Polynom => {\r\n        if(this._config.factorable && this._config.degree>1){\r\n            return this.factorable()\r\n        }\r\n\r\n        // Create the polynom\r\n        let P = new Polynom().empty(),\r\n            M: Monom\r\n\r\n        for (let i = this._config.degree; i >= 0; i--) {\r\n            // Create monom of corresponding degree.\r\n            M = new rndMonom({\r\n                letters: this._config.letters,\r\n                degree: i,\r\n                fraction: this._config.fraction,\r\n                zero: (i === this._config.degree) ? false : this._config.allowNullMonom\r\n            }).generate()\r\n\r\n            // If degree is the greatest and unit is true, set the monom value to one.\r\n            if (this._config.unit && this._config.degree === i) {\r\n                M.coefficient.one()\r\n            }\r\n\r\n            // Add to the polynom\r\n            P.add(M)\r\n        }\r\n\r\n        // Make sure the first monom is positive.\r\n        if(this._config.positive && P.monomByDegree().coefficient.isNegative()){\r\n            P.monomByDegree().coefficient.opposed()\r\n        }\r\n\r\n        // If the number of monoms is greater than the allowed value, remove some of them... except the first one !\r\n        if (this._config.numberOfMonoms > 0 && this._config.numberOfMonoms < P.length) {\r\n            // Get the greatest degree monom\r\n            let M = P.monomByDegree().clone()\r\n            P.monoms = Random.array(P.monoms.slice(1), this._config.numberOfMonoms-1)\r\n            P.add(M).reorder().reduce()\r\n        }\r\n        return P\r\n    }\r\n\r\n    factorable = (): Polynom => {\r\n        let P = new Polynom().one()\r\n\r\n        let _factorableConfig = {...this._config}\r\n        _factorableConfig.degree = 1\r\n        _factorableConfig.factorable = false\r\n\r\n        for(let i=0; i<this._config.degree;i++){\r\n            P.multiply(Random.polynom(_factorableConfig))\r\n        }\r\n\r\n        return P\r\n    }\r\n}","export type tokenType = {\r\n    [key: string]: {\r\n        precedence: number,\r\n        associative: string,\r\n        type: string\r\n    }\r\n}\r\n\r\nexport const tokenConstant: { [Key: string]: number } = {\r\n    pi: Math.PI,\r\n    e: Math.exp(1)\r\n}\r\n\r\nexport enum ShutingyardType {\r\n    VARIABLE = 'variable',\r\n    COEFFICIENT = 'coefficient',\r\n    OPERATION = 'operation',\r\n    CONSTANT = 'constant',\r\n    FUNCTION = 'function',\r\n    MONOM = 'monom'\r\n}\r\n\r\nexport enum ShutingyardMode {\r\n    POLYNOM = 'polynom',\r\n    SET = 'set',\r\n    NUMERIC = 'numeric'\r\n}\r\n\r\nexport type Token = { token: string, tokenType: string }\r\n\r\nexport class Shutingyard {\r\n    readonly _mode: ShutingyardMode;\r\n    private _tokenConfig: tokenType;\r\n    private _tokenConstant: { [Key: string]: number }\r\n    private _tokenKeys: string[]\r\n    private _uniformize: boolean;\r\n\r\n    constructor(mode?: ShutingyardMode) {\r\n        this._mode = typeof mode === 'undefined' ? ShutingyardMode.POLYNOM : mode;\r\n        this.tokenConfigInitialization()\r\n    }\r\n\r\n    private _rpn: Token[] = [];\r\n\r\n    // Getter\r\n    get rpn() {\r\n        // console.log(this._rpn)\r\n        return this._rpn;\r\n    }\r\n\r\n    /**\r\n     * Determin if the token is a defined operation\r\n     * Defined operations: + - * / ^ sin cos tan\r\n     * @param token\r\n     */\r\n    // isOperation(token: string): boolean {\r\n    //     if (token[0].match(/[+\\-*/^]/g)) {\r\n    //         return true;\r\n    //     }\r\n    //     //\r\n    //     // if (token.match(/^sin|cos|tan/g)) {\r\n    //     //     return true;\r\n    //     // }\r\n    //\r\n    //     return false;\r\n    // }\r\n\r\n    tokenConfigInitialization(): tokenType {\r\n        if (this._mode === ShutingyardMode.SET) {\r\n            this._tokenConfig = {\r\n                '&': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '|': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '!': {precedence: 4, associative: 'right', type: ShutingyardType.OPERATION},\r\n                '-': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION}\r\n            }\r\n            this._uniformize = false;\r\n        } else if (this._mode === ShutingyardMode.NUMERIC) {\r\n            this._tokenConfig = {\r\n                '^': {precedence: 4, associative: 'right', type: ShutingyardType.OPERATION},\r\n                '*': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '/': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '+': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '-': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '%': {precedence: 3, associative: 'right', type: ShutingyardType.OPERATION},\r\n                'sin': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'cos': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'tan': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                'sqrt': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n            }\r\n            this._uniformize = false\r\n        } else {\r\n            this._tokenConfig = {\r\n                '^': {precedence: 4, associative: 'right', type: ShutingyardType.OPERATION},\r\n                '*': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '/': {precedence: 3, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '+': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION},\r\n                '-': {precedence: 2, associative: 'left', type: ShutingyardType.OPERATION},\r\n                // '%': {precedence: 3, associative: 'right', type: ShutingyardType.OPERATION},\r\n                // 'sin': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                // 'cos': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n                // 'tan': {precedence: 4, associative: 'right', type: ShutingyardType.FUNCTION},\r\n            }\r\n            this._uniformize = true\r\n        }\r\n\r\n        this._tokenKeys = Object.keys(this._tokenConfig).sort((a, b) => b.length - a.length)\r\n        return this._tokenConfig\r\n    }\r\n\r\n    /**\r\n     * Get the next token to analyse.\r\n     * @param expr (string) Expression to analyse\r\n     * @param start (number) CUrrent position in the expr string.\r\n     */\r\n    NextToken(expr: string, start: number): [string, number, string] {\r\n        let token: string, tokenType: string;\r\n        token = '';\r\n        tokenType = '';\r\n        // Case of parenthesis or comma (generic items)\r\n        if (expr[start] === '(') {\r\n            token = '(';\r\n            tokenType = '(';\r\n        }\r\n        // It's a closing parenthese\r\n        else if (expr[start] === ')') {\r\n            token = ')';\r\n            tokenType = ')';\r\n        }\r\n        // It's an argument separator for a function\r\n        else if (expr[start] === ',') {\r\n            token = ',';\r\n            tokenType = 'function-argument';\r\n        } else {\r\n            // Order token keys by token characters length (descending)\r\n            // TODO: this is done each time ! SHould be done once !\r\n            // const keys = Object.keys(this._tokenConfig).sort((a,b)=>b.length-a.length)\r\n\r\n            // Extract operation and function tokens\r\n            for (let key of this._tokenKeys) {\r\n                if (expr.substring(start, start + key.length) === key) {\r\n                    token += key;\r\n                    tokenType = this._tokenConfig[key].type\r\n                    break\r\n                }\r\n            }\r\n\r\n            // Extract constant\r\n            for (let key in tokenConstant) {\r\n                if (expr.substring(start, start + key.length) === key) {\r\n                    token += key;\r\n                    tokenType = ShutingyardType.CONSTANT\r\n                    break\r\n                }\r\n            }\r\n\r\n            if (token === '') {\r\n                // No function found ! Might be a coefficient !\r\n                if (expr[start].match(/[0-9]/)) {\r\n                    if (this._mode === ShutingyardMode.POLYNOM && false) {\r\n                        token = expr.substring(start).match(/^([0-9.,/]+)/)[0]\r\n                    } else {\r\n                        token = expr.substring(start).match(/^([0-9.,]+)/)[0]\r\n                    }\r\n                    tokenType = ShutingyardType.COEFFICIENT\r\n                } else if (expr[start].match(/[a-zA-Z]/)) {\r\n                    token = expr.substring(start).match(/^([a-zA-Z])/)[0]\r\n                    tokenType = ShutingyardType.VARIABLE\r\n                } else {\r\n                    console.log('Unidentified token', expr[start], expr, start)\r\n                    token = expr[start]\r\n                    tokenType = ShutingyardType.MONOM\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        return [token, start + token.length, tokenType];\r\n    }\r\n\r\n    /**\r\n     * Sanitize an expression by adding missing common operation (multiplication between parentheseses)\r\n     * @param expr\r\n     * @constructor\r\n     */\r\n    Uniformizer(expr: string): string {\r\n        // Determiner if need to be uniformized\r\n        if (!this._uniformize) {\r\n            return expr\r\n        }\r\n\r\n        let expr2;\r\n        // Replace missing multiplication between two parenthese\r\n        expr2 = expr.replace(/\\)\\(/g, ')*(');\r\n\r\n        // Replace missing multiplication between number or setLetter and parenthese.\r\n\r\n        // 3x(x-4) => 3x*(x-4)\r\n        expr2 = expr2.replace(/([\\da-zA-Z])(\\()/g, \"$1*$2\");\r\n\r\n        // (x-4)3x => (x-4)*3x\r\n        expr2 = expr2.replace(/(\\))([\\da-zA-Z])/g, \"$1*$2\");\r\n\r\n        // Add multiplication between number and letters.\r\n        // 3x => 3*x\r\n        expr2 = expr2.replace(/([0-9])([a-zA-Z])/g, \"$1*$2\");\r\n        expr2 = expr2.replace(/([a-zA-Z])([0-9])/g, \"$1*$2\");\r\n\r\n        // Add multiplication between letters ?\r\n        // TODO: More robust solution to handle all letters ?\r\n        expr2 = expr2.replace(/([abcxyz])([abcxyz])/g, \"$1*$2\");\r\n\r\n        // Restore operation auto formating (prevent adding the mutliplcation star)\r\n        // TODO: Accept list of functions\r\n        let fnToken = ['sin', 'cos', 'tan']\r\n        for (let token of fnToken) {\r\n            expr2 = expr2.replace(new RegExp(token + '\\\\*', 'g'), token);\r\n        }\r\n\r\n        return expr2;\r\n    }\r\n\r\n    /**\r\n     * Parse an expression using the shutting yard tree algorithms\r\n     * @param expr (string) Expression to analyse\r\n     * Returns a RPN list of items.\r\n     * @param operators\r\n     */\r\n    parse(expr: string, operators?: string[]): Shutingyard {\r\n        let outQueue: { token: string, tokenType: string }[] = [],    // Output queue\r\n            opStack: { token: string, tokenType: string }[] = [],     // Operation queue\r\n            token: string = '',\r\n            tokenPos: number = 0,\r\n            tokenType: string = '',\r\n            previousOpStatckLength = 0\r\n\r\n        expr = this.Uniformizer(expr);\r\n\r\n        let securityLoopLvl1 = 50,\r\n            securityLoopLvl2_default = 50,\r\n            securityLoopLvl2;\r\n\r\n        while (tokenPos < expr.length) {\r\n            securityLoopLvl1--;\r\n            if (securityLoopLvl1 === 0) {\r\n                console.log('SECURITY LEVEL 1 EXIT');\r\n                break;\r\n            }\r\n\r\n            // Get the next token and the corresponding new (ending) position\r\n            [token, tokenPos, tokenType] = this.NextToken(expr, tokenPos);\r\n\r\n            switch (tokenType) {\r\n                case 'monom':\r\n                case 'coefficient':\r\n                case 'variable':\r\n                case 'constant':\r\n                    outQueue.push({\r\n                        token,\r\n                        tokenType\r\n                    });\r\n                    // if(previousOpStatckLength == opStack.length && outQueue.length>=2){\r\n                    //     console.log('opStatckLength', outQueue, opStack.length)\r\n                    //     outQueue.push('*')\r\n                    // }\r\n                    break;\r\n                case 'operation':\r\n                    previousOpStatckLength = opStack.length;\r\n                    //If the token is an operator, o1, then:\r\n                    if (opStack.length > 0) {\r\n                        let opTop = opStack[opStack.length - 1];\r\n\r\n\r\n                        securityLoopLvl2 = +securityLoopLvl2_default;\r\n\r\n                        //while there is an operator token o2, at the top of the operator stack and\r\n                        while (opTop.token in this._tokenConfig && (\r\n                                //either o1 is left-associative and its precedence is less than or equal to that of o2,\r\n                                (this._tokenConfig[token].associative === 'left' && this._tokenConfig[token].precedence <= this._tokenConfig[opTop.token].precedence)\r\n                                ||\r\n                                //or o1 is right associative, and has precedence less than that of o2,\r\n                                (this._tokenConfig[token].associative === 'right' && this._tokenConfig[token].precedence < this._tokenConfig[opTop.token].precedence)\r\n                            )\r\n                            ) {\r\n\r\n                            /* Security exit ! */\r\n                            securityLoopLvl2--;\r\n                            if (securityLoopLvl2 === 0) {\r\n                                console.log('SECURITY LEVEL 2 OPERATION EXIT');\r\n                                break;\r\n                            }\r\n\r\n                            // Add the operation to the queue\r\n                            outQueue.push((opStack.pop()) || {token: '', tokenType: 'operation'});\r\n\r\n                            // Get the next operation on top of the Stack.\r\n                            if (opStack.length === 0) {\r\n                                break;\r\n                            }\r\n                            opTop = opStack[opStack.length - 1];\r\n                        }\r\n                    }\r\n                    //at the end of iteration push o1 onto the operator stack\r\n                    opStack.push({token, tokenType});\r\n                    break;\r\n                case 'function-argument':\r\n                    // TODO: check if the opStack exist.\r\n                    securityLoopLvl2 = +securityLoopLvl2_default;\r\n                    while (opStack[opStack.length - 1].token !== '(' && opStack.length > 0) {\r\n                        securityLoopLvl2--;\r\n                        if (securityLoopLvl2 === 0) {\r\n                            console.log('SECURITY LEVEL 2 FUNCTION ARGUMENT EXIT');\r\n                            break;\r\n                        }\r\n\r\n                        outQueue.push((opStack.pop()) || {token, tokenType});\r\n                    }\r\n                    break;\r\n                case '(':\r\n                    opStack.push({token, tokenType});\r\n                    // Add an empty value if next element is negative.\r\n                    if (expr[tokenPos] === '-') {\r\n                        outQueue.push({token: '0', tokenType: 'coefficient'});\r\n                    }\r\n                    break;\r\n                case ')':\r\n                    securityLoopLvl2 = +securityLoopLvl2_default;\r\n                    //Until the token at the top of the stack is a left parenthesis, pop operators off the stack onto the output queue.\r\n                    while (opStack[opStack.length - 1].token !== '(' && opStack.length > 1 /*Maybe zero !? */) {\r\n                        securityLoopLvl2--;\r\n                        if (securityLoopLvl2 === 0) {\r\n                            console.log('SECURITY LEVEL 2 CLOSING PARENTHESE EXIT');\r\n                            break;\r\n                        }\r\n\r\n                        outQueue.push((opStack.pop()) || {token, tokenType});\r\n                    }\r\n\r\n                    //Pop the left parenthesis from the stack, but not onto the output queue.\r\n                    opStack.pop();\r\n                    break;\r\n                case 'function':\r\n                    opStack.push({token, tokenType});\r\n                    break;\r\n                default:\r\n                    // In theory, everything should be handled.\r\n                    console.log(`SHUTING YARD: ${tokenType} : ${token} `);\r\n            }\r\n\r\n            // Output\r\n            // console.log(outQueue.concat(opStack.reverse()).join(\" \"));\r\n        }\r\n\r\n        // console.log(outQueue.concat(opStack.reverse()));\r\n        this._rpn = outQueue.concat(opStack.reverse());\r\n\r\n        return this;\r\n    }\r\n\r\n\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(607);\n"],"names":["ShutingYard","Shutingyard","Numeric","NumExp","Fraction","Root","NthRoot","Monom","Polynom","Equation","LinearSystem","Rational","Logicalset","Random","PolynomExpFactor","PolynomExpProduct","Geometry","Vector","Point","Line","Triangle","Circle","window","Pi","PARTICULAR_SOLUTION","constructor","equations","_varnothing","varnothing","_real","real","_randomizeDefaults","degree","parse","equationString","pStr","strSign","this","_findSign","split","create","_formatSign","console","error","left","right","sign","_left","_right","_sign","clone","randomize","opts","moveLeft","subtract","zero","reorder","allLeft","mMove","m","monoms","isZero","simplify","multiply","lcm","getDenominators","divide","gcd","getNumerators","isolate","letter","isOne","isMultiVariable","cMove","hasLetter","add","opposed","length","coefficient","replaceBy","P","value","F","_reverseSign","invert","max","letters","Set","solve","_solutions","_polynom","_solveDegree1","_solveDegree2","_solveDegree3plus","makeSolutionsUnique","test","values","evaluate","isEqual","includes","log","signStr","undefined","replace","isGreater","indexOf","isStrictEqual","isAlsoEqual","m1","monomByDegree","m0","v","s","tex","NaN","exact","delta","nthDelta","realX1","realX2","sX1","sX2","aF","bF","cF","denominator","a","b","Math","sqrt","toFixed","reduce","hasRadical","S1","S2","dfrac","sol","equ","factorize","factors","forEach","factor","leq","factorAsEquation","solutions","solution","push","isEquation","map","x","join","isReal","isVarnothing","signAsTex","display","raw","variables","concat","numberOfVars","randomizeDefaults","static","sorted","solutionAsTex","uniqueSolutions","filter","sort","equationStrings","_equations","_findLetters","setCoefficient","coefficients","i","_letters","slice","toString","setLetters","generate","solutionsF","_generateOneEquation","coeff","leftValue","equString","numberSym","_checkIfLinerCombination","mergeEquations","eq1","eq2","factor1","factor2","eq1multiplied","eq2multiplied","E","_resolutionSteps","V","_solveOneLetter","str","isSolvable","equStr","LS","equArray","L","monomByLetter","repeat","_linearReduction","c1","c2","LE","reducedEquations","_rpn","ShutingyardMode","SET","rpn","_rawString","isLogicalset","tokenSets","reference","referenceSet","varStack","key","token","tokenType","second","pop","first","has","vennAB","A","B","vennABC","C","inputStr","_shutingYardToReducedMonom","_coefficient","_literal","copyLiterals","literal","stack","element","one","setLetter","addToken","k","makeSame","M","clean","isSameAs","multiplyByNumber","pow","nb","root","p","isSquare","compare","M1","M2","K","item","isLiteralSquare","isRational","isEven","hasFractionCoefficient","isNotZero","Object","t","n","r","tmpValues","derivative","d","dM","primitive","areSameAs","areEquals","literalSqrt","literalStr","matchAll","keys","isNotEqual","dividers","isRelative","numerator","abs","literals","_getLiteralDividers","monomDividers","N","arr","tmpList","litt","currentLetter","displayWithSign","texWithSign","isStrictlyPositive","tfrac","q1","q2","ShutingyardType","COEFFICIENT","VARIABLE","OPERATION","coeffN","coeffD","min","xmultiply","polynomString","_monoms","_factors","_parseString","empty","Number","isSafeInteger","multiplyByPolynom","multiplyByFraction","multiplyByMonom","multiplyByInteger","euclidian","quotient","reminder","maxMP","degreeP","newM","MaxIteration","geq","isPositive","divideByFraction","divideByInteger","cP1","cP2","isOpposedAt","isFactorized","match","e","polynomStringNormalized","replaceAll","polynomStringReduced","substr","polyFactors","f","splice","isDeveloped","j","S","resultPolynom","monom","dP","integrate","valuesA","valuesB","tempPolynom","commonMonom","result","securityLoop","m2","m1d","m2d","dividerPolynom","getZeroes","monomsByDegree","Ms","denominators","numerators","lcmDenominator","gcdDenominator","lcmNumerator","gcdNumerator","limitToInfinity","infinite","limitToNegativeInfinity","genDisplay","output","forceSign","wrapParentheses","shutingYardToReducedPolynom","nbF","_factorize2ndDegree","P1","P2","c","x1","x2","xyzPolynom","xFactors","_factorizeByGroups","texString","_texString","texFactors","isNaN","fractions","CONSTANT","MONOM","FUNCTION","_numerator","_denominator","domain","zeroes","amplify","D","dN","dD","NumeratorEuclidien","DenominatorEuclidien","R","limits","offset","Infinity","theLimit","theSign","evalValues","evalValuesOffset","FR","isInfinity","makeTableOfSigns","NFactors","DFactors","tableOfSigns","_makeOneLineOfTableOfSigns","resultLine","index","current","tos","signs","_makeTexFromTableOfSigns","list","zeroSign","oneLine","currentZero","denominatorOrPeriodic","floor","invalid","Q","controlNumerator","g","compareFraction","lesser","than","greater","isOpposed","isInverted","isNegativeOne","isNegative","isStrictlyNegative","isFinite","isReduced","isNatural","isOdd","frac","average","unique","distinct","reverse","radical","nthroot","_nth","_radical","_isValid","nth","_expression","NUMERIC","isValid","expression","_extractDecimalPart","decimal","substring","_numberCorrection","epsilon","n9","n0","mod0","mod9","_addToStack","tokenConstant","sin","cos","tan","polynom","mathFunction","_degree","_fn","_powerAsInteger","_forceParenthesis","forceParenthesis","fn","powerAsInteger","isCoefficient","firstCoefficient","_texDegree","setForceParenthesis","_positive","_asPositiveDegree","positive","asPositiveDegree","parenthesis","numeratorsAsTex","denominatorsAsTex","name","polynoms","d1","d2","_integrateWithInternalDerivative","applyMathFunction","mathFn","Pinternal","internalDerivative","relativePosition","distance","distanceTo","center","radius","_squareRadius","lineIntersection","solX","intersectionPoints","_cartesian","equX","lineX","equation","lineY","tangents","_tangentsWithSlope","isPointOnCircle","_tangentsThroughOnePointOnTheCircle","_tangentsThroughOnePointOutsideTheCircle","y","getPointsOnCircle","numberIsInteger","pt","triplets","pythagoricianTripletsWithTarget","points","triplet","isInListOfPoints","CT","_center","LinePropriety","Perpendicular","cx_px","cy_py","polyLeft","polyRight","squareRadius","h","slope","sq","_exists","cartesian","exists","cx","cy","developed","_calculateCartesian","_reset","_parseEquation","_parseCopyCircle","_parseThroughtThreePoints","_parseCenterAndPointThrough","_parseCenterAndRadius","circle","square","pointThrough","normSquare","y1","y2","T","mAB","remarquables","mediators","AB","mAC","AC","intersection","point","parseEquation","parseByPointAndVector","parseByPointAndNormal","parseByCoefficient","Parallel","parseByPointAndLine","elem","delete","size","_a","_b","_c","_d","_OA","_n","normal","orientation","director","isParellelTo","line","height","isVertical","simplifyDirection","Pt","isParallel","isSame","hasIntersection","getValueAtX","getValueAtY","canonical","mxh","OA","parametric","pmatrix","fraction","hitSegment","iPt","canonicalAsFloatCoefficient","decimals","PERPENDICULAR","PARALLEL","_x","_y","xy","origin","middleOf","texValues","numberOfDigits","pts","norm","_lines","intersect","_B","_C","_A","_updateTriangle","BC","_middles","_remarquables","_calculateRemarquableLines","getPointByName","ptName","toUpperCase","getSegment","ptName1","ptName2","_calculateBisectors","medians","heights","bisectors","tlines","lines","b1","b2","BA","CB","CA","isRectangle","isNormalTo","isEquilateral","isIsocele","reset","components","scalarProductWithVector","multiplyByScalar","scalar","divideByScalar","angleWith","sharp","radian","toDegree","PI","acos","scalarProduct","v1","v2","round","primes","maxV","gcd2","target","targetIsSquare","targetValue","u","config","rndPolynom","rndMonom","rndFraction","number","from","to","rndHelpers","randomInt","allowZero","randomIntSym","bool","percent","randomBool","array","randomArray","randomItem","shuffle","shuffleArray","mergeConfig","defaultConfig","_config","_defaultConfig","randomCore","userConfig","super","negative","natural","reduced","random","temp","factorable","allowNullMonom","unit","numberOfMonoms","_factorableConfig","pi","exp","mode","_mode","POLYNOM","tokenConfigInitialization","_tokenConfig","precedence","associative","type","_uniformize","_tokenKeys","NextToken","expr","start","Uniformizer","expr2","fnToken","RegExp","operators","outQueue","opStack","tokenPos","previousOpStatckLength","securityLoopLvl2","securityLoopLvl1","opTop","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call"],"sourceRoot":""}