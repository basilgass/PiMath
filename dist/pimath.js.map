{"version":3,"file":"pimath.js","sources":["../src/numeric.ts","../src/coefficients/fraction.ts","../src/coefficients/nthRoot.ts","../src/algebra/equationSolver.ts","../node_modules/piexpression/dist/piexpression.js","../src/algebra/monom.ts","../src/helpers.ts","../src/algebra/operations.ts","../src/algebra/polynom.ts","../src/algebra/equation.ts","../src/algebra/factor.ts","../src/algebra/linearSystem.ts","../src/algebra/logicalset.ts","../src/algebra/polyFactor.ts","../src/algebra/matrix.ts","../src/geometry/geomMath.ts","../src/geometry/TupleN.ts","../src/coefficients/root.ts","../src/geometry/point.ts","../src/geometry/vector.ts","../src/pimath.interface.ts","../src/randomization/rndHelpers.ts","../src/geometry/line.ts","../src/geometry/triangle.ts","../src/analyze/solution.ts","../src/geometry/circle.ts","../src/geometry/line3.ts","../src/geometry/plane3.ts","../src/geometry/sphere3.ts","../src/randomization/coefficient/rndFraction.ts","../src/randomization/algebra/rndMonom.ts","../src/randomization/algebra/rndPolynom.ts","../src/randomization/algebra/rndEquation.ts","../src/randomization/geometry/rndVector.ts","../src/randomization/geometry/rndCircle.ts","../src/randomization/geometry/rndLine.ts","../src/randomization/geometry/rndLine3.ts","../src/randomization/random.ts","../src/index.ts"],"sourcesContent":["\r\nfunction decompose(value: number): number[][] {\r\n    const divs: number[] = dividers(value)\r\n    const arr: number[][] = []\r\n    let u, v\r\n\r\n    while (divs.length > 0) {\r\n        u = divs.shift() ?? 1\r\n        v = (divs.length > 0 ? divs.pop() : +u) ?? 1\r\n\r\n        arr.push([u, v])\r\n    }\r\n\r\n    return arr\r\n}\r\n\r\nfunction divideNumbersByGCD(...values: number[]): number[] {\r\n    const g = greatestCommonDivisor(...values)\r\n\r\n    return values.map(x => x / g)\r\n}\r\n\r\n/**\r\n * Get the list of all dividers of a number.\r\n * @param value\r\n */\r\nfunction dividers(value: number): number[] {\r\n    const absV = Math.abs(value)\r\n    const maxV = Math.sqrt(absV)\r\n\r\n    // Initialize the list of dividers.\r\n    const D: number[] = []\r\n\r\n    for (let i = 1; i <= maxV; i++) {\r\n        if (value % i === 0) {\r\n            D.push(i)\r\n            D.push(absV / i)\r\n        }\r\n    }\r\n\r\n    // Order numbers.\r\n    D.sort(function (a, b) {\r\n        return a - b\r\n    })\r\n\r\n    // Make sure the array of value is unique.\r\n    return [...new Set(D)]\r\n}\r\n\r\n/**\r\n * Great Common Divisor\r\n * @param values : number values\r\n */\r\nfunction greatestCommonDivisor(...values: number[]): number {\r\n    // Define the gcd for two number\r\n    const gcd2 = function (a: number, b: number): number {\r\n        if (b === 0) {\r\n            return a\r\n        }\r\n        return gcd2(b, a % b)\r\n    }\r\n\r\n    let g = 1,\r\n        i = 2\r\n\r\n    // Nothing is given\r\n    if (values.length === 0) {\r\n        return 1\r\n    }\r\n    // Only one number is given\r\n    if (values.length === 1) {\r\n        // The first number is zero\r\n        if (values[0] === 0) {\r\n            return 1\r\n        }\r\n        // Return the number\r\n        return values[0]\r\n    }\r\n\r\n    // We have at least 2 numbers.\r\n    g = gcd2(values[0], values[1])\r\n\r\n    // The gcd of the two first value is one ? It's already finished.\r\n    if (g === 1) {\r\n        return 1\r\n    }\r\n\r\n    // The current gcd isn't one. Continue with all next values.\r\n    for (i = 2; i < values.length; i++) {\r\n        g = gcd2(g, values[i])\r\n        // Escape if gcd is already one.\r\n        if (g === 1) {\r\n            break\r\n        }\r\n    }\r\n\r\n    return Math.abs(g)\r\n}\r\n\r\n/**\r\n * Least Common Multiple\r\n * @param values: list of numbers\r\n */\r\nfunction leastCommonMultiple(...values: number[]): number {\r\n    return values.reduce(function (a, b) {\r\n        return Math.abs(a * b / greatestCommonDivisor(a, b))\r\n    })\r\n}\r\n\r\nfunction numberCorrection(value: number, number_of_digits = 3) {\r\n    return +value.toFixed(number_of_digits)\r\n}\r\n\r\nfunction periodic(value: number): number {\r\n    if (Number.isSafeInteger(value)) {\r\n        return 0\r\n    }\r\n\r\n    // Assume it's with decimal.\r\n    const decimal = (value.toString()).split('.')[0]\r\n\r\n    // The decimal part is limited\r\n    if (decimal.length < 10) {\r\n        return 0\r\n    }\r\n\r\n    // Find the periodic if it exists.\r\n    throw new Error('Periodic value: Not implemented yet')\r\n}\r\n\r\n/**\r\n * Get the list of the nth first prime numbers.\r\n * @param nb : number of primes to choose from\r\n */\r\nfunction primes(nb?: number): number[] {\r\n    const primesValues: number[] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]\r\n    if (nb === undefined) {\r\n        return primesValues\r\n    } else {\r\n        return primesValues.slice(0, Math.min(primesValues.length, nb))\r\n    }\r\n}\r\n\r\nfunction pythagoreanTripletsWithTarget(target: number, targetIsSquare?: boolean): number[][] {\r\n    // méthode inverse, à partir du triplet.\r\n    const triplets = [],\r\n        targetValue = targetIsSquare === true ? +target : target ** 2\r\n    for (let u = 0; u <= target; u++) {\r\n        for (let v = 0; v <= target; v++) {\r\n            if (u ** 2 + v ** 2 === targetValue) {\r\n                triplets.push([u, v, target])\r\n            }\r\n        }\r\n    }\r\n\r\n    return triplets\r\n}\r\n\r\nfunction round(value: number, decimals = 2): number {\r\n    const exp: number = Math.round(Number(`${value}e${decimals}`))\r\n\r\n    return Number(`${exp}e-${decimals}`)\r\n}\r\n\r\nfunction greatestPower(value: number, index: number): number {\r\n    let search_value = Math.floor(Math.pow(value, 1 / index))\r\n\r\n    const radical = value\r\n    const factor = 1\r\n\r\n    while (search_value > 1) {\r\n        const pow = Math.pow(search_value, index)\r\n        if (radical % pow === 0) {\r\n            return pow\r\n        }\r\n\r\n        search_value--\r\n    }\r\n\r\n    return factor\r\n}\r\n\r\n\r\nexport const Numeric = {\r\n    decompose,\r\n    dividers,\r\n    divideNumbersByGCD,\r\n    gcd: greatestCommonDivisor,\r\n    lcm: leastCommonMultiple,\r\n    numberCorrection,\r\n    periodic,\r\n    primes,\r\n    pythagoreanTripletsWithTarget,\r\n    round,\r\n    greatestPower\r\n}","import type {compareSign, IExpression, InputValue, IPiMathObject} from \"../pimath.interface\"\r\nimport {Numeric} from \"../numeric\"\r\n\r\nexport enum FRAC_TYPE {\r\n    frac = 'frac',\r\n    dfrac = 'dfrac',\r\n    tfrac = 'tfrac'\r\n}\r\n\r\n/**\r\n * The fraction class make possible to handle\r\n * \\\\(\\frac{a}{b}\\\\) or \\\\[\\frac{a}{b}\\\\]  values.\r\n */\r\n\r\nexport class Fraction implements IPiMathObject<Fraction>, IExpression<Fraction> {\r\n    #approximative = false\r\n    #denominator = 1\r\n    #digits = 3\r\n    #numerator = 1\r\n    #type: FRAC_TYPE = FRAC_TYPE.frac\r\n    #withSign = false\r\n\r\n    constructor()\r\n    constructor(value: InputValue<Fraction>)\r\n    constructor(numerator: number, denominator: number)\r\n    constructor(decimal: number, periodLength: number)\r\n    constructor(value?: InputValue<Fraction>, denominatorOrPeriodic?: number) {\r\n\r\n        if (value !== undefined) {\r\n            this.parse(value, denominatorOrPeriodic)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse the value to get the numerator and denominator\r\n     * @param value : number or string to parse to get the fraction\r\n     * @param denominatorOrPeriodic (optional|number) : length of the periodic part: 2.333333 => 1 or denominator value\r\n     */\r\n    public parse = (value: InputValue<Fraction>, denominatorOrPeriodic?: number): Fraction => {\r\n        let S: string[]\r\n\r\n        // A null value means a zero fraction.\r\n        if (value === \"\") {\r\n            this.#numerator = 0\r\n            this.#denominator = 1\r\n            return this\r\n        }\r\n\r\n        switch (typeof value) {\r\n            case \"string\":\r\n                // Split the string value in two parts: Numerator/Denominator\r\n                S = value.split('/')\r\n\r\n                // Security checks\r\n                if (S.length > 2) {\r\n                    this.#numerator = NaN\r\n                    // throw new Error(`The given value is not a valid fraction (${value})`)\r\n                }\r\n                if (S.map(x => x === '' || isNaN(Number(x))).includes(true)) {\r\n                    this.#numerator = NaN\r\n                    // throw new Error(`The given value is not a valid fraction (${value})`)\r\n                }\r\n\r\n                if (S.length === 1) {\r\n                    // No divide sign - it's a number\r\n                    return this.parse(+S[0])\r\n                } else if (S.length === 2) {\r\n                    // One divide signe\r\n                    // We check if the denominator is zero\r\n                    if (S[1] === '0') {\r\n                        this.#numerator = NaN\r\n                        this.#denominator = 1\r\n                    } else {\r\n                        this.#numerator = +S[0]\r\n                        this.#denominator = +S[1]\r\n                    }\r\n                } else {\r\n                    // More than one divide sign ?\r\n                    // This is not a fraction\r\n                    this.#numerator = NaN\r\n                    this.#denominator = 1\r\n                }\r\n                break\r\n            case \"number\":\r\n                if (Number.isSafeInteger(value)) {\r\n                    // The given value is an integer\r\n                    this.#numerator = +value\r\n\r\n                    if (denominatorOrPeriodic === undefined || !Number.isSafeInteger(denominatorOrPeriodic)) {\r\n                        this.#denominator = 1\r\n                    } else {\r\n                        this.#denominator = +denominatorOrPeriodic\r\n                    }\r\n                } else {\r\n                    // The given value is a float number\r\n                    // Get the number of decimals after the float sign\r\n                    const [, decimal] = (value.toString()).split('.')\r\n                    const p: number = decimal ? decimal.length : 0\r\n                    const power = Math.pow(10, p)\r\n\r\n                    // Detect if the decimal part is periodic or not...\r\n                    if (denominatorOrPeriodic === undefined) {\r\n                        // Transform the float number in two integer\r\n                        // 0.123 = 0.123*10^3 / 10^3\r\n                        this.#numerator = value * power\r\n                        this.#denominator = power\r\n                    } else if (Number.isSafeInteger(denominatorOrPeriodic)) {\r\n                        this.#numerator = value * power - Math.floor(value * Math.pow(10, p - denominatorOrPeriodic))\r\n                        this.denominator = power - Math.pow(10, p - denominatorOrPeriodic)\r\n                    }\r\n\r\n                    this.#numerator = Numeric.numberCorrection(this.#numerator)\r\n                    this.#denominator = Numeric.numberCorrection(this.#denominator)\r\n\r\n                    this.reduce()\r\n                }\r\n                break\r\n            case \"object\":\r\n                if (value instanceof Fraction) {\r\n                    this.#numerator = +value.numerator\r\n                    this.#denominator = +value.denominator\r\n                }\r\n                break\r\n        }\r\n        return this\r\n    }\r\n\r\n    public clone = (): Fraction => {\r\n        const F = new Fraction()\r\n        F.numerator = this.#numerator\r\n        F.denominator = this.#denominator\r\n        F.approximative = this.approximative\r\n        return F\r\n    }\r\n\r\n    public get tex(): string {\r\n        if (this.isInfinity()) {\r\n            return `${this.sign() === 1 ? '+' : '-'}\\\\infty`\r\n        }\r\n\r\n        const plus = this.#withSign && this.isPositive() ? '+' : ''\r\n\r\n        // TODO: implement the withSign\r\n        // TODO: Transform all get mutation to method...\r\n        if (this.isExact()) {\r\n            if (this.#denominator === 1) {\r\n                return `${plus}${this.#numerator}`\r\n            } else if (this.#numerator < 0) {\r\n                return `-\\\\${this.#type}{ ${-this.#numerator} }{ ${this.#denominator} }`\r\n            } else {\r\n                return `${plus}\\\\${this.#type}{ ${this.#numerator} }{ ${this.#denominator} }`\r\n            }\r\n        } else {\r\n            return plus + this.value.toFixed(this.#digits)\r\n        }\r\n    }\r\n\r\n    public get display(): string {\r\n        if (this.isInfinity()) {\r\n            return `${this.sign() === 1 ? '+' : '-'}oo`\r\n        }\r\n\r\n        const plus = this.#withSign && this.isPositive() ? '+' : ''\r\n\r\n        if (this.isExact()) {\r\n            if (this.#denominator === 1) {\r\n                return `${plus}${this.#numerator}`\r\n            } else {\r\n                return `${plus}${this.#numerator}/${this.#denominator}`\r\n            }\r\n        } else {\r\n            return plus + this.value.toFixed(this.#digits)\r\n        }\r\n    }\r\n\r\n    public static average = (...fractions: (InputValue<Fraction>)[]): Fraction => {\r\n        const M = new Fraction().zero()\r\n\r\n        for (const f of fractions) {\r\n            M.add(f)\r\n        }\r\n\r\n        M.divide(fractions.length)\r\n\r\n        return M\r\n    }\r\n\r\n    public static isFraction(value: InputValue<Fraction>) {\r\n        if (value instanceof Fraction ||\r\n            (typeof value === \"number\" && !isNaN(+value))\r\n        ) {\r\n            return true\r\n        }\r\n\r\n        if (typeof value === \"string\") {\r\n            const [num, den] = value.split('/')\r\n\r\n            return !isNaN(+num) && !isNaN(+den)\r\n        }\r\n\r\n        return false\r\n\r\n    }\r\n\r\n    public static max = (...fractions: InputValue<Fraction>[]): Fraction => {\r\n        let M = new Fraction(fractions[0])\r\n\r\n        for (const m of fractions) {\r\n            const compare = new Fraction(m)\r\n            if (compare.isGreater(M)) {\r\n                M = compare.clone()\r\n            }\r\n        }\r\n\r\n        return M\r\n    }\r\n\r\n    public static min = (...fractions: (InputValue<Fraction>)[]): Fraction => {\r\n        let M = new Fraction(fractions[0])\r\n\r\n        for (const m of fractions) {\r\n            const compare = new Fraction(m)\r\n            if (compare.isLesser(M)) {\r\n                M = compare.clone()\r\n            }\r\n        }\r\n\r\n        return M\r\n    }\r\n\r\n    public static sort = (fractions: (InputValue<Fraction>)[], reverse?: boolean): Fraction[] => {\r\n        const fractionsObject: Fraction[] = fractions.map(f => f instanceof Fraction ? f : new Fraction(f))\r\n\r\n        const sorted = fractionsObject.sort((a, b) => a.value - b.value)\r\n\r\n        if (reverse) {\r\n            sorted.reverse()\r\n        }\r\n\r\n        return sorted\r\n    }\r\n\r\n    public static toSameDenominateur(...fractions: InputValue<Fraction>[]): Fraction[] {\r\n        const F = fractions.map(x => new Fraction(x))\r\n        const lcm = Numeric.lcm(...F.map(x => x.denominator))\r\n\r\n        F.forEach(x => x.amplify(lcm / x.denominator))\r\n\r\n        return F\r\n    }\r\n\r\n    public static unique = (fractions: (InputValue<Fraction>)[]): Fraction[] => {\r\n        const unique: Record<string, boolean> = {},\r\n            distinct: Fraction[] = []\r\n\r\n        fractions.forEach(x => {\r\n            if (!(x instanceof Fraction)) {\r\n                x = new Fraction(x)\r\n            }\r\n\r\n            if (!unique[x.clone().reduce().tex]) {\r\n                distinct.push(x.clone())\r\n                unique[x.tex] = true\r\n            }\r\n        })\r\n\r\n        return distinct\r\n    }\r\n\r\n    public static xMultiply = (...values: (InputValue<Fraction>)[]): Fraction => {\r\n        const R = new Fraction()\r\n        // Parse the value.\r\n        // If it's a fraction, return a clone of it\r\n        // If it's an integer, return the fraction F/1\r\n        for (const value of values) {\r\n\r\n            const F = new Fraction(value)\r\n            R.numerator = R.numerator * F.numerator\r\n            R.denominator = R.denominator * F.denominator\r\n        }\r\n\r\n        return R\r\n    }\r\n\r\n    public abs = (): this => {\r\n        this.#numerator = Math.abs(this.#numerator)\r\n        this.#denominator = Math.abs(this.#denominator)\r\n        return this\r\n    }\r\n\r\n    public add = (F: InputValue<Fraction>): Fraction => {\r\n        if (F instanceof Fraction) {\r\n            const N: number = this.#numerator,\r\n                D: number = this.#denominator\r\n\r\n            this.#numerator = N * F.denominator + F.numerator * D\r\n            this.#denominator = D * F.denominator\r\n            this.approximative = this.approximative || F.approximative\r\n        } else {\r\n            return this.add(new Fraction(F))\r\n        }\r\n\r\n        return this.reduce()\r\n    }\r\n\r\n    public amplify = (k: number): this => {\r\n        if (Number.isSafeInteger(k)) {\r\n            this.#numerator *= k\r\n            this.#denominator *= k\r\n        }\r\n        return this\r\n    }\r\n\r\n    get approximative(): boolean {\r\n        return this.#approximative\r\n    }\r\n\r\n    set approximative(value: boolean) {\r\n        this.#approximative = value\r\n    }\r\n\r\n    public areEquals = (...F: Fraction[]): boolean => {\r\n        return F.every(f => f.isEqual(F[0]))\r\n    }\r\n\r\n    /**\r\n     * Compare the current coefficient with another coefficient\r\n     * @param F (Coefficient) The coefficient to _compare\r\n     * @param sign (string| default is =): authorized values: =, <, <=, >, >= with some variations.\r\n     */\r\n    public compare = (F: InputValue<Fraction>, sign?: compareSign): boolean => {\r\n        sign ??= '='\r\n\r\n        let compareFraction: Fraction\r\n        if (F instanceof Fraction) {\r\n            compareFraction = F.clone()\r\n        } else {\r\n            compareFraction = new Fraction(F)\r\n        }\r\n\r\n        switch (sign) {\r\n            case '>':\r\n                return this.value > compareFraction.value\r\n            case \">=\":\r\n            case \"=>\":\r\n            case \"geq\":\r\n                return this.value >= compareFraction.value\r\n            case \"<\":\r\n                return this.value < compareFraction.value\r\n            case \"<=\":\r\n            case \"=<\":\r\n            case \"leq\":\r\n                return this.value <= compareFraction.value\r\n            case \"=\":\r\n                return this.value === compareFraction.value\r\n            case \"<>\":\r\n                return this.value !== compareFraction.value\r\n            default:\r\n                return false\r\n        }\r\n    }\r\n\r\n    public get denominator(): number {\r\n        return this.#denominator\r\n    }\r\n\r\n    public set denominator(value: number) {\r\n        this.#denominator = value\r\n    }\r\n\r\n    public get dfrac(): this {\r\n        this.#type = FRAC_TYPE.dfrac\r\n        return this\r\n    }\r\n\r\n    digits(value: number): this {\r\n        this.#digits = value\r\n        return this\r\n    }\r\n\r\n    public divide = (F: Fraction | number): Fraction => {\r\n        const Q = new Fraction(F)\r\n\r\n        if (Q.numerator === 0) {\r\n            return new Fraction().infinite()\r\n        }\r\n\r\n        const N: number = this.#numerator,\r\n            D: number = this.#denominator\r\n\r\n        this.#numerator = N * Q.denominator\r\n        this.#denominator = D * Q.numerator\r\n\r\n        this.approximative = this.approximative || Q.approximative\r\n        return this.reduce()\r\n    }\r\n\r\n    public get frac(): this {\r\n        this.#type = FRAC_TYPE.frac\r\n        return this\r\n    }\r\n\r\n    public infinite = (): this => {\r\n        this.#numerator = Infinity\r\n        this.#denominator = 1\r\n        this.approximative = false\r\n        return this\r\n    }\r\n\r\n    public invalid = (): this => {\r\n        this.#numerator = NaN\r\n        this.#denominator = 1\r\n        this.approximative = false\r\n        return this\r\n    }\r\n\r\n    public inverse = (): this => {\r\n        const sign = this.sign()\r\n        const n = Math.abs(this.#numerator)\r\n        this.#numerator = Math.abs(this.#denominator) * sign\r\n        this.#denominator = n\r\n\r\n        return this\r\n    }\r\n\r\n    public isApproximative = (): boolean => {\r\n        return this.#approximative ||\r\n            this.#numerator.toString().length >= 15 && this.#denominator.toString().length >= 15\r\n    }\r\n\r\n    public isEqual = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '=')\r\n    }\r\n\r\n    public isEven = (): boolean => {\r\n        return this.isRelative() && this.value % 2 === 0\r\n    }\r\n\r\n    public isExact = (): boolean => {\r\n        return !this.isApproximative()\r\n    }\r\n\r\n    public isFinite = (): boolean => {\r\n        return !this.isInfinity() && !this.isNaN()\r\n    }\r\n\r\n    public isGeq = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '>=')\r\n    }\r\n\r\n    public isGreater = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '>')\r\n    }\r\n\r\n    public isInfinity = (): boolean => {\r\n        return Math.abs(this.#numerator) === Infinity\r\n    }\r\n\r\n    public isLeq = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '<=')\r\n    }\r\n\r\n    public isLesser = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '<')\r\n    }\r\n\r\n    public isNaN = (): boolean => {\r\n        return isNaN(this.#numerator)\r\n    }\r\n\r\n    public isNatural = (): boolean => {\r\n        return this.isRelative() && this.isPositive()\r\n    }\r\n\r\n    public isNegative = (): boolean => {\r\n        return this.sign() === -1\r\n    }\r\n\r\n    public isNotEqual = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '<>')\r\n    }\r\n\r\n    public isNotZero = (): boolean => {\r\n        return this.#numerator !== 0\r\n    }\r\n\r\n    public isOdd = (): boolean => {\r\n        return this.isRelative() && this.value % 2 === 1\r\n    }\r\n\r\n    public isOne = (): boolean => {\r\n        return this.#numerator === 1 && this.#denominator === 1\r\n    }\r\n\r\n    public isPositive = (): boolean => {\r\n        return this.sign() === 1\r\n    }\r\n\r\n    public isRational = (): boolean => {\r\n        return !this.isApproximative() && !this.isRelative()\r\n    }\r\n\r\n    public isReduced = (): boolean => {\r\n        return Math.abs(Numeric.gcd(this.#numerator, this.#denominator)) === 1\r\n    }\r\n\r\n    public isRelative = (): boolean => {\r\n        return !this.isApproximative() && this.clone().reduce().denominator === 1\r\n    }\r\n\r\n    public isSquare = (): boolean => {\r\n        return Math.sqrt(this.#numerator) % 1 === 0 && Math.sqrt(this.#denominator) % 1 === 0\r\n    }\r\n\r\n    public isStrictlyNegative = (): boolean => {\r\n        return this.value < 0\r\n    }\r\n\r\n    public isStrictlyPositive = (): boolean => {\r\n        return this.value > 0\r\n    }\r\n\r\n    public isUnit(): boolean {\r\n        return Math.abs(this.#numerator) === 1 && this.#denominator === 1\r\n    }\r\n\r\n    // Mathematical operations specific to fractions\r\n    public isZero = (): boolean => {\r\n        return this.#numerator === 0\r\n    }\r\n\r\n    public multiply = (F: Fraction | number): this => {\r\n        // Parse the value.\r\n        // If it's a fraction, return a clone of it\r\n        // If it's an integer, return the fraction F/1\r\n        const Q = new Fraction(F)\r\n\r\n        this.#numerator = this.#numerator * Q.numerator\r\n        this.#denominator = this.#denominator * Q.denominator\r\n\r\n        this.approximative = this.approximative || Q.approximative\r\n\r\n        return this.reduce()\r\n    }\r\n\r\n    // ------------------------------------------\r\n    public get numerator(): number {\r\n        return this.#numerator\r\n    }\r\n\r\n    public set numerator(value: number) {\r\n        this.#numerator = value\r\n    }\r\n\r\n    public one = (): this => {\r\n        this.#approximative = false\r\n        this.#numerator = 1\r\n        this.#denominator = 1\r\n        return this\r\n    }\r\n\r\n    public opposite = (): this => {\r\n        this.#numerator = -this.#numerator\r\n        return this\r\n    }\r\n\r\n    public pow = (p: number | Fraction): Fraction => {\r\n        if (p instanceof Fraction) {\r\n            return this.pow(p.value)\r\n        }\r\n\r\n        this.reduce()\r\n        if (p < 0) {\r\n            this.inverse()\r\n        }\r\n\r\n        // Check if numerator and denominator are roots of...\r\n        // otherwise, convert to numeric.\r\n        const controlNumerator = Math.floor(Math.pow(this.#numerator, Math.abs(p))),\r\n            controlDenominator = Math.floor(Math.pow(this.#denominator, Math.abs(p)))\r\n\r\n        if (controlNumerator ** Math.abs(p) === this.#numerator\r\n            &&\r\n            controlDenominator ** Math.abs(p) === this.#denominator) {\r\n            this.#numerator = this.#numerator ** Math.abs(p)\r\n            this.#denominator = this.#denominator ** Math.abs(p)\r\n        } else {\r\n            this.#numerator = this.#numerator ** Math.abs(p)\r\n            this.#denominator = this.#denominator ** Math.abs(p)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    public reduce = (): this => {\r\n        const g = Numeric.gcd(this.#numerator, this.#denominator)\r\n        this.#numerator = this.#numerator / g\r\n        this.#denominator = this.#denominator / g\r\n\r\n        if (this.#denominator < 0) {\r\n            this.#denominator = -this.#denominator\r\n            this.#numerator = -this.#numerator\r\n        }\r\n        return this\r\n    }\r\n\r\n    public root = (p: number): this => {\r\n\r\n        // Check if they are perfect roots..\r\n        if (p === 0) {\r\n            return this\r\n        }\r\n\r\n        // If negative, inverse the fraction\r\n        if (p < 0) {\r\n            this.inverse()\r\n        }\r\n\r\n        // if p is not a safe integer, throw error\r\n        if (!Number.isSafeInteger(p)) {\r\n            throw new Error(\"The root must be an integer.\")\r\n        }\r\n\r\n        // if the fraction is negative and the root is even, throw error\r\n        if (this.isNegative() && p % 2 === 0) {\r\n            throw new Error(\"The root of a negative number must be odd.\")\r\n        }\r\n\r\n        // get the sign of the fraction and make it positive\r\n        const sign = this.sign()\r\n        this.abs()\r\n\r\n        // Reduce the fraction\r\n        this.reduce()\r\n\r\n        // Check if numerator and denominator are roots of...\r\n        // otherwise, convert to numeric.\r\n        const controlNumerator = Math.floor(Math.pow(this.#numerator, Math.abs(1 / p))),\r\n            controlDenominator = Math.floor(Math.pow(this.#denominator, Math.abs(1 / p)))\r\n\r\n        this.#numerator = Math.pow(this.#numerator, Math.abs(1 / p))\r\n        this.#denominator = Math.pow(this.#denominator, Math.abs(1 / p))\r\n\r\n        if (controlNumerator !== this.#numerator\r\n            ||\r\n            controlDenominator !== this.#denominator) {\r\n            // The fraction is not a perfect root - make it approximative\r\n            this.#numerator = this.#numerator / this.#denominator\r\n            this.#denominator = 1\r\n            this.#approximative = true\r\n        }\r\n\r\n        // Restore the sign\r\n        this.multiply(sign)\r\n\r\n        return this\r\n    }\r\n\r\n    public sign = (): 1 | -1 => {\r\n        return (this.#numerator * this.#denominator >= 0) ? 1 : -1\r\n    }\r\n\r\n    public sqrt = (): this => {\r\n        return this.root(2)\r\n    }\r\n\r\n    public subtract = (F: Fraction | number): Fraction => {\r\n        if (F instanceof Fraction) {\r\n            return this.add(F.clone().opposite())\r\n        } else {\r\n            return this.add(-F)\r\n        }\r\n    }\r\n\r\n    public get texWithSign(): string {\r\n        return this.isPositive() ? `+${this.tex}` : this.tex\r\n    }\r\n\r\n    public get tfrac(): this {\r\n        this.#type = FRAC_TYPE.tfrac\r\n        return this\r\n    }\r\n\r\n    public get value(): number {\r\n        const result = this.#numerator / this.#denominator\r\n        return result === 0 ? 0 : result\r\n    }\r\n\r\n    withSign(value = true): this {\r\n        this.#withSign = value\r\n        return this\r\n    }\r\n\r\n    public zero = (): this => {\r\n        this.#approximative = false\r\n        this.#numerator = 0\r\n        this.#denominator = 1\r\n        return this\r\n    }\r\n}","// TODO: Remove NthRoot class\r\n/**\r\n * NthRoot is something like \"a+b\\sqrt{3}\r\n */\r\nexport class NthRoot {\r\n    #radical: number\r\n    #nth: number\r\n    #coefficient: number\r\n    #isValid: boolean\r\n\r\n    constructor(...values: number[]) {\r\n        this.#radical = 1\r\n        this.#coefficient = 1\r\n        this.#nth = 2\r\n        this.#isValid = true\r\n\r\n        if (values.length > 0) {\r\n            this.parse(values[0], values[1], values[2])\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get radical(): number {\r\n        return this.#radical\r\n    }\r\n\r\n    set radical(value: number) {\r\n        this.#radical = value\r\n    }\r\n\r\n    get nth(): number {\r\n        return this.#nth\r\n    }\r\n\r\n    set nth(value: number) {\r\n        if (Number.isSafeInteger(value) && value >= 2) {\r\n            this.#nth = value\r\n        } else {\r\n            // Error setting the nth root.\r\n            console.log('Error setting the nth root')\r\n            this.#nth = 2\r\n        }\r\n    }\r\n\r\n    get coefficient(): number {\r\n        return this.#coefficient\r\n    }\r\n\r\n    set coefficient(value: number) {\r\n        this.#coefficient = value\r\n    }\r\n\r\n    get tex(): string {\r\n        let C: string\r\n\r\n        if (this.#coefficient === 1) {\r\n            C = ''\r\n        } else if (this.#coefficient === -1) {\r\n            C = '-'\r\n        } else {\r\n            C = this.#coefficient.toString()\r\n        }\r\n\r\n        if (this.#radical === 1) {\r\n            return `${this.#coefficient}`\r\n        } else {\r\n            if (this.#nth === 2) {\r\n                return `${C}\\\\sqrt{${this.#radical}}`\r\n            } else {\r\n                return `${C}\\\\sqrt[${this.#nth}]{${this.#radical}}`\r\n            }\r\n        }\r\n    }\r\n\r\n    get display(): string {\r\n        let C: string\r\n\r\n        if (this.#coefficient === 1) {\r\n            C = ''\r\n        } else if (this.#coefficient === -1) {\r\n            C = '-'\r\n        } else {\r\n            C = this.#coefficient.toString()\r\n        }\r\n\r\n        if (this.#radical === 1) {\r\n            return `${this.#coefficient}`\r\n        } else {\r\n            if (this.#nth === 2) {\r\n                return `${C}sqrt{${this.#radical}}`\r\n            } else {\r\n                return `${C}root(${this.#nth}){${this.#radical}}`\r\n            }\r\n        }\r\n    }\r\n\r\n    get value(): number {\r\n        return this.#coefficient * Math.pow(this.#radical, 1 / this.#nth)\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (radical: number, nthroot?: number, coefficient?: number): this => {\r\n        this.#coefficient = coefficient ?? 1\r\n        this.#nth = nthroot ?? 2\r\n        this.#radical = radical\r\n\r\n        if (this.#nth % 2 === 0 && this.#radical < 0) {\r\n            this.#isValid = false\r\n        }\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    reduce = (): this => {\r\n        // Max value to test.\r\n        let V = Math.floor(Math.pow(this.#radical, 1 / this.#nth))\r\n        while (V > 1) {\r\n            if (this.#radical % Math.pow(V, this.#nth) === 0) {\r\n                // It's dividable by V^n\r\n                this.#coefficient *= V\r\n                this.#radical = this.#radical / Math.pow(V, this.#nth)\r\n\r\n                // Redifine the new testing value (this is optimization)\r\n                V = Math.floor(Math.pow(this.#radical, 1 / this.#nth))\r\n                continue\r\n            }\r\n            V--\r\n        }\r\n        return this\r\n    }\r\n\r\n    multiply = (N: NthRoot): this => {\r\n        this.#radical *= N.radical\r\n        return this.reduce()\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Help functions\r\n    // ------------------------------------------\r\n    hasRadical = (): boolean => {\r\n        return !(this.#radical === 1 || this.#radical === 0 || !this.#isValid)\r\n    }\r\n}","import type {InputValue, ISolution} from \"../pimath.interface\"\r\nimport type {Polynom} from \"./polynom\"\r\nimport {Fraction} from \"../coefficients\"\r\nimport {Numeric} from \"../numeric\"\r\nimport type {Equation} from \"./equation\"\r\n\r\nexport class EquationSolver {\r\n    #bissectionCompexityCounter: number\r\n    #bissectionDeltaX: number\r\n    readonly #leftPolynom: Polynom\r\n    readonly #variable: string\r\n\r\n    constructor(left: Polynom | Equation, right?: Polynom, variable = \"x\") {\r\n        this.#variable = variable\r\n        this.#bissectionDeltaX = 1e-4\r\n        this.#bissectionCompexityCounter = 0\r\n\r\n        if (Object.hasOwn(left, 'moveLeft')) {\r\n            const equ = left as Equation\r\n            this.#leftPolynom = equ.left.clone().subtract(equ.right)\r\n        } else {\r\n            this.#leftPolynom = (left as Polynom).clone().subtract(right ?? 0)\r\n        }\r\n    }\r\n\r\n    get bissectionCompexityCounter(){\r\n        return this.#bissectionCompexityCounter\r\n    }\r\n\r\n    get bissectionDeltaX() {\r\n        return this.#bissectionDeltaX\r\n    }\r\n\r\n    set bissectionDeltaX(value: number) {\r\n        this.#bissectionDeltaX = value\r\n    }\r\n\r\n    public solve(): ISolution[] {\r\n        const degree = this.#leftPolynom.degree().value\r\n\r\n        if (degree === 0) {\r\n            return []\r\n        }\r\n\r\n        if (degree === 1) {\r\n            return this.#solveLinear()\r\n        }\r\n\r\n        if (degree === 2) {\r\n            return this.#solveQuadratic()\r\n        }\r\n\r\n        // Try to solve by factorization -> exact solutions.\r\n        const {solutions, polynom} = this.#solveByFactorization()\r\n\r\n        // The remaining polynom is of degree zero. No more solutions available.\r\n        if (polynom.degree().isZero()) {\r\n            return solutions\r\n        }\r\n\r\n        // The remaining polyno is of degree one or two, but cannot be solved by factorization (!).\r\n        if (polynom.degree().value <= 2) {\r\n            return solutions.concat(\r\n                new EquationSolver(polynom.clone()).solve()\r\n            )\r\n        }\r\n\r\n        // Use approximative solutions, using bissection algorithm.\r\n        // TODO: doit gérer le fait que si on a trouvé des solutions, on peut réduire avant de faire la bissection\r\n        this.#bissectionCompexityCounter = 0\r\n        return solutions.concat(\r\n            this.#solveByBissection(polynom)\r\n        ).sort((a, b) => a.value - b.value)\r\n    }\r\n\r\n    public solveAsCardan(): ISolution[] {\r\n        if (this.#leftPolynom.degree().value !== 3) {\r\n            throw new Error(\"The equation is not cubic.\")\r\n        }\r\n        return this.#solveCubic_CardanFormula()\r\n    }\r\n\r\n    #makeApproximativeSolution(value: number, output?: { tex: string, display: string }): ISolution {\r\n        return {\r\n            variable: this.#variable,\r\n            exact: false,\r\n            value: +value.toFixed(10),\r\n            tex: output?.tex ?? '',\r\n            display: output?.display ?? ''\r\n        }\r\n    }\r\n\r\n    #makeSolution(value: InputValue<Fraction>): ISolution {\r\n        if (value instanceof Fraction && value.isApproximative()) {\r\n            return this.#makeApproximativeSolution(value.value)\r\n        }\r\n\r\n        const fraction = new Fraction(value)\r\n        return {\r\n            variable: this.#variable,\r\n            exact: fraction,\r\n            value: fraction.value,\r\n            tex: fraction.tex,\r\n            display: fraction.display\r\n        }\r\n    }\r\n\r\n    // Solve using bissection algorithm (approximative solution)\r\n    #solveByBissection(polynom: Polynom): ISolution[] {\r\n        const solutions: ISolution[] = []\r\n        const degree = polynom.degree().value\r\n\r\n        // Calculate the Cauchy Bounds.\r\n        const [a, ...values] = polynom.getCoefficients()\r\n        const B = 2 + Math.max(...values.map(x => x.value / a.value))\r\n\r\n        // Cut the [-B;B] interval in *n* parts : n = 100\r\n\r\n        // Calculate the f(x) value at each points\r\n        const evaluatedPoints = this.#solveByBissection_evaluatePoints(polynom, B, 100)\r\n\r\n        // Check if there is a least n opposite couples\r\n        const couples = this.#solveByBissection_getCouples(evaluatedPoints, degree)\r\n\r\n        // All solutions fund !\r\n        couples.forEach(couple => {\r\n            const [a, b] = couple\r\n\r\n            if (a === b) {\r\n                // Exact solution\r\n                solutions.push(this.#makeSolution(a))\r\n            } else {\r\n                const bissection = this.#solveByBissection_algorithm(polynom, a, b)\r\n\r\n                if (bissection !== null) {\r\n                    solutions.push(this.#makeApproximativeSolution(bissection))\r\n                }\r\n            }\r\n        })\r\n\r\n        console.log('COMPLEXITY: ', this.#bissectionCompexityCounter)\r\n        return solutions\r\n    }\r\n\r\n    #solveByBissection_algorithm(polynom: Polynom, a: number, b: number): number | null {\r\n        let fa = polynom.evaluate(a, true) as number\r\n        let fb = polynom.evaluate(b, true) as number\r\n\r\n        if (fa * fb > 0) {\r\n            console.log(\"Pas de racine dans l'intervalle donné\")\r\n            return null\r\n        }\r\n\r\n        let mid: number\r\n        while ((b - a) / 2 > this.#bissectionDeltaX) {\r\n            this.#bissectionCompexityCounter++\r\n\r\n            mid = (a + b) / 2\r\n            const fmid = polynom.evaluate(mid, true) as number\r\n\r\n            if (fmid === 0) {\r\n                return mid // racine exacte trouvée\r\n            } else if (fa * fmid < 0) {\r\n                b = mid\r\n                fb = fmid\r\n            } else {\r\n                a = mid\r\n                fa = fmid\r\n            }\r\n        }\r\n        return (a + b) / 2 // retourner la racine approximative\r\n    }\r\n\r\n    #solveByBissection_evaluatePoints(polynom: Polynom, bounds: number, slice: number): { x: number, fx: number }[] {\r\n\r\n        const evaluatedPoints: { x: number, fx: number }[] = []\r\n\r\n        const dx = 2 * bounds / slice\r\n\r\n        for (let searchValue = -bounds; searchValue <= bounds; searchValue += dx) {\r\n\r\n            const x = Numeric.numberCorrection(searchValue)\r\n            evaluatedPoints.push(\r\n                {\r\n                    x,\r\n                    fx: polynom.evaluate(x, true) as number\r\n                }\r\n            )\r\n        }\r\n\r\n        return evaluatedPoints\r\n    }\r\n\r\n    #solveByBissection_getCouples(evaluatedPoints: { x: number, fx: number }[], degree: number): [number, number][] {\r\n        const couples: [number, number][] = []\r\n\r\n        for (let index = 1; index < evaluatedPoints.length; index++) {\r\n\r\n            const value = evaluatedPoints[index]\r\n            const previous = evaluatedPoints[index - 1]\r\n\r\n            if (value.fx === 0) {\r\n                // exact value\r\n                couples.push([value.x, value.x])\r\n            } else if (value.fx * previous.fx < 0) {\r\n                // both evaluated expression are of opposite sign.\r\n                couples.push([previous.x, value.x])\r\n            }\r\n\r\n            if (couples.length === degree) {\r\n                // All couples are found.\r\n                return couples\r\n            }\r\n        }\r\n\r\n        return couples\r\n    }\r\n\r\n    #solveByFactorization(): { solutions: ISolution[], polynom: Polynom } {\r\n        // Move everything to the left.\r\n\r\n        // Get the polynom on the left (on the right, it's zero)\r\n        const left = this.#leftPolynom.clone()\r\n\r\n        // The solutions of the equation\r\n        const solutions: ISolution[] = []\r\n\r\n        // multiply by the lcm of the denominators\r\n        // to get rid of the fractions\r\n        const lcm = left.lcmDenominator()\r\n        if (lcm !== 1) {\r\n            left.multiply(lcm)\r\n        }\r\n\r\n        // alternative method : if there is no monom of degree zero.\r\n        // - get the monom with the smallest degree.\r\n        // - if degree>0, divide by x^{degree}\r\n        const a = left.monomByDegree().coefficient\r\n        const b = left.monomByDegree(0).coefficient\r\n        if (b.isZero()) {\r\n            solutions.push(this.#makeSolution(0))\r\n\r\n            const m = left.monoms.reduce((min, curr) => curr.degree().value < min.degree().value ? curr : min)\r\n            const k = m.coefficient\r\n            m.clone().divide(k) // make the monom unit\r\n            left.divide(m)\r\n        }\r\n\r\n        // get all dividers of a and b\r\n        const dividersA = Numeric.dividers(a.value)\r\n        const dividersB = Numeric.dividers(b.value)\r\n\r\n        // gel all possible solutions\r\n        const testingSolutions: Fraction[] = []\r\n        for (const da of dividersA) {\r\n            for (const db of dividersB) {\r\n                const f = new Fraction(db, da)\r\n                if (!testingSolutions.find(s => s.value === f.value)) {\r\n                    testingSolutions.push(f.clone())\r\n                    testingSolutions.push(f.opposite().clone())\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        // Each value in testingSolutions are \"unique\" -> juste test them to see if it evaluates to zero.\r\n        testingSolutions.forEach(f => {\r\n            if ((left.evaluate(f) as Fraction).isZero()) {\r\n                solutions.push(this.#makeSolution(f))\r\n            }\r\n        })\r\n\r\n        // divide the left polynom by the solutions (as polynom)\r\n        // to get the reduced polynom\r\n        for (const s of solutions) {\r\n            // all solutions are exact solutions.\r\n            // skip the zero solutions if it exists.\r\n            if ((s.exact as Fraction).isZero()) {\r\n                continue\r\n            }\r\n\r\n            // // if the solution is exact and is zero, it's already divided: skip it !\r\n            // if (s.exact !== false && (s.exact as Fraction).isZero()) {\r\n            //     continue\r\n            // }\r\n\r\n            const p = left.clone().fromCoefficients(\r\n                (s.exact as Fraction).denominator,\r\n                -(s.exact as Fraction).numerator\r\n            )\r\n\r\n            // const p = this.#equation.clone().parse('x', (s.exact as Fraction).denominator, -(s.exact as Fraction).numerator)\r\n\r\n            while (left.isDividableBy(p)) {\r\n                left.divide(p)\r\n            }\r\n        }\r\n\r\n        // if the reduced polynom is of degree 0, we have found all the solutions\r\n        // if the reduced polynom is of degree greater than 3, we can't solve it\r\n        if (left.degree().isZero() || left.degree().value > 3) {\r\n            // Tri des réponses\r\n            solutions.sort((a, b) => a.value - b.value)\r\n            return {solutions, polynom: left}\r\n        }\r\n\r\n        // if the reduced polynom is of degree 1 or 2, we can solve it\r\n        const zeroPolynom = left.clone().zero()\r\n\r\n        const solver = new EquationSolver(left, zeroPolynom, this.#variable)\r\n        return {\r\n            solutions: solutions\r\n                .concat(solver.solve())\r\n                .sort((a, b) => a.value - b.value),\r\n            polynom: zeroPolynom\r\n        }\r\n    }\r\n\r\n    #solveCubic_CardanFormula(): ISolution[] {\r\n        // get the coefficients of the equation\r\n        const left = this.#leftPolynom\r\n\r\n        // left is a polynom ax^3+bx^2+cx+d => the solution is x = (-b±√(b^2-4ac))/2a\r\n        const a = left.monomByDegree(3).coefficient\r\n        const b = left.monomByDegree(2).coefficient\r\n        const c = left.monomByDegree(1).coefficient\r\n        const d = left.monomByDegree(0).coefficient\r\n\r\n        // normalize the coefficient by dividing by a\r\n        const an = b.clone().divide(a)\r\n        const bn = c.clone().divide(a)\r\n        const cn = d.clone().divide(a)\r\n\r\n        // Depressed cubic equation\r\n        // x^3+px+q=0\r\n        const p = bn.clone().subtract(an.clone().pow(2).divide(3))\r\n        const q = cn.clone()\r\n            .subtract(an.clone().multiply(bn).divide(3))\r\n            .add(an.clone().pow(3).multiply(2).divide(27))\r\n\r\n\r\n        // Cardan method\r\n        // X^2 + qX - p^3/27 = 0\r\n        // X^2 -SX + P = 0\r\n        // S = u^3 + v^3 = -q\r\n        // P = u^3v^3 = -p^3/27\r\n        // u^3 and v^3 are the roots of the equation\r\n        const S = q.clone().opposite()\r\n        const P = p.clone().opposite().pow(3).divide(27)\r\n\r\n        // Discriminant : delta = -(S^2 - 4P)\r\n        // delta < 0 : 1 real solution\r\n        // delta = 0 : 2 real solutions\r\n        // delta > 0 : 3 real solutions\r\n        const delta = S.clone().pow(2).subtract(P.clone().multiply(4)).opposite()\r\n        // console.log('an=', an.display, 'bn=', bn.display, 'cn=', cn.display)\r\n        // console.log('p=', p.display, 'q=', q.display)\r\n        // console.log('S=', S.display, 'P=', P.display)\r\n        // console.log('delta=', delta.display)\r\n\r\n        // if delta is negative, there is one real solution\r\n        if (delta.isNegative()) {\r\n            const u = q.clone().opposite().add(delta.clone().opposite().sqrt()).divide(2).root(3)\r\n            const v = q.clone().opposite().subtract(delta.clone().opposite().sqrt()).divide(2).root(3)\r\n\r\n            const x = u.clone().add(v).subtract(an.clone().divide(3))\r\n\r\n            return [this.#makeSolution(x)]\r\n        }\r\n\r\n        // if delta is zero, there are two real solutions\r\n        if (delta.isZero()) {\r\n            const u = q.clone().opposite().divide(2).root(3)\r\n\r\n            const x1 = u.clone().opposite().subtract(an.clone().divide(3))\r\n            const x2 = u.clone().multiply(2).subtract(an.clone().divide(3))\r\n\r\n            // There is only one unique solution\r\n            if (x1.isEqual(x2)) {\r\n                return [this.#makeSolution(x1)]\r\n            }\r\n\r\n            return [\r\n                this.#makeSolution(x2),\r\n                this.#makeSolution(x1)\r\n            ].sort((a, b) => a.value - b.value)\r\n        }\r\n\r\n        // if delta is positive, there are three real solutions\r\n        if (delta.isPositive()) {\r\n            const x: number[] = []\r\n            const pv = p.value,\r\n                qv = q.value,\r\n                anv = an.value\r\n\r\n            for (let i = 0; i < 3; i++) {\r\n                x.push(2 * Math.sqrt(-pv / 3) * Math.cos(Math.acos(3 * qv / (2 * pv) * Math.sqrt(-3 / pv)) / 3 + 2 * Math.PI * i / 3) - anv / 3)\r\n            }\r\n\r\n            return x\r\n                .map(v => this.#makeApproximativeSolution(v))\r\n                .sort((a, b) => a.value - b.value)\r\n\r\n        }\r\n\r\n        return []\r\n    }\r\n\r\n    #solveLinear(): ISolution[] {\r\n        // The equation is linear.\r\n        const [a, b] = this.#leftPolynom.getCoefficients()\r\n\r\n        // left is a polynom ax+b => the solution is x = -b/a\r\n        const f = b.opposite().divide(a)\r\n\r\n        return [\r\n            this.#makeSolution(f)\r\n        ]\r\n    }\r\n\r\n    #solveQuadratic(): ISolution[] {\r\n\r\n        // The equation is quadratic.\r\n        // We can solve it by isolating the variable.\r\n\r\n        // The monom with greatest degree must be positive.\r\n        const left = this.#leftPolynom\r\n        if (left.monomByDegree().coefficient.isNegative()) {\r\n            left.opposite()\r\n        }\r\n\r\n        // left is a polynom ax^2+bx+c => the solution is x = (-b±√(b^2-4ac))/2a\r\n        const [a, b, c] = left.getCoefficients()\r\n\r\n        // delta2 = b^2-4ac\r\n        const delta2 = b.clone().pow(2).subtract(a.clone().multiply(c).multiply(4))\r\n\r\n        // if delta2 is negative, there is no solution\r\n        if (delta2.isNegative()) {\r\n            return []\r\n        }\r\n\r\n        // if delta2 is zero, there is one solution\r\n        // if delta2 is positive, there are two solutions\r\n        // if delta2 is a square, it will be an exact solution.\r\n\r\n        if (delta2.isSquare()) {\r\n            // delta is a fraction.\r\n            // the solutions are (-b±√(b^2-4ac))/2a\r\n            const delta = delta2.sqrt()\r\n            const f1 = b.clone().opposite().subtract(delta).divide(a.clone().multiply(2))\r\n            const f2 = b.clone().opposite().add(delta).divide(a.clone().multiply(2))\r\n\r\n            // Delta is zero, there is only one solution\r\n            if (delta.isZero()) {\r\n                return [this.#makeSolution(f1)]\r\n            }\r\n\r\n            // delta is positive, there are two solutions\r\n            return [\r\n                this.#makeSolution(f1),\r\n                this.#makeSolution(f2)\r\n            ].sort((a, b) => a.value - b.value)\r\n        }\r\n\r\n        // delta is not a square, there are one or two approximative solutions.\r\n        // We will use the approximate value of the square root.\r\n        // const delta = delta2.value ** 0.5\r\n        // const f1 = (-b.value + delta) / (2 * a.value)\r\n        // const f2 = (-b.value - delta) / (2 * a.value)\r\n\r\n        return this.#solveQuadratic_Output(a, b, delta2)\r\n    }\r\n\r\n    #solveQuadratic_Output(a: Fraction, b: Fraction, delta: Fraction): ISolution[] {\r\n        // -b +/- sqrt(delta) / 2a\r\n        // reduce the sqrt - extract pow.\r\n\r\n        // Get the greatest square factor\r\n        const deltaFactor: number = Numeric\r\n            .dividers(delta.value)\r\n            .filter(x => Math.sqrt(x) % 1 === 0)\r\n            .map(x => Math.sqrt(x)).pop() ?? 1\r\n\r\n        // Get the GCD of a, b, and the greatest delta factor.\r\n        const gcd = Numeric.gcd(2 * a.value, b.value, deltaFactor) * (a.isNegative() ? -1 : 1)\r\n\r\n        // Calculate the various values and transforming\r\n        const b2 = b.clone().divide(gcd).opposite()\r\n        const a2 = a.clone().divide(gcd).multiply(2)\r\n        const deltaGcd = Math.abs(deltaFactor / gcd)\r\n        const deltaTex = `${deltaFactor === 1 ? '' : deltaGcd + ' '}\\\\sqrt{ ${delta.clone().divide(deltaFactor ** 2).tex} }`\r\n        const deltaDisplay = `${deltaFactor === 1 ? '' : deltaGcd}sqrt(${delta.clone().divide(deltaFactor ** 2).display})`\r\n        // const deltaK1 = deltaFactor === 1 ? '-' : `-${deltaGcd} `\r\n        // const deltaK2 = deltaFactor === 1 ? '+' : `+${deltaGcd} `\r\n\r\n        function texOutput(a: string, b: string, sign: string, delta: string) {\r\n            // (B+D)/A\r\n            const B = b === '0' ? '' : b\r\n            const S = (sign === '-' || B !== '') ? ` ${sign} ` : ''\r\n\r\n            if (a === \"1\") {\r\n                return `${B}${S}${delta}`\r\n            }\r\n            return `\\\\frac{ ${S}${S}${delta} }{ ${a} }`\r\n        }\r\n\r\n        function displayOutput(a: string, b: string, sign: string, delta: string) {\r\n            // (B+D)/A\r\n            const B = b === '0' ? '' : b\r\n            const S = (sign === '-' || B !== '') ? sign : ''\r\n\r\n\r\n            if (a === \"1\") {\r\n                return `${B}${S}${delta}`\r\n            }\r\n            return `(${B}${S}${delta})/${a}`\r\n        }\r\n\r\n        const d = delta.value ** 0.5\r\n        const f1 = (-b.value - d) / (2 * a.value)\r\n        const f2 = (-b.value + d) / (2 * a.value)\r\n\r\n        return [\r\n            this.#makeApproximativeSolution(f1,\r\n                {\r\n                    tex: texOutput(a2.tex, b2.tex, '-', deltaTex),\r\n                    display: displayOutput(a2.display, b2.display, '-', deltaDisplay),\r\n                }\r\n            ),\r\n            this.#makeApproximativeSolution(f2,\r\n                {\r\n                    tex: texOutput(a2.tex, b2.tex, '+', deltaTex),\r\n                    display: displayOutput(a2.display, b2.display, '+', deltaDisplay),\r\n                }\r\n            )\r\n        ].sort((a, b) => a.value - b.value)\r\n    }\r\n}\r\n","const T = {\n  pi: Math.PI,\n  e: Math.exp(1)\n};\nvar e = /* @__PURE__ */ ((o) => (o.VARIABLE = \"variable\", o.COEFFICIENT = \"coefficient\", o.OPERATION = \"operation\", o.CONSTANT = \"constant\", o.FUNCTION = \"function\", o.FUNCTION_ARGUMENT = \"function-argument\", o.MONOM = \"monom\", o.LEFT_PARENTHESIS = \"(\", o.RIGHT_PARENTHESIS = \")\", o))(e || {}), N = /* @__PURE__ */ ((o) => (o.EXPRESSION = \"expression\", o.POLYNOM = \"polynom\", o.SET = \"set\", o.NUMERIC = \"numeric\", o))(N || {});\nfunction O(o, c) {\n  if (o.length <= 1)\n    return o;\n  const i = Object.keys(c).filter((r) => c[r].type === e.FUNCTION).map((r) => r);\n  i.sort((r, p) => p.length - r.length);\n  const n = new RegExp(`^(${i.join(\"|\")})\\\\(`), t = Object.keys(T);\n  t.sort((r, p) => p.length - r.length);\n  const s = new RegExp(`^(${t.join(\"|\")})`), f = /^(\\d+(\\.\\d+)?)/;\n  let l = \"\", E, a, h;\n  for (i.forEach((r) => {\n    if (o.includes(r)) {\n      const p = new RegExp(`${r}([0-9.]+)`, \"g\");\n      o = o.replaceAll(p, `${r}($1)`);\n    }\n  }); o.length > 0; ) {\n    if (E = a, h = void 0, i.length > 0 && n.exec(o)) {\n      const r = i.find((p) => o.startsWith(p));\n      r && (h = r + \"(\", o = o.slice(r.length + 1), a = e.FUNCTION);\n    } else if (t.length > 0 && s.exec(o)) {\n      const r = t.find((p) => o.startsWith(p));\n      r && (h = r, o = o.slice(r.length), a = e.CONSTANT);\n    } else if (f.exec(o)) {\n      const r = f.exec(o);\n      r && (h = r[0], o = o.slice(r[0].length), a = e.COEFFICIENT);\n    } else\n      switch (h = o[0], o = o.slice(1), h) {\n        case \"(\":\n          a = e.LEFT_PARENTHESIS;\n          break;\n        case \")\":\n          a = e.RIGHT_PARENTHESIS;\n          break;\n        case \",\":\n          a = e.FUNCTION_ARGUMENT;\n          break;\n        case \"+\":\n        case \"-\":\n        case \"*\":\n        case \"/\":\n        case \"^\":\n          a = e.OPERATION;\n          break;\n        default:\n          a = e.VARIABLE;\n      }\n    if (h === void 0 || a === void 0)\n      throw new Error(\"The token is undefined\");\n    l += I(E, a), l += h;\n  }\n  return l;\n}\nfunction I(o, c) {\n  return o === void 0 || o === e.OPERATION || c === e.OPERATION || o === e.LEFT_PARENTHESIS || o === e.FUNCTION || o === e.FUNCTION_ARGUMENT || c === e.RIGHT_PARENTHESIS || c === e.FUNCTION_ARGUMENT ? \"\" : \"*\";\n}\nconst d = {\n  \"^\": { precedence: 4, associative: \"right\", type: e.OPERATION },\n  \"*\": { precedence: 3, associative: \"left\", type: e.OPERATION },\n  \"/\": { precedence: 3, associative: \"left\", type: e.OPERATION },\n  \"+\": { precedence: 2, associative: \"left\", type: e.OPERATION },\n  \"-\": { precedence: 2, associative: \"left\", type: e.OPERATION }\n}, k = {\n  \"^\": { precedence: 4, associative: \"right\", type: e.OPERATION },\n  \"*\": { precedence: 3, associative: \"left\", type: e.OPERATION },\n  \"/\": { precedence: 3, associative: \"left\", type: e.OPERATION },\n  \"+\": { precedence: 2, associative: \"left\", type: e.OPERATION },\n  \"-\": { precedence: 2, associative: \"left\", type: e.OPERATION },\n  \"%\": { precedence: 3, associative: \"right\", type: e.OPERATION },\n  sin: { precedence: 4, associative: \"right\", type: e.FUNCTION },\n  cos: { precedence: 4, associative: \"right\", type: e.FUNCTION },\n  tan: { precedence: 4, associative: \"right\", type: e.FUNCTION },\n  sqrt: { precedence: 4, associative: \"right\", type: e.FUNCTION },\n  nthrt: { precedence: 4, associative: \"right\", type: e.FUNCTION },\n  \",\": { precedence: 2, associative: \"left\", type: e.FUNCTION_ARGUMENT }\n}, u = {\n  \"^\": { precedence: 4, associative: \"right\", type: e.OPERATION },\n  \"*\": { precedence: 3, associative: \"left\", type: e.OPERATION },\n  \"/\": { precedence: 3, associative: \"left\", type: e.OPERATION },\n  \"+\": { precedence: 2, associative: \"left\", type: e.OPERATION },\n  \"-\": { precedence: 2, associative: \"left\", type: e.OPERATION },\n  \"%\": { precedence: 3, associative: \"right\", type: e.OPERATION },\n  sin: { precedence: 4, associative: \"right\", type: e.FUNCTION },\n  cos: { precedence: 4, associative: \"right\", type: e.FUNCTION },\n  tan: { precedence: 4, associative: \"right\", type: e.FUNCTION },\n  sqrt: { precedence: 4, associative: \"right\", type: e.FUNCTION },\n  nthrt: { precedence: 4, associative: \"right\", type: e.FUNCTION },\n  ln: { precedence: 4, associative: \"right\", type: e.FUNCTION },\n  log: { precedence: 4, associative: \"right\", type: e.FUNCTION }\n}, R = {\n  \"&\": { precedence: 3, associative: \"left\", type: e.OPERATION },\n  \"|\": { precedence: 3, associative: \"left\", type: e.OPERATION },\n  \"!\": { precedence: 4, associative: \"right\", type: e.OPERATION },\n  \"-\": { precedence: 2, associative: \"left\", type: e.OPERATION }\n};\nclass g {\n  #i;\n  #s = [];\n  #e = {};\n  #n = [];\n  #t;\n  constructor(c) {\n    this.#i = typeof c > \"u\" ? N.POLYNOM : c, this.tokenConfigInitialization();\n  }\n  // Getter\n  get rpn() {\n    return this.#s;\n  }\n  get rpnToken() {\n    return this.#s.map((c) => c.token);\n  }\n  tokenConfigInitialization() {\n    return this.#i === N.SET ? (this.#e = R, this.#t = !1) : this.#i === N.NUMERIC ? (this.#e = u, this.#t = !0) : this.#i === N.EXPRESSION ? (this.#e = k, this.#t = !0) : (this.#e = d, this.#t = !0), this.#n = Object.keys(this.#e).sort((c, i) => i.length - c.length), this.#e;\n  }\n  /**\n   * Get the next token to analyse.\n   * @param expr (string) Expression to analyse\n   * @param start (number) CUrrent position in the expr string.\n   */\n  NextToken(c, i) {\n    let n, t;\n    if (n = \"\", t = void 0, c[i] === \"(\")\n      n = \"(\", t = e.LEFT_PARENTHESIS;\n    else if (c[i] === \")\")\n      n = \")\", t = e.RIGHT_PARENTHESIS;\n    else if (c[i] === \",\")\n      n = \",\", t = e.FUNCTION_ARGUMENT;\n    else {\n      for (const s of this.#n)\n        if (c.substring(i, i + s.length) === s) {\n          n += s, t = this.#e[s].type;\n          break;\n        }\n      for (const s in T)\n        if (c.substring(i, i + s.length) === s) {\n          n += s, t = e.CONSTANT;\n          break;\n        }\n      if (n === \"\")\n        if (/[0-9.]/.exec(c[i])) {\n          const s = /^([0-9.]+)/.exec(c.substring(i));\n          n = s ? s[0] : \"\", t = e.COEFFICIENT;\n        } else if (/[a-zA-Z]/.exec(c[i])) {\n          const s = /^([a-zA-Z])/.exec(c.substring(i));\n          n = s ? s[0] : \"\", t = e.VARIABLE;\n        } else\n          console.log(\"Unidentified token\", c[i], c, i), n = c[i], t = e.MONOM;\n    }\n    if (t === void 0)\n      throw new Error(`Token type is undefined for token ${n}`);\n    return [n, i + n.length, t];\n  }\n  /**\n   * Parse an expression using the shutting yard tree algorithms\n   * @param expr (string) Expression to analyse\n   * Returns a RPN list of items.\n   * @param uniformize\n   */\n  parse(c, i) {\n    const n = [], t = [];\n    let s = \"\", f = 0, l;\n    (i ?? this.#t) && (c = O(c, this.#e));\n    let E = 50, a;\n    for (; f < c.length; ) {\n      if (E--, E === 0) {\n        console.log(\"SECURITY LEVEL 1 EXIT\");\n        break;\n      }\n      switch ([s, f, l] = this.NextToken(c, f), l) {\n        case e.MONOM:\n        case e.COEFFICIENT:\n        case e.VARIABLE:\n        case e.CONSTANT:\n          n.push({\n            token: s,\n            tokenType: l\n          });\n          break;\n        case e.OPERATION:\n          if (t.length > 0) {\n            let h = t[t.length - 1];\n            for (a = 50; h.token in this.#e && //either o1 is left-associative and its precedence is less than or equal to that of o2,\n            (this.#e[s].associative === \"left\" && this.#e[s].precedence <= this.#e[h.token].precedence || //or o1 is right associative, and has precedence less than that of o2,\n            this.#e[s].associative === \"right\" && this.#e[s].precedence < this.#e[h.token].precedence); ) {\n              if (a--, a === 0) {\n                console.log(\"SECURITY LEVEL 2 OPERATION EXIT\");\n                break;\n              }\n              if (n.push(t.pop() ?? { token: \"\", tokenType: e.OPERATION }), t.length === 0)\n                break;\n              h = t[t.length - 1];\n            }\n          }\n          t.push({ token: s, tokenType: l });\n          break;\n        case e.FUNCTION_ARGUMENT:\n          for (a = 50; t[t.length - 1].token !== \"(\" && t.length > 0; ) {\n            if (a--, a === 0) {\n              console.log(\"SECURITY LEVEL 2 FUNCTION ARGUMENT EXIT\");\n              break;\n            }\n            n.push(t.pop() ?? { token: s, tokenType: l });\n          }\n          break;\n        case e.LEFT_PARENTHESIS:\n          t.push({ token: s, tokenType: l }), c[f] === \"-\" && n.push({ token: \"0\", tokenType: e.COEFFICIENT });\n          break;\n        case e.RIGHT_PARENTHESIS:\n          for (a = 50; t[t.length - 1].token !== \"(\" && t.length > 1; ) {\n            if (a--, a === 0) {\n              console.log(\"SECURITY LEVEL 2 CLOSING PARENTHESIS EXIT\");\n              break;\n            }\n            n.push(t.pop() ?? { token: s, tokenType: l });\n          }\n          t.pop();\n          break;\n        case e.FUNCTION:\n          t.push({ token: s, tokenType: l });\n          break;\n        default:\n          throw new Error(`Token type ${s} is not handled`);\n      }\n    }\n    return this.#s = n.concat(t.reverse()), this;\n  }\n}\nclass A {\n  _rpn;\n  _expression;\n  _isValid;\n  constructor(c, i) {\n    this._expression = c;\n    try {\n      this._rpn = new g(N.NUMERIC).parse(c, i).rpn;\n    } catch (n) {\n      throw this._rpn = null, this._isValid = !1, console.warn(n), new Error(`There was a problem parsing: ${c}`);\n    }\n  }\n  get rpn() {\n    return this._rpn ?? [];\n  }\n  get isValid() {\n    if (this._isValid === void 0)\n      try {\n        this.evaluate({ x: 2 });\n      } catch {\n        this._isValid = !1;\n      }\n    return this._isValid ?? !1;\n  }\n  set isValid(c) {\n    this._isValid = c;\n  }\n  get expression() {\n    return this._expression;\n  }\n  evaluate(c) {\n    const i = [];\n    if (this._rpn === null)\n      return this._isValid = !1, 0;\n    this._isValid = !0;\n    for (const n of this._rpn)\n      if (n.tokenType === e.COEFFICIENT)\n        if (!isNaN(+n.token))\n          i.push(+n.token);\n        else {\n          const t = n.token.split(\"/\");\n          if (t.length !== 2)\n            throw this._isValid = !1, new Error(\"This coefficient is not a fraction\");\n          i.push(+t[0] / +t[1]);\n        }\n      else if (n.tokenType === e.VARIABLE && c !== void 0)\n        Object.hasOwn(c, n.token) && i.push(+c[n.token]);\n      else if (n.tokenType === e.CONSTANT)\n        i.push(T[n.token]);\n      else if (n.tokenType === e.OPERATION) {\n        if (n.token === \"*\") {\n          const t = i.pop(), s = i.pop();\n          if (s === void 0 || t === void 0)\n            throw this._isValid = !1, new Error(`The multiplication factors ${s ?? \"a\"} or ${t ?? \"b\"} are not defined`);\n          i.push(s * t);\n        } else if (n.token === \"/\") {\n          const t = i.pop(), s = i.pop();\n          if (s === void 0 || t === void 0)\n            throw this._isValid = !1, new Error(`The division values ${s ?? \"a\"} or ${t ?? \"b\"} are not defined`);\n          i.push(s / t);\n        } else if (n.token === \"+\") {\n          const t = i.pop(), s = i.pop();\n          if (s === void 0 || t === void 0)\n            throw this._isValid = !1, new Error(`The addition values ${s ?? \"a\"} or ${t ?? \"b\"} are not defined`);\n          i.push(+s + +t);\n        } else if (n.token === \"-\") {\n          const t = i.pop(), s = i.pop() ?? 0;\n          if (t === void 0)\n            throw this._isValid = !1, new Error(\"The subtraction value b is  not defined\");\n          i.push(s - t);\n        } else if (n.token === \"^\") {\n          const t = i.pop(), s = i.pop();\n          if (s === void 0 || t === void 0)\n            throw this._isValid = !1, new Error(`The base value ${s ?? \"a\"} or exponent ${t ?? \"b\"} are not defined`);\n          i.push(Math.pow(s, t));\n        }\n      } else if (n.tokenType === e.FUNCTION) {\n        const t = i.pop();\n        if (t === void 0)\n          throw this._isValid = !1, new Error(`The parameters for ${n.token} is not defined`);\n        if (n.token === \"sin\")\n          i.push(Math.sin(t));\n        else if (n.token === \"cos\")\n          i.push(Math.cos(t));\n        else if (n.token === \"tan\")\n          i.push(Math.tan(t));\n        else if (n.token === \"sqrt\")\n          i.push(Math.sqrt(t));\n        else if (n.token === \"nthrt\") {\n          const s = i.pop();\n          if (s === void 0)\n            throw this._isValid = !1, new Error(\"The nthrt function requires two parameters\");\n          t % 2 === 0 && s < 0 ? i.push(NaN) : i.push((s < 0 ? -1 : 1) * Math.pow(Math.abs(s), 1 / t));\n        } else n.token === \"ln\" ? i.push(Math.log(t)) : n.token === \"log\" && i.push(Math.log10(t));\n      }\n    if (i.length === 1)\n      return this._numberCorrection(i[0]);\n    throw new Error(`There was a problem parsing: ${this._expression}`);\n  }\n  _numberCorrection(c, i = 8) {\n    return +c.toFixed(i);\n  }\n}\nexport {\n  A as NumExp,\n  g as ShutingYard,\n  N as ShutingyardMode,\n  e as ShutingyardType,\n  T as tokenConstant\n};\n//# sourceMappingURL=piexpression.js.map\n","/***\r\n * Monom class\r\n */\r\nimport type {\r\n    IAlgebra,\r\n    IAnalyse,\r\n    IExpression,\r\n    InputAlgebra,\r\n    InputValue,\r\n    IPiMathObject,\r\n    literalType\r\n} from \"../pimath.interface\"\r\nimport {Fraction} from \"../coefficients\"\r\nimport {Numeric} from \"../numeric\"\r\n\r\nimport {ShutingYard, ShutingyardType, type Token} from \"piexpression\"\r\n\r\nexport class Monom implements IPiMathObject<Monom>, IExpression<Monom>, IAnalyse<Monom>, IAlgebra<Monom> {\r\n    #coefficient: Fraction\r\n    #literal: literalType<Fraction>\r\n\r\n    constructor(value?: InputValue<Fraction>)\r\n    constructor(value?: Monom)\r\n    constructor(value?: InputAlgebra<Fraction>) {\r\n        this.#coefficient = new Fraction().zero()\r\n        this.#literal = {}\r\n\r\n        if (value !== undefined) {\r\n            // A string is given - try to parse the value.\r\n            this.parse(value)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    // -----------------------------------------\r\n    /**\r\n     * Parse a string to a monom. The string may include fraction.\r\n     * @param inputStr\r\n     */\r\n    public parse(inputStr: InputAlgebra<Monom>): this {\r\n        // Initialize the monom\r\n        this.#coefficient = new Fraction()\r\n        this.#literal = {}\r\n\r\n        if (inputStr instanceof Monom) {\r\n            this.#coefficient = inputStr.#coefficient.clone()\r\n\r\n            // Copy the literal parts\r\n            this.#cloneLiteral(inputStr)\r\n            return this\r\n        }\r\n\r\n        if (inputStr instanceof Fraction) {\r\n            this.#coefficient = inputStr.clone()\r\n            return this\r\n        }\r\n\r\n        if (typeof inputStr === 'number') {\r\n            this.#coefficient = new Fraction(inputStr)\r\n            return this\r\n        }\r\n\r\n\r\n        if (!isNaN(Number(inputStr))) {\r\n            this.#coefficient = new Fraction(Number(inputStr))\r\n        } else {\r\n            this.#shutingYardToReducedMonom(inputStr)\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Clone the current Monom.\r\n     */\r\n    public clone = (): Monom => {\r\n        const F: Monom = new Monom()\r\n\r\n        F.coefficient = this.#coefficient.clone()\r\n\r\n        // Copy the literal parts.\r\n        for (const k in this.#literal) {\r\n            F.setLetter(k, this.#literal[k].clone())\r\n        }\r\n        return F\r\n    }\r\n\r\n    /**\r\n     * Get the tex output of the monom\r\n     */\r\n    public get tex(): string {\r\n        let L = ''\r\n        const letters = Object.keys(this.#literal).sort()\r\n\r\n        for (const letter of letters) {\r\n            if (this.#literal[letter].isNotZero()) {\r\n                L += letter\r\n                if (this.#literal[letter].isNotEqual(1)) {\r\n                    L += `^{ ${this.#literal[letter].tfrac.tex} }`\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this.#coefficient.value != 0) {\r\n                return this.#coefficient.frac.tex\r\n            } else {\r\n                return '0'\r\n            }\r\n        } else {\r\n            if (this.#coefficient.value === 1) {\r\n                return L\r\n            } else if (this.#coefficient.value === -1) {\r\n                return `-${L}`\r\n            } else if (this.#coefficient.value === 0) {\r\n                return '0'\r\n            } else {\r\n                return `${this.#coefficient.frac.tex}${L}`\r\n            }\r\n        }\r\n    }\r\n\r\n    // Display getter\r\n    /**\r\n     * This display getter is to be used in the polynom display getter\r\n     */\r\n    public get display(): string {\r\n        let L = ''\r\n        const letters = Object.keys(this.#literal).sort()\r\n        for (const letter of letters) {\r\n            if (this.#literal[letter].isNotZero()) {\r\n                L += letter\r\n                if (this.#literal[letter].isNotEqual(1)) {\r\n                    L += `^(${this.#literal[letter].display})`\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this.#coefficient.value != 0) {\r\n                return this.#coefficient.display\r\n            } else {\r\n                return ''\r\n            }\r\n        } else {\r\n            if (this.#coefficient.value === 1) {\r\n                return L\r\n            } else if (this.#coefficient.value === -1) {\r\n                return `-${L}`\r\n            } else if (this.#coefficient.value === 0) {\r\n                return '0'\r\n            } else {\r\n                return `${this.#coefficient.display}${L}`\r\n            }\r\n        }\r\n    }\r\n\r\n    public static gcd = (...monoms: Monom[]): Monom => {\r\n        // All the monoms must be with natural powers...\r\n        for (const m of monoms) {\r\n            if (m.containsRationalPower()) {\r\n                return new Monom().zero()\r\n            }\r\n        }\r\n\r\n        const M = new Monom(),\r\n            n: number = Numeric.gcd(...monoms.map(value => value.coefficient.numerator)),\r\n            d: number = Numeric.lcm(...monoms.map(value => value.coefficient.denominator))\r\n\r\n        // Get the coefficient.\r\n        M.coefficient = new Fraction(n, d).reduce()\r\n\r\n        // Set the literal parts - go through each monoms literal parts and get only the lowest degree of each letters.\r\n        for (const m of monoms) {\r\n            // Remove the inexistant letters from the resulting monom\r\n            for (const letter in M.literal) {\r\n                if (!(letter in m.literal)) {\r\n                    M.literal[letter].zero()\r\n                }\r\n            }\r\n            for (const letter in m.literal) {\r\n                if (!M.hasVariable(letter) && m.literal[letter].isStrictlyPositive()) {\r\n                    M.literal[letter] = m.literal[letter].clone()\r\n                } else {\r\n                    M.literal[letter] = new Fraction(Math.min(m.literal[letter].value, M.literal[letter].value))\r\n                }\r\n            }\r\n        }\r\n\r\n        return M\r\n    }\r\n\r\n    /**\r\n     * Multiply two monoms and return a NEW monom.\r\n     * @param monoms\r\n     */\r\n    public static xMultiply = (...monoms: Monom[]): Monom => {\r\n        const M = new Monom().one()\r\n\r\n        for (const m of monoms) {\r\n            M.multiply(m)\r\n        }\r\n\r\n        return M\r\n    }\r\n\r\n    /**\r\n     * Add all similar monoms. If they aren't similar, they are simply skipped.\r\n     * @param M (Monom[]) The monoms to add.\r\n     */\r\n    public add = (...M: InputAlgebra<Fraction>[]): this => {\r\n        for (const m of M) {\r\n            // If the value given is not a monom, create it.\r\n            const mAsMonom = (!(m instanceof Monom)) ? new Monom(m) : m\r\n\r\n            if (this.isSameAs(mAsMonom)) {\r\n                if (this.isZero()) {\r\n                    this.#cloneLiteral(mAsMonom)\r\n                }\r\n\r\n                this.#coefficient.add(mAsMonom.coefficient)\r\n            } else {\r\n                console.log('Add monom: ' + this.display + ' is not similar with ', mAsMonom.display)\r\n            }\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Get the coefficient \\\\(k\\\\) of the Monom \\\\(k\\\\cdot x^{n}\\\\)\r\n     * @returns {Fraction}\r\n     */\r\n    public get coefficient(): Fraction {\r\n        return this.#coefficient\r\n    }\r\n\r\n    /**\r\n     * Set the coefficient \\\\(k\\\\) value of the monom\r\n     * @param {Fraction | number | string} F\r\n     */\r\n    public set coefficient(F: InputValue<Fraction>) {\r\n        this.#coefficient = new Fraction(F)\r\n    }\r\n\r\n    public containsRationalPower = (): boolean => {\r\n        return Object.values(this.#literal).some((value) => value.isRational())\r\n    }\r\n\r\n    /**\r\n     * Get the degree of a monom. If no setLetter is given, the result will be the global degree.\r\n     * @param letter (string) Letter to get to degree (power)\r\n     */\r\n    public degree = (letter?: string): Fraction => {\r\n        if (this.variables.length === 0) {\r\n            return new Fraction().zero()\r\n        }\r\n        if (letter === undefined) {\r\n            // Not setLetter given -> we get the global monom degree (sum of all the letters).\r\n            return Object.values(this.#literal).reduce((t, n) => t.clone().add(n))\r\n        } else {\r\n            // A setLetter is given -> get the corresponding power.\r\n            return !this.hasVariable(letter) ? new Fraction().zero() : this.#literal[letter].clone()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Derivative the monom\r\n     * @param letter\r\n     */\r\n    public derivative = (letter = 'x'): Monom => {\r\n        // No setLetter given - assume it's the setLetter 'x'\r\n        if (this.hasVariable(letter)) {\r\n            const d = this.#literal[letter].clone(),\r\n                dM = this.clone()\r\n\r\n            // Subtract one to the degree.\r\n            dM.#literal[letter].subtract(1)\r\n\r\n            // Multiply the coefficient by the previous degree\r\n            dM.#coefficient.multiply(new Fraction(d.clone()))\r\n            return dM\r\n        } else {\r\n            return new Monom().zero()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Divide the current monoms by multiple monoms\r\n     * @param M (Monom[])\r\n     */\r\n    public divide = (...M: InputAlgebra<Fraction>[]): this => {\r\n        // Depending on the given value, choose the current item\r\n        for (const m of M) {\r\n            // If the value given is not a monom, create it.\r\n            const mAsMonom = (!(m instanceof Monom)) ? new Monom(m) : m\r\n\r\n            // Divide the coefficient\r\n            this.#coefficient.divide(mAsMonom.coefficient)\r\n\r\n            // Subtract the power values\r\n            for (const letter in mAsMonom.literal) {\r\n\r\n                this.#literal[letter] = this.hasVariable(letter) ?\r\n                    this.#literal[letter].subtract(mAsMonom.literal[letter]) :\r\n                    mAsMonom.literal[letter].clone().opposite()\r\n\r\n\r\n                // If the power of a particular setLetter is zero, delete it from the literal part..\r\n                if (this.#literal[letter].isZero()) {\r\n                    this.removeVariable(letter)\r\n                }\r\n            }\r\n        }\r\n        return this\r\n    }\r\n\r\n    public get dividers(): Monom[] {\r\n        // Decompose only if the coefficient is a natural number\r\n        if (!this.coefficient.isRelative()) {\r\n            return [this.clone()]\r\n        }\r\n\r\n        // Decompose only if the power values are natural numbers.\r\n        if (this.containsRationalPower()) {\r\n            return [this.clone()]\r\n        }\r\n\r\n        // Security : do not do this if greater than 10000\r\n        if (this.coefficient.numerator > 1000000) {\r\n            return [this.clone()]\r\n        }\r\n\r\n        const dividers = Numeric.dividers(Math.abs(this.coefficient.numerator))\r\n\r\n        // Decompose the literals parts.\r\n        let literals: literalType<Fraction>[] = []\r\n        for (const L in this.literal) {\r\n            // L is the letter.\r\n            literals = this._getLiteralDividers(literals, L)\r\n        }\r\n\r\n        const monomDividers: Monom[] = []\r\n        if (literals.length > 0 && dividers.length > 0) {\r\n            for (const N of dividers) {\r\n                for (const L of literals) {\r\n                    const M = new Monom()\r\n                    M.coefficient = new Fraction(N)\r\n                    M.literal = L\r\n                    monomDividers.push(M)\r\n                }\r\n            }\r\n        } else if (dividers.length === 0) {\r\n            for (const L of literals) {\r\n                const M = new Monom()\r\n                M.coefficient = new Fraction().one()\r\n                M.literal = L\r\n                monomDividers.push(M)\r\n            }\r\n        } else {\r\n            for (const N of dividers) {\r\n                const M = new Monom()\r\n                M.coefficient = new Fraction(N)\r\n                monomDividers.push(M)\r\n            }\r\n        }\r\n\r\n        return monomDividers.length === 0 ? [new Monom().one()] : monomDividers\r\n    }\r\n\r\n    /**\r\n     * Evaluate a monom. Each setLetter must be assigned to a Fraction.\r\n     * @param values    Dictionary of <setLetter: Fraction>\r\n     * @param asNumeric\r\n     */\r\n    public evaluate = (values: literalType<number | Fraction> | InputValue<Fraction>, asNumeric?: boolean): Fraction | number => {\r\n        // If as numeric return the numeric value\r\n        if (asNumeric === true) {\r\n            // Convert all values to numeric\r\n            // If the value is a Fraction, convert it to a number\r\n            if (values instanceof Fraction) {\r\n                return this.#evaluateAsNumeric(values.value)\r\n            }\r\n\r\n            // If the value is a number, return the numeric value\r\n            if (typeof values === 'number') {\r\n                return this.#evaluateAsNumeric(values)\r\n            }\r\n\r\n            // If the value is an object, return the numeric value\r\n            if (typeof values === 'object') {\r\n                // Convert {[key:string]:Fraction} to {[key:string]:number}\r\n                const tmpValues: literalType<number> = {}\r\n                for (const L in values) {\r\n                    tmpValues[L] = new Fraction(values[L]).value\r\n                }\r\n\r\n                return this.#evaluateAsNumeric(tmpValues)\r\n            }\r\n        }\r\n\r\n        // The answer must be a Fraction\r\n        const r = this.coefficient.clone()\r\n\r\n        if (typeof values === 'number' || values instanceof Fraction) {\r\n            const tmpValues: literalType<Fraction> = {}\r\n            tmpValues[this.variables[0]] = new Fraction(values)\r\n            return this.evaluate(tmpValues)\r\n        }\r\n\r\n        if (typeof values === 'object') {\r\n            if (this.variables.length === 0) {\r\n                return this.coefficient\r\n            }\r\n\r\n            for (const L in this.#literal) {\r\n                const value = new Fraction(values[L])\r\n\r\n                r.multiply(value.pow(this.#literal[L]))\r\n            }\r\n        }\r\n\r\n        return r\r\n    }\r\n\r\n    // -------------------------------------\r\n    /**\r\n     * Determine if a monom contains a setLetter in it's literal part\r\n     * @param letter\r\n     */\r\n    public hasVariable = (letter?: string): boolean => {\r\n        // The letter was not found\r\n        return Object.hasOwn(this.#literal, letter ?? 'x')\r\n    }\r\n\r\n    public integrate(a: InputValue<Fraction>, b: InputValue<Fraction>, letter?: string): Fraction {\r\n        const primitive = this.primitive(letter)\r\n\r\n        return (primitive.evaluate(b) as Fraction)\r\n            .subtract(primitive.evaluate(a) as Fraction)\r\n    }\r\n\r\n    public inverse = (): this => {\r\n        this.#coefficient.opposite()\r\n        for (const letter in this.#literal) {\r\n            this.#literal[letter].opposite()\r\n        }\r\n        return this\r\n    }\r\n\r\n    public isDivisible = (div: Monom): boolean => {\r\n        // For all variables (letters), the current monom must have a degree higher than the divider\r\n        if (div.degree().isStrictlyPositive()) {\r\n            for (const letter of div.variables) {\r\n                if (!this.degree(letter).isGeq(div.degree(letter))) {\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n\r\n        // If the coefficient is rational, we suppose we don't need to check the division by the coefficient.\r\n        if (this.coefficient.isRational() || div.coefficient.isRational()) {\r\n            return true\r\n        }\r\n\r\n        return this.coefficient.clone().divide(div.coefficient).isRelative()\r\n    }\r\n\r\n    /**\r\n     * Determine if two monoms are equals\r\n     * @param M\r\n     */\r\n    public isEqual = (M: Monom): boolean => {\r\n        return this.isSameAs(M) && this.#coefficient.isEqual(M.coefficient)\r\n    }\r\n\r\n    public isLiteralSquare = (): boolean => {\r\n        for (const letter in this.literal) {\r\n            // A literal square must have a natural power\r\n            if (this.literal[letter].isRational()) {\r\n                return false\r\n            }\r\n\r\n            // The natural power must be be even\r\n            if (this.literal[letter].isEven()) {\r\n                return false\r\n            }\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is one\r\n     */\r\n    public isOne = (): boolean => {\r\n        return this.#coefficient.value === 1 && this.variables.length === 0\r\n    }\r\n\r\n    /**\r\n     * Determine if two monoms are similar\r\n     * @param M\r\n     */\r\n    public isSameAs = (M: Monom): boolean => {\r\n        // Get the list of all variables from both monoms.\r\n        const M1: string[] = this.variables\r\n        const M2: string[] = M.variables\r\n\r\n        // Get the list of all variables from both monoms.\r\n        const K: string[] = M1.concat(M2.filter((item) => !M1.includes(item)))\r\n\r\n        // If one of the monom is zero, it is the same than the other.\r\n        if (this.isZero() || M.isZero()) {\r\n            return true\r\n        }\r\n\r\n        // Both monoms has no literal part.\r\n        if (M1.length === 0 && M2.length === 0) {\r\n            return true\r\n        }\r\n\r\n        // Both monoms must have the same variables\r\n        if (M1.length !== M2.length) {\r\n            return false\r\n        }\r\n\r\n        // To _compare, both must be different from zero.\r\n        if (!this.isZero() && !M.isZero()) {\r\n            for (const key of K) {\r\n                // The variable is not available in one of the monom\r\n                if (!this.hasVariable(key) || !M.hasVariable(key)) {\r\n                    return false\r\n                }\r\n\r\n                // The variable does not have the same power in each monoms.\r\n                if (!this.#literal[key].isEqual(M.literal[key])) {\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n\r\n        // All are positive check - the monoms are the sames.\r\n        return true\r\n    }\r\n\r\n    public isSquare = (): boolean => {\r\n        if (!this.coefficient.isSquare()) {\r\n            return false\r\n        }\r\n        return this.isLiteralSquare()\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is null\r\n     */\r\n    public isZero = (): boolean => {\r\n        return this.#coefficient.value === 0\r\n    }\r\n\r\n    /**\r\n     * Get the literal part of \\\\(x^{n_1}y^{n_2}\\\\) as dictionary \\\\[\\\\begin{array}{ll}x&=n_1\\\\\\\\y&=n_2\\\\end{array}\\\\]\r\n     * @returns {literalType}\r\n     */\r\n    public get literal(): literalType<Fraction> {\r\n        return this.#literal\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom. Must be a dictionary {x: Fraction, y: Fraction, ...}\r\n     * @param {literalType<Fraction>} L\r\n     */\r\n    public set literal(L: literalType<Fraction>) {\r\n        this.#literal = L\r\n    }\r\n\r\n    /**\r\n     * Get the literal square roots of the Monom.\r\n     * @returns {literalType<Fraction>}\r\n     */\r\n    public get literalSqrt(): literalType<Fraction> {\r\n        // TODO: used in Polynom._factorize2ndDegree : remove it from here ?\r\n        if (this.isLiteralSquare()) {\r\n            const L: literalType<Fraction> = {}\r\n            for (const key in this.#literal) {\r\n                L[key] = this.#literal[key].clone().sqrt()\r\n            }\r\n            return L\r\n        } else {\r\n            return this.#literal\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom from a string\r\n     * @param inputStr  String like x^2y^3\r\n     */\r\n    public set literalStr(inputStr: string) {\r\n        // TODO : parse using ShutingYard tree !\r\n\r\n        // Match all x^n\r\n        for (const v of [...inputStr.matchAll(/([a-z])\\^([+-]?[0-9]+)/g)]) {\r\n            // Create the default letter entry if necessary.\r\n            if (!(v[1] in this.#literal)) {\r\n                this.#literal[v[1]] = new Fraction().zero()\r\n            }\r\n\r\n            // Add the new value.\r\n            // TODO: actually, it adds only numeric value\r\n            this.#literal[v[1]].add(+v[2])\r\n        }\r\n\r\n        // Match all x\r\n        for (const v of [...inputStr.matchAll(/([a-z](?!\\^))/g)]) {\r\n            // Match all single letters\r\n            if (!(v[1] in this.#literal)) {\r\n                this.#literal[v[1]] = new Fraction().zero()\r\n            }\r\n\r\n            // Add one to the value.\r\n            this.#literal[v[1]].add(1)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Multiple multiple monoms to the current monom\r\n     * @param M (Monom[]) The monoms to multiply to.\r\n     */\r\n    public multiply = (...M: InputAlgebra<Fraction>[]): this => {\r\n        for (const m of M) {\r\n            // If the value given is not a monom, create it.\r\n            const mAsMonom = (!(m instanceof Monom)) ? new Monom(m) : m\r\n\r\n            // Multiply the coefficient.\r\n            this.#coefficient.multiply(mAsMonom.coefficient)\r\n\r\n            // Multiply the literal parts.\r\n            for (const letter in mAsMonom.literal) {\r\n                if (!this.hasVariable(letter)) {\r\n                    this.#literal[letter] = mAsMonom.literal[letter].clone()\r\n                } else {\r\n                    this.#literal[letter].add(mAsMonom.literal[letter])\r\n                }\r\n            }\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Create a one value monom\r\n     */\r\n    public one = (): this => {\r\n        this.#coefficient = new Fraction().one()\r\n        this.#literal = {}\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Get the opposite\r\n     * Returns a monom.\r\n     */\r\n    public opposite = (): this => {\r\n        this.#coefficient.opposite()\r\n        return this\r\n    }\r\n\r\n    public get plotFunction(): string {\r\n        let L = ''\r\n        const letters = Object.keys(this.#literal).sort()\r\n\r\n        for (const letter of letters) {\r\n            if (this.#literal[letter].isNotZero()) {\r\n                L += (L === '' ? \"\" : \"*\") + letter\r\n                if (this.#literal[letter].isNotEqual(1)) {\r\n                    L += `^(${this.#literal[letter].display})`\r\n                }\r\n            }\r\n        }\r\n\r\n        // No literal part\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this.#coefficient.value != 0) {\r\n                return this.#coefficient.display\r\n            } else {\r\n                return ''\r\n            }\r\n        } else {\r\n            if (this.#coefficient.value === 1) {\r\n                return L\r\n            } else if (this.#coefficient.value === -1) {\r\n                return `-${L}`\r\n            } else if (this.#coefficient.value === 0) {\r\n                return '0'\r\n            } else {\r\n                return `${this.#coefficient.display}*${L}`\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the pow of a monom.\r\n     * @param nb (number) : Mathematical pow\r\n     */\r\n    public pow = (nb: number | Fraction): this => {\r\n        this.#coefficient.pow(nb)\r\n        for (const letter in this.#literal) {\r\n            this.#literal[letter].multiply(nb)\r\n        }\r\n        return this\r\n    }\r\n\r\n    public primitive = (letter = 'x'): Monom => {\r\n        // TODO: derivative including the ln value => implies creating different monom asSystem ?\r\n\r\n        // Zero monom\r\n        const M = this.clone()\r\n        let degree: Fraction\r\n\r\n        if (M.hasVariable(letter)) {\r\n            degree = M.degree(letter).clone().add(1)\r\n            M.coefficient = M.coefficient.clone().divide(degree)\r\n            M.setLetter(letter, degree)\r\n        } else {\r\n            // There is no letter.\r\n\r\n            // The coefficient might be zero (=> x) or a number a (=> ax)\r\n            if (M.coefficient.isZero()) {\r\n                M.coefficient = new Fraction().one()\r\n            }\r\n            M.setLetter(letter, 1)\r\n        }\r\n\r\n        return M\r\n    }\r\n\r\n    public reduce = (): this => {\r\n        // Reduce the coefficient\r\n        this.coefficient.reduce()\r\n\r\n        // Reduce the literal parts (removing null powers)\r\n        for (const letter in this.#literal) {\r\n            if (this.#literal[letter].isZero()) {\r\n                this.removeVariable(letter)\r\n            }\r\n        }\r\n        return this\r\n    }\r\n\r\n    public removeVariable(letter: string) {\r\n        /* eslint-disable */\r\n        delete this.#literal[letter]\r\n        /* eslint-enable */\r\n    }\r\n\r\n    /**\r\n     * Get the nth-root of the monom\r\n     */\r\n    public root = (): this => {\r\n        throw new Error('Method not implemented.')\r\n    }\r\n\r\n    /**\r\n     * Set the power of a particular setLetter\r\n     * @param letter (string) Letter to change\r\n     * @param pow (number) Power of the setLetter (must be positive integer.\r\n     */\r\n    public setLetter = (letter: string, pow: InputValue<Fraction>): this => {\r\n        if (!(pow instanceof Fraction)) {\r\n            return this.setLetter(letter, new Fraction(pow))\r\n        }\r\n\r\n        // Set the power of the letter to zero => remove it\r\n        if (this.hasVariable(letter) && pow.isZero()) {\r\n            this.removeVariable(letter)\r\n        }\r\n\r\n\r\n        this.#literal[letter] = pow.clone()\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Return the square root of a monom\r\n     */\r\n    public sqrt = (): this => {\r\n        if (this.isSquare()) {\r\n            this.#coefficient.sqrt()\r\n            for (const letter in this.#literal) {\r\n                this.#literal[letter].clone().divide(2)\r\n            }\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Subtract multiple monoms\r\n     * @param M (Monom[]) The monoms to subtract\r\n     */\r\n    public subtract = (...M: InputAlgebra<Fraction>[]): this => {\r\n        for (const m of M) {\r\n            // If the value given is not a monom, create it.\r\n            const mAsMonom = (!(m instanceof Monom)) ? new Monom(m) : m\r\n\r\n            if (this.isSameAs(mAsMonom)) {\r\n                if (this.isZero()) {\r\n                    this.#cloneLiteral(mAsMonom)\r\n                }\r\n\r\n                this.#coefficient.add(mAsMonom.clone().coefficient.opposite())\r\n            } else {\r\n                console.log('Subtract: Is not similar: ', mAsMonom.display)\r\n            }\r\n        }\r\n        return this\r\n    }\r\n\r\n    // Getter helpers.\r\n    /**\r\n     * Get the variables letters\r\n     */\r\n    public get variables(): string[] {\r\n        // const M = this.clone().clean()\r\n\r\n        const L: string[] = []\r\n        Object.entries(this.literal).forEach(\r\n            ([key, value]) => {\r\n                if (!value.isZero()) {\r\n                    L.push(key)\r\n                }\r\n            })\r\n        L.sort()\r\n        return L\r\n        // return Object.keys(M.literal)\r\n    }\r\n\r\n    /**\r\n     * Create a zero value monom\r\n     */\r\n    public zero = (): this => {\r\n        this.#coefficient = new Fraction().zero()\r\n        this.#literal = {}\r\n        return this\r\n    }\r\n\r\n    #cloneLiteral(inputStr: Monom) {\r\n        for (const k in inputStr.literal) {\r\n            this.#literal[k] = inputStr.literal[k].clone()\r\n        }\r\n    }\r\n\r\n    #evaluateAsNumeric = (values: literalType<number | Fraction> | InputValue<Fraction>): number => {\r\n        let r = this.coefficient.value\r\n\r\n        if (typeof values === \"number\") {\r\n            const tmpValues: literalType<number> = {}\r\n            const key = this.variables[0]\r\n            tmpValues[key] = values\r\n\r\n            return this.#evaluateAsNumeric(tmpValues)\r\n        }\r\n\r\n        if (values instanceof Fraction) {\r\n            const tmpValues: literalType<number> = {}\r\n            tmpValues[this.variables[0]] = new Fraction(values).value\r\n            return this.#evaluateAsNumeric(tmpValues)\r\n        }\r\n\r\n        if (typeof values === 'object') {\r\n            if (this.variables.length === 0) {\r\n                return this.coefficient.value\r\n            }\r\n\r\n            for (const L in this.#literal) {\r\n                const v = values[L]\r\n\r\n                if (v instanceof Fraction) {\r\n                    r *= v.value ** (this.#literal[L].value)\r\n                } else {\r\n                    r *= v ** (this.#literal[L].value)\r\n                }\r\n            }\r\n        }\r\n\r\n        return r\r\n    }\r\n\r\n    #shutingYardToReducedMonom = (inputStr: string): this => {\r\n        // Get the RPN array of the current expression\r\n        const SY: ShutingYard = new ShutingYard().parse(inputStr)\r\n        const rpn: { token: string, tokenType: ShutingyardType }[] = SY.rpn\r\n\r\n        const stack: Monom[] = []\r\n\r\n        if (rpn.length === 0) {\r\n            this.zero()\r\n            return this\r\n        } else if (rpn.length === 1) {\r\n            const element = rpn[0]\r\n\r\n            this.one()\r\n            if (element.tokenType === ShutingyardType.COEFFICIENT) {\r\n                this.coefficient = new Fraction(element.token)\r\n            } else if (element.tokenType === ShutingyardType.VARIABLE) {\r\n                this.setLetter(element.token, 1)\r\n            }\r\n            return this\r\n        } else {\r\n            // Reset the monom\r\n            for (const element of rpn) {\r\n                this.#shutingYard_AddToken(stack, element)\r\n            }\r\n        }\r\n\r\n        this.one()\r\n        this.multiply(stack[0])\r\n        return this\r\n    }\r\n\r\n    #shutingYard_AddToken = (stack: Monom[], element: Token): void => {\r\n        let q1: Monom, q2: Monom, m: Monom, letter: string, pow: Fraction\r\n\r\n        if (element.tokenType === ShutingyardType.COEFFICIENT) {\r\n            stack.push(new Monom(new Fraction(element.token)))\r\n\r\n        } else if (element.tokenType === ShutingyardType.VARIABLE) {\r\n            const M = new Monom().one()\r\n            M.setLetter(element.token, 1)\r\n            stack.push(M.clone())\r\n\r\n        } else if (element.tokenType === ShutingyardType.OPERATION) {\r\n            switch (element.token) {\r\n                case '-':\r\n                    // this should only happen for negative powers or for negative coefficient.\r\n                    q2 = (stack.pop()) ?? new Monom().zero()\r\n                    q1 = (stack.pop()) ?? new Monom().zero()\r\n\r\n                    stack.push(q1.subtract(q2))\r\n\r\n                    break\r\n                case '*':\r\n                    // Get the last element in the stack\r\n                    q2 = (stack.pop()) ?? new Monom().one()\r\n                    q1 = (stack.pop()) ?? new Monom().one()\r\n\r\n                    stack.push(q1.multiply(q2))\r\n                    break\r\n                case '/':\r\n                    // Get the last element in the stack\r\n                    q2 = (stack.pop()) ?? new Monom().one()\r\n                    q1 = (stack.pop()) ?? new Monom().one()\r\n\r\n                    stack.push(q1.divide(q2))\r\n                    break\r\n                case '^': {\r\n                    // get the two last elements in the stack\r\n                    const poppedCoefficient = stack.pop()?.coefficient\r\n                    pow = poppedCoefficient ?? new Fraction().one()\r\n                    m = stack.pop() ?? new Monom().one()\r\n\r\n                    letter = m.variables[0]\r\n\r\n                    if (letter) {\r\n                        m.setLetter(letter, pow)\r\n                    }\r\n\r\n                    stack.push(m)\r\n                    // this.multiply(m.clone())\r\n                    break\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getLiteralDividers(arr: literalType<Fraction>[], letter: string): literalType<Fraction>[] {\r\n        const tmpList: Record<string, Fraction>[] = []\r\n\r\n        // Be default, this.literal[letter] should be a rational number.\r\n        for (let d = 0; d <= this.literal[letter].value; d++) {\r\n            if (arr.length === 0) {\r\n                const litt: literalType<Fraction> = {}\r\n                litt[letter] = new Fraction(d)\r\n                tmpList.push(litt)\r\n            } else {\r\n                for (const item of arr) {\r\n                    const litt: literalType<Fraction> = {}\r\n                    for (const currentLetter in item) {\r\n                        litt[currentLetter] = item[currentLetter]\r\n                    }\r\n                    litt[letter] = new Fraction(d)\r\n                    tmpList.push(litt)\r\n                }\r\n            }\r\n        }\r\n        return tmpList\r\n    }\r\n}\r\n","export function wrapParenthesis(str: string, tex = true): string {\r\n    return tex ? `\\\\left( ${str} \\\\right)` : `(${str})`\r\n}\r\n\r\nexport function stripParenthesis(str: string): string {\r\n    if(str.startsWith('(')){\r\n        str = str.substring(1)\r\n    }\r\n\r\n    if(str.endsWith(')')){\r\n        str = str.substring(0, str.length-1)\r\n    }\r\n\r\n    return str\r\n}\r\n\r\nexport function wrapVert(str: string, tex = true): string {\r\n    return tex ? `\\\\left\\\\vert ${str} \\\\right\\\\vert` : `|${str}|`\r\n}\r\n\r\nexport function wrapNorm(str: string, tex = true): string {\r\n    return tex ? `\\\\left\\\\Vect ${str} \\\\right\\\\Vect` : `||${str}||`\r\n}\r\n\r\nexport function replace_in_array<T>(haystack: string[], search: string, target: string, start?: number, end?: number): T {\r\n    return haystack.map((x, index) => {\r\n        if (start !== undefined && index < start) {\r\n            return x\r\n        }\r\n        if (end !== undefined && index > end) {\r\n            return x\r\n        }\r\n        return x === search ? target : x\r\n    }) as T\r\n}\r\n","import type {IExpressionMultiply, IPiMathObject} from \"../pimath.interface\"\r\n\r\n// TODO: create other operation_** to make things more generic !\r\nexport function operation_pow<T extends IPiMathObject<T> & IExpressionMultiply<T>>(item: T, value: number): T {\r\n    // TODO: Implement the operation_pow to other classes\r\n    if (!Number.isSafeInteger(value)) {\r\n        throw new Error('Can only raise item by an integer')\r\n    }\r\n\r\n    if (value < 0) {\r\n        throw new Error('Can only raise item by a positive integer')\r\n    }\r\n\r\n    if (value === 0) {\r\n        return item.one()\r\n    }\r\n\r\n    const P = item.clone()\r\n    for (let i = 1; i < value; i++) {\r\n        item.multiply(P)\r\n    }\r\n\r\n    return item\r\n}\r\n","/**\r\n * Polynom module contains everything necessary to handle polynoms.*\r\n */\r\nimport {ShutingYard, ShutingyardType, type Token} from \"piexpression\"\r\nimport type {\r\n    IAlgebra,\r\n    IAnalyse,\r\n    IExpression,\r\n    InputAlgebra,\r\n    InputValue,\r\n    IPiMathObject,\r\n    ISolution,\r\n    literalType,\r\n    TABLE_OF_SIGNS,\r\n    TABLE_OF_SIGNS_VALUES\r\n} from \"../pimath.interface\"\r\nimport {Fraction} from \"../coefficients\"\r\nimport {Numeric} from '../numeric'\r\nimport {EquationSolver} from './equationSolver'\r\nimport {Monom} from './monom'\r\nimport {replace_in_array} from \"../helpers\"\r\nimport {operation_pow} from \"./operations\"\r\n\r\n\r\nexport type PolynomParsingType = InputValue<Polynom> | Monom\r\n\r\nexport interface IEuclidean {\r\n    quotient: Polynom,\r\n    reminder: Polynom\r\n}\r\n\r\n/**\r\n * Polynom class can handle polynoms, reorder, resolve, ...\r\n * ```\r\n * let P = new Polynom('3x-4')\r\n * ```\r\n */\r\nexport class Polynom implements IPiMathObject<Polynom>,\r\n    IExpression<Polynom>,\r\n    IAnalyse<Polynom>,\r\n    IAlgebra<Polynom> {\r\n\r\n    #defaultVariable = 'x'\r\n    #factors: Polynom[]\r\n    #monoms: Monom[]\r\n    #roots: ISolution[]\r\n    #rootsCache = false\r\n\r\n    constructor(value: InputValue<Fraction>)\r\n    constructor(value: string)\r\n    constructor(value: Monom)\r\n    constructor(value: Polynom)\r\n    constructor(...values: InputValue<Fraction>[])\r\n    constructor(...values: InputAlgebra<Polynom>[])\r\n    constructor(polynomString?: InputAlgebra<Polynom>, ...values: InputAlgebra<Fraction>[]) {\r\n        this.#monoms = []\r\n        this.#factors = []\r\n        this.#roots = []\r\n\r\n        if (polynomString !== undefined) {\r\n            this.parse(polynomString, ...values)\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Parse a string to a polynom.\r\n     * @param inputStr\r\n     * @param values\r\n     */\r\n    public parse = (inputStr: PolynomParsingType, ...values: InputAlgebra<Monom>[]): this => {\r\n        // Reset the main variables.\r\n        this.#monoms = []\r\n        this.#factors = []\r\n\r\n        if (typeof inputStr === 'string') {\r\n            return this.#parseString(inputStr, ...values)\r\n        } else if (\r\n            (typeof inputStr === 'number' || inputStr instanceof Fraction || inputStr instanceof Monom)\r\n            && (values.length === 0)\r\n        ) {\r\n            this.#monoms.push(new Monom(inputStr as Monom))\r\n        } else if (inputStr instanceof Monom && values.length > 0) {\r\n            this.#monoms.push(new Monom(inputStr))\r\n            values.forEach(m => {\r\n                this.#monoms.push(new Monom(m as Monom))\r\n            })\r\n        } else if (inputStr instanceof Polynom) {\r\n            for (const m of inputStr.monoms) {\r\n                this.#monoms.push(m.clone())\r\n            }\r\n        }\r\n\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Clone the polynom\r\n     */\r\n    public clone = (): Polynom => {\r\n        const P = new Polynom()\r\n        const M: Monom[] = []\r\n\r\n        for (const m of this.#monoms) {\r\n            M.push(m.clone())\r\n        }\r\n\r\n\r\n        P.monoms = M\r\n\r\n        return P\r\n    }\r\n\r\n    public get tex(): string {\r\n        return this.#genDisplay('tex')\r\n    }\r\n\r\n    public get display(): string {\r\n        return this.#genDisplay()\r\n    }\r\n\r\n    public add = (...values: InputAlgebra<Polynom>[]): Polynom => {\r\n\r\n        for (const value of values) {\r\n            if (value instanceof Polynom) {\r\n                this.#monoms = this.#monoms.concat(value.monoms)\r\n            } else if (value instanceof Monom) {\r\n                this.#monoms.push(value.clone())\r\n            } else if (typeof value === \"number\" && Number.isSafeInteger(value)) {\r\n                this.#monoms.push(new Monom(value.toString()))\r\n            } else {\r\n                this.#monoms.push(new Monom(value))\r\n            }\r\n        }\r\n\r\n\r\n        return this.reduce()\r\n    }\r\n\r\n    public commonMonom = (): Monom => {\r\n        const M = new Monom().one()\r\n        const numerator: number = this.gcdNumerator()\r\n        const denominator: number = this.gcdDenominator()\r\n        const degree = this.degree()\r\n\r\n        M.coefficient = new Fraction(numerator, denominator)\r\n        for (const L of this.variables) {\r\n            // Initialize the setLetter with the max degree\r\n            M.setLetter(L, degree)\r\n            for (const m of this.#monoms) {\r\n                M.setLetter(L, Fraction.min(m.degree(L), M.degree(L)))\r\n                if (M.degree(L).isZero()) {\r\n                    break\r\n                }\r\n\r\n            }\r\n        }\r\n        return M\r\n    }\r\n\r\n    public degree = (letter?: string): Fraction => {\r\n        let d: Fraction = new Fraction().zero()\r\n        for (const m of this.#monoms) {\r\n            d = Fraction.max(m.degree(letter).value, d)\r\n        }\r\n\r\n        return d\r\n    }\r\n\r\n    public derivative = (letter?: string): Polynom => {\r\n        const dP = new Polynom()\r\n\r\n        for (const m of this.#monoms) {\r\n            dP.add(m.derivative(letter))\r\n        }\r\n\r\n        return dP.reduce()\r\n    }\r\n\r\n    public divide = (value: InputAlgebra<Polynom>): Polynom => {\r\n\r\n        if (value instanceof Fraction) {\r\n            return this.#divideByFraction(value)\r\n        } else if (typeof value === 'number' && Number.isSafeInteger(value)) {\r\n            return this.#divideByInteger(value)\r\n        } else if (value instanceof Monom) {\r\n            return this.divide(new Polynom(value))\r\n        } else if (value instanceof Polynom) {\r\n            if (value.monoms.length === 1 && value.variables.length === 0) {\r\n                return this.#divideByFraction(value.monoms[0].coefficient)\r\n            } else {\r\n                const {quotient, reminder} = this.euclidean(value)\r\n                if (reminder.isZero()) {\r\n                    this.#monoms = quotient.monoms\r\n                    return this\r\n                }\r\n            }\r\n        } else if (typeof value === 'string') {\r\n            return this.divide(new Polynom(value))\r\n        }\r\n\r\n        throw new Error(`Cannot divide by ${value as unknown as string}`)\r\n    }\r\n\r\n    public empty = (): this => {\r\n        this.#monoms = []\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Divide the current polynom by another polynom.\r\n     * @param P\r\n     * returns {quotient: Polynom, reminder: Polynom}\r\n     */\r\n    public euclidean = (P: Polynom): IEuclidean => {\r\n        const letter: string = P.variables[0]\r\n        const quotient: Polynom = new Polynom().zero()\r\n        const reminder: Polynom = this.clone().reorder(letter)\r\n\r\n        // There is no variable - means it's a number\r\n        if (P.variables.length === 0) {\r\n            const q = this.clone().divide(P)\r\n\r\n            return {\r\n                quotient: q.reduce(),\r\n                reminder: new Polynom().zero()\r\n            }\r\n        }\r\n\r\n        // Get at least a letter\r\n        const maxMP: Monom = P.monomByDegree(undefined, letter)\r\n        const degreeP: Fraction = P.degree(letter)\r\n\r\n        let newM: Monom\r\n\r\n        // Make the Euclidean division of the two polynoms.\r\n        let MaxIteration = this.degree(letter).value * 2\r\n        while (reminder.degree(letter).isGeq(degreeP) && MaxIteration > 0) {\r\n            MaxIteration--\r\n\r\n            // Get the greatest monom divided by the max monom of the divider\r\n            newM = reminder.monomByDegree(undefined, letter).clone().divide(maxMP)\r\n\r\n            if (newM.isZero()) {\r\n                continue\r\n            }\r\n\r\n            // Get the new quotient and reminder.\r\n            quotient.add(newM)\r\n            reminder.subtract(P.clone().multiply(newM)).reduce()\r\n\r\n            // Check if the reminder is zero.\r\n            if (newM.degree(letter).isZero()) {\r\n                break\r\n            }\r\n        }\r\n\r\n        quotient.reduce()\r\n        reminder.reduce()\r\n        return {quotient, reminder}\r\n    }\r\n\r\n    public evaluate = (values: literalType<Fraction | number> | InputValue<Fraction>, asNumeric?: boolean): Fraction | number => {\r\n        // Return the numeric value, without using Fraction\r\n        if (asNumeric) {\r\n            return this.#evaluateAsNumeric(values)\r\n        }\r\n\r\n        // Build the evaluated fraction\r\n        const r = new Fraction().zero()\r\n        this.#monoms.forEach(monom => {\r\n            //console.log('Evaluate polynom: ', monom.display, values, monom.evaluate(values).display);\r\n            r.add(monom.evaluate(values, asNumeric))\r\n        })\r\n\r\n        return r\r\n    }\r\n\r\n    // -------------------------------------\r\n    /**\r\n     * Factorize a polynom and store the best results in factors.\r\n     * @param letter\r\n     */\r\n\r\n        // REFACTOR: duplicate code with equationSolver.\r\n    public factorize = (letter?: string): Polynom[] => {\r\n        let factors: Polynom[] = []\r\n        let P = this.clone().reorder()\r\n\r\n        // Extract the common monom\r\n        // 2x^3+6x^2 => 2x^2\r\n        const M = P.commonMonom()\r\n        // If the polynom starts with a negative monom, factorize it.\r\n        if (P.monomByDegree().coefficient.isStrictlyNegative() && M.coefficient.isStrictlyPositive() && !M.isOne()) {\r\n            M.opposite()\r\n        }\r\n\r\n\r\n        if (!M.isOne()) {\r\n            const tempPolynom: Polynom = new Polynom(M)\r\n            factors = [tempPolynom.clone()]\r\n            P = P.euclidean(tempPolynom).quotient\r\n        }\r\n\r\n        // Main loop\r\n        let securityLoop = P.degree().clone().multiply(2).value,\r\n            maxDegree = 1\r\n        while (securityLoop >= 0) {\r\n            securityLoop--\r\n            if (P.monoms.length < 2) {\r\n                // The polynom has only one monom => 7x^2\r\n                // No need to continue.\r\n                if (!P.isOne()) {\r\n                    factors.push(P.clone())\r\n                    P.one()\r\n                }\r\n                break\r\n            } else if (P.degree(letter).isOne()) {\r\n                // The polynom is a first degree polynom => 3x-5\r\n                // No need to continue\r\n                factors.push(P.clone())\r\n                P.one()\r\n                break\r\n            } else {\r\n                // Create the list of all \"potential\" polynom dividers.\r\n                let allDividers: Polynom[] = this.#getAllPotentialFactors(P, maxDegree, letter ?? 'x')\r\n                maxDegree = P.degree(letter).value\r\n\r\n                // Actually: 100ms\r\n                while (allDividers.length > 0) {\r\n                    const div = allDividers[0]\r\n\r\n                    if (!P.isDividableBy(div))\r\n                        // Not dividable. Remove it from the list\r\n                    {\r\n                        allDividers.shift()\r\n                    } else {\r\n                        // It's dividable - so make the division\r\n                        const result = P.euclidean(div)\r\n\r\n                        // Add the factor\r\n                        factors.push(div)\r\n\r\n                        // As it's dividable, get the quotient.\r\n                        P = result.quotient.clone()\r\n\r\n                        // filter all dividers that are no more suitable.\r\n                        allDividers = allDividers.filter(x => {\r\n                            const pX = P.monoms[0],\r\n                                pC = P.monoms[P.monoms.length - 1],\r\n                                dX = x.monoms[0],\r\n                                dC = x.monoms[x.monoms.length - 1]\r\n\r\n                            // Check last item (degree zero)\r\n                            if (!pC.isDivisible(dC)) {\r\n                                return false\r\n                            }\r\n\r\n                            // Check the first item (degree max)\r\n                            return pX.isDivisible(dX)\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Maybe there is still something in the Polynom (not everything was possible to factorize)\r\n        if (!P.isOne()) {\r\n            factors.push(P.clone())\r\n        }\r\n\r\n\r\n        // Save the factors\r\n        this.#factors = factors\r\n\r\n        return this.#factors\r\n    }\r\n\r\n    public fromCoefficients(...values: InputValue<Fraction>[]) {\r\n\r\n        this.#monoms = []\r\n        const letter = this.#defaultVariable ?? 'x'\r\n        values.reverse().forEach((coeff, index) => {\r\n            const monom = new Monom()\r\n            monom.coefficient = new Fraction(coeff)\r\n            monom.setLetter(letter, index)\r\n\r\n            this.#monoms.push(monom)\r\n        })\r\n\r\n        return this.reorder()\r\n    }\r\n\r\n    public gcdDenominator = (): number => {\r\n        return Numeric.gcd(...this.getDenominators())\r\n    }\r\n\r\n    public gcdNumerator = (): number => {\r\n        return Numeric.gcd(...this.getNumerators())\r\n    }\r\n\r\n    public getCoefficients(): Fraction[] {\r\n        // Assume there is only one letter.\r\n        const orderedPolynom = this.clone().reorder()\r\n\r\n        const length = this.degree().value + 1\r\n        const coeffs = new Array(length).fill(new Fraction(0)) as unknown as Fraction[]\r\n\r\n        orderedPolynom.monoms.forEach(monom => {\r\n            const index = length - monom.degree().value - 1\r\n            coeffs[index] = monom.coefficient.clone()\r\n        })\r\n\r\n        // return orderedPolynom.monoms.map(x=>x.coefficient)\r\n        return coeffs\r\n    }\r\n\r\n    // Next functions are used for for commonMonom, which is used in the factorize method.\r\n    public getDenominators = (): number[] => {\r\n        const denominators: number[] = []\r\n        for (const m of this.#monoms) {\r\n            denominators.push(m.coefficient.denominator)\r\n        }\r\n\r\n        return denominators\r\n    }\r\n\r\n    public getNumerators = (): number[] => {\r\n        const numerators: number[] = []\r\n        for (const m of this.#monoms) {\r\n            numerators.push(m.coefficient.numerator)\r\n        }\r\n\r\n        return numerators\r\n    }\r\n\r\n    public getZeroes = (): ISolution[] => {\r\n        if (this.degree().isZero()) {\r\n            return []\r\n        }\r\n\r\n        this.roots = new EquationSolver(this.clone()).solve()\r\n        return this.roots\r\n    }\r\n\r\n    public hasVariable(letter: string): boolean {\r\n        return this.variables.includes(letter)\r\n    }\r\n\r\n    public integrate = (a: InputValue<Fraction>, b: InputValue<Fraction>, letter = 'x'): Fraction => {\r\n        const primitive = this.primitive(letter)\r\n\r\n        const valuesA: literalType<Fraction> = {},\r\n            valuesB: literalType<Fraction> = {}\r\n\r\n        valuesA[letter] = new Fraction(a)\r\n        valuesB[letter] = new Fraction(b)\r\n\r\n        return (primitive.evaluate(valuesB) as Fraction).subtract(primitive.evaluate(valuesA))\r\n    }\r\n\r\n    public inverse(): Polynom | undefined {\r\n        return undefined\r\n    }\r\n\r\n    public isDeveloped = (polynomString: string): boolean => {\r\n        let P: Polynom\r\n\r\n        // Start by removing the parenthesis after a \"power\"\r\n        const pString = polynomString.replaceAll(/\\^\\(([-0-9/]+)\\)/g, '$1')\r\n\r\n        // There is at least one parenthesis - it is not developed.\r\n        if (pString.includes('(') || pString.includes(')')) {\r\n            return false\r\n        }\r\n\r\n\r\n        // Try to build the polynom\r\n        try {\r\n            // Build the polynom\r\n            P = new Polynom(polynomString)\r\n        } catch {\r\n            return false\r\n        }\r\n\r\n        // Both polynom aren't the same (once developed and reduced => they cannot be equivalent)\r\n        if (!this.isEqual(P)) {\r\n            return false\r\n        }\r\n\r\n\r\n        // Check that everything is completely developed. Actually, there are no parentheses... so it is fully developed\r\n        return true\r\n    }\r\n\r\n    public isDividableBy = (div: Polynom): boolean => {\r\n        // Quick evaluation.\r\n        if (div.degree().isOne()) {\r\n            const zero = div.getZeroes()[0]\r\n\r\n            if (zero.exact instanceof Fraction) {\r\n                return (this.evaluate(zero.exact) as Fraction).isZero()\r\n            } else {\r\n                return false\r\n            }\r\n\r\n        } else {\r\n            const {reminder} = this.euclidean(div)\r\n            return reminder.isZero()\r\n        }\r\n    }\r\n\r\n    public isEqual = (P: Polynom): boolean => {\r\n        return this.#compare(P, '=')\r\n    }\r\n\r\n    public get isMultiVariable(): boolean {\r\n        // Determine if a monom has more than one variable.\r\n        return this.#monoms.some(m => m.variables.length > 1)\r\n    }\r\n\r\n    public isOne(): boolean {\r\n        return this.#monoms.length === 1 && this.#monoms[0].coefficient.isOne() && this.degree().isZero()\r\n    }\r\n\r\n    public isOppositeAt = (P: Polynom): boolean => {\r\n        return this.#compare(P.clone().opposite(), '=')\r\n    }\r\n\r\n    public isReduced = (polynomString: string): boolean => {\r\n        // The polynom must be developed to be reduced.\r\n        if (!this.isDeveloped(polynomString)) {\r\n            return false\r\n        }\r\n\r\n\r\n        const P = new Polynom(polynomString)\r\n        if (P.monoms.length > this.monoms.length) {\r\n            return false\r\n        }\r\n\r\n\r\n        // TODO: Not sure the reduced asSystem checking is working properly !\r\n        for (const m of P.monoms) {\r\n            if (!m.coefficient.isReduced()) {\r\n                return false\r\n            }\r\n        }\r\n\r\n\r\n        return false\r\n    }\r\n\r\n    public isSameAs = (P: Polynom): boolean => {\r\n        return this.#compare(P, 'same')\r\n    }\r\n\r\n    public isZero(): boolean {\r\n        return (this.#monoms.length === 1 && this.#monoms[0].coefficient.isZero()) || this.#monoms.length === 0\r\n    }\r\n\r\n    public lcmDenominator = (): number => {\r\n        return Numeric.lcm(...this.getDenominators())\r\n    }\r\n\r\n    public lcmNumerator = (): number => {\r\n        return Numeric.lcm(...this.getNumerators())\r\n    }\r\n\r\n    public get length() {\r\n        return this.#monoms.length\r\n    }\r\n\r\n    public letters = (): string[] => {\r\n        let S = new Set<string>()\r\n\r\n        for (const m of this.#monoms) {\r\n            S = new Set([...S, ...m.variables])\r\n        }\r\n\r\n\r\n        return [...S]\r\n    }\r\n\r\n    public limitToInfinity = (letter?: string): Fraction => {\r\n        const M = this.monomByDegree(undefined, letter),\r\n            sign = M.coefficient.sign(),\r\n            degree = M.degree(letter)\r\n\r\n        if (degree.isStrictlyPositive()) {\r\n            return sign === 1 ? (new Fraction()).infinite() : (new Fraction()).infinite().opposite()\r\n        } else if (degree.isZero()) {\r\n            return M.coefficient\r\n        }\r\n\r\n\r\n        // Any other cases\r\n        return (new Fraction()).zero()\r\n    }\r\n\r\n    public limitToNegativeInfinity = (letter?: string): Fraction => {\r\n        const M = this.monomByDegree(undefined, letter),\r\n            sign = M.coefficient.sign(),\r\n            degree = M.degree(letter)\r\n\r\n        if (degree.isStrictlyPositive()) {\r\n            return sign === -1 ? (new Fraction()).infinite() : (new Fraction()).infinite().opposite()\r\n        } else if (degree.isZero()) {\r\n            return M.coefficient\r\n        }\r\n\r\n\r\n        // Any other cases\r\n        return (new Fraction()).zero()\r\n    }\r\n\r\n    public monomByDegree = (degree?: Fraction | number, letter?: string): Monom => {\r\n        if (degree === undefined)\r\n            // return the highest degree monom.\r\n        {\r\n            return this.monomByDegree(this.degree(letter), letter)\r\n        }\r\n\r\n\r\n        // Reduce the polynom.\r\n        const M = this.clone().reduce()\r\n        for (const m of M.#monoms) {\r\n            if (m.degree(letter).isEqual(degree)) {\r\n                return m.clone()\r\n            }\r\n        }\r\n\r\n\r\n        // Nothing was found - return the null monom.\r\n        return new Monom().zero()\r\n    }\r\n\r\n    // Used in LinearSystem.tex\r\n    public monomByLetter = (letter: string): Monom => {\r\n        const M = this.clone().reduce()\r\n        for (const m of M.#monoms) {\r\n            if (m.hasVariable(letter)) {\r\n                return m.clone()\r\n            }\r\n        }\r\n\r\n\r\n        return new Monom().zero()\r\n    }\r\n\r\n    // ------------------------------------------\r\n    public get monoms() {\r\n        return this.#monoms\r\n    }\r\n\r\n    public set monoms(M: Monom[]) {\r\n        this.#monoms = M\r\n    }\r\n\r\n    public monomsByDegree = (degree?: number | Fraction, letter?: string): Monom[] => {\r\n        if (degree === undefined)\r\n            // return the highest degree monom.\r\n        {\r\n            return this.monomsByDegree(this.degree(letter))\r\n        }\r\n\r\n        // Reduce the polynom.\r\n        const Ms: Monom[] = []\r\n\r\n        const M = this.clone().reduce()\r\n        for (const m of M.#monoms) {\r\n            if (m.degree(letter).isEqual(degree)) {\r\n                Ms.push(m.clone())\r\n            }\r\n        }\r\n\r\n\r\n        return Ms\r\n        // Nothing was found - return\r\n    }\r\n\r\n    public multiply = (value: InputAlgebra<Polynom>): Polynom => {\r\n\r\n        if (value instanceof Polynom) {\r\n            return this.#multiplyByPolynom(value)\r\n        } else if (value instanceof Fraction) {\r\n            return this.#multiplyByFraction(value)\r\n        } else if (value instanceof Monom) {\r\n            return this.#multiplyByMonom(value)\r\n        } else if (Number.isSafeInteger(value) && typeof value === 'number') {\r\n            return this.#multiplyByInteger(value)\r\n        } else if (typeof value === 'string') {\r\n            try {\r\n                const k = new Fraction(value)\r\n                return this.#multiplyByFraction(k)\r\n            } catch {\r\n                throw new Error('Cannot multiply by this value.')\r\n            }\r\n\r\n\r\n        }\r\n\r\n\r\n        // Something went wrong...\r\n        throw new Error('Cannot multiply by this value.')\r\n    }\r\n\r\n    public get numberOfVars(): number {\r\n        return this.variables.length\r\n    }\r\n\r\n    public one = (): this => {\r\n        this.#monoms = []\r\n        this.#monoms.push(new Monom().one())\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    public opposite = (): this => {\r\n        this.#monoms = this.#monoms.map(m => m.opposite())\r\n        return this\r\n    }\r\n\r\n    public get plotFunction(): string {\r\n        return this.#genDisplay('tex', false, false, true)\r\n    }\r\n\r\n    public pow = (nb: number): Polynom => {\r\n        return operation_pow(this as Polynom, nb).reduce()\r\n    }\r\n\r\n    public primitive = (letter?: string): Polynom => {\r\n        const dP = new Polynom()\r\n\r\n        for (const m of this.#monoms) {\r\n            dP.add(m.primitive(letter))\r\n        }\r\n\r\n        return dP\r\n    }\r\n\r\n    public reduce = (): Polynom => {\r\n        // Reduce the polynom\r\n\r\n        // Group the monoms by similarity\r\n        let i = 0\r\n        while (i < this.#monoms.length) {\r\n            for (let j = i + 1; j < this.#monoms.length; j++) {\r\n                if (this.#monoms[i].isSameAs(this.#monoms[j])) {\r\n                    this.#monoms[i].add(this.#monoms[j])\r\n                    this.#monoms.splice(j, 1)\r\n                    if (this.#monoms[i].isZero()) {\r\n                        this.#monoms[i] = new Monom().zero()\r\n                    }\r\n\r\n                    j--\r\n                }\r\n            }\r\n\r\n\r\n            i++\r\n        }\r\n\r\n        // Remove all null monoms\r\n        this.#monoms = this.#monoms.filter((m) => {\r\n            return !m.coefficient.isZero()\r\n        })\r\n\r\n        // Reduce all monoms coefficient.\r\n        for (const m of this.#monoms) {\r\n            m.coefficient.reduce()\r\n        }\r\n\r\n\r\n        if (this.length === 0) {\r\n            return new Polynom().zero()\r\n        }\r\n\r\n\r\n        return this.reorder()\r\n    }\r\n\r\n    public reorder = (letter = 'x', revert = false): this => {\r\n        const otherLetters = this.variables.filter(x => x !== letter)\r\n        this.#monoms.sort(function (a, b) {\r\n            const da = a.degree(letter).value,\r\n                db = b.degree(letter).value\r\n\r\n            // Values are different\r\n            if (da !== db) {\r\n                return revert ? da - db : db - da\r\n            }\r\n\r\n            // if values are equals, check other letters - it must be reverted in that case !\r\n            if (otherLetters.length > 0) {\r\n                for (const L of otherLetters) {\r\n                    const da = a.degree(L).value,\r\n                        db = b.degree(L).value\r\n\r\n                    // Values are different\r\n                    if (da !== db) {\r\n                        return revert ? da - db : db - da\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            return 0\r\n        })\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Replace a variable (letter) by a polynom.\r\n     * @param letter\r\n     * @param P\r\n     */\r\n    public replaceBy = (letter: string, P: Polynom): this => {\r\n        let pow: Fraction\r\n        const resultPolynom: Polynom = new Polynom().zero()\r\n\r\n        for (const m of this.monoms) {\r\n            if (!m.hasVariable(letter) || m.literal[letter].isZero()) {\r\n                resultPolynom.add(m.clone())\r\n            } else {\r\n                // We have found a variable to replace.\r\n\r\n                // Get the power.\r\n                pow = m.literal[letter].clone()\r\n\r\n                // Remove the variable from the monom\r\n                m.removeVariable(letter)\r\n\r\n                // Add the new monom to the result polynom\r\n                resultPolynom.add(P.clone().pow(Math.abs(pow.numerator)).multiply(m))\r\n            }\r\n        }\r\n\r\n\r\n        // Reduce the monoms\r\n        this.#monoms = resultPolynom.reduce().monoms\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n\r\n    public root(): Polynom {\r\n        throw new Error('Cannot take the root from a polynom')\r\n    }\r\n\r\n    get roots(): ISolution[] {\r\n        return this.#rootsCache ? this.#roots : this.getZeroes()\r\n    }\r\n\r\n    set roots(value: ISolution[]) {\r\n        this.#rootsCache = true\r\n        this.#roots = value\r\n    }\r\n\r\n    public setVariable(value: string): this {\r\n        this.#defaultVariable = value\r\n\r\n        return this\r\n    }\r\n\r\n    public sqrt(): Polynom {\r\n        throw new Error('Cannot take the square root from a polynom')\r\n    }\r\n\r\n    public subtract = (...values: InputAlgebra<Polynom>[]): Polynom => {\r\n        for (const value of values) {\r\n            if (value instanceof Polynom) {\r\n                this.add(value.clone().opposite())\r\n            } else if (value instanceof Monom) {\r\n                this.#monoms.push(value.clone().opposite())\r\n            } else {\r\n                this.#monoms.push(new Monom(value).opposite())\r\n            }\r\n        }\r\n\r\n\r\n        return this.reduce()\r\n    }\r\n\r\n    public tableOfSigns(): TABLE_OF_SIGNS {\r\n        // returns ['+-', 'd|t|z', '+-']...\r\n\r\n        // global roots from eventually Polyfactor. Allows to add \"extra column\".\r\n        const roots: ISolution[] = this.roots\r\n\r\n        // Build the table os sign length and default values\r\n        // The signs looks like: ['+', 't', '+', 't', '+', 't', '+']\r\n        let signs: TABLE_OF_SIGNS_VALUES[] = new Array(2 * roots.length + 1)\r\n            .fill('')\r\n            .map((_x, index) => {\r\n                return index % 2 === 0 ? '' : 'z'\r\n            })\r\n\r\n\r\n        if (signs.length === 1) {\r\n            // The polynom is a constant or has not roots\r\n            const [a] = this.getCoefficients().map(x => x.value)\r\n            signs = replace_in_array(signs, '', a > 0 ? '+' : '-')\r\n        } else if (this.degree().isOne()) {\r\n            // First degree: ax+b\r\n            const [a] = this.getCoefficients().map(x => x.value)\r\n\r\n            // Get the index of the zero.\r\n            signs[0] = a > 0 ? '-' : '+'\r\n            signs[1] = 'z'\r\n            signs[2] = a > 0 ? '+' : '-'\r\n        } else {\r\n            const testingRoots = [\r\n                roots[0].value - 1,\r\n                ...roots.map((_root, index) => {\r\n                    return index === roots.length - 1 ?\r\n                        roots[index].value + 1 :\r\n                        (roots[index].value + roots[index + 1].value) / 2\r\n                })\r\n            ]\r\n\r\n            testingRoots.forEach((test, index) => {\r\n                const sign = this.evaluate({x: test}, true) as number\r\n                signs[index * 2] = sign > 0 ? '+' : '-'\r\n            })\r\n        }\r\n\r\n        return {roots, signs}\r\n    }\r\n\r\n    public get value(): number | undefined {\r\n        if (this.degree().isZero()) {\r\n            return this.monoms[0]?.coefficient.value ?? 0\r\n        }\r\n\r\n        return undefined\r\n    }\r\n\r\n    public get variables(): string[] {\r\n        let V: string[] = []\r\n\r\n        for (const m of this.#monoms) {\r\n            V = V.concat(m.variables)\r\n        }\r\n\r\n\r\n        // Remove duplicates.\r\n        V = [...new Set(V)]\r\n        V.sort()\r\n        return V\r\n    }\r\n\r\n    /**\r\n     * Set the polynom to zero.\r\n     * @returns {this}\r\n     */\r\n    public zero = (): this => {\r\n        this.#monoms = []\r\n        this.#monoms.push(new Monom().zero())\r\n        return this\r\n    }\r\n\r\n    public get zeroes(): ISolution[] {\r\n        return this.getZeroes()\r\n    }\r\n\r\n    #compare = (P: Polynom, sign?: string): boolean => {\r\n        sign ??= '='\r\n\r\n        // Create clone version to reduce them without altering the original polynoms.\r\n        const cP1 = this.clone().reduce().reorder()\r\n        const cP2 = P.clone().reduce().reorder()\r\n\r\n        switch (sign) {\r\n            case '=':\r\n                // They must have the isSame length and the isSame degree\r\n                if (cP1.length !== cP2.length || !cP1.degree().isEqual(cP2.degree())) {\r\n                    return false\r\n                }\r\n\r\n                // Check if the coefficients are the isSame.\r\n                return cP1.monoms\r\n                    .every((m1, index) => m1.isEqual(cP2.monoms[index]))\r\n\r\n            case 'same':\r\n                // They must have the same length and the same degree\r\n                if (cP1.length !== cP2.length || !cP1.degree().isEqual(cP2.degree())) {\r\n                    return false\r\n                }\r\n\r\n                return cP1.monoms\r\n                    .every((m1, index) => m1.isSameAs(cP2.monoms[index]))\r\n\r\n            default:\r\n                return false\r\n        }\r\n    }\r\n\r\n\r\n    #divideByFraction = (F: Fraction): this => {\r\n        for (const m of this.#monoms) {\r\n            m.coefficient.divide(F)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    #divideByInteger = (nb: number): this => {\r\n        const nbF = new Fraction(nb)\r\n        for (const m of this.#monoms) {\r\n            m.coefficient.divide(nbF)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    #evaluateAsNumeric = (values: literalType<number | Fraction> | InputValue<Fraction>): number => {\r\n        let r = 0\r\n        this.#monoms.forEach(monom => {\r\n            r += monom.evaluate(values, true) as number\r\n        })\r\n\r\n        return r\r\n    }\r\n\r\n    #factorize2ndDegree = (letter: string): Polynom[] => {\r\n        let P1: Polynom, P2: Polynom,\r\n            a, b, c, delta, x1, x2, factor\r\n\r\n        // One variable only\r\n        if (this.numberOfVars === 1) {\r\n            a = this.monomByDegree(2, letter).coefficient\r\n            b = this.monomByDegree(1, letter).coefficient\r\n            c = this.monomByDegree(0, letter).coefficient\r\n            delta = b.clone().pow(2).subtract(a.clone().multiply(c).multiply(4))\r\n\r\n            if (delta.isZero()) {\r\n                x1 = b.clone().opposite().divide(a.clone().multiply(2))\r\n                P1 = new Polynom(letter).subtract(x1.display).multiply(x1.denominator)\r\n                P2 = new Polynom(letter).subtract(x1.display).multiply(x1.denominator)\r\n                factor = a.divide(x1.denominator).divide(x1.denominator)\r\n\r\n                if (!factor.isOne()) {\r\n                    return [new Polynom(factor.display), P1, P2]\r\n                } else {\r\n                    return [P1, P2]\r\n                }\r\n\r\n            } else if (delta.isPositive() && delta.isSquare()) {\r\n                x1 = b.clone().opposite()\r\n                    .add(delta.clone().sqrt())\r\n                    .divide(a.clone().multiply(2))\r\n                x2 = b.clone().opposite()\r\n                    .subtract(delta.clone().sqrt())\r\n                    .divide(a.clone().multiply(2))\r\n\r\n                // (2x+5)(3x-2)\r\n                // 6x^2+11x-10\r\n                // a = 6, b = 11, c = -10\r\n                // delta = 121-4*6*(-10) = 361= 19^2\r\n                // x1 = (-11 + 19)  / 12 = 8/12 = 2/3\r\n                // x2 = (-11 - 19)  / 12 = -30/12 = -5/2\r\n                factor = a.divide(x1.denominator).divide(x2.denominator)\r\n                if (factor.isOne()) {\r\n                    return [\r\n                        new Polynom(letter).subtract(x1.display).multiply(x1.denominator),\r\n                        new Polynom(letter).subtract(x2.display).multiply(x2.denominator),\r\n                    ]\r\n                } else {\r\n                    return [\r\n                        new Polynom(factor.display),\r\n                        new Polynom(letter).subtract(x1.display).multiply(x1.denominator),\r\n                        new Polynom(letter).subtract(x2.display).multiply(x2.denominator),\r\n                    ]\r\n                }\r\n\r\n\r\n            } else\r\n                // No solution possible - return the complete value.\r\n            {\r\n                return [this.clone()]\r\n            }\r\n\r\n        } else {\r\n            // If multiple variables, only handle perfect squares...\r\n            a = this.monomByDegree(2, letter)\r\n            b = this.monomByDegree(1, letter)\r\n            c = this.monomByDegree(0, letter)\r\n\r\n            if (a.isLiteralSquare() && c.isLiteralSquare())\r\n                // Check the middle item is same as...\r\n\r\n\r\n            {\r\n                if (b.clone().pow(2).isSameAs(a.clone().multiply(c))) {\r\n                    // Determine if the coefficient values matches.\r\n\r\n                    // Search 4 values (r, s, t, u) that matches:\r\n                    // (r X + s Y)(t X + u Y) = rt X^2 + (ru + st) XY + su Y^2\r\n\r\n                    const xPolynom = new Polynom('x', a.coefficient, b.coefficient, c.coefficient)\r\n                    const xFactors = xPolynom.#factorize2ndDegree('x')\r\n\r\n                    const factors = []\r\n                    let xyzPolynom: Polynom\r\n\r\n                    if (xFactors.length >= 2) {\r\n                        for (const p of xFactors) {\r\n                            if (p.degree().isZero()) {\r\n                                factors.push(p.clone())\r\n                            } else {\r\n                                xyzPolynom = p.clone()\r\n                                xyzPolynom.monoms[0].literal = a.literalSqrt\r\n                                xyzPolynom.monoms[1].literal = c.literalSqrt\r\n                                factors.push(xyzPolynom.clone())\r\n                            }\r\n                        }\r\n\r\n\r\n                        return factors\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            return [this.clone()]\r\n        }\r\n    }\r\n\r\n    #genDisplay = (output?: string, forceSign?: boolean, wrapParentheses?: boolean, withAllMultiplicationSign?: boolean): string => {\r\n        let P = ''\r\n\r\n        for (const k of this.#monoms) {\r\n            if (k.coefficient.value === 0) {\r\n                continue\r\n            }\r\n\r\n\r\n            // The monom to be displayed\r\n            let m\r\n            if (withAllMultiplicationSign) {\r\n                m = k.plotFunction\r\n            } else {\r\n                m = (output === 'tex') ? k.tex : k.display\r\n            }\r\n\r\n            P += `${(k.coefficient.sign() === 1 && (P !== '' || forceSign === true)) ? '+' : ''}${m}`\r\n        }\r\n\r\n        if (wrapParentheses === true && this.length > 1) {\r\n            if (output === 'tex') {\r\n                P = `\\\\left( ${P} \\\\right)`\r\n            } else {\r\n                P = `(${P})`\r\n            }\r\n        }\r\n\r\n\r\n        if (P === '') {\r\n            P = '0'\r\n        }\r\n\r\n        return P\r\n    }\r\n\r\n    #getAllPotentialFactors = (P: Polynom, maxDegree: number, letter: string): Polynom[] => {\r\n        const m1 = P.monoms[0].dividers,\r\n            m2 = P.monoms[P.monoms.length - 1].dividers\r\n\r\n        const allDividers: Polynom[] = []\r\n        m1.forEach(m1d => {\r\n            // Get only polynom that has a degree less than a specific value\r\n            if (m1d.degree(letter).isLeq(maxDegree)) {\r\n                m2.forEach(m2d => {\r\n                    if (m1d.degree(letter).isNotEqual(m2d.degree(letter))) {\r\n                        allDividers.push(new Polynom(m1d, m2d))\r\n                        allDividers.push(new Polynom(m1d, m2d.clone().opposite()))\r\n                    }\r\n                })\r\n            }\r\n\r\n\r\n        })\r\n\r\n        return allDividers\r\n    }\r\n\r\n    #multiplyByFraction = (F: Fraction): Polynom => {\r\n        for (const m of this.#monoms) {\r\n            m.coefficient.multiply(F)\r\n        }\r\n\r\n\r\n        return this.reduce()\r\n    }\r\n\r\n    #multiplyByInteger = (nb: number): Polynom => {\r\n        return this.#multiplyByFraction(new Fraction(nb))\r\n    }\r\n\r\n    #multiplyByMonom = (M: Monom): Polynom => {\r\n        for (const m of this.#monoms) {\r\n            m.multiply(M)\r\n        }\r\n\r\n        return this.reduce()\r\n    }\r\n\r\n    #multiplyByPolynom = (P: Polynom): Polynom => {\r\n        const M: Monom[] = []\r\n        for (const m1 of this.#monoms) {\r\n            for (const m2 of P.monoms) {\r\n                M.push(Monom.xMultiply(m1, m2))\r\n            }\r\n        }\r\n\r\n\r\n        this.#monoms = M\r\n        return this.reduce()\r\n    }\r\n\r\n    #parseString(inputStr: string, ...values: unknown[]): this {\r\n        if (values.length === 0) {\r\n            // Parse the polynom using the shutting yard algorithm\r\n            if (inputStr !== '' && !isNaN(Number(inputStr))) {\r\n                this.empty()\r\n                // It's a simple number.\r\n                const m = new Monom(Number(inputStr))\r\n                // m.coefficient = new Fraction(inputStr);\r\n                // m.literalStr = '';\r\n                this.add(m)\r\n                return this\r\n            }\r\n\r\n            // Parse the string.\r\n            return this.#shutingYardToReducedPolynom(inputStr)\r\n        } else if (/^[a-z]+/.test(inputStr)) {\r\n            // We assume the inputStr contains only letters.\r\n            this.empty()\r\n\r\n            const fractions = values.map(x => new Fraction(x as InputValue<Fraction>))\r\n\r\n            // Multiple setLetter version\r\n            if (inputStr.length > 1) {\r\n                const letters = inputStr.split('')\r\n\r\n                if (letters.length < values.length - 2) {\r\n                    throw new Error('Too many factors for too few variables !')\r\n                }\r\n\r\n                let i = 0\r\n\r\n                for (const F of fractions) {\r\n                    const m = new Monom()\r\n                    m.coefficient = F.clone()\r\n                    m.literalStr = letters[i] || ''\r\n                    this.add(m)\r\n                    i++\r\n                }\r\n            }\r\n            // Single setLetter version\r\n            else {\r\n                let n = fractions.length - 1\r\n                for (const F of fractions) {\r\n                    const m = new Monom()\r\n                    m.coefficient = F.clone()\r\n                    m.literalStr = `${inputStr}^${n}`\r\n                    this.add(m)\r\n                    n--\r\n                }\r\n            }\r\n            return this\r\n        } else {\r\n            return this.zero()\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Main parse using a shutting yard class\r\n     * @param inputStr\r\n     */\r\n    #shutingYardToReducedPolynom = (inputStr: string): this => {\r\n        // Get the RPN array of the current expression\r\n        const SY: ShutingYard = new ShutingYard().parse(inputStr)\r\n        const rpn: { token: string, tokenType: ShutingyardType }[] = SY.rpn\r\n\r\n        // New version for reducing shuting yard.\r\n        this.zero()\r\n\r\n        const stack: Polynom[] = []\r\n\r\n        // Loop through the each element of the RPN\r\n        for (const element of rpn) {\r\n            this.#shutingYard_addToken(stack, element)\r\n        }\r\n\r\n\r\n        if (stack.length === 1) {\r\n            this.add(stack[0])\r\n        }\r\n\r\n\r\n        return this.reorder()\r\n    }\r\n\r\n    #shutingYard_addToken = (stack: Polynom[], element: Token): void => {\r\n        switch (element.tokenType) {\r\n            case ShutingyardType.COEFFICIENT:\r\n                stack.push(new Polynom(element.token))\r\n                break\r\n\r\n            case ShutingyardType.VARIABLE:\r\n                stack.push(new Polynom().add(new Monom(element.token)))\r\n                break\r\n\r\n            case ShutingyardType.CONSTANT:\r\n                // TODO: add constant support to Polynom parsing.\r\n                console.log('Actually, not supported - will be added later !')\r\n                break\r\n\r\n            case ShutingyardType.OPERATION:\r\n                if (stack.length >= 2) {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop()\r\n\r\n                    // Check if the polynoms are not undefined.\r\n                    if (a === undefined || b === undefined) {\r\n                        break\r\n                    }\r\n\r\n                    if (element.token === '+') {\r\n                        stack.push(a.add(b))\r\n                    } else if (element.token === '-') {\r\n                        stack.push(a.subtract(b))\r\n                    } else if (element.token === '*') {\r\n                        stack.push(a.multiply(b))\r\n                    } else if (element.token === '/') {\r\n                        if (b.degree().isStrictlyPositive()) {\r\n                            console.log('divide by a polynom -> should create a rational polynom !')\r\n                        } else {\r\n                            // a.divide(b.monoms[0].coefficient)\r\n                            stack.push(a.divide(b.monoms[0].coefficient))\r\n                        }\r\n                    } else if (element.token === '^') {\r\n                        if (b.degree().isStrictlyPositive()) {\r\n                            throw new Error('Cannot elevate a polynom with another polynom !')\r\n                        } else if (b.monoms[0].coefficient.isRelative())\r\n                            // Integer power\r\n                        {\r\n                            stack.push(a.pow(b.monoms[0].coefficient.value))\r\n                        } else {\r\n                            // Only allow power if the previous polynom is only a monom, without coefficient.\r\n                            if (a.monoms.length === 1 && a.monoms[0].coefficient.isOne()) {\r\n                                for (const letter in a.monoms[0].literal) {\r\n                                    a.monoms[0].literal[letter].multiply(b.monoms[0].coefficient)\r\n                                }\r\n\r\n                                stack.push(a)\r\n                            } else {\r\n                                console.error('Cannot have power with fraction')\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                } else if (element.token === '-') {\r\n                    const a = stack.pop()\r\n                    if (a) {\r\n                        stack.push(a.opposite())\r\n                    }\r\n                } else {\r\n                    throw new Error(\"Error parsing the polynom\")\r\n                }\r\n\r\n\r\n                break\r\n\r\n            case ShutingyardType.MONOM:\r\n                // Should never appear.\r\n                console.error('The monom token should not appear here')\r\n                break\r\n\r\n            case ShutingyardType.FUNCTION:\r\n                // Should never appear.\r\n                console.error('The function token should not appear here - might be introduced later.')\r\n                break\r\n        }\r\n\r\n\r\n    }\r\n\r\n}\r\n","import type {\r\n    EQUATION_SIGN,\r\n    IAlgebra,\r\n    IEquation,\r\n    InputAlgebra,\r\n    InputValue,\r\n    IPiMathObject,\r\n    ISolution,\r\n    literalType\r\n} from \"../pimath.interface\"\r\nimport {Fraction} from \"../coefficients/fraction\"\r\nimport {Numeric} from \"../numeric\"\r\nimport {EquationSolver} from \"./equationSolver\"\r\nimport {Monom} from \"./monom\"\r\nimport {Polynom} from \"./polynom\"\r\n\r\nexport class Equation implements\r\n    IPiMathObject<Equation>,\r\n    IEquation<Equation>,\r\n    IAlgebra<Equation> {\r\n\r\n    // Left part of the equation\r\n    #left: Polynom\r\n    // Right part of the equation\r\n    #right: Polynom\r\n    // Signe of the equation\r\n    #sign: EQUATION_SIGN\r\n\r\n\r\n    constructor(equation: InputAlgebra<Polynom> | Equation)\r\n    constructor(left: InputAlgebra<Polynom>, right: InputAlgebra<Polynom>, sign?: EQUATION_SIGN)\r\n    constructor(left?: InputAlgebra<Polynom> | Equation, right?: InputAlgebra<Polynom>, sign?: EQUATION_SIGN) {\r\n        // Default equation\r\n        this.#left = new Polynom().zero()\r\n        this.#right = new Polynom().zero()\r\n        this.#sign = '='\r\n\r\n        // Only one value, it's an equation\r\n        if (left !== undefined && right === undefined) {\r\n            if (left instanceof Equation) {\r\n                return left.clone()\r\n            } else if (typeof left === 'string') {\r\n                // Parse the equation as a string.\r\n                this.parse(left)\r\n            }\r\n\r\n        } else if (left !== undefined && right !== undefined) {\r\n            // Two values, it's an equation with left and right polynoms.\r\n            this.left = new Polynom(left as InputAlgebra<Polynom>)\r\n            this.right = new Polynom(right)\r\n        }\r\n\r\n        if (sign !== undefined) {\r\n            this.sign = sign\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    public parse = (equationString: string): this => {\r\n        // Find the string separator\r\n        const strSign: string | false = this.#findSign(equationString)\r\n\r\n        if (strSign === false) {\r\n            throw new Error('The equation is not valid (no sign found)')\r\n        }\r\n\r\n        // The StrSign is found\r\n        const pStr: string[] = equationString.split(strSign)\r\n\r\n        return this.create(new Polynom(pStr[0]), new Polynom(pStr[1]), this.#formatSign(strSign))\r\n    }\r\n\r\n    public clone = (): Equation => {\r\n        return new Equation(this.#left.clone(), this.#right.clone(), this.#sign)\r\n    }\r\n\r\n    public get tex(): string {\r\n        return `${this.#left.tex}${this.signAsTex}${this.#right.tex}`\r\n    }\r\n\r\n    public get display(): string {\r\n        return `${this.#left.display}${this.signAsTex}${this.#right.display}`\r\n    }\r\n\r\n    public static isEquationString(equationString: string): boolean {\r\n        // The equation sign can be one of the following:\r\n        // =, <, >, <=, >=\r\n\r\n        return equationString.includes('=') ||\r\n            equationString.includes('<') ||\r\n            equationString.includes('>') ||\r\n            equationString.includes('<=') ||\r\n            equationString.includes('>=')\r\n    }\r\n\r\n    public static makeSolutionsUnique(solutions: ISolution[], sorted?: boolean): ISolution[] {\r\n        const solutionAsTex: string[] = [],\r\n            uniqueSolutions = solutions.filter(sol => {\r\n                if (!solutionAsTex.includes(sol.tex)) {\r\n                    solutionAsTex.push(sol.tex)\r\n                    return true\r\n                } else {\r\n                    return false\r\n                }\r\n            })\r\n\r\n        if (sorted === true) {\r\n            uniqueSolutions.sort((a, b) => a.value - b.value)\r\n        }\r\n\r\n        return uniqueSolutions\r\n    }\r\n\r\n    /**\r\n     * Add a value to the equation\r\n     * if value is an equation, add the left part to the left part of the equation\r\n     * and the right part to the right part of the equation\r\n     * if value is a string, try to create an equation\r\n     * if it fails, create a polynom and add it to the left and right part of the equation\r\n     * @param value | Polynom | Monom | Fraction | string | monom\r\n     */\r\n    public add(value: InputValue<Equation | Polynom>): this {\r\n\r\n        if (value instanceof Equation) {\r\n            // add the left part of the equation\r\n            this.#left.add(value.left)\r\n            // add the right part of the equation\r\n            this.#right.add(value.right)\r\n\r\n            return this\r\n        }\r\n\r\n        if (typeof value === 'string' &&\r\n            !Equation.isEquationString(value)) {\r\n\r\n            return this.add(new Equation(value))\r\n        }\r\n\r\n        const p = new Polynom(value)\r\n        this.#left.add(p)\r\n        this.#right.add(p)\r\n\r\n        return this\r\n    }\r\n\r\n    public create = (left: Polynom, right: Polynom, sign?: string): this => {\r\n        this.#left = left\r\n        this.#right = right\r\n        this.#sign = this.#formatSign(sign ?? \"=\")\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Get the degree of the equation\r\n     * @param letter\r\n     */\r\n    public degree = (letter?: string): Fraction => {\r\n        return Fraction.max(this.#left.degree(letter), this.#right.degree(letter))\r\n    }\r\n\r\n    /**\r\n     * divide an equation by a given value (transformed as a fraction)\r\n     *\r\n     * ```\r\n     * 8x+10=6x \\vert 2\r\n     * 4x+5=3x\r\n     * ```\r\n     *\r\n     * |>Alternatively with $3x-4$ maybe it's working ?\r\n     * $$\\frac{3x}{5}$$\r\n     *\r\n     * @param value\r\n     * @returns {Equation}\r\n     */\r\n    public divide = (value: InputValue<Fraction>): this => {\r\n        // Make sure we have a fraction.\r\n        const F: Fraction = new Fraction(value)\r\n\r\n        if (F.isZero()) {\r\n            return this\r\n        } else {\r\n            return this.multiply(F.inverse())\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create an Equation using two polynoms.\r\n     * Markdown *support* is cool\r\n     * @param values\r\n     * @param asNumeric\r\n     */\r\n    public evaluate(values: InputValue<Fraction> | literalType<number | Fraction>, asNumeric?: boolean  ): boolean {\r\n        // Evaluate the left and right part of the equation.\r\n        // compare the results.\r\n\r\n        // Evaluate the left and right part of the equation.\r\n        const left = this.#left.evaluate(values, asNumeric),\r\n            right = this.#right.evaluate(values, asNumeric)\r\n\r\n        // compare the results.\r\n        if (asNumeric) {\r\n            return left === right\r\n        }\r\n\r\n        return (left as Fraction).isEqual(right as Fraction)\r\n    }\r\n\r\n    // -----------------------------------------------\r\n\r\n    /**\r\n     * Determine if the equation contains a variable.\r\n     * @param letter\r\n     */\r\n    public hasVariable = (letter: string): boolean => {\r\n        return this.variables.includes(letter)\r\n    }\r\n\r\n    public isEqual(value: InputValue<Equation>): boolean {\r\n        const equ = new Equation(value)\r\n        return equ.left.isEqual(this.#left) && equ.right.isEqual(this.#right)\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations operations\r\n\r\n    // Equations helpers\r\n    public isEqualTo = (equ: Equation): boolean => {\r\n        const p1 = equ.clone().moveLeft().left,\r\n            p2 = this.clone().moveLeft().left\r\n\r\n        // They are the same.\r\n        return p1.isEqual(p2) || p1.isOppositeAt(p2)\r\n    }\r\n\r\n    public isLinearTo = (equ: Equation): boolean => {\r\n        // Move all left.\r\n        const p1 = equ.clone().moveLeft().simplify().left,\r\n            p2 = this.clone().moveLeft().simplify().left\r\n\r\n        // They are the same.\r\n        return p1.isEqual(p2) || p1.isOppositeAt(p2)\r\n    }\r\n\r\n    /**\r\n     * Determine if the equation contains more than one letter/variable.\r\n     */\r\n    public isMultiVariable = (): boolean => {\r\n        return this.#left.isMultiVariable || this.#right.isMultiVariable\r\n    }\r\n\r\n    /**\r\n     * Reorder the polynom to have only one letter on the left, the rest on the right.\r\n     * @param letter\r\n     */\r\n    public isolate = (letter?: string): this | false => {\r\n        // Determine if we can isolate the variables.\r\n\r\n        // Both part of the equations must be of the first degree.\r\n        if (!this.degree(letter).isOne()) {\r\n            return false\r\n        }\r\n\r\n        // Modify the equation to isolate the asked variable.\r\n        if (this.isMultiVariable()) {\r\n            return false\r\n        }\r\n\r\n        // Isolate the letter.\r\n        let mMove: Monom\r\n        // Start by moving everything to the left.\r\n        this.#left.subtract(this.#right)\r\n        this.#right.zero()\r\n        const values = [...this.#left.monoms]\r\n        for (const m of values) {\r\n            if (!m.hasVariable(letter)) {\r\n                mMove = m.clone()\r\n                this.#left.subtract(mMove)\r\n                this.#right.subtract(mMove)\r\n            }\r\n        }\r\n\r\n        // In theory, we should have only one item on the left.\r\n        if (this.#left.length !== 1) {\r\n            return false\r\n        }\r\n\r\n        const cMove: Fraction = this.#left.monoms[0].coefficient.clone()\r\n        this.#left.divide(cMove)\r\n        this.#right.divide(cMove)\r\n        return this\r\n    }\r\n\r\n    // Getter and setter\r\n    public get left(): Polynom {\r\n        return this.#left\r\n    }\r\n\r\n    public set left(value: Polynom) {\r\n        this.#left = value\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    public letters = (): string[] => {\r\n        return [...new Set([...this.#left.letters(), ...this.#right.letters()])]\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    /**\r\n     * Reorder will move all monoms containing a letter on the left, all the other on the right.\r\n     */\r\n    public moveLeft = (): this => {\r\n        this.#left.subtract(this.#right)\r\n        this.#right.zero()\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Multiple an equation by a fraction value.\r\n     * @param value\r\n     */\r\n    public multiply = (value: InputValue<Fraction>): this => {\r\n        // Make sure we have a fraction.\r\n        const F: Fraction = new Fraction(value)\r\n\r\n        // Multiply each part of the equation by the fraction\r\n        this.#left.multiply(F)\r\n        this.#right.multiply(F)\r\n\r\n        // The sign of the inequality must be changed.\r\n        if (this.#sign !== '=' && F.sign() === -1) {\r\n            this.#reverseSign()\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    public get numberOfVars(): number {\r\n        return this.variables.length\r\n    }\r\n\r\n    public opposite = (): this => {\r\n        this.#left = this.#left.opposite()\r\n        this.#right = this.#right.opposite()\r\n        return this\r\n    }\r\n\r\n    public pow(value: number): this {\r\n        this.#left.pow(value)\r\n        this.#right.pow(value)\r\n        return this\r\n    }\r\n\r\n    public reduce(): this {\r\n        // reduce means moving everything to the left\r\n        // remove the fractions\r\n        // simplify the equation\r\n        // reorder the equation\r\n        // start with a positive left part\r\n\r\n        // Move all left. The right part is now zero.\r\n        this.moveLeft()\r\n\r\n        // Reduce the equation: simplify and reorder.\r\n        this.#left.reduce()\r\n\r\n        // Simplify the equation.\r\n        this.simplify()\r\n\r\n        // Make sure the first part is positive.\r\n        if (this.#left.monoms[0].coefficient.isNegative()) {\r\n            this.multiply(-1)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    public reorder = (allLeft?: boolean): this => {\r\n        // Move all monoms of degree greater than 0 to the left.\r\n        // and all zero degree monoms to the right.\r\n        this.#left.subtract(this.#right)\r\n        this.#right.zero()\r\n        this.#left.reorder()\r\n\r\n        // we have all left (so equal zero) : it's done !\r\n        if (allLeft) {\r\n            return this\r\n        }\r\n\r\n        // Fetch all zero degree monoms.\r\n        this.#left.monoms\r\n            .filter(m => m.degree().isZero())\r\n            .forEach(m => {\r\n                const move = m.clone()\r\n                this.#left.subtract(move)\r\n                this.#right.subtract(move)\r\n            })\r\n\r\n        // Reorder the left and right polynoms\r\n        this.#left.reorder()\r\n        this.#right.reorder()\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    public replaceBy = (letter: string, P: Polynom): this => {\r\n        this.#left.replaceBy(letter, P)\r\n        this.#right.replaceBy(letter, P)\r\n        return this\r\n    }\r\n\r\n    public get right(): Polynom {\r\n        return this.#right\r\n    }\r\n\r\n    public set right(value: Polynom) {\r\n        this.#right = value\r\n    }\r\n\r\n    // ------------------------------------------\r\n    public get sign(): string {\r\n        return this.#sign\r\n    }\r\n\r\n    public set sign(value: string) {\r\n        // Set the sign value as formatted.\r\n        this.#sign = this.#formatSign(value)\r\n    }\r\n\r\n    public get signAsTex(): string {\r\n        if (this.#sign === '>=') {\r\n            return '\\\\geq'\r\n        }\r\n\r\n        if (this.#sign === '<=') {\r\n            return '\\\\leq'\r\n        }\r\n\r\n        return this.#sign\r\n    }\r\n\r\n    /**\r\n     * Multiply by the lcm denominator and divide by the gcm numerators.\r\n     */\r\n    public simplify = (): this => {\r\n        this.multiply(Numeric.lcm(...this.#left.getDenominators(), ...this.#right.getDenominators()))\r\n        this.divide(Numeric.gcd(...this.#left.getNumerators(), ...this.#right.getNumerators()))\r\n        return this\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    public solve = (): ISolution[] => {\r\n        const solver = new EquationSolver(this.clone())\r\n        return solver.solve()\r\n    }\r\n\r\n    public split(): [Polynom, Polynom] {\r\n        return [this.#left.clone(), this.#right.clone()]\r\n    }\r\n\r\n    public subtract(value: InputValue<Equation | Polynom>): this {\r\n        if (value instanceof Equation) {\r\n            this.#left.subtract(value.left)\r\n            this.#right.subtract(value.right)\r\n\r\n            return this\r\n        }\r\n\r\n        if (typeof value === 'string' &&\r\n            !Equation.isEquationString(value)) {\r\n            return this.subtract(new Equation(value))\r\n        }\r\n\r\n        const p = new Polynom(value)\r\n        this.#left.subtract(p)\r\n        this.#right.subtract(p)\r\n\r\n        return this\r\n    }\r\n\r\n    public test = (values: literalType<Fraction>): boolean => {\r\n        return (this.left.evaluate(values) as Fraction).isEqual(this.right.evaluate(values))\r\n    }\r\n\r\n    public get variables(): string[] {\r\n        return [...new Set(this.#right.variables.concat(this.#left.variables))]\r\n    }\r\n\r\n    #findSign = (equationString: string): string | false => {\r\n        if (equationString.includes('geq')) {\r\n            return (equationString.includes('\\\\geq')) ? '\\\\geq' : 'geq'\r\n        } else if (equationString.includes('leq')) {\r\n            return (equationString.includes('\\\\leq')) ? '\\\\leq' : 'leq'\r\n        } else if (equationString.includes('>=')) {\r\n            return '>='\r\n        } else if (equationString.includes('=>')) {\r\n            return '=>'\r\n        } else if (equationString.includes('>')) {\r\n            return '>'\r\n        } else if (equationString.includes('<=')) {\r\n            return '<='\r\n        } else if (equationString.includes('=<')) {\r\n            return '=<'\r\n        } else if (equationString.includes('<')) {\r\n            return '<'\r\n        } else if (equationString.includes('=')) {\r\n            return '='\r\n        }\r\n\r\n        throw new Error('The equation is not valid (no sign found)')\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations solving algorithms\r\n    #formatSign = (signStr?: string): EQUATION_SIGN => {\r\n        if (signStr === undefined) {\r\n            return '='\r\n        }\r\n\r\n        if (signStr.includes('geq')) {\r\n            return '>='\r\n        } else if (signStr.includes('>=')) {\r\n            return '>='\r\n        } else if (signStr.includes('=>')) {\r\n            return '>='\r\n        } else if (signStr.includes('>')) {\r\n            return '>'\r\n        } else if (signStr.includes('leq')) {\r\n            return '<='\r\n        } else if (signStr.includes('<=')) {\r\n            return '<='\r\n        } else if (signStr.includes('=<')) {\r\n            return '<='\r\n        } else if (signStr.includes('<')) {\r\n            return '<'\r\n        } else {\r\n            return '='\r\n        }\r\n    }\r\n\r\n    #reverseSign = (): this => {\r\n        if (this.#sign === '=') {\r\n            return this\r\n        }\r\n\r\n        if (this.#sign.includes('<')) {\r\n            this.#sign.replace('<', '>')\r\n            return this\r\n        }\r\n        if (this.#sign.includes('>')) {\r\n            this.#sign.replace('>', '<')\r\n            return this\r\n        }\r\n\r\n        return this\r\n    }\r\n}\r\n","import type {\r\n    IAlgebra,\r\n    IExpression,\r\n    InputAlgebra,\r\n    InputValue,\r\n    IPiMathObject,\r\n    ISolution,\r\n    literalType,\r\n    TABLE_OF_SIGNS\r\n} from \"../pimath.interface\"\r\nimport {Fraction} from \"../coefficients/fraction\"\r\nimport {Polynom} from \"./polynom\"\r\nimport {replace_in_array, wrapParenthesis} from \"../helpers\"\r\n\r\nexport class Factor implements IPiMathObject<Factor>,\r\n    IExpression<Factor>,\r\n    IAlgebra<Factor> {\r\n    #displayMode: FACTOR_DISPLAY\r\n    #polynom: Polynom\r\n    #power: Fraction\r\n    #singleMode = false\r\n\r\n    constructor(value?: InputAlgebra<Polynom> | Factor, power?: InputValue<Fraction>) {\r\n\r\n\r\n        if (value instanceof Factor) {\r\n            this.#polynom = value.polynom.clone()\r\n            this.#power = value.power.clone()\r\n\r\n            if(power !== undefined){\r\n                this.#power.multiply(new Fraction(power))\r\n            }\r\n        } else if(value !== undefined) {\r\n            this.#polynom = new Polynom(value)\r\n            this.#power = new Fraction(power ?? 1)\r\n        }else{\r\n            this.#polynom = new Polynom()\r\n            this.#power = new Fraction(1)\r\n        }\r\n\r\n        this.#displayMode = FACTOR_DISPLAY.POWER\r\n\r\n        return this\r\n    }\r\n\r\n    public parse(/*value: InputValue<Factor>*/): Factor {\r\n        throw new Error(\"Method not implemented.\")\r\n    }\r\n\r\n    public clone(): Factor {\r\n        return new Factor(this)\r\n    }\r\n\r\n    public fromPolynom(polynom: InputValue<Polynom>): this {\r\n        this.#polynom = new Polynom(polynom)\r\n        this.#power = new Fraction(1)\r\n        return this\r\n    }\r\n    public get tex(): string {\r\n        const num = this.power.numerator\r\n        const den = this.power.denominator\r\n\r\n        let base: string\r\n        let power: string\r\n\r\n        if (this.#displayMode === FACTOR_DISPLAY.ROOT && den > 1) {\r\n            base = `\\\\sqrt${den === 2 ? '' : `[ ${den} ]`}{ ${this.polynom.tex} }`\r\n            power = num === 1 ? '' : `^{ ${num} }`\r\n        } else {\r\n            base = this.#singleMode && this.power.isOne() ? this.polynom.tex : wrapParenthesis(this.polynom.tex)\r\n            power = (den === 1 && num === 1) ? '' : `^{ ${this.power.tex} }`\r\n        }\r\n\r\n        // Add the power if it's not 1 or -1\r\n        base = `${base}${power}`\r\n\r\n        // If the power is negative, make it as a fraction.\r\n        if (this.#displayMode === FACTOR_DISPLAY.ROOT && num < 0) {\r\n            base = `\\\\frac{ 1 }{ ${base} }`\r\n        }\r\n\r\n\r\n        return base\r\n    }\r\n\r\n    public get display(): string {\r\n        const num = this.power.numerator\r\n        const den = this.power.denominator\r\n\r\n        let base: string\r\n        let power: string\r\n\r\n        if (this.#displayMode === FACTOR_DISPLAY.ROOT && den > 1) {\r\n            base = `${den === 2 ? 'sqrt' : `root(${den})`}(${this.polynom.display})`\r\n            power = num === 1 ? '' : `^(${num})`\r\n        } else {\r\n            base = this.#singleMode && this.power.isOne() ? this.polynom.display : wrapParenthesis(this.polynom.display, false)\r\n            power = (den === 1 && num === 1) ? '' : `^(${this.power.display})`\r\n        }\r\n\r\n        // Add the power if it's not 1 or -1\r\n        base = `${base}${power}`\r\n\r\n        // If the power is negative, make it as a fraction.\r\n        if (this.#displayMode === FACTOR_DISPLAY.ROOT && num < 0) {\r\n            base = `1/(${base})`\r\n        }\r\n\r\n\r\n        return base\r\n    }\r\n\r\n    public add(): Factor {\r\n        throw new Error(\"Adding two factors is not possible\")\r\n    }\r\n\r\n    public get asSingle(): this {\r\n        this.#singleMode = true\r\n        return this\r\n    }\r\n\r\n    public degree(letter?: string): Fraction {\r\n        return this.polynom.degree(letter).multiply(this.power)\r\n    }\r\n\r\n    public derivative(): Factor[] {\r\n        // The power is zero, the derivative is zero\r\n        if (this.power.isZero()) {\r\n            return [new Factor('0')]\r\n        }\r\n\r\n        // The power is one, the derivative is the derivative of the polynom\r\n        if (this.power.isOne()) {\r\n            return [new Factor(this.polynom.clone().derivative())]\r\n        }\r\n\r\n        // In any other case, the derivative consist of three Factors:\r\n        // the derivative of the polynom, the power and the polynom\r\n        return [\r\n            new Factor(this.power.clone()),\r\n            new Factor(this.polynom.clone().derivative()),\r\n            new Factor(this.polynom.clone(), this.power.clone().subtract(1))\r\n        ]\r\n    }\r\n\r\n    public develop(): Polynom {\r\n        if (this.power.isNatural()) {\r\n            return this.polynom.clone().pow(this.power.value)\r\n        }\r\n\r\n        throw new Error(\"The power must be a natural number\")\r\n    }\r\n\r\n    public divide(value: InputAlgebra<Factor | Polynom>): this {\r\n        if (value instanceof Factor) {\r\n            if (this.isSameAs(value)) {\r\n                this.power.subtract(value.power)\r\n                return this\r\n            }\r\n        }\r\n\r\n\r\n        const P = new Polynom(value as Polynom)\r\n        if (this.isSameAs(P)) {\r\n            this.power.subtract(1)\r\n            return this\r\n        }\r\n\r\n        throw new Error(\"The two factors must be the same\")\r\n    }\r\n\r\n    public evaluate(values: InputValue<Fraction> | literalType<number | Fraction>, asNumeric?: boolean): number | Fraction {\r\n        if (asNumeric) {\r\n            return (this.polynom.evaluate(values, true) as number) ** this.power.value\r\n        }\r\n\r\n\r\n        return (this.polynom.evaluate(values) as Fraction).pow(this.power)\r\n    }\r\n\r\n    public hasVariable(letter: string): boolean {\r\n        return this.polynom.hasVariable(letter)\r\n    }\r\n\r\n    public inverse(): this {\r\n        this.power.opposite()\r\n        return this\r\n    }\r\n\r\n    public isEqual(value: Factor): boolean {\r\n        // Must have the same polynom and the same reduce power\r\n\r\n        return this.isSameAs(value) &&\r\n            this.power.isEqual(value.power)\r\n    }\r\n\r\n    public isOne(): boolean {\r\n        return this.polynom.isOne() || this.power.isZero()\r\n    }\r\n\r\n    public isSameAs(value: InputAlgebra<Factor | Polynom>) {\r\n        let P: Polynom\r\n        if (value instanceof Factor) {\r\n            P = value.polynom\r\n        } else if (value instanceof Polynom) {\r\n            P = value\r\n        } else {\r\n            P = new Polynom(value)\r\n        }\r\n\r\n\r\n        return this.polynom.isEqual(P)\r\n    }\r\n\r\n    public isZero(): boolean {\r\n        return this.polynom.isZero()\r\n    }\r\n\r\n    public multiply(value: InputAlgebra<Factor | Polynom>): this {\r\n        if (value instanceof Factor) {\r\n            if (this.isSameAs(value)) {\r\n                this.power.add(value.power)\r\n                return this\r\n            }\r\n        }\r\n\r\n\r\n        const P = new Polynom(value as Polynom)\r\n        if (this.isSameAs(P)) {\r\n            this.power.add(1)\r\n            return this\r\n        }\r\n\r\n        throw new Error(\"The two factors must be the same\")\r\n    }\r\n\r\n    public one(): this {\r\n        this.#polynom.one()\r\n        this.#power.one()\r\n        return this\r\n    }\r\n\r\n    public opposite(): Factor {\r\n        throw new Error(\"Method not implemented.\")\r\n    }\r\n\r\n    public get polynom(): Polynom {\r\n        return this.#polynom\r\n    }\r\n\r\n    public set polynom(value: Polynom) {\r\n        this.#polynom = value\r\n    }\r\n\r\n    public pow(value: number | Fraction): this {\r\n        this.power.multiply(value)\r\n        return this\r\n    }\r\n\r\n    public get power(): Fraction {\r\n        return this.#power\r\n    }\r\n\r\n    public set power(value: InputValue<Fraction>) {\r\n        this.#power = new Fraction(value)\r\n    }\r\n\r\n    public primitive(): Factor {\r\n        throw new Error(\"Method not implemented.\")\r\n    }\r\n\r\n    public reduce(): Factor {\r\n        throw new Error(\"Method not implemented.\")\r\n    }\r\n\r\n    public root(value: number): this {\r\n        this.power.divide(value)\r\n        return this\r\n    }\r\n\r\n    public sqrt(): this {\r\n        return this.root(2)\r\n    }\r\n\r\n    public subtract(): Factor {\r\n        throw new Error(\"Subtracting two factors is not possible\")\r\n    }\r\n\r\n    public tableOfSigns(): TABLE_OF_SIGNS {\r\n        const pow = this.power.clone().reduce()\r\n        const tos = this.polynom.tableOfSigns()\r\n\r\n        // The zero roots becomes defence (d) if the power is negative\r\n        if (pow.isStrictlyNegative()) {\r\n            tos.signs = replace_in_array(tos.signs, 'z', 'd')\r\n        }\r\n\r\n        // The - sign becomes\r\n        // + (plus) if the power num is even and the power den is odd\r\n        // i (invalid) if the power denominator is even\r\n        if (pow.denominator % 2 === 0) {\r\n            // it's an even roots : no negative values!\r\n            tos.signs = replace_in_array(tos.signs, '-', 'h')\r\n        } else if (pow.numerator % 2 === 0) {\r\n            // it's an even power :  negative values becomes positive !\r\n            tos.signs = replace_in_array(tos.signs, '-', '+')\r\n        }\r\n\r\n\r\n        return {roots: tos.roots, signs: tos.signs}\r\n    }\r\n\r\n    public get variables(): string[] {\r\n        return this.polynom.variables\r\n    }\r\n\r\n    public get withPower(): this {\r\n        this.#displayMode = FACTOR_DISPLAY.POWER\r\n        return this\r\n    }\r\n\r\n    public get withRoot(): this {\r\n        this.#displayMode = FACTOR_DISPLAY.ROOT\r\n        return this\r\n    }\r\n\r\n    public zero(): this {\r\n        this.#polynom.zero()\r\n        this.#power.one()\r\n        return this\r\n    }\r\n\r\n}\r\n\r\nexport enum FACTOR_DISPLAY {\r\n    ROOT,\r\n    POWER\r\n}\r\n\r\n","import type {IAlgebra, IEquation, InputValue, IPiMathObject, ISolution, literalType} from \"../pimath.interface\"\r\nimport {Fraction} from \"../coefficients\"\r\nimport {Equation} from \"./equation\"\r\nimport {Monom} from \"./monom\"\r\nimport {Polynom} from \"./polynom\"\r\nimport {Numeric} from \"../numeric\"\r\n\r\nexport class LinearSystem implements IPiMathObject<LinearSystem>,\r\n    IEquation<LinearSystem>,\r\n    IAlgebra<LinearSystem> {\r\n\r\n    #equations: Equation[]\r\n    // Solve steps for TeX output.\r\n    #steps: string[] = []\r\n    // Determine the letters in the linear asSystem, usually ['x', 'y']\r\n    #variables: string[]\r\n\r\n    constructor(...values: (string | Equation)[]) {\r\n        this.#equations = []\r\n        this.#variables = []\r\n\r\n        if (values.length > 0) {\r\n            this.parse(...values)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    public parse = (...equations: (string | Equation)[]): this => {\r\n        // make the original equations\r\n        this.#equations = equations.map(value => new Equation(value))\r\n\r\n        // get the letters.\r\n        this.#findLetters()\r\n        return this\r\n    }\r\n\r\n    public clone = (): LinearSystem => {\r\n        return new LinearSystem()\r\n            .parse(...this.#equations.map(equ => equ.clone()))\r\n    }\r\n\r\n    public get tex(): string {\r\n        // Build the array of values.\r\n        // Reorder\r\n        // This clone the asSystem :!!!\r\n        //TODO: Avoid cloning this linear asSystem\r\n        const LS = this.clone().reorder()\r\n\r\n        return this.buildTex(LS.equations)\r\n    }\r\n\r\n    get display() {\r\n        // TODO : LinearSystem - display: implement the display of the linear asSystem\r\n        return this.tex + 'as display'\r\n    }\r\n\r\n    public static fromMatrix(\r\n        matrix: InputValue<Fraction>[][],\r\n        letters = 'xyz'): LinearSystem {\r\n        // Check that each row has the same number of columns\r\n        const cols = matrix[0].length\r\n        if (matrix.some(row => row.length !== cols)) {\r\n            throw new Error(\"All rows must have the same number of columns\")\r\n        }\r\n\r\n        // Determine the default letters. The number of letters are cols-1\r\n        const vars = letters.split('')\r\n            .splice(0, cols - 1)\r\n\r\n        // Create a new LinearSystem\r\n        return new LinearSystem(\r\n            ...matrix.map(row => {\r\n                const P = new Polynom(vars.join(''), ...row)\r\n                return new Equation(P, 0)\r\n            })\r\n        )\r\n\r\n    }\r\n\r\n    public add(value: InputValue<LinearSystem | Equation | Polynom>, index?: number): this {\r\n        if (value instanceof LinearSystem) {\r\n            const length = value.equations.length\r\n            if (length !== this.#equations.length) {\r\n                throw new Error(\"The number of equations must be the same\")\r\n            }\r\n\r\n            for (let i = 0; i < length; i++) {\r\n                this.#equations[i].add(value.equations[i])\r\n            }\r\n        } else {\r\n            if (index === undefined || index < 0 || index >= this.#equations.length) {\r\n                throw new Error(\"Index out of range\")\r\n            }\r\n            const equ = new Equation(value)\r\n            this.#equations[index].add(equ)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    public buildTex = (equations: Equation[], operators?: (string[])[]): string => {\r\n        let equStr: string[]\r\n        let m: Monom\r\n        let letters: string[] = []\r\n        const equArray: string[] = []\r\n\r\n        // Get the letters from the linear asSystem\r\n        for (const equ of equations) {\r\n            letters = letters.concat(equ.letters())\r\n        }\r\n\r\n        letters = [...new Set(letters)]\r\n        letters.sort()\r\n\r\n        for (let i = 0; i < equations.length; i++) {\r\n            const equ = equations[i]\r\n\r\n            equStr = []\r\n            for (const L of letters) {\r\n                m = equ.left.monomByLetter(L)\r\n\r\n                if (equStr.length === 0) {\r\n                    equStr.push(m.isZero() ? '' : m.tex)\r\n                } else {\r\n                    equStr.push(m.isZero() ? '' : ((m.coefficient.sign() === 1) ? '+' : '') + m.tex)\r\n                }\r\n            }\r\n\r\n            // Add the equal sign\r\n            equStr.push('=')\r\n\r\n            // Add the right hand part of the equation (should be only a number, because it has been reordered)\r\n            equStr.push(equ.right.tex)\r\n\r\n            // Add the operations if existing\r\n            if (operators?.[i] !== undefined) {\r\n                // add extra space at the end of the equation\r\n                equStr[equStr.length - 1] = equStr[equStr.length - 1] + ' \\\\phantom{\\\\quad}'\r\n                for (const o of operators[i]) {\r\n                    equStr.push(`\\\\ \\\\cdot\\\\ ${o.startsWith('-') ? \"\\\\left(\" + o + \"\\\\right)\" : o}`)\r\n                }\r\n            }\r\n\r\n            // Add to the list.\r\n            equArray.push(equStr.join('&'))\r\n        }\r\n\r\n        let operatorsColumns = 0\r\n        if (operators !== undefined && operators.length > 0) {\r\n            operatorsColumns = operators[0].length\r\n        }\r\n\r\n        return `\\\\left\\\\{\\\\begin{array}{${\"r\".repeat(letters.length)}cl ${\"|l\".repeat(operatorsColumns)}}${equArray.join('\\\\\\\\ ')}\\\\end{array}\\\\right.`\r\n    }\r\n\r\n    public degree(letter?: string): Fraction {\r\n        return Fraction.max(...this.#equations.map(equ => equ.degree(letter)))\r\n    }\r\n\r\n    // ------------------------------------------\r\n    public get equations(): Equation[] {\r\n        return this.#equations\r\n    }\r\n\r\n    public set equations(value) {\r\n        this.#equations = value\r\n\r\n        // update the variables.\r\n        this.#findLetters()\r\n    }\r\n\r\n    public evaluate(values: InputValue<Fraction> | literalType<number | Fraction>, asNumeric?: boolean): number | Fraction {\r\n        throw new Error(\"Method not implemented.\")\r\n    }\r\n\r\n    public hasVariable(letter: string): boolean {\r\n        return this.#variables.includes(letter)\r\n    }\r\n\r\n    public isEqual(value: LinearSystem): boolean {\r\n        return this.equations.every((equ, index) => equ.isEqual(value.equations[index]))\r\n    }\r\n\r\n    public get isSolvable(): boolean {\r\n        const V = this.variables\r\n\r\n        // TODO: in some case, it is possible to resolve systems if there isn't the isSame number of vars and equations\r\n        if (V.length !== this.#equations.length) {\r\n            return false\r\n        }\r\n\r\n        //TODO: Must check if two equations isn't a linear combination of the others ?\r\n\r\n        return true\r\n    }\r\n\r\n    public get matrix(): [Fraction[][], Fraction[]] {\r\n        //TODO: use Matrix class\r\n        return this.#makeMatrix()\r\n    }\r\n\r\n    public mergeEquations(equation1: { id: number, factor: InputValue<Fraction> }, equation2: {\r\n        id: number,\r\n        factor: number\r\n    }): Equation {\r\n        // Set and clone the equations.\r\n        const eq1multiplied = this.equations[equation1.id].clone().multiply(equation1.factor)\r\n        const eq2multiplied = this.equations[equation2.id].clone().multiply(equation2.factor)\r\n\r\n        // Add both equations together.\r\n        return eq1multiplied.add(eq2multiplied)\r\n    }\r\n\r\n    public multiply(value: InputValue<Fraction> | InputValue<Fraction>[], index?: number): this {\r\n        // Multiply the asSystem by a number\r\n        // the value can be an array of numbers\r\n        // the value can be a number and the index of the equation to multiply\r\n        if (Array.isArray(value)) {\r\n            if (value.length !== this.#equations.length) {\r\n                throw new Error(\"The number of values must be the same as the number of equations\")\r\n            }\r\n\r\n            for (let i = 0; i < value.length; i++) {\r\n                this.#equations[i].multiply(value[i])\r\n            }\r\n            return this\r\n        }\r\n\r\n        if (index === undefined || index < 0 || index >= this.#equations.length) {\r\n            throw new Error(\"Index out of range\")\r\n        }\r\n\r\n        this.#equations[index].multiply(value)\r\n\r\n        return this\r\n    }\r\n\r\n    public reduce(): this {\r\n        // reduce all equations at once.\r\n        this.equations.forEach(equ=>equ.reduce())\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    public reorder = (): this => {\r\n        for (const E of this.#equations) {\r\n            E.reorder()\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    solve(): ISolution[] {\r\n        // TODO : à retravailler, car ce n'est ni l'endroit, ni l'intérêt de l'avoir ici.\r\n        // 1. search in the equations if a variable has two same or opposite value = candidate for merging\r\n        // 2. if 1 is false, search for a variable that has coefficient one\r\n        // 3. if 2 is false, search for a variable that has a coefficient multiple of another.\r\n        // 4. if 3 is false, multiply both lines.\r\n        // => merge the equations and cycle.\r\n        const output: string[] = [this.tex]\r\n\r\n        const LS = this.clone()\r\n\r\n        while (LS.variables.length>1){\r\n            const letter = LS.variables[LS.variables.length-1]\r\n            const emptyLS = new LinearSystem()\r\n            const factors = LS.solve_compute_factors(letter).slice(0, LS.variables.length-1)\r\n            factors.forEach(factor=> {\r\n                emptyLS.equations.push(LS.mergeEquations(...factor))\r\n            })\r\n\r\n            LS.equations = emptyLS.equations\r\n\r\n            output.push(LS.tex)\r\n\r\n            // add the same but with a reduced value.\r\n            LS.reduce()\r\n            output.push(LS.tex)\r\n        }\r\n\r\n\r\n        console.log('\\\\begin{aligned}' + output.join('\\\\\\\\[2em]') + '\\\\end{aligned}')\r\n\r\n        return []\r\n    }\r\n\r\n    public solveMatrix = (): Fraction[] => {\r\n        const [matrix, vector] = this.matrix\r\n        // Solve the matrix\r\n\r\n        // Make the augmented matrix (matrix + vector)\r\n        const augmentedMatrix: Fraction[][] = matrix.map((row, index) => [...row, vector[index]])\r\n\r\n        // Reduce the matrix\r\n        for (let i = 0; i < matrix.length; i++) {\r\n            // Find the pivot (the first non-zero element in the row)\r\n            let pivot = augmentedMatrix[i][i].clone()\r\n            if (pivot.isZero()) {\r\n                // throw new Error('Divide by zero !')\r\n                // Search a line below that would add it.\r\n                const row_to_add = augmentedMatrix\r\n                    .find((row, index) => {\r\n                        return index > i && !row[i].isZero()\r\n                    })\r\n\r\n                if (row_to_add) {\r\n                    augmentedMatrix[i].forEach((value, index) => value.add(row_to_add[index]))\r\n                    pivot = augmentedMatrix[i][i].clone()\r\n                } else {\r\n                    throw new Error('Unsolvable...')\r\n                }\r\n\r\n\r\n            }\r\n\r\n            // Normalize the row: divide all elements by the pivot\r\n            // the pivot is now 1\r\n            augmentedMatrix[i] = augmentedMatrix[i].map(x => x.divide(pivot))\r\n\r\n            // reduce the other rows using the pivot.\r\n            for (let j = 0; j < matrix.length; j++) {\r\n                if (j === i) {\r\n                    continue\r\n                }\r\n\r\n                const factor = augmentedMatrix[j][i].clone().opposite()\r\n                for (let k = 0; k < augmentedMatrix[j].length; k++) {\r\n                    augmentedMatrix[j][k].add(augmentedMatrix[i][k].clone().multiply(factor))\r\n                }\r\n\r\n                // Check if the asSystem is undetermined (no solution or infinite solutions)\r\n                // the j line must not be all zeros\r\n                // the last element must be zero => the asSystem is undetermined\r\n                // the last element must not be zero => the asSystem is impossible\r\n                if (augmentedMatrix[j].slice(0, augmentedMatrix[j].length - 1).every(x => x.isZero())) {\r\n                    if (augmentedMatrix[j][augmentedMatrix[j].length - 1].isZero()) {\r\n                        return [new Fraction().infinite()]\r\n                    } else {\r\n                        return []\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return augmentedMatrix.map(x => x[x.length - 1])\r\n    }\r\n\r\n    solve_compute_factors(letter: string):\r\n        [{ id: number, factor: number }, { id: number, factor: number }][] {\r\n        // when solving, every monoms with a variable is on the left !\r\n        // and every coefficient are relative numbers.\r\n        const result: [{ id: number, factor: number }, { id: number, factor: number }][] = []\r\n        const coefficients = this.equations.map(equ => equ.left.monomByLetter(letter).coefficient.value)\r\n\r\n        // search for a factor\r\n        coefficients.forEach((reference, index) => {\r\n            for (let i = index + 1; i < coefficients.length; i++) {\r\n                const lcm = Numeric.lcm(reference, coefficients[i])\r\n\r\n                const sign = reference < 0 ? -1 : 1\r\n                result.push([\r\n                    {\r\n                        id: index, factor: sign * lcm / reference\r\n                    }, {\r\n                        id: i, factor: -sign * lcm / coefficients[i]\r\n                    }])\r\n            }\r\n        })\r\n\r\n        // Sort the value: prefer the smallest absolute values (1/-1, 2/-2, ...)\r\n        return result.sort((a, b) => {\r\n            return (Math.abs(a[0].factor) + Math.abs(a[1].factor)) - (Math.abs(b[0].factor) + Math.abs(b[1].factor))\r\n        })\r\n    }\r\n\r\n    public subtract(value: InputValue<LinearSystem | Equation | Polynom>, index?: number): this {\r\n        if (value instanceof LinearSystem) {\r\n            const length = value.equations.length\r\n            if (length !== this.#equations.length) {\r\n                throw new Error(\"The number of equations must be the same\")\r\n            }\r\n\r\n            for (let i = 0; i < length; i++) {\r\n                this.#equations[i].subtract(value.equations[i])\r\n            }\r\n        } else {\r\n            if (index === undefined || index < 0 || index >= this.#equations.length) {\r\n                throw new Error(\"Index out of range\")\r\n            }\r\n            const equ = new Equation(value)\r\n            this.#equations[index].subtract(equ)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    public get variables(): string[] {\r\n        return this.#variables\r\n    }\r\n\r\n    public set variables(value: string | string[]) {\r\n        const vars = (typeof value === \"string\") ? value.split('') : [...value]\r\n        vars.sort()\r\n        this.#variables = vars\r\n    }\r\n\r\n    #findLetters = (): this => {\r\n        this.#variables = this.#equations.reduce((acc: string[], equ) => {\r\n            return [...new Set([...acc, ...equ.variables])]\r\n        }, [])\r\n\r\n        this.#variables.sort()\r\n        return this\r\n    }\r\n\r\n    #makeMatrix = (): [Fraction[][], Fraction[]] => {\r\n        // Make the matrix\r\n        const matrix: Fraction[][] = []\r\n        const vector: Fraction[] = []\r\n\r\n        for (const E of this.#equations) {\r\n            const row: Fraction[] = []\r\n\r\n            const equ = E.clone().reorder()\r\n            for (const L of this.variables) {\r\n                const m = equ.left.monomByLetter(L)\r\n                row.push(m.coefficient)\r\n            }\r\n\r\n            // Add the \"no letter part\"\r\n            vector.push(equ.right.monoms[0].coefficient)\r\n\r\n            // Add to the matrix\r\n            matrix.push(row)\r\n        }\r\n\r\n        return [matrix, vector]\r\n    }\r\n\r\n}\r\n","/**\r\n * Polynom module contains everything necessary to handle polynoms.\r\n * @module Logicalset\r\n */\r\nimport {ShutingYard, ShutingyardMode} from \"piexpression\"\r\n\r\n/**\r\n * Polynom class can handle polynoms, reorder, resolve, ...\r\n */\r\nexport class LogicalSet {\r\n    #rpn: { token: string, tokenType: string }[]\r\n\r\n    /**\r\n     *\r\n     * @param {string} value (optional) Default polynom to parse on class creation\r\n     */\r\n    constructor(value?: string) {\r\n        this.#rpn = []\r\n\r\n        if (value !== undefined) {\r\n            this.parse(value)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    parse = (value: string): this => {\r\n        // Parse the updated value to the shutingyard algorithm\r\n        this.#rpn = new ShutingYard(ShutingyardMode.SET)\r\n            .parse(value)\r\n            .rpn\r\n\r\n        return this\r\n    }\r\n\r\n    evaluate(values: Record<string, boolean>): boolean {\r\n        // Add missing key(s) and set them as false by default.\r\n        this.variables.forEach(key => {\r\n            if (!Object.hasOwn(values, key)) {\r\n                values[key] = false\r\n            }\r\n        })\r\n\r\n        const stack: boolean[] = []\r\n        for (const token of this.#rpn) {\r\n            console.log(token)\r\n            if (token.tokenType === 'variable') {\r\n                stack.push(values[token.token])\r\n            } else if (token.tokenType === 'operation') {\r\n                if (token.token === '!') {\r\n                    // need only one item from stack\r\n                    if (stack.length >= 1) {\r\n                        const a = stack.pop()\r\n                        stack.push(!a)\r\n                    } else {\r\n                        return false\r\n                    }\r\n                } else {\r\n                    // All other operations needs two items from stack\r\n                    const a = stack.pop()\r\n                    const b = stack.pop()\r\n                    if (a !== undefined && b !== undefined) {\r\n                        switch (token.token) {\r\n                            case \"&\":\r\n                                stack.push(a && b)\r\n                                break\r\n                            case \"|\":\r\n                                stack.push(a || b)\r\n                                break\r\n                            case \"-\":\r\n                                return false\r\n                        }\r\n\r\n                    } else {\r\n                        return false\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return stack.length === 1 && stack[0]\r\n    }\r\n\r\n    get rpn(): { token: string, tokenType: string }[] {\r\n        return this.#rpn\r\n    }\r\n\r\n    get tex(): string {\r\n        const varStack: { token: string, tokenType: string }[] = []\r\n\r\n        for (const token of this.#rpn) {\r\n            if (token.tokenType === 'variable') {\r\n                varStack.push(token)\r\n            } else {\r\n                switch (token.token) {\r\n                    case '&':\r\n                        if (varStack.length >= 2) {\r\n                            const second = varStack.pop(),\r\n                                first = varStack.pop()\r\n\r\n                            if (second && first) {\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\cap ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                        }\r\n                        break\r\n                    case '|':\r\n                        if (varStack.length >= 2) {\r\n                            const second = varStack.pop(),\r\n                                first = varStack.pop()\r\n\r\n                            if (second && first) {\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\cup ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                        }\r\n                        break\r\n                    case '-':\r\n                        if (varStack.length >= 2) {\r\n                            const second = varStack.pop(),\r\n                                first = varStack.pop()\r\n\r\n                            if (second && first) {\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\setminus ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                        }\r\n                        break\r\n                    case '!':\r\n                        if (varStack.length >= 1) {\r\n                            const first = varStack.pop()\r\n\r\n                            if (first) {\r\n                                varStack.push({token: `\\\\overline{ ${first.token} }`, tokenType: 'variable'})\r\n                            }\r\n                        }\r\n                        break\r\n                }\r\n            }\r\n        }\r\n\r\n        return varStack[0].token\r\n    }\r\n\r\n    get variables(): string[] {\r\n        return this.#rpn\r\n            .filter(value => value.tokenType === 'variable')\r\n            .map(value => value.token)\r\n    }\r\n\r\n    vennAB(): string[] {\r\n        return this.#evaluateAsVenn({\r\n                A: ['A', 'AB'],\r\n                B: ['B', 'AB']\r\n            },\r\n            ['A', 'B', 'AB', 'E']\r\n        )\r\n    }\r\n\r\n    vennABC(): string[] {\r\n        return this.#evaluateAsVenn({\r\n                A: ['A', 'AB', 'AC', 'ABC'],\r\n                B: ['B', 'AB', 'BC', 'ABC'],\r\n                C: ['C', 'AC', 'BC', 'ABC']\r\n            },\r\n            ['A', 'B', 'C', 'AB', 'AC', 'BC', 'ABC', 'E']\r\n        )\r\n    }\r\n\r\n    #evaluateAsVenn(tokenSets: Record<string, string[] | undefined>, reference?: string[]): string[] {\r\n        const varStack: (Set<string>)[] = []\r\n\r\n        let referenceSet: Set<string>\r\n        if (reference === undefined) {\r\n            referenceSet = new Set()\r\n            for (const key in tokenSets) {\r\n                referenceSet = new Set([\r\n                    ...referenceSet,\r\n                    ...(tokenSets[key] ?? [])\r\n                ])\r\n            }\r\n        } else {\r\n            referenceSet = new Set(reference)\r\n        }\r\n\r\n        for (const token of this.#rpn) {\r\n            if (token.tokenType === 'variable') {\r\n                // The variable has no token - assume it's empty.\r\n                if (tokenSets[token.token] === undefined) {\r\n                    varStack.push(new Set())\r\n                } else {\r\n                    varStack.push(new Set(tokenSets[token.token]))\r\n                }\r\n\r\n            } else {\r\n                switch (token.token) {\r\n                    case '&':\r\n                        if (varStack.length >= 2) {\r\n                            const second = varStack.pop(),\r\n                                first = varStack.pop()\r\n\r\n                            if (first && second) {\r\n                                varStack.push(new Set([...first].filter(x => second.has(x))))\r\n                            }\r\n                        }\r\n                        break\r\n                    case '|':\r\n                        if (varStack.length >= 2) {\r\n                            const second = varStack.pop(),\r\n                                first = varStack.pop()\r\n                            if (first && second) {\r\n                                varStack.push(new Set([...first, ...second]))\r\n                            }\r\n                        }\r\n                        break\r\n                    case '-':\r\n                        if (varStack.length >= 2) {\r\n                            const second = varStack.pop(),\r\n                                first = varStack.pop()\r\n\r\n                            if (first && second) {\r\n                                varStack.push(new Set([...first].filter(x => !second.has(x))))\r\n                            }\r\n                        }\r\n                        break\r\n                    case '!':\r\n                        if (varStack.length >= 1) {\r\n                            const first = varStack.pop()\r\n\r\n                            if (first) {\r\n                                varStack.push(new Set([...referenceSet].filter(x => !first.has(x))))\r\n                            }\r\n                        }\r\n                        break\r\n                }\r\n            }\r\n        }\r\n\r\n        return [...varStack[0]].sort()\r\n    }\r\n}","import type {\r\n    FACTOR_TABLE_OF_SIGNS,\r\n    IAlgebra,\r\n    IExpression,\r\n    InputAlgebra,\r\n    InputValue,\r\n    IPiMathObject,\r\n    ISolution,\r\n    literalType,\r\n    POLYFACTOR_TABLE_OF_SIGNS,\r\n    TABLE_OF_SIGNS_VALUES\r\n} from \"../pimath.interface\"\r\nimport {Fraction} from \"../coefficients\"\r\nimport {Factor, FACTOR_DISPLAY} from \"./factor\"\r\nimport {Polynom} from \"./polynom\"\r\nimport type {Solution} from \"../analyze/solution\"\r\n\r\n\r\n// PolyFactor is a class that represents a polynomial in factored form.\r\nexport class PolyFactor implements IPiMathObject<PolyFactor>,\r\n    IExpression<PolyFactor>,\r\n    IAlgebra<PolyFactor> {\r\n\r\n    #displayMode: FACTOR_DISPLAY = FACTOR_DISPLAY.POWER\r\n    #factors: Factor[] = []\r\n\r\n    constructor(...values: (InputAlgebra<Polynom> | Factor | PolyFactor)[]) {\r\n        this.parse(...values)\r\n        return this\r\n    }\r\n\r\n    public parse(...values: (InputAlgebra<Polynom> | Factor | PolyFactor)[]): this {\r\n        // Init the factors list\r\n        this.#factors = []\r\n\r\n        // Nothing to create\r\n        if (values.length === 0) {\r\n            return this\r\n        }\r\n\r\n        values.forEach(value => {\r\n            if (value instanceof PolyFactor) {\r\n                this.#factors.push(...value.factors.map(f => f.clone()))\r\n            } else {\r\n                this.#factors.push(new Factor(value))\r\n            }\r\n        })\r\n\r\n        return this\r\n    }\r\n\r\n    public clone(): PolyFactor {\r\n        return new PolyFactor(...this.#factors.map(f => f.clone()))\r\n    }\r\n\r\n    public get tex(): string {\r\n        const {num, den} = this.#extractNumeratorAndDenominator()\r\n\r\n        if (den.length === 0) {\r\n            if (num.length === 1) {\r\n                return num[0].asSingle.tex\r\n            }\r\n\r\n            return num.map(f => f.tex).join(\"\")\r\n        }\r\n\r\n        // There is a numerator and a denominator\r\n        const numTeX = num.length === 1 ? num[0].asSingle.tex : num.map(f => f.tex).join(\"\")\r\n        const denTeX = den.length === 1 ? den[0].asSingle.tex : den.map(f => f.tex).join(\"\")\r\n\r\n        return `\\\\frac{ ${numTeX} }{ ${denTeX} }`\r\n\r\n    }\r\n\r\n    public get display(): string {\r\n        const {num, den} = this.#extractNumeratorAndDenominator()\r\n\r\n        if (den.length === 0) {\r\n            if (num.length === 1) {\r\n                return num[0].asSingle.display\r\n            }\r\n\r\n            return num.map((f, index) =>\r\n                index === 0 && f.polynom.monoms.length === 1 ? f.asSingle.display : f.display\r\n            ).join(\"\")\r\n        }\r\n\r\n        // There is a numerator and a denominator\r\n        const numTeX = num.length === 1 ? num[0].asSingle.display : num.map(f => f.display).join(\"\")\r\n        const denTeX = den.length === 1 ? den[0].asSingle.display : den.map(f => f.display).join(\"\")\r\n\r\n        return `(${numTeX})/(${denTeX})`\r\n\r\n    }\r\n\r\n    static #gcdWith(PF1: PolyFactor, PF2: PolyFactor): PolyFactor {\r\n        // Get all factors of the two polynomials\r\n        // Find the common factors\r\n        const factors1 = keyFactors(PF1)\r\n\r\n        const factors2 = keyFactors(PF2)\r\n\r\n        const common = Object.keys(factors1).filter(k => Object.hasOwn(factors2, k))\r\n\r\n        // Find the minimum power of the common factors\r\n        const factors = common.map(k => {\r\n            const power = factors1[k].reduce((acc, f) => acc.add(f.power), new Fraction('0'))\r\n            const power2 = factors2[k].reduce((acc, f) => acc.add(f.power), new Fraction('0'))\r\n            return new Factor(k, Fraction.min(power, power2))\r\n        })\r\n\r\n        return new PolyFactor(...factors)\r\n    }\r\n\r\n    static #lcmWith(PF1: PolyFactor, PF2: PolyFactor): PolyFactor {\r\n\r\n        const factors1 = keyFactors(PF1)\r\n\r\n        const factors2 = keyFactors(PF2)\r\n\r\n        const common = [...new Set([...Object.keys(factors1), ...Object.keys(factors2)])]\r\n\r\n        // Find the maximum power of the common factors\r\n        const factors = common.map(k => {\r\n            const power =\r\n                Object.hasOwn(factors1, k) ?\r\n                    factors1[k].reduce((acc, f) => acc.add(f.power), new Fraction('0')) :\r\n                    new Fraction(0)\r\n            const power2 = Object.hasOwn(factors2, k) ?\r\n                factors2[k].reduce((acc, f) => acc.add(f.power), new Fraction('0')) :\r\n                new Fraction(0)\r\n            return new Factor(k, Fraction.max(power, power2))\r\n        })\r\n\r\n        return new PolyFactor(...factors)\r\n    }\r\n\r\n    public static gcd(...values: PolyFactor[]): PolyFactor {\r\n        if (values.length === 0) {\r\n            return new PolyFactor().one()\r\n        }\r\n        if (values.length === 1) {\r\n            return values[0]\r\n        }\r\n        if (values.length === 2) {\r\n            return PolyFactor.#gcdWith(values[0], values[1])\r\n        }\r\n\r\n        // values is not undefined,\r\n        let PF = values[0]\r\n        values.shift()\r\n        values.forEach(value => PF = PolyFactor.#gcdWith(PF, value))\r\n\r\n        return PF\r\n    }\r\n\r\n    public static lcm(...values: PolyFactor[]): PolyFactor {\r\n        if (values.length === 0) {\r\n            return new PolyFactor().one()\r\n        }\r\n        if (values.length === 1) {\r\n            return values[0]\r\n        }\r\n\r\n        let PF = values[0]\r\n        values.shift()\r\n        values.forEach(value => PF = PolyFactor.#lcmWith(PF, value))\r\n        return PF\r\n    }\r\n\r\n    public add(...values: PolyFactor[]): this {\r\n        // Adding two (or more) polyfactors:\r\n        // if both are numerators only, use the common polynom\r\n        // if there are denominators, multiply every polyfactors to match the lcm polyfactor.\r\n\r\n        const numerators: PolyFactor[] = [this.numerator, ...values.map(x => x.numerator)]\r\n        const denominators: PolyFactor[] = [this.denominator, ...values.map(x => x.denominator)]\r\n\r\n        let denominator: PolyFactor | undefined\r\n        if (denominators.some(d => d.factors.length > 0)) {\r\n            // At least one of the denominators is not empty.\r\n            const lcm = PolyFactor.lcm(...denominators)\r\n\r\n            // Multiply each numerators by the complementary.\r\n            numerators.forEach((n, index) => {\r\n                n.multiply(lcm.clone().divide(denominators[index]))\r\n            })\r\n\r\n            // Set the common denominator to the lcm PolyFctor\r\n            denominator = lcm\r\n        }\r\n\r\n        // Now, every polyfactor should have a common denominator. Just add the numerators.\r\n        const gcd = PolyFactor.gcd(...numerators)\r\n        const remainingPolynom = new Polynom(0)\r\n            .add(...numerators.map(pf => {\r\n                    return pf\r\n                        .divide(gcd).reduce()\r\n                        .develop() // should be a polyfactor with one factor, with a power of 1\r\n                        .factors[0]\r\n                        .polynom\r\n                })\r\n            ).reduce()\r\n\r\n        this.#factors = [\r\n            ...gcd.factors,\r\n            new Factor(remainingPolynom)\r\n        ]\r\n\r\n        if (denominator) {\r\n            this.divide(denominator)\r\n        }\r\n\r\n        // Remove all factors with a power of zero\r\n        this.#factors = this.#factors.filter(x => !x.power.isZero())\r\n\r\n        return this\r\n    }\r\n\r\n    get asPower(): this {\r\n        this.#displayMode = FACTOR_DISPLAY.POWER\r\n        return this\r\n    }\r\n\r\n    get asRoot(): this {\r\n        this.#displayMode = FACTOR_DISPLAY.ROOT\r\n        return this\r\n    }\r\n\r\n    public degree(letter?: string): Fraction {\r\n        return this.#factors.reduce((acc, f) => acc.add(f.degree(letter)), new Fraction('0'))\r\n    }\r\n\r\n    get denominator(): PolyFactor {\r\n        return new PolyFactor(...this.#factors\r\n            .filter(f => f.power.isNegative())\r\n            .map(f => f.clone().inverse())\r\n        )\r\n    }\r\n\r\n    public derivative(): this {\r\n        // (fgh)' = f'gh+fg'h+fgh'\r\n        // dPF = [f'gh, fg'h, fgh']\r\n        const dPF: PolyFactor[] = []\r\n\r\n        const length = this.#factors.length\r\n\r\n        for (let i = 0; i < length; i++) {\r\n            // unchanged factors\r\n            const factors = this.#factors.slice()\r\n            // derivative factor\r\n            const derivativeFactor = factors.splice(i, 1)[0].derivative()\r\n            // Add the product of factors\r\n            dPF.push(\r\n                new PolyFactor(...factors, ...derivativeFactor))\r\n        }\r\n\r\n        // Reduce the polyFactors\r\n        dPF.forEach(pf => pf.reduce())\r\n\r\n        const first = dPF.shift()\r\n        if (first !== undefined) {\r\n            this.#factors = first.factors\r\n        }\r\n\r\n        // Add each factors together.\r\n        return this.add(...dPF)\r\n    }\r\n\r\n    public develop(): PolyFactor {\r\n        // Develop each factor and multiply them\r\n        const N = new Polynom('1')\r\n        const D = new Polynom('1')\r\n\r\n        this.numerator.factors.forEach(f => {\r\n            N.multiply(f.develop())\r\n        })\r\n        this.denominator.factors.forEach(f => {\r\n            D.multiply(f.develop())\r\n        })\r\n\r\n        return new PolyFactor().fromPolynom(N, D)\r\n    }\r\n\r\n    public divide(value: PolyFactor): this {\r\n        this.#factors = this.#factors.concat(value.clone().factors.map(f => f.inverse()))\r\n        return this\r\n    }\r\n\r\n    public evaluate(values: InputValue<Fraction> | literalType<number | Fraction>, asNumeric?: boolean): number | Fraction {\r\n        if (asNumeric) {\r\n            return this.#factors\r\n                .reduce((acc, f) => acc * (f.evaluate(values, asNumeric) as number), 1)\r\n        }\r\n\r\n        return this.#factors\r\n            .reduce((acc, f) => acc.multiply(f.evaluate(values)), new Fraction('1'))\r\n    }\r\n\r\n    public factorize(letter?: string): PolyFactor {\r\n        // Go through each factors.\r\n        // If it can be factorized, remove the factor (set its power to zero) and insert the new factors instead.\r\n        const newFactors: Factor[] = []\r\n\r\n        this.#factors.forEach(factor => {\r\n            const factors = factor.polynom.factorize(letter)\r\n            if (factors.length > 1) {\r\n                const pow = factor.power.clone()\r\n                newFactors.push(...factors.map(x => new Factor(x, pow)))\r\n            } else {\r\n                newFactors.push(factor.clone())\r\n            }\r\n        })\r\n\r\n        const result = new PolyFactor(...newFactors)\r\n        const numerator = result.numerator.reduce()\r\n        const denominator = result.denominator.reduce()\r\n\r\n        return numerator.divide(denominator)\r\n    }\r\n\r\n    public get factors(): Factor[] {\r\n        return this.#factors\r\n    }\r\n\r\n    public set factors(value: Factor[]) {\r\n        this.#factors = value\r\n    }\r\n\r\n    public fromPolynom(numerator: InputAlgebra<Polynom>, denominator?: InputAlgebra<Polynom>): this {\r\n        // fromPolynom loads the numerator and denominator as is, without factorizing !\r\n        this.#factors = [new Factor(new Polynom(numerator))]\r\n\r\n        if (denominator) {\r\n            const polynom = new Polynom(denominator)\r\n\r\n            if (polynom.isOne()) {\r\n                return this\r\n            }\r\n            if (polynom.isZero()) {\r\n                throw new Error(\"Cannot divide by zero\")\r\n            }\r\n            this.#factors.push(new Factor(polynom, -1))\r\n        }\r\n        // // Find all factors from a polynom\r\n        // this.#factors = new Polynom(numerator)\r\n        //     .factorize(letter)\r\n        //     .map(value => new Factor(value))\r\n        //\r\n        // if (denominator) {\r\n        //     new Polynom(denominator)\r\n        //         .factorize(letter)\r\n        //         .forEach(value => this.#factors.push(new Factor(value, -1)))\r\n        // }\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Get the roots of the PolyFactor.\r\n     */\r\n    public getRoots(): Solution[] {\r\n        return []\r\n    }\r\n\r\n    public getZeroes(): ISolution[] {\r\n        // Calculate the list of roots (ordered, unique)\r\n        const roots: ISolution[] = ([] as ISolution[])\r\n            .concat(...this.#factors.map(x => x.polynom.getZeroes()))\r\n        // .concat(...tos.map(x => x.roots))\r\n\r\n        // Sort the values.\r\n        roots.sort((a, b) => a.value - b.value)\r\n        // Remove duplicates.\r\n        return roots\r\n            .filter((value, index, self) =>\r\n                    index === self.findIndex((t) =>\r\n                        t.value === value.value\r\n                    )\r\n            )\r\n    }\r\n\r\n    public hasVariable(letter: string): boolean {\r\n        return this.#factors.some(f => f.hasVariable(letter))\r\n    }\r\n\r\n    public inverse(): this {\r\n        this.#factors = this.#factors.map(f => f.inverse())\r\n        return this\r\n    }\r\n\r\n    public isEqual(value: PolyFactor): boolean {\r\n        const gcd = PolyFactor.gcd(this, value)\r\n\r\n        const PF1 = this.clone().divide(gcd).reduce()\r\n        const PF2 = value.clone().divide(gcd).reduce()\r\n\r\n        return PF1.isOne() && PF2.isOne()\r\n    }\r\n\r\n    public isOne(): boolean {\r\n        return this.#factors.every(f => f.isOne())\r\n    }\r\n\r\n    public isZero(): boolean {\r\n        return this.#factors.every(f => f.isZero())\r\n    }\r\n\r\n    public multiply(...values: PolyFactor[]): this {\r\n        values.forEach(value => {\r\n            this.#factors = this.#factors.concat(value.clone().factors)\r\n        })\r\n\r\n        return this\r\n    }\r\n\r\n    get numerator(): PolyFactor {\r\n        return new PolyFactor(...this.#factors.filter(f => f.power.isPositive()))\r\n    }\r\n\r\n    public one(): this {\r\n        this.#factors = [new Factor('1', '1')]\r\n        return this\r\n    }\r\n\r\n    public opposite(): this {\r\n        // Add the -1 factor or remove if it exists\r\n        const index = this.#factors.findIndex(f => f.display === '(-1)')\r\n\r\n        if (index >= 0) {\r\n            this.#factors.splice(index, 1)\r\n        } else {\r\n            this.#factors.push(new Factor('-1', '1'))\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    public pow(value: number | Fraction): this {\r\n        this.#factors = this.#factors.map(f => f.pow(value))\r\n        return this\r\n    }\r\n\r\n    public primitive(): PolyFactor {\r\n        throw new Error(\"Method not implemented.\")\r\n    }\r\n\r\n    public reduce(): this {\r\n        // Regroup the factors by their base\r\n        const factors = keyFactors(this)\r\n\r\n        // Multiply the factors of the same base\r\n        this.#factors = Object.values(factors)\r\n            .map(f => {\r\n                const base = f[0].polynom\r\n                const power = f.reduce((acc, f) => acc.add(f.power), new Fraction('0'))\r\n                return new Factor(base, power.reduce())\r\n            })\r\n            .filter(f => !f.power.isZero())\r\n\r\n        return this\r\n    }\r\n\r\n    public root(value: number): this {\r\n        this.#factors = this.#factors.map(f => f.root(value))\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Reoarder the factors using :\r\n     * 1. number of monoms\r\n     * 2. degree of polynom\r\n     * 3. power of polyfactor\r\n     */\r\n    public sort(letter?: string): this {\r\n        this.#factors.sort((a, b) => {\r\n            // If the compare powers are opposite, the negative power goes to the end.\r\n            const aPower = a.power.value\r\n            const bPower = b.power.value\r\n            if (aPower * bPower < 0) {\r\n                return -aPower\r\n            }\r\n\r\n\r\n            // Monom length\r\n            const aLength = a.polynom.monoms.length\r\n            const bLength = b.polynom.monoms.length\r\n            if (aLength !== bLength) {\r\n                return aLength - bLength\r\n            }\r\n\r\n            // The monom length are the same, check the polynom degree.\r\n            const aDegree = a.polynom.degree(letter).value\r\n            const bDegree = b.polynom.degree(letter).value\r\n            if (aDegree !== bDegree) {\r\n                return aDegree - bDegree\r\n            }\r\n\r\n            // The power of the PolyFactor\r\n            if (aPower !== bPower) {\r\n                return aPower - bPower\r\n            }\r\n\r\n            return a.degree().isLeq(b.degree()) ? -1 : 1\r\n        })\r\n\r\n        return this\r\n    }\r\n\r\n    public sqrt(): this {\r\n        this.#factors = this.#factors.map(f => f.sqrt())\r\n        return this\r\n    }\r\n\r\n    public subtract(...values: PolyFactor[]): this {\r\n        return this.add(...values.map(f => f.opposite()))\r\n    }\r\n\r\n    public tableOfSigns(): POLYFACTOR_TABLE_OF_SIGNS {\r\n        // Calculate the table of signs for each factor\r\n        const roots = this.getZeroes()\r\n        const roots_key = roots.map(x => x.value)\r\n\r\n        // Get the table of signs of every factors\r\n\r\n\r\n        // These signs are NOT aligned\r\n        const factors: FACTOR_TABLE_OF_SIGNS[] = this.factorize().factors\r\n            .map(factor => {\r\n                return {factor: new Factor(factor), ...factor.tableOfSigns()}\r\n            })\r\n\r\n        // Build the table of signs with extra roots for each factors.\r\n        factors.forEach(item => {\r\n            // Create the new signs row\r\n            const empty_signs: TABLE_OF_SIGNS_VALUES[] = new Array(2 * roots.length + 1).fill('') as unknown as TABLE_OF_SIGNS_VALUES[]\r\n\r\n            let sign = item.signs.shift() as unknown as TABLE_OF_SIGNS_VALUES\r\n            let root = item.roots.shift()\r\n\r\n            const aligned_signs = empty_signs.map((_sign, index) => {\r\n                if (index % 2 === 0) {\r\n                    return sign\r\n                }\r\n\r\n                // The sign for this indexed root is a t(ab)\r\n                if (root === undefined || root.value !== roots_key[(index - 1) / 2]) {\r\n                    return 't'\r\n                }\r\n\r\n                // The indexed root is the new root\r\n                const rootSign = item.signs.shift() as unknown as TABLE_OF_SIGNS_VALUES\r\n\r\n                // Make the new signs.\r\n                sign = item.signs.shift() as unknown as TABLE_OF_SIGNS_VALUES\r\n                root = item.roots.shift()\r\n                return rootSign\r\n            })\r\n\r\n            // Set the roots for this item to all roots\r\n            item.roots = roots\r\n            item.signs = aligned_signs\r\n        })\r\n\r\n        // Build the table of signs with extra roots : reault line\r\n        const signs: TABLE_OF_SIGNS_VALUES[] = factors\r\n            .map((item) => [...item.signs])\r\n            .reduce<TABLE_OF_SIGNS_VALUES[]>((a, b) => {\r\n                if (a.length === 0) {\r\n                    return b\r\n                }\r\n\r\n                // a and b are \"not aligned\"\r\n                b.forEach((value, index) => {\r\n                    // Case of a zero, invalid or tab value\r\n                    // tab < zero < defence\r\n                    switch (value) {\r\n                        case \"d\":\r\n                            a[index] = \"d\"\r\n                            break\r\n                        case \"z\":\r\n                            a[index] = a[index] === \"d\" ? \"d\" : \"z\"\r\n                            break\r\n                        case \"h\":\r\n                            a[index] = \"h\"\r\n                            break\r\n                        case \"-\":\r\n                            a[index] = a[index] === \"h\" ? \"h\" : a[index] === \"-\" ? \"+\" : \"-\"\r\n                            break\r\n                    }\r\n                })\r\n\r\n                return a\r\n            }, [])\r\n\r\n        return {signs, roots, factors}\r\n    }\r\n\r\n    public get variables(): string[] {\r\n        return this.#factors\r\n            .reduce((acc: string[], f: Factor) => acc.concat(f.variables), [])\r\n    }\r\n\r\n    public zero(): this {\r\n        this.#factors = [new Factor('0', '1')]\r\n        return this\r\n    }\r\n\r\n    #extractNumeratorAndDenominator() {\r\n        let num: Factor[],\r\n            den: Factor[] = []\r\n\r\n        if (this.#displayMode === FACTOR_DISPLAY.ROOT) {\r\n            // the power are positive integers\r\n            num = this.numerator.factors\r\n            den = this.denominator.factors\r\n        } else {\r\n            num = this.#factors\r\n        }\r\n\r\n        // There is no factor\r\n        if (num.length === 0) {\r\n            num = [new Factor('1')]\r\n        }\r\n        return {num, den}\r\n    }\r\n\r\n}\r\n\r\nfunction keyFactors(value: PolyFactor): Record<string, Factor[]> {\r\n    const k_numerator = new Fraction().one()\r\n    const k_denominator = new Fraction().one()\r\n\r\n    const kF = value.factors\r\n        .reduce((acc: Record<string, Factor[]>, f) => {\r\n            // It's only a value\r\n            if (f.polynom.degree().isZero()) {\r\n                if (f.power.isPositive()) {\r\n                    k_numerator.multiply(f.polynom.monoms[0].coefficient)\r\n                } else {\r\n                    k_denominator.multiply(f.polynom.monoms[0].coefficient)\r\n                }\r\n\r\n                return acc\r\n            }\r\n\r\n            // It's a polynom\r\n            const base = f.polynom.display\r\n            if (Object.hasOwn(acc, base)) {\r\n                acc[base].push(f)\r\n            } else {\r\n                acc[base] = [f]\r\n            }\r\n\r\n            return acc\r\n        }, {})\r\n\r\n\r\n    const {numerator, denominator} = k_numerator.divide(k_denominator).reduce()\r\n    if(numerator!==1){\r\n        kF[numerator.toString()] = [new Factor(numerator, 1)]\r\n    }\r\n    if(denominator!==1){\r\n        kF[denominator.toString()] = [new Factor(denominator, -1)]\r\n    }\r\n\r\n    return kF\r\n}\r\n","import type {IExpressionMultiply, InputAlgebra, InputValue, IPiMathObject} from \"../pimath.interface\"\r\nimport {Polynom} from \"./polynom\"\r\nimport type {Vector} from \"../geometry\"\r\nimport {operation_pow} from \"./operations\"\r\n\r\nexport type IMatrixValues = InputAlgebra<Polynom>[][]\r\n\r\nexport class Matrix implements IPiMathObject<Matrix>,\r\n    IExpressionMultiply<Matrix> {\r\n    #digits: number | null = null\r\n    #matrix_parenthesis = true\r\n    #values: Polynom[][] = []\r\n\r\n    constructor(rowCount?: number, colCount?: number) {\r\n        if (rowCount) {\r\n            colCount = colCount ?? rowCount\r\n            this.fromDimensions(rowCount, colCount)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    public parse(values: IMatrixValues): this {\r\n        return this.fromValues(values)\r\n\r\n        return this\r\n    }\r\n\r\n    public clone(): Matrix {\r\n        // Copy the matrix.\r\n        const duplicates: IMatrixValues = []\r\n\r\n        this.#values.forEach(row => {\r\n            const dup_row: Polynom[] = []\r\n            row.forEach(value => {\r\n                dup_row.push(value.clone())\r\n            })\r\n\r\n            duplicates.push(dup_row)\r\n        })\r\n\r\n        return new Matrix().fromValues(duplicates)\r\n    }\r\n\r\n    get tex(): string {\r\n        if (this.#values.length === 0) {\r\n            return \"\"\r\n        }\r\n\r\n        const wrapper = this.#matrix_parenthesis ? 'pmatrix' : 'bmatrix'\r\n\r\n\r\n        const output = [\r\n            `\\\\begin{${wrapper}}`,\r\n            ...this.rows\r\n                .map(row => '\\t' + row\r\n                    .map(p => this.#digits !== null && p.value ? +p.value.toFixed(this.#digits):p.tex)\r\n                    .join(' & ') + '\\\\\\\\'\r\n                ),\r\n            `\\\\end{${wrapper}}`\r\n        ].join('\\n')\r\n\r\n        this.#digits = null\r\n\r\n        return output\r\n    }\r\n\r\n    get display(): string {\r\n        if (this.#values.length === 0) {\r\n            return \"\"\r\n        }\r\n\r\n        const wrapper = this.#matrix_parenthesis ? ['(', ')'] : ['[', ']']\r\n\r\n        const output = wrapper[0] +\r\n            this.map(aij => this.#digits !== null && aij.value ? +aij.value.toFixed(this.#digits): aij.display)\r\n                .map(row => `(${row.join(',')})`)\r\n                .join(',') +\r\n            wrapper[1]\r\n\r\n        this.#digits = null\r\n\r\n        return output\r\n    }\r\n\r\n    public add(value: Matrix): this {\r\n        if (!this.canBeAdded(value)) {\r\n            throw new Error(\"Cannot add a matrix with different dimensions.\")\r\n        }\r\n        this.forEach((aij, i, j) => {\r\n            aij.add(value.values[i][j])\r\n        })\r\n\r\n        return this\r\n    }\r\n\r\n    public aij(i: number, j: number) {\r\n        if (i < 0 || i > this.dimension.rows || j < 0 || j > this.dimension.cols) {\r\n            return null\r\n        }\r\n\r\n        return this.#values[i][j]\r\n    }\r\n\r\n    get bmatrix(): this {\r\n        this.#matrix_parenthesis = false\r\n        return this\r\n    }\r\n\r\n    public canBeAdded(matrix: Matrix): boolean {\r\n        const {rows, cols} = this.dimension\r\n        const {rows: rows2, cols: cols2} = matrix.dimension\r\n\r\n        return rows === rows2 && cols === cols2\r\n    }\r\n\r\n    public canBeInverted(): boolean {\r\n        if (!this.isSquare()) {\r\n            return false\r\n        }\r\n\r\n        const determinant = this.determinant()\r\n        if (determinant.isZero()) {\r\n            return false\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    public canBeMultiplied(matrix: Matrix): boolean {\r\n        return this.dimension.cols === matrix.dimension.rows\r\n    }\r\n\r\n    public characteristic_polynom(letter?: string): Polynom {\r\n        letter ??= 'k'\r\n\r\n        return this.clone().subtract(\r\n            new Matrix(this.dimension.rows).one().multiply(new Polynom(letter))\r\n        ).determinant()\r\n    }\r\n\r\n    public cofactor(row: number, column: number): Polynom {\r\n        // Remove a line.\r\n        const coMatrix = this.clone()\r\n\r\n        coMatrix.values.splice(row, 1)\r\n\r\n        // Remove a column\r\n        coMatrix.values.forEach(row => {\r\n            row.splice(column, 1)\r\n        })\r\n\r\n        return coMatrix.determinant().multiply((-1) ** (row + column))\r\n    }\r\n\r\n    get cols(): Polynom[][] {\r\n        // Return the rows of the transposed matrix !\r\n        const arr = Array.from({length: this.dimension.cols}, () => {\r\n            return Array.from({length: this.dimension.rows}, () => new Polynom())\r\n        })\r\n\r\n        this.forEach((aij, i, j) => {\r\n            arr[j][i] = aij\r\n        })\r\n\r\n        return arr\r\n    }\r\n\r\n    public determinant(): Polynom {\r\n        if (!this.isSquare()) {\r\n            throw new Error('Matrix is not square')\r\n        }\r\n\r\n        // Use the first line.\r\n        // For each value, create the cofactor matrix -> get the determinant\r\n        const det = new Polynom()\r\n\r\n        // It's a 1x1 matrix\r\n        if (this.#values.length === 1) {\r\n            return this.#values[0][0].clone()\r\n        }\r\n\r\n        // It's a matrix greater than 1x1\r\n        this.values[0].forEach((aij, column) => {\r\n            const C = this.cofactor(0, column)\r\n            det.add(aij.clone().multiply(C))\r\n        })\r\n\r\n        return det\r\n    }\r\n\r\n    get dimension(): { rows: number, cols: number } {\r\n        return {\r\n            rows: this.#values.length,\r\n            cols: this.#values[0].length,\r\n        }\r\n    }\r\n\r\n    public flat(): Polynom[] {\r\n        return this.#values.flat()\r\n    }\r\n\r\n    public forEach(callback: (aij: Polynom, row: number, column: number) => void): void {\r\n        this.#values.forEach((row, i) => {\r\n            row.forEach((aij, j) => {\r\n                callback(aij, i, j)\r\n            })\r\n        })\r\n    }\r\n\r\n    public fromDimensions(rows: number, cols: number): this {\r\n        this.#values = Array.from({length: rows}, () => {\r\n            return Array.from({length: cols}, () => new Polynom())\r\n        }) as unknown as Polynom[][]\r\n\r\n        return this\r\n    }\r\n\r\n    public fromString(value: string): this {\r\n        // value = ((a,b),(c,d),(e,f))\r\n        if (value.startsWith('((') && value.endsWith(\"))\")) {\r\n            return this.fromString(value.substring(1, value.length - 1))\r\n        }\r\n\r\n        // value = (a,b),(c,d),(e,f)\r\n        const arr = value.split('),(')\r\n\r\n        this.#values = arr\r\n            .map((row, index) => {\r\n                // (a,b or c,d or e,f)\r\n                if (index === 0) {\r\n                    return row.substring(1).split(',')\r\n                } else if (index === arr.length - 1) {\r\n                    return row.substring(0, row.length - 1).split(',')\r\n                }\r\n\r\n                return row.split(',')\r\n            })\r\n            .map(rowItems =>\r\n                rowItems.map(item => new Polynom(item))\r\n            )\r\n\r\n        return this\r\n    }\r\n\r\n    public fromValues(values: IMatrixValues): this {\r\n        this.#values = []\r\n\r\n        // Check dimensions of each rows.\r\n        const L = values[0].length\r\n        if (values.some(row => row.length !== L)) {\r\n            throw new Error(\"Each line must be the same length\")\r\n        }\r\n\r\n        values.forEach(row => {\r\n            const dup_row: Polynom[] = []\r\n            row.forEach(value => {\r\n                dup_row.push(new Polynom(value))\r\n            })\r\n\r\n            this.#values.push(dup_row)\r\n        })\r\n\r\n        return this\r\n    }\r\n\r\n    public fromVectors(...vectors: Vector[]): this {\r\n\r\n        this.#values = []\r\n\r\n        // Each vectors must be the same dimension\r\n        const L = vectors[0].dimension\r\n        if (vectors.some(v => v.dimension !== L)) {\r\n            throw new Error(\"Each vectors must be the same dimension\")\r\n        }\r\n\r\n        this.fromDimensions(vectors[0].dimension, vectors.length)\r\n\r\n        vectors.forEach((vector, column) => {\r\n            vector.array.forEach((value, row) => {\r\n                this.#values[row][column] = new Polynom(value)\r\n            })\r\n        })\r\n\r\n        return this\r\n    }\r\n\r\n    public inverse(): this {\r\n        if (!this.canBeInverted()) {\r\n            throw new Error('The matrix cannot be inverted.')\r\n        }\r\n\r\n        const cofactors_matrix = new Matrix().fromDimensions(this.dimension.rows, this.dimension.cols)\r\n        cofactors_matrix.forEach((_, row, column) => {\r\n            cofactors_matrix.setValue(row, column, this.cofactor(row, column))\r\n        })\r\n\r\n        cofactors_matrix.transpose()\r\n\r\n        // Copy the value to \"this\"\r\n        const determinant = this.determinant()\r\n        cofactors_matrix.forEach((aij, i, j) => this.setValue(i, j, aij.divide(determinant).reduce()))\r\n\r\n        return this\r\n    }\r\n\r\n    public isEqual(value: Matrix): boolean {\r\n        // Two matrix are equals if they are the same dimension and all aij are equals.\r\n        if (!this.canBeAdded(value)) {\r\n            return false\r\n        }\r\n\r\n        let aij_are_equals = true\r\n        this.forEach((aij, row, column) => {\r\n            aij_are_equals &&= aij.isEqual(value.values[row][column])\r\n        })\r\n\r\n        return aij_are_equals\r\n    }\r\n\r\n    public isOne(): boolean {\r\n        for (let row = 0; row < this.#values.length; row++) {\r\n            for (let col = 0; col < this.#values[row].length; col++) {\r\n                if (col === row && !this.#values[row][col].isOne()) {\r\n                    return false\r\n                }\r\n                if (col !== row && !this.#values[row][col].isZero()) {\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    public isSquare(): boolean {\r\n        return this.dimension.cols === this.dimension.rows\r\n    }\r\n\r\n    public isZero(): boolean {\r\n        return this.flat().every(v => v.isZero())\r\n    }\r\n\r\n    public map<T>(callback: (aij: Polynom, row: number, column: number) => T): T[][] {\r\n        const {rows, cols} = this.dimension\r\n\r\n        const arr = Array.from({length: rows}, () => {\r\n            return Array.from({length: cols}, () => undefined as T)\r\n        })\r\n\r\n        this.#values.forEach((row, i) => {\r\n            row.forEach((aij, j) => {\r\n                arr[i][j] = callback(aij, i, j)\r\n            })\r\n        })\r\n\r\n        return arr\r\n    }\r\n\r\n    public multiply(value: InputValue<Polynom> | Matrix): this {\r\n        if (value instanceof Matrix) {\r\n            if (!this.canBeMultiplied(value)) {\r\n                throw new Error(`Cannot multiply a matrix with incompatibles dimensions`)\r\n            }\r\n\r\n            // Multiply two matrix\r\n            const result = new Matrix(this.dimension.rows, value.dimension.cols)\r\n            result.forEach((_, i, j) => {\r\n                // Multiply this.rows[i] by this.cols[j]\r\n                const row = this.rows[i]\r\n                const col = value.cols[j]\r\n\r\n                const v = new Polynom()\r\n\r\n                row.forEach((left, k) => {\r\n                    v.add(left.clone().multiply(col[k]))\r\n                })\r\n\r\n                result.setValue(i, j, v)\r\n            })\r\n\r\n            this.#values = result.values\r\n            return this\r\n        }\r\n\r\n        // Scalar multiplication\r\n        this.forEach((aij, i, j) => {\r\n            this.setValue(i, j, aij.multiply(value))\r\n        })\r\n        return this\r\n    }\r\n\r\n    public one(): this {\r\n        this.forEach((aij, row, column) => {\r\n            if (row === column) {\r\n                aij.one()\r\n            } else {\r\n                aij.zero()\r\n            }\r\n        })\r\n        return this\r\n    }\r\n\r\n    public opposite(): this {\r\n        this.forEach((aij) => {\r\n            aij.opposite()\r\n        })\r\n        return this\r\n    }\r\n\r\n    get pmatrix(): this {\r\n        this.#matrix_parenthesis = true\r\n        return this\r\n    }\r\n\r\n    public pow(value: number): this {\r\n        return operation_pow(this as Matrix, value) as this\r\n    }\r\n\r\n    public reduce(): Matrix {\r\n        throw new Error('Not yet implemented')\r\n    }\r\n\r\n    get rows(): Polynom[][] {\r\n        return this.#values\r\n    }\r\n\r\n    public setValue(row: number, column: number, value: InputAlgebra<Polynom>): this {\r\n        const {rows, cols} = this.dimension\r\n        if ((row < 0 || row >= rows) ||\r\n            column < 0 || column >= cols) {\r\n            throw new Error(`${row}x${column} is out of range (${rows}x${cols})`)\r\n        }\r\n\r\n        this.#values[row][column] = new Polynom(value)\r\n        return this\r\n    }\r\n\r\n    public subtract(value: Matrix): this {\r\n        if (!this.canBeAdded(value)) {\r\n            throw new Error(\"Cannot subtract a matrix with different dimensions.\")\r\n        }\r\n\r\n        this.forEach((aij, i, j) => {\r\n            aij.subtract(value.values[i][j])\r\n        })\r\n\r\n        return this\r\n    }\r\n\r\n    toFixed(value: number): this {\r\n        this.#digits = value\r\n        return this\r\n    }\r\n\r\n    public transpose(): this {\r\n        const temp = this.clone()\r\n\r\n        temp.forEach((aij, i, j) => {\r\n            this.setValue(j, i, aij.clone())\r\n        })\r\n\r\n        return this\r\n    }\r\n\r\n    get values(): Polynom[][] {\r\n        return this.#values\r\n    }\r\n\r\n    public zero(): this {\r\n        this.forEach(aij => aij.zero())\r\n        return this\r\n    }\r\n}","import {Fraction} from \"../coefficients\"\r\nimport type {Vector} from \"./vector\"\r\nimport type {Point} from \"./point\"\r\n\r\ntype V = Vector | Point\r\nexport function areVectorsEquals(v1: V, v2: V): boolean {\r\n    return v1.dimension === v2.dimension &&\r\n        v1.array.every(\r\n            (value, index) => {\r\n                return v2.array[index].isEqual(value)\r\n            })\r\n}\r\n\r\nexport function areVectorsColinears(v1: V, v2: V): boolean {\r\n    if (v1.dimension !== v2.dimension) { return false }\r\n\r\n    // Constant of proportionality\r\n    const k = v2.array[0].value / v1.array[0].value\r\n    return v1.array.every(\r\n        (value, index) => {\r\n            return v2.array[index].value === value.value * k\r\n        })\r\n}\r\n\r\n\r\nexport function dotProduct(v1: V, v2: V): Fraction {\r\n    if (v1.dimension !== v2.dimension) { return new Fraction().invalid() }\r\n\r\n    // Calculate the dot product\r\n    // Why does the reduce not add the last element?\r\n\r\n    return v1.array.reduce(\r\n        (acc, value, index) => {\r\n            return acc.add(value.clone().multiply(v2.array[index]))\r\n        }, new Fraction(0))\r\n}\r\n\r\nexport function determinantFromVectors(...values: V[]): Fraction {\r\n    // TODO: Make it work for vectors of dimension n\r\n    // Check if the vectors are in the same dimension\r\n    if (values.some((value) => value.dimension !== values[0].dimension)) {\r\n        throw new Error('All vectors must have the same dimension')\r\n    }\r\n\r\n    // Check if the vectors are in dimension 2 or 3 and that the number of values is correct\r\n    if (values[0].dimension !== values.length ) {\r\n        throw new Error(`The determinant of dimension ${values[0].dimension} must have the same number of vectors (${values.length} given)`)\r\n    }\r\n\r\n    // Calculate the determinant 2x2\r\n    if (values[0].dimension === 2) {\r\n        return values[0].array[0].clone().multiply(values[1].array[1])\r\n            .subtract(values[0].array[1].clone().multiply(values[1].array[0]))\r\n    }\r\n\r\n    // Calculate the determinant 3x3\r\n    return values[0].array[0].clone()\r\n        .multiply(\r\n            values[1].array[1].clone().multiply(values[2].array[2])\r\n                .subtract(values[1].array[2].clone().multiply(values[2].array[1]))\r\n        )\r\n        .subtract(values[0].array[1].clone()\r\n            .multiply(\r\n                values[1].array[0].clone().multiply(values[2].array[2])\r\n                    .subtract(values[1].array[2].clone().multiply(values[2].array[0]))\r\n            )\r\n        )\r\n        .add(values[0].array[2].clone()\r\n            .multiply(values[1].array[0].clone().multiply(values[2].array[1])\r\n                .subtract(values[1].array[1].clone().multiply(values[2].array[0]))))\r\n}\r\n","/**\r\n * POint module contains everything necessary to handle 2d Points\r\n * It's a \"wrapper\" of the Vector class.\r\n * @module Point\r\n */\r\n\r\nimport {Fraction} from \"../coefficients\"\r\nimport type {InputValue} from \"../pimath.interface\"\r\n\r\nexport abstract class TupleN {\r\n    #array: Fraction[] = []\r\n\r\n    constructor(...values: InputValue<Fraction>[]) {\r\n        this.#array = values.map(x=>new Fraction(x))\r\n    };\r\n\r\n    public abstract clone(): void\r\n\r\n    public copy(): Fraction[] {\r\n        return this.#array.map(x => x.clone())\r\n    }\r\n\r\n    abstract get tex(): string\r\n\r\n    abstract get display(): string\r\n\r\n    get array(): Fraction[] {\r\n        return this.#array\r\n    }\r\n\r\n    set array(value: Fraction[]) {\r\n        this.#array = value\r\n    }\r\n\r\n    get dimension(): number {\r\n        return this.array.length\r\n    }\r\n\r\n\r\n\r\n    public fromString(value: string): this {\r\n        // Remove the first letter if it's a parenthesis.\r\n        if (value.startsWith('(')) {\r\n            value = value.substring(1)\r\n        }\r\n\r\n        // Remove the last letter if it's a parenthesis.\r\n        if (value.endsWith(')')) {\r\n            value = value.substring(0, value.length - 1)\r\n        }\r\n\r\n        // Split comma, semi colon or single space.\r\n        const components = value.split(/[,;\\s]/g)\r\n            .filter((v) => v.trim() !== '')\r\n\r\n        // there must be at least two components.\r\n        if (components.length < 2) {\r\n            return this\r\n        }\r\n\r\n        // Validate the fraction values.\r\n        this.#array = components.map(x => new Fraction(x))\r\n        return this\r\n    }\r\n\r\n    setDimension(value = 2): this {\r\n        if (value < 2) {\r\n            throw new Error('Dimension must be at least 2')\r\n        }\r\n\r\n        if (value < this.dimension) {\r\n            this.#array = this.#array.slice(0, value)\r\n        } else if (value > this.dimension) {\r\n            for (let i = this.dimension; i < value; i++) {\r\n                this.#array.push(new Fraction(0))\r\n            }\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    get x(): Fraction {\r\n        return this.#array[0]\r\n    }\r\n\r\n    set x(value: Fraction | number | string) {\r\n        this.#array[0] = new Fraction(value)\r\n    }\r\n\r\n    get y(): Fraction {\r\n        return this.#array[1]\r\n    }\r\n\r\n    set y(value: Fraction | number | string) {\r\n        this.#array[1] = new Fraction(value)\r\n    }\r\n\r\n    get z(): Fraction {\r\n        if (this.dimension < 3) {\r\n            throw new Error('Vector is not 3D')\r\n        }\r\n        return this.#array[2]\r\n    }\r\n\r\n    set z(value: Fraction | number | string) {\r\n        if (this.dimension < 3) {\r\n            throw new Error('Vector is not 3D')\r\n        }\r\n        this.#array[2] = new Fraction(value)\r\n    }\r\n\r\n    zero = (): this => {\r\n        this.#array.forEach(x => x.zero())\r\n        return this\r\n    }\r\n\r\n}\r\n","import {Fraction} from \"./fraction\"\r\nimport type {IExpression, InputValue, IPiMathObject} from \"../pimath.interface\"\r\nimport {stripParenthesis} from \"../helpers\"\r\nimport {Numeric} from \"../numeric\"\r\n\r\nexport class Root implements IPiMathObject<Root>, IExpression<Root> {\r\n    #factor: Fraction\r\n    #index: number\r\n    #radical: Fraction\r\n    #withSign = false\r\n\r\n    constructor(value?: InputValue<Root | Fraction>) {\r\n        this.#index = 2\r\n        this.#factor = new Fraction().zero()\r\n        this.#radical = new Fraction().zero()\r\n\r\n        if (value) {\r\n            this.parse(value)\r\n        }\r\n\r\n\r\n        return this\r\n    }\r\n\r\n    parse(value: InputValue<Root | Fraction>): this {\r\n        // should be able to parse \"display\" roots.\r\n        // sqrt12 or sqrt(12) or sqrt(12/5) => [2, 12 or 12/5, 1]\r\n        // root(n)10 or root(n)(10) or root(n)(10/3) => [n, 10 or 10/3, 1]\r\n        // 7sqrt12 or 7sqrt(12) or 7sqrt(12/5) => [2, 12 or 12/5, 7]\r\n        // 7root(n)10 or 7root(n)(10) or 7root(n)(10/3) => [n, 10 or 10/3, 7]\r\n\r\n        if (value instanceof Root) {\r\n            this.index = value.index\r\n            this.radical = value.radical.clone()\r\n            this.factor = value.factor.clone()\r\n\r\n            return this\r\n        }\r\n\r\n        if (value instanceof Fraction) {\r\n            this.index = 2\r\n            this.factor = value.clone()\r\n            this.radical.one()\r\n\r\n            return this\r\n        }\r\n\r\n        if (typeof value === \"string\") {\r\n            if (value.includes('sqrt')) {\r\n                return this.#parse_sqrt(value)\r\n            }\r\n\r\n            if (value.includes('root')) {\r\n                return this.#parse_root(value)\r\n            }\r\n        }\r\n\r\n        this.index = 2\r\n        this.factor = new Fraction(value)\r\n        this.radical.one()\r\n\r\n        return this\r\n    }\r\n\r\n    clone(): Root {\r\n        return new Root().from(this.index, this.radical, this.factor)\r\n    }\r\n\r\n    get tex(): string {\r\n        // b \\sqrt{}\r\n        // b\r\n        // \\sqrt{}\r\n        // -\\sqrt{}\r\n\r\n        // Force the plus sign.\r\n        const plus = this.#withSign && this.factor.isPositive() ? '+' : ''\r\n\r\n        // There is no radical - output the factor\r\n        if (this.#radical.isZero()) return `${plus}${this.#factor.tex}`\r\n\r\n        // The radical has an index of 1 - no radical.\r\n        if(this.index===1) return `${plus}${this.factor.clone().multiply(this.radical).tex}`\r\n\r\n        // Make the root part\r\n        const rad = this.index === 2\r\n                ? `\\\\sqrt{ ${this.#radical.tex} }`\r\n                : `\\\\sqrt[ ${this.index} ]{ ${this.#radical.tex} }`\r\n\r\n        if(this.#factor.isUnit()){\r\n            return this.#withSign\r\n                ? `${this.#factor.isOne()?plus:'-'} ${rad}`\r\n                : `${this.#factor.isOne()?'':'-'}${rad}`\r\n        }\r\n\r\n        return `${plus}${this.#factor.tex} ${rad}`\r\n    }\r\n\r\n    get display(): string {\r\n        const plus = this.#withSign && this.factor.isPositive() ? '+' : ''\r\n\r\n        // There is no radical - output the factor\r\n        if (this.#radical.isZero()) return `${plus}${this.#factor.display}`\r\n\r\n        // The radical has an index of 1 - no radical.\r\n        if(this.index===1) return `${plus}${this.factor.clone().multiply(this.radical).display}`\r\n\r\n        // Make the root part\r\n        const rad = this.index === 2\r\n            ? `sqrt(${this.#radical.tex})`\r\n            : `root(${this.index})(${this.#radical.display})`\r\n\r\n        if(this.#factor.isUnit()) return `${this.#factor.isOne()?plus:'-'}${rad}`\r\n\r\n        return `${plus}${this.#factor.display}${rad}`\r\n    }\r\n\r\n    add(value: InputValue<Root>): this {\r\n        const rt = new Root(value)\r\n\r\n        if (\r\n            this.index !== rt.index &&\r\n            !this.radical.isEqual(rt.radical)\r\n        ) {\r\n            throw new Error(\"Add can only be done with two same index and radical\")\r\n        }\r\n\r\n        this.factor.add(rt.factor)\r\n\r\n        return this\r\n    }\r\n\r\n    divide(value: InputValue<Root>): this {\r\n        return this.multiply(new Root(value).inverse())\r\n    }\r\n\r\n    get factor(): Fraction {\r\n        return this.#factor\r\n    }\r\n\r\n    set factor(value: Fraction) {\r\n        this.#factor = value\r\n    }\r\n\r\n    from(index: number, radical: InputValue<Fraction>, factor?: InputValue<Fraction>): this {\r\n        // set the index\r\n        this.index = index\r\n\r\n        // set the racial\r\n        this.radical = new Fraction(radical)\r\n\r\n        // set the factor if any\r\n        this.factor = factor ? new Fraction(factor) : new Fraction().one()\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * convert to root(index)(radical), without factor\r\n     */\r\n    group(): this {\r\n        this.radical.multiply(this.factor.pow(this.index))\r\n        this.factor.one()\r\n\r\n        return this\r\n    }\r\n\r\n    get index(): number {\r\n        return this.#index\r\n    }\r\n\r\n    set index(value: number) {\r\n        if (!Number.isSafeInteger(value) || value <= 0) {\r\n            throw new Error(\"Index must be a strictly positive integer.\")\r\n        }\r\n        this.#index = value\r\n    }\r\n\r\n    get indexAsPow(): Fraction {\r\n        return new Fraction(this.index).inverse()\r\n    }\r\n\r\n    inverse(): this {\r\n        this.factor.inverse()\r\n        this.radical.inverse()\r\n        return this\r\n    }\r\n\r\n    isEqual(root: Root): boolean {\r\n        return this.value === root.value\r\n    }\r\n\r\n    isOne(): boolean {\r\n        return this.factor.isOne() && this.radical.isOne()\r\n    }\r\n\r\n    isZero(): boolean {\r\n        return this.factor.isZero() || this.radical.isZero()\r\n    }\r\n\r\n    multiply(value: InputValue<Root>): this {\r\n        const rt = new Root(value)\r\n\r\n        this.factor.multiply(rt.factor)\r\n\r\n        if (this.index === rt.index) {\r\n            this.radical.multiply(rt.radical)\r\n            return this\r\n        }\r\n\r\n        if (this.radical.isEqual(rt.radical)) {\r\n            const F = this.indexAsPow.add(rt.indexAsPow).reduce()\r\n            this.index = F.denominator\r\n            this.radical = this.radical.pow(F.numerator)\r\n            return this\r\n        }\r\n\r\n        throw new Error('Multiply can only be done if radical or index as equals.')\r\n    }\r\n\r\n    one(): this {\r\n        this.radical.one()\r\n        this.factor.one()\r\n\r\n        return this\r\n    }\r\n\r\n    opposite(): this {\r\n        this.factor.opposite()\r\n        return this\r\n    }\r\n\r\n    pow(value: number): this {\r\n        this.factor.pow(value)\r\n\r\n        const g = Numeric.gcd(this.index, value)\r\n        this.index = this.index / g\r\n        this.radical.pow(value / g)\r\n\r\n        return this\r\n    }\r\n\r\n    get radical(): Fraction {\r\n        return this.#radical\r\n    }\r\n\r\n    set radical(value: Fraction) {\r\n        this.#radical = value\r\n    }\r\n\r\n    reduce(): this {\r\n        // 1. extract roots\r\n        // 2. avoid roots at denominator.\r\n\r\n        // Remove the roots at denominator\r\n        if (this.radical.isRational()) {\r\n            const den = this.radical.denominator\r\n            this.radical.denominator = 1\r\n            this.radical.numerator *= den\r\n\r\n            this.factor.divide(den)\r\n        }\r\n\r\n        // Extract the greatest root from.\r\n        const greatest = Numeric.greatestPower(this.radical.value, this.index)\r\n\r\n        this.factor.multiply(Math.pow(greatest, 1 / this.index))\r\n        this.radical.divide(greatest)\r\n\r\n        return this\r\n    }\r\n\r\n    root(value: number): this {\r\n        this.group()\r\n        this.index = this.index * value\r\n        return this\r\n    }\r\n\r\n    sqrt(): this {\r\n        return this.root(2)\r\n    }\r\n\r\n    subtract(value: InputValue<Root>): this {\r\n        const rt = new Root(value)\r\n\r\n        return this.add(rt.opposite())\r\n    }\r\n\r\n    public get value(): number {\r\n        return Numeric.numberCorrection(this.factor.value * Math.pow(this.radical.value, 1 / this.index))\r\n    }\r\n\r\n    withSign(value = true): this {\r\n        this.#withSign = value\r\n        return this\r\n    }\r\n\r\n    zero(): this {\r\n        this.radical.zero()\r\n        this.factor.zero()\r\n        return this\r\n    }\r\n\r\n    #parse_root(value: string): this {\r\n        // value = a root(n)b or a root(n)(b)\r\n        const [factor, index_radical] = value.split('root')\r\n        const [index, radical] = index_radical.split(')')\r\n\r\n        this.index = +stripParenthesis(index)\r\n\r\n        this.radical = new Fraction(stripParenthesis(radical))\r\n\r\n        this.factor = factor === '' ? new Fraction().one() : new Fraction(factor)\r\n\r\n        return this\r\n    }\r\n\r\n    #parse_sqrt(value: string): this {\r\n        // value = asqrtb\r\n        const [factor, radical] = value.split('sqrt')\r\n\r\n        this.index = 2\r\n\r\n        this.radical = new Fraction(stripParenthesis(radical))\r\n\r\n        this.factor = factor === '' ? new Fraction().one() : new Fraction(factor)\r\n\r\n        return this\r\n    }\r\n}","/**\r\n * POint module contains everything necessary to handle 2d Points\r\n * It's a \"wrapper\" of the Vector class.\r\n * @module Point\r\n */\r\n\r\nimport {Fraction} from \"../coefficients\"\r\nimport type {InputValue} from \"../pimath.interface\"\r\nimport {Root} from \"../coefficients/root\"\r\nimport {TupleN} from \"./TupleN\"\r\nimport type {Vector} from \"./vector\"\r\n\r\nexport class Point extends TupleN {\r\n    constructor(...values: (Point|Vector)[] | InputValue<Fraction>[]) {\r\n        super()\r\n\r\n        // Initialize the vector\r\n        if (values.length > 0) {\r\n            this.parse(...values)\r\n        }\r\n    };\r\n\r\n    public parse(...values: (Point|Vector)[] | InputValue<Fraction>[]): this {\r\n        if (values.length === 1) {\r\n            if (values[0] instanceof TupleN) {\r\n                this.array = values[0].copy()\r\n                return this\r\n            }\r\n\r\n            if (typeof values[0] === 'string') {\r\n                this.fromString(values[0])\r\n                return this\r\n            }\r\n        }\r\n\r\n\r\n        if (values.length > 1) {\r\n            if (values.some(x => x instanceof Point)) {\r\n                throw new Error('Creating a point with  multiple argument requires an input fraction')\r\n            }\r\n\r\n            const nbs: Fraction[] = values.map(x => new Fraction(x as InputValue<Fraction>))\r\n\r\n            if (nbs.some(x => x.isNaN())) {\r\n                throw new Error('The given values are not a valid point string (a,b): ')\r\n            }\r\n\r\n            this.array = nbs\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    public clone(): Point {\r\n        return new Point(...this.copy())\r\n    }\r\n\r\n    get tex(): string {\r\n        return `\\\\left(${this.array.map(x => x.tex).join(';')}\\\\right)`\r\n    }\r\n\r\n    get display(): string {\r\n        return `(${this.array.map(x => x.display).join(';')})`\r\n    }\r\n\r\n    distanceTo(B: Point): Root {\r\n        if (this.dimension !== B.dimension) {\r\n            throw new Error('The two points must have the same dimensions.')\r\n        }\r\n\r\n        const AB = this.array\r\n            .map((x, index) => B.array[index].clone().subtract(x))\r\n\r\n        const distance2 = AB\r\n            .reduce(\r\n                (acc, x) =>\r\n                    acc.add(x.clone().pow(2)), new Fraction(0)\r\n            )\r\n\r\n        return new Root().from(2, distance2).reduce()\r\n    }\r\n\r\n    middleOf(V1: Point, V2: Point): this {\r\n        if (V1.dimension !== V2.dimension) {\r\n            throw new Error('Vectors must be the same dimension')\r\n        }\r\n\r\n        this.array = []\r\n        V1.array.forEach((x, index) => {\r\n            this.array.push(x.clone().add(V2.array[index]).divide(2))\r\n        })\r\n\r\n        return this\r\n    }\r\n\r\n\r\n}\r\n","/**\r\n * Vector2D module contains everything necessary to handle 2d vectors.\r\n * @module Vector\r\n */\r\nimport type {InputValue, IPiMathObject} from \"../pimath.interface\"\r\nimport {Fraction} from \"../coefficients\"\r\nimport {Numeric} from \"../numeric\"\r\nimport {areVectorsColinears, areVectorsEquals, dotProduct} from \"./geomMath\"\r\nimport {TupleN} from \"./TupleN\"\r\nimport {type Point} from \"./point\"\r\n\r\nexport class Vector extends TupleN implements IPiMathObject<Vector> {\r\n    constructor(...values: (Vector | Point)[] | InputValue<Fraction>[]) {\r\n        super()\r\n\r\n        if (values.length > 0) {\r\n            this.parse(...values)\r\n        }\r\n\r\n        return this\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n\r\n    public parse(...values: (Vector | Point)[] | InputValue<Fraction>[]): this {\r\n        if (values.length === 0) {\r\n            throw new Error(`Invalid value`)\r\n        }\r\n\r\n        if (values.length === 1) {\r\n            if (values[0] instanceof TupleN) {\r\n                this.array = values[0].copy()\r\n                return this\r\n            }\r\n\r\n            if (typeof values[0] === 'string') {\r\n                return this.fromString(values[0])\r\n            }\r\n\r\n            throw new Error(`Invalid value`)\r\n        }\r\n\r\n        // Two values are given\r\n        if (values.length === 2) {\r\n            const [A, B] = values\r\n\r\n            // The two values are vectors\r\n            if (A instanceof TupleN && B instanceof TupleN) {\r\n                if (A.dimension !== B.dimension) {\r\n                    throw new Error('Vectors must have the same dimension')\r\n                }\r\n\r\n                this.array = B.array.map((x, index) => x.clone().subtract(A.array[index]))\r\n                return this\r\n            }\r\n        }\r\n\r\n        // Two ore more values as number, string, fraction...\r\n        this.array = values.map(x => new Fraction(x as InputValue<Fraction>))\r\n        return this\r\n    }\r\n\r\n    public clone(): Vector {\r\n        return new Vector(...this.copy())\r\n    }\r\n\r\n    get tex(): string {\r\n        return `\\\\begin{pmatrix} ${this.array.map(x => x.tex).join(' \\\\\\\\ ')} \\\\end{pmatrix}`\r\n    }\r\n\r\n    get display(): string {\r\n        return `((${this.array.map(x => x.display).join(',')}))`\r\n    }\r\n\r\n    static asDisplay(...values: string[]): string {\r\n        return `((${values.join(',')}))`\r\n    }\r\n\r\n    static asTex(...values: string[]): string {\r\n        return `\\\\begin{pmatrix} ${values.join(' \\\\\\\\ ')} \\\\end{pmatrix}`\r\n    }\r\n\r\n    add = (V: Vector): this => {\r\n        this.array.forEach((x, index) => x.add(V.array[index]))\r\n        return this\r\n    }\r\n\r\n    angle = (V: Vector, sharp?: boolean, radian?: boolean): number => {\r\n\r\n        let scalar = this.dot(V).value\r\n        if (sharp) {\r\n            scalar = Math.abs(scalar)\r\n        }\r\n\r\n        const toDegree = radian ? 1 : 180 / Math.PI\r\n\r\n        return toDegree * Math.acos(scalar / (this.norm * V.norm))\r\n    }\r\n\r\n    cross(value: Vector): Vector {\r\n        if (this.dimension !== 3 || value.dimension !== 3) {\r\n            throw new Error('Cross product can only be determined in 3D')\r\n        }\r\n\r\n        return new Vector(\r\n            this.y.clone().multiply(value.z).subtract(this.z.clone().multiply(value.y)),\r\n            this.z.clone().multiply(value.x).subtract(this.x.clone().multiply(value.z)),\r\n            this.x.clone().multiply(value.y).subtract(this.y.clone().multiply(value.x))\r\n        )\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n\r\n    divideByScalar = (k: InputValue<Fraction>): this => {\r\n        return this.multiplyByScalar(new Fraction(k).inverse())\r\n    }\r\n\r\n    dot = (V: Vector |Point): Fraction => {\r\n        return dotProduct(this, V)\r\n    }\r\n\r\n    override fromString(value: string): this {\r\n        if (value.startsWith('((') && value.endsWith('))')) {\r\n            return super.fromString(value.slice(1, -1))\r\n        }\r\n\r\n        return super.fromString(value)\r\n    }\r\n\r\n    isColinearTo = (v: Vector): boolean => {\r\n        return areVectorsColinears(this, v)\r\n    }\r\n\r\n    isEqual = (v: Vector): boolean => {\r\n        return areVectorsEquals(this, v)\r\n    }\r\n\r\n    isNormalTo = (v: Vector): boolean => {\r\n        return this.dot(v).isZero()\r\n    }\r\n\r\n    // ------------------------------------------\r\n    get isNull(): boolean {\r\n        return this.array.every(x => x.isZero())\r\n    }\r\n\r\n    isOne(): boolean {\r\n        return this.array.every((x, index) => index === 0 ? x.isOne() : x.isZero())\r\n    }\r\n\r\n    isZero(): boolean {\r\n        return this.array.every(x => x.isZero())\r\n    }\r\n\r\n    multiplyByScalar = (k: InputValue<Fraction>): this => {\r\n        const scalar = new Fraction(k)\r\n        this.array.forEach(x => x.multiply(scalar))\r\n        return this\r\n    }\r\n\r\n    get norm(): number {\r\n        return Math.sqrt(this.normSquare.value)\r\n    }\r\n\r\n    get normSquare(): Fraction {\r\n        // Get the norm square of the vector\r\n        return this.array.reduce((acc, x) => acc.add(x.clone().pow(2)), new Fraction(0))\r\n    }\r\n\r\n    normal = (): this => {\r\n        if (this.dimension >= 3) {\r\n            throw new Error('Normal vector can only be determined in 2D')\r\n        }\r\n\r\n        const x = this.x.clone().opposite()\r\n        const y = this.y.clone()\r\n\r\n        this.array[0] = y\r\n        this.array[1] = x\r\n        return this\r\n    }\r\n\r\n    one = (): this => {\r\n        this.zero()\r\n        this.x.one()\r\n        return this\r\n    }\r\n\r\n    opposite = (): this => {\r\n        this.array.forEach(x => x.opposite())\r\n        return this\r\n    }\r\n\r\n    simplify = (): this => {\r\n        // Multiply by the lcm of denominators.\r\n        return this\r\n            .multiplyByScalar(\r\n                Numeric.lcm(...this.array.map(x => x.denominator))\r\n            )\r\n            .divideByScalar(\r\n                Numeric.gcd(...this.array.map(x => x.numerator))\r\n            ).multiplyByScalar(\r\n                this.x.isNegative() ? -1 : 1\r\n            )\r\n    }\r\n\r\n    subtract = (V: Vector): this => {\r\n        return this.add(V.clone().opposite())\r\n    }\r\n\r\n    translate(...values: Fraction[]): this {\r\n        this.array.forEach((x, index) => x.add(values[index]))\r\n        return this\r\n    }\r\n\r\n    unit = (): this => {\r\n        const norm = this.norm\r\n        if (norm === 0) {\r\n            return this\r\n        }\r\n\r\n        return this.divideByScalar(norm)\r\n    }\r\n\r\n}\r\n","import type {Fraction} from \"./coefficients\"\r\nimport type {Equation, Factor, Monom} from \"./algebra\"\r\nimport type {Line, Point, Vector} from \"./geometry\"\r\n\r\nexport type InputValue<T> = T | string | number | Fraction // | Root;\r\nexport type InputAlgebra<T> = InputValue<T> | Monom\r\nexport type literalType<T> = Record<string, T>;\r\n\r\nexport type compareSign =\r\n    '>' | \">=\" | \"=>\" | \"geq\" |\r\n    '<' | \"<=\" | \"=<\" | \"leq\" |\r\n    '=' | \"<>\" | \"neq\" | \"same\";\r\n\r\nexport type EQUATION_SIGN = \"=\" | \"<=\" | \">=\" | \"<\" | \">\"\r\n\r\nexport enum PARTICULAR_SOLUTION {\r\n    real = \"\\\\mathbb{R}\",\r\n    varnothing = \"\\\\varnothing\"\r\n}\r\n\r\nexport interface IPiMathObject<T> {\r\n    readonly display: string\r\n    readonly tex: string\r\n\r\n    parse(...value: unknown[]): T;\r\n\r\n    clone(): T;\r\n}\r\n\r\nexport interface IExpressionBase<T> {\r\n    add(value: InputValue<T>): T;\r\n\r\n    isEqual(value: InputValue<T>): boolean;\r\n\r\n    isOne(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    one(): T;\r\n\r\n    opposite(): T;\r\n\r\n    reduce(): T;\r\n\r\n    subtract(value: InputValue<T>): T;\r\n\r\n    zero(): T;\r\n}\r\n\r\nexport interface IExpressionMultiply<T> extends IExpressionBase<T> {\r\n    multiply(value: InputValue<T>): T;\r\n\r\n    pow(value: number): T;\r\n}\r\n\r\nexport interface IExpression<T> extends IExpressionMultiply<T> {\r\n    divide(value: InputValue<T>): T | null;\r\n\r\n    inverse(): T | undefined;\r\n\r\n    root(value: number): T | undefined;\r\n\r\n    sqrt(): T | undefined;\r\n}\r\n\r\nexport interface IEquation<T> {\r\n\r\n    reduce(): T;\r\n\r\n    solve(): ISolution[]\r\n}\r\n\r\nexport interface IAlgebra<T> {\r\n    readonly variables: string[];\r\n\r\n    degree(letter?: string): Fraction;\r\n\r\n    evaluate(values: literalType<Fraction | number> | InputValue<Fraction>, asNumeric?: boolean): Fraction | number | boolean;\r\n\r\n    hasVariable(letter: string): boolean;\r\n}\r\n\r\nexport interface IAnalyse<T> {\r\n    derivative(): T | T[];\r\n\r\n    integrate(a: InputValue<Fraction>, b: InputValue<T>, letter?: string): Fraction;\r\n\r\n    primitive(): T;\r\n}\r\n\r\nexport interface ISolution {\r\n    display: string,\r\n    exact: Fraction | boolean\r\n    tex: string,\r\n    value: number,\r\n    variable: string,\r\n}\r\n\r\nexport type TABLE_OF_SIGNS_VALUES = '-' | '+' | 'h' | 'z' | 't' | 'd' | 'u' | 'n' | ''\r\n\r\nexport interface TABLE_OF_SIGNS {\r\n    roots: ISolution[],\r\n    signs: TABLE_OF_SIGNS_VALUES[]\r\n}\r\n\r\nexport interface FACTOR_TABLE_OF_SIGNS extends TABLE_OF_SIGNS {\r\n    factor: Factor\r\n}\r\n\r\nexport interface POLYFACTOR_TABLE_OF_SIGNS extends TABLE_OF_SIGNS {\r\n    factors: FACTOR_TABLE_OF_SIGNS[]\r\n}\r\n\r\nexport enum LinePropriety {\r\n    None = 'none',\r\n    Parallel = 'parallel',\r\n    Perpendicular = 'perpendicular',\r\n    Tangent = 'tangent'\r\n}\r\n\r\nexport enum Line3Propriety {\r\n    None = 'none',\r\n    Parallel = 'parallel',\r\n    Perpendicular = 'perpendicular',\r\n    Tangent = 'tangent'\r\n}\r\n\r\nexport interface Plane3Config {\r\n    coefficients?: number[]\r\n    directions?: Vector[],\r\n    equation?: Equation,\r\n    normal?: Vector,\r\n    point?: Point,\r\n    points?: Point[],\r\n}\r\n\r\n\r\nexport interface remarquableLines {\r\n    'bisectors': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point | null\r\n    },\r\n    externalBisectors: {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point | null\r\n    }\r\n    'heights': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point | null\r\n    },\r\n    'medians': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point | null\r\n    },\r\n    'mediators': {\r\n        'AB': Line,\r\n        'AC': Line,\r\n        'BC': Line,\r\n        'intersection': Point | null\r\n    },\r\n}\r\n","/**\r\n * Random helpers\r\n */\r\nimport { Numeric } from \"../numeric\"\r\n\r\n\r\n/**\r\n * Random boolean with a percent ratio\r\n * @param percent\r\n */\r\nexport function randomBool(percent = 0.5): boolean {\r\n    return Math.random() < percent\r\n}\r\n\r\n/**\r\n * Random integer between two values.\r\n * @param a (number) : From this value to the second value. If the second is ommited, this value is the max value.\r\n * @param b (number) : To this value. If this is ommited.\r\n */\r\nexport function randomInt(a: number, b?: number, exclude?: number[]): number {\r\n    if (b === undefined) {\r\n        if (a >= 0) {\r\n            return randomInt(0, a)\r\n        } else {\r\n            return randomInt(a, 0)\r\n        }\r\n    }\r\n\r\n    // Same start and end values\r\n    if (a === b) {\r\n        return a\r\n    }\r\n\r\n    // No exclusion\r\n    if (exclude === undefined) {\r\n        return Math.floor(Math.random() * (b - a + 1) + a)\r\n    }\r\n\r\n    // With exclusion\r\n    if (Math.abs(b - a) <= exclude.length) {\r\n        throw new Error('The number of excluded values is too high.')\r\n    }\r\n\r\n    let r = randomInt(a, b)\r\n    while (exclude.includes(r)) {\r\n        r = randomInt(a, b)\r\n    }\r\n    return r\r\n}\r\n\r\n/**\r\n * Random integer between -max and max value.\r\n * @param max (number) : determine the limits.\r\n * @param zero (bool) : determine if zero is allowed or not.\r\n */\r\nexport function randomIntSym(max: number, zero?: boolean): number {\r\n    if (zero === false) {\r\n        return randomBool() ? randomInt(1, max) : -randomInt(1, max)\r\n    } else {\r\n        return randomInt(-max, max)\r\n    }\r\n}\r\n\r\nexport function randomPrime(max?: number): number {\r\n    let primes = Numeric.primes()\r\n    if (max !== undefined) {\r\n        primes = primes.filter(x => x < max)\r\n    }\r\n    return randomItem(primes)\r\n}\r\n\r\nexport function randomArray<T>(arr: T[], number?: number): T[] {\r\n    if (number === undefined) {\r\n        number = 1\r\n    }\r\n\r\n    // Return a clone array\r\n    if (arr.length <= 0) {\r\n        return Object.values(arr)\r\n    }\r\n\r\n    // Randomize the array and return the n first elements.\r\n    return shuffleArray(arr).slice(0, number)\r\n}\r\n\r\nexport function randomItem<T>(arr: T[]): T {\r\n    if (arr.length === 0) { return null as T }\r\n    return arr[randomInt(0, arr.length - 1)]\r\n}\r\n\r\nexport function shuffleArray<T>(arr: T[]): T[] {\r\n    // The Fisher-Yates algorithm\r\n    const shuffleArray = Object.values(arr)\r\n    for (let i = shuffleArray.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1))\r\n        const temp = shuffleArray[i]\r\n        shuffleArray[i] = shuffleArray[j]\r\n        shuffleArray[j] = temp\r\n    }\r\n\r\n    return shuffleArray\r\n}\r\n","/**\r\n * This class works for 2d line in a plane.\r\n */\r\n\r\nimport {Numeric} from \"../numeric\"\r\nimport {Fraction} from \"../coefficients\"\r\nimport {Equation, Monom, Polynom} from \"../algebra\"\r\nimport {Vector} from \"./vector\"\r\nimport {type InputValue, type IPiMathObject, LinePropriety} from \"../pimath.interface\"\r\nimport {randomIntSym} from \"../randomization/rndHelpers\"\r\nimport {Point} from \"./point\"\r\nimport {Root} from \"../coefficients/root\"\r\n\r\nenum LINE_DISPLAY {\r\n    CARTESIAN,\r\n    CANONICAL,\r\n    MXH,\r\n    PARAMETRIC,\r\n    SYSTEM\r\n}\r\n\r\nexport class Line implements IPiMathObject<Line> {\r\n    static PARALLEL = LinePropriety.Parallel\r\n    static PERPENDICULAR = LinePropriety.Perpendicular\r\n    #OA: Vector\r\n\r\n    // A line is defined as the canonical form\r\n    // ax + by + c = 0\r\n    #a: Fraction\r\n    #b: Fraction\r\n    #c: Fraction\r\n\r\n    // output mode.\r\n    #outputMode: LINE_DISPLAY = LINE_DISPLAY.CANONICAL\r\n\r\n    /**\r\n     * Value can be a mix of:\r\n     *\r\n     * @param values\r\n     */\r\n    constructor(...values: unknown[]) {\r\n        this.#a = new Fraction().zero()\r\n        this.#b = new Fraction().zero()\r\n        this.#c = new Fraction().zero()\r\n        this.#OA = new Vector()\r\n\r\n        if (values.length > 0) {\r\n            this.parse(...values)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse data to a line\r\n     * @param {any} values\r\n     * @returns {Line}\r\n     */\r\n    parse = (...values: unknown[]): this => {\r\n        // Nothing is given...\r\n        if (values.length === 0) {\r\n            return this\r\n        }\r\n\r\n        // One value only: already a line (clone it), an Equation, a string (as Equation)\r\n        if (values.length === 1) {\r\n            if (values[0] instanceof Line) {\r\n                // Already a Line\r\n                return this.fromCoefficient(values[0].a, values[0].b, values[0].c)\r\n            }\r\n\r\n            if (values[0] instanceof Equation) {\r\n                // It's an Equation\r\n                return this.fromEquation(values[0])\r\n            }\r\n\r\n            if (typeof values[0] === \"string\") {\r\n                // It's a string - create an Equation from it.\r\n                try {\r\n                    const E = new Equation(values[0])\r\n                    return this.parse(E)\r\n                } catch (e) {\r\n                    console.warn(e)\r\n                    return this\r\n                }\r\n            }\r\n        }\r\n\r\n        if (values.length === 2) {\r\n            if (values[0] instanceof Point && values[1] instanceof Point) {\r\n                return this.fromPoints(values[0], values[1])\r\n            }\r\n\r\n            if (values[0] instanceof Point && values[1] instanceof Vector) {\r\n                return this.fromPointAndDirection(values[0], values[1])\r\n            }\r\n        }\r\n\r\n        if (values.length === 3 && values.every(x => Fraction.isFraction(x as InputValue<Fraction>))) {\r\n            return this.fromCoefficient(\r\n                values[0] as InputValue<Fraction>,\r\n                values[1] as InputValue<Fraction>,\r\n                values[2] as InputValue<Fraction>\r\n            )\r\n        }\r\n\r\n        console.log('Something wrong happened while creating the line')\r\n        console.log(values)\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n\r\n    clone = (): this => {\r\n        this.#a = this.#a.clone()\r\n        this.#b = this.#b.clone()\r\n        this.#c = this.#c.clone()\r\n\r\n        this.#OA = this.#OA.clone()\r\n        return this\r\n    }\r\n\r\n    get tex(): string {\r\n        // canonical    =>  ax + by + c = 0\r\n        // mxh          =>  y = -a/b x - c/b\r\n        // parametric   =>  (xy) = OA + k*d\r\n        // equation     => ax + by = -c\r\n        // system       => \\begin{}...\r\n\r\n        const output = this.#outputMode\r\n        this.#outputMode = LINE_DISPLAY.CANONICAL\r\n\r\n        switch (output) {\r\n            case LINE_DISPLAY.CARTESIAN:\r\n                return this.getEquation().reorder().tex\r\n            case LINE_DISPLAY.MXH:\r\n                return this.slope.isInfinity() ?\r\n                    'x=' + this.OA.x.tex :\r\n                    'y=' + new Polynom().parse('x', this.slope, this.height).tex\r\n            case LINE_DISPLAY.PARAMETRIC:\r\n            case LINE_DISPLAY.SYSTEM: {\r\n                const d = this.d.clone().simplify()\r\n\r\n                if (output === LINE_DISPLAY.PARAMETRIC) {\r\n                    return `${Vector.asTex('x', 'y')} = ${Vector.asTex(this.#OA.x.tex, this.#OA.y.tex)} + k\\\\cdot ${Vector.asTex(d.x.tex, d.y.tex)}`\r\n                } else {\r\n                    return `\\\\left\\\\{\\\\begin{aligned}\r\n            x &= ${(new Polynom(this.#OA.x)\r\n                        .add(new Monom(this.d.x).multiply(new Monom('k'))))\r\n                        .reorder('k', true)\r\n                        .tex}\\\\\\\\ \r\n            y &= ${(new Polynom(this.#OA.y)\r\n                        .add(new Monom(this.d.y).multiply(new Monom('k'))))\r\n                        .reorder('k', true)\r\n                        .tex}\r\n            \\\\end{aligned}\\\\right.`\r\n                }\r\n            }\r\n            default: {\r\n                const canonical = this.getEquation()\r\n                if (this.#a.isNegative()) {\r\n                    canonical.multiply(-1)\r\n                }\r\n                return canonical.tex\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    get display(): string {\r\n        // canonical    =>  ax + by + c = 0\r\n        // mxh          =>  y = -a/b x - c/b\r\n        // parametric   =>  (xy) = OA + k*d // not relevant in display mode.\r\n        const output = this.#outputMode\r\n        this.#outputMode = LINE_DISPLAY.CANONICAL\r\n\r\n        switch (output) {\r\n            case LINE_DISPLAY.CARTESIAN:\r\n                return this.getEquation().reorder().display\r\n            case LINE_DISPLAY.MXH:\r\n                return this.slope.isInfinity() ?\r\n                    'x=' + this.OA.x.display :\r\n                    'y=' + new Polynom().parse('x', this.slope, this.height).display\r\n            case LINE_DISPLAY.PARAMETRIC: {\r\n                const d = this.d.clone().simplify()\r\n                return `((x,y))=((${this.#OA.x.display},${this.#OA.y.display}))+k((${d.x.display},${d.y.display}))`\r\n            }\r\n            case LINE_DISPLAY.SYSTEM: {\r\n                // TODO: line as system in ascii math\r\n                return ''\r\n            }\r\n            default: {\r\n                const canonical = this.getEquation()\r\n                // Make sur the first item is positive.\r\n                if (this.#a.isNegative()) {\r\n                    canonical.multiply(-1)\r\n                }\r\n                return canonical.display\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    get OA(): Vector {\r\n        return this.#OA\r\n    }\r\n\r\n    set OA(value: Vector | Point) {\r\n        this.fromPointAndNormal(value, this.n)\r\n    }\r\n\r\n    get a(): Fraction {\r\n        return this.#a\r\n    }\r\n\r\n    set a(value: Fraction) {\r\n        this.#a = value\r\n    }\r\n\r\n    asCanonical(): this {\r\n        this.#outputMode = LINE_DISPLAY.CANONICAL\r\n        return this\r\n    }\r\n\r\n    asCartesian(): this {\r\n        this.#outputMode = LINE_DISPLAY.CARTESIAN\r\n        return this\r\n    }\r\n\r\n    asMxh(): this {\r\n        this.#outputMode = LINE_DISPLAY.MXH\r\n        return this\r\n    }\r\n\r\n    asParametric(): this {\r\n        this.#outputMode = LINE_DISPLAY.PARAMETRIC\r\n        return this\r\n    }\r\n\r\n    asSystem(): this {\r\n        this.#outputMode = LINE_DISPLAY.SYSTEM\r\n        return this\r\n    }\r\n\r\n    get b(): Fraction {\r\n        return this.#b\r\n    }\r\n\r\n    set b(value: Fraction) {\r\n        this.#b = value\r\n    }\r\n\r\n    get c(): Fraction {\r\n        return this.#c\r\n    }\r\n\r\n    set c(value: Fraction) {\r\n        this.#c = value\r\n    }\r\n\r\n    // ------------------------------------------\r\n    canonicalAsFloatCoefficient(decimals = 2): string {\r\n        let canonical = ''\r\n\r\n        if (!this.#a.isZero()) {\r\n            if (this.#a.isOne()) {\r\n                canonical = 'x'\r\n            } else if (this.#a.clone().opposite().isOne()) {\r\n                canonical = '-x'\r\n            } else {\r\n                canonical = this.#a.value.toFixed(decimals) + 'x'\r\n            }\r\n        }\r\n\r\n        if (!this.#b.isZero()) {\r\n            if (this.#b.isPositive()) {\r\n                canonical += '+'\r\n            }\r\n            canonical += this.#b.value.toFixed(decimals) + 'y'\r\n        }\r\n\r\n        if (!this.#c.isZero()) {\r\n            if (this.#c.isPositive()) {\r\n                canonical += '+'\r\n            }\r\n            canonical += this.#c.value.toFixed(decimals)\r\n        }\r\n\r\n\r\n        return canonical + '=0'\r\n    }\r\n\r\n    get d(): Vector {\r\n        return new Vector(this.#b.clone(), this.#a.clone().opposite())\r\n    }\r\n\r\n    set d(value: Vector) {\r\n        this.fromPointAndDirection(this.OA, value)\r\n    }\r\n\r\n    get director(): Vector {\r\n        return this.d\r\n    }\r\n\r\n    distanceTo(pt: Point): Root {\r\n        const numerator = pt.x.clone().multiply(this.#a)\r\n            .add(pt.y.clone().multiply(this.#b))\r\n            .add(this.#c).abs()\r\n        const d2 = this.normal.normSquare\r\n\r\n        // The denominator is null - shouldn't be possible\r\n        if (d2.isZero()) {\r\n            return new Root(0)\r\n        }\r\n\r\n        return new Root().from(2, d2.inverse(), numerator)\r\n\r\n        // The denominator is a perfect square - simplify the tex result\r\n        // const value = numerator.value / Math.sqrt(d2.value)\r\n        // const F = numerator.clone().divide(d2.clone().sqrt())\r\n\r\n        //\r\n        // if (d2.isSquare()) {\r\n        //\r\n        //     return {\r\n        //         value,\r\n        //         tex: F.tex,\r\n        //         fraction: F\r\n        //     }\r\n        // }\r\n        // // Complete answer...\r\n        // return {\r\n        //     value,\r\n        //     tex: `\\\\frac{${numerator.tex}}{\\\\sqrt{${d2.tex}}}`,\r\n        //     fraction: F\r\n        // }\r\n    }\r\n\r\n    fromCoefficient = (a: InputValue<Fraction>, b: InputValue<Fraction>, c: InputValue<Fraction>): this => {\r\n        this.#a = new Fraction(a)\r\n        this.#b = new Fraction(b)\r\n        this.#c = new Fraction(c)\r\n\r\n        // make sure the coefficients are relative...\r\n        const lcm = Numeric.lcm(this.#a.denominator, this.#b.denominator, this.#c.denominator)\r\n        if (lcm > 1) {\r\n            this.#a.multiply(lcm).reduce()\r\n            this.#b.multiply(lcm).reduce()\r\n            this.#c.multiply(lcm).reduce()\r\n        }\r\n\r\n        if (this.#b.isZero()) {\r\n            // ax+c=0 => x = -c/a\r\n            this.#OA = new Vector(this.#c.clone().divide(this.#a).opposite(), 0)\r\n            return this\r\n        }\r\n\r\n        // ax+by+c=0 => x=0 => y = a/b x - c/b = (ax-c)/b\r\n        for (let x = 0; x < this.#b.value; x++) {\r\n            const y = this.#a.clone().divide(this.#b)\r\n                .multiply(x)\r\n                .subtract(this.#c.clone().divide(this.#b))\r\n                .reduce()\r\n\r\n            this.#OA = new Vector(x, y)\r\n\r\n            if (y.isRelative()) {\r\n                return this\r\n            }\r\n        }\r\n\r\n        // no \"nice\" point... do it with 'x=0'\r\n        const y = this.#c.clone().divide(this.#b).opposite().reduce()\r\n        this.#OA = new Vector(0, y)\r\n\r\n        return this\r\n    }\r\n\r\n    fromEquation = (equ: Equation): this => {\r\n        // Reorder the equation\r\n        equ.reorder(true)\r\n\r\n        // It must contain either x, y or both.\r\n        const letters = new Set(equ.letters())\r\n\r\n        // No 'x', no 'y' in the equations\r\n        if (!(letters.has('x') || letters.has('y'))) {\r\n            return this\r\n        }\r\n\r\n        // Another letter in the equation ?\r\n        for (const elem of ['x', 'y']) {\r\n            if (letters.has(elem)) {\r\n                letters.delete(elem)\r\n            }\r\n        }\r\n\r\n        if (letters.size > 0) {\r\n            return this\r\n        }\r\n\r\n        // Everything should be ok now...\r\n        return this.fromCoefficient(\r\n            equ.left.monomByLetter('x').coefficient,\r\n            equ.left.monomByLetter('y').coefficient,\r\n            equ.left.monomByDegree(0).coefficient\r\n        )\r\n    }\r\n\r\n    fromPointAndDirection = (P: Point | Vector, d: Vector): this => {\r\n        return this.fromPointAndNormal(P, d.clone().normal())\r\n    }\r\n\r\n    fromPointAndLine = (P: Vector, L: Line, orientation: LinePropriety = LinePropriety.Parallel): this => {\r\n\r\n        if (orientation === LinePropriety.Perpendicular) {\r\n            return this.fromPointAndNormal(P, L.director)\r\n        }\r\n\r\n        return this.fromPointAndNormal(P, L.normal)\r\n    }\r\n\r\n    fromPointAndNormal = (P: Point | Vector, n: Vector): this => {\r\n        this.fromCoefficient(\r\n            n.x,\r\n            n.y,\r\n            P.x.clone().multiply(n.x)\r\n                .add(P.y.clone().multiply(n.y)).opposite()\r\n        )\r\n\r\n        this.#OA = new Vector(P.clone())\r\n\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n\r\n    fromPoints(A: Point, B: Point) {\r\n        return this.fromPointAndNormal(A, new Vector(A, B).normal())\r\n    }\r\n\r\n    // ------------------------------------------\r\n    getEquation(): Equation {\r\n        const equ = new Equation(new Polynom().parse('xy', this.#a, this.#b, this.#c), new Polynom('0'))\r\n        return equ.simplify()\r\n    }\r\n\r\n    getValueAtX = (value: Fraction | number): Fraction => {\r\n        const equ = this.getEquation().isolate('y'),\r\n            F = new Fraction(value)\r\n\r\n        if (equ instanceof Equation) {\r\n            return equ.right.evaluate({x: F}) as Fraction\r\n        }\r\n        return new Fraction().invalid()\r\n    }\r\n\r\n    getValueAtY = (value: Fraction | number): Fraction => {\r\n        const equ = this.getEquation().isolate('x'),\r\n            F = new Fraction(value)\r\n\r\n        if (equ instanceof Equation) {\r\n            return equ.right.evaluate({y: F}) as Fraction\r\n        }\r\n\r\n        return new Fraction().invalid()\r\n    }\r\n\r\n    get height(): Fraction {\r\n        return this.#c.clone().opposite().divide(this.#b)\r\n    }\r\n\r\n    hitSegment(A: Point, B: Point): boolean {\r\n        const iPt = this.intersection(\r\n            new Line().fromPoints(A, B)\r\n        )\r\n\r\n        // There is an intersection point\r\n        if (iPt.hasIntersection) {\r\n            return iPt.point.x.value >= Math.min(A.x.value, B.x.value)\r\n                && iPt.point.x.value <= Math.max(A.x.value, B.x.value)\r\n                && iPt.point.y.value >= Math.min(A.y.value, B.y.value)\r\n                && iPt.point.y.value <= Math.max(A.y.value, B.y.value)\r\n        }\r\n        return false\r\n    }\r\n\r\n    intersection = (line: Line): { point: Point, hasIntersection: boolean, isParallel: boolean, isSame: boolean } => {\r\n        // TODO: rework Line.intersection\r\n        const Pt = new Point()\r\n        let isParallel = false, isSame = false\r\n\r\n        // this         => ax+by+c = 0\r\n        // line         => dx+ey+f = 0\r\n        //\r\n        //  aex + bey + ce = 0\r\n        //  dbx + bey + bf = 0\r\n        // (ae-db)x + ce-bf = 0\r\n        //\r\n        //  adx + bdy + cd = 0\r\n        //  adx + aey + af = 0\r\n        // (bd-ae)y + (cd-af)\r\n        //\r\n        // x = (bf-ce)/(ae-db)\r\n        // y = (af-cd)/(bd-ae)\r\n\r\n\r\n        // Theres is no 'y'\r\n        if (this.#b.isZero() || line.b.isZero()) {\r\n            // TODO : handle no y in the line canonical form\r\n        }\r\n\r\n        if (this.isParallelTo(line)) {\r\n            Pt.x = new Fraction().invalid()\r\n            Pt.y = new Fraction().invalid()\r\n            isParallel = true\r\n        } else if (this.isSameAs(line)) {\r\n            Pt.x = new Fraction().invalid()\r\n            Pt.y = new Fraction().invalid()\r\n            isSame = true\r\n        } else {\r\n            Pt.x = this.#b.clone().multiply(line.c).subtract(this.#c.clone().multiply(line.b))\r\n                .divide(this.#a.clone().multiply(line.b).subtract(this.#b.clone().multiply(line.a)))\r\n            Pt.y = this.#a.clone().multiply(line.c).subtract(this.#c.clone().multiply(line.a))\r\n                .divide(this.#b.clone().multiply(line.a).subtract(this.#a.clone().multiply(line.b)))\r\n        }\r\n\r\n        return {\r\n            point: Pt,\r\n            hasIntersection: !(isParallel || isSame),\r\n            isParallel,\r\n            isSame\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    isOnLine(pt: Point): boolean {\r\n        return this.#a.clone()\r\n            .multiply(pt.x)\r\n            .add(\r\n                this.#b.clone()\r\n                    .multiply(pt.y)\r\n            )\r\n            .add(this.#c)\r\n            .isZero()\r\n    }\r\n\r\n    isParallelTo = (line: Line): boolean => {\r\n        // Do they have the isSame direction ?\r\n        return this.slope.isEqual(line.slope) && this.height.isNotEqual(line.height)\r\n    }\r\n\r\n    isPerpendicularTo = (line: Line): boolean => {\r\n        return this.d.isNormalTo(line.d)\r\n    }\r\n\r\n    isSameAs = (line: Line): boolean => {\r\n        return this.slope.isEqual(line.slope) && this.height.isEqual(line.height)\r\n    }\r\n\r\n    isVertical = (): boolean => {\r\n        return this.slope.isInfinity()\r\n    }\r\n\r\n    get n(): Vector {\r\n        return this.d.normal()\r\n    }\r\n\r\n    get normal(): Vector {\r\n        return new Vector(this.#a, this.#b)\r\n    }\r\n\r\n    randomNearPoint = (k?: number): Point => {\r\n        const pt = this.randomPoint(k)\r\n\r\n        let maxIterationTest = 10\r\n        while (this.isOnLine(pt) && maxIterationTest > 0) {\r\n            pt.x.add(randomIntSym(1, false))\r\n            pt.y.add(randomIntSym(1, false))\r\n            maxIterationTest--\r\n\r\n        }\r\n\r\n        return pt\r\n    }\r\n\r\n    randomPoint = (k?: number): Point => {\r\n        // Return a random point on the line.\r\n        const pt = this.d\r\n            .clone()\r\n            .multiplyByScalar(randomIntSym((k === undefined || k <= 1) ? 3 : k, false))\r\n            .add(this.#OA)\r\n\r\n        return new Point(pt)\r\n    }\r\n\r\n    simplify = (): this => {\r\n        const lcm = Numeric.lcm(this.#a.denominator, this.#b.denominator, this.#c.denominator),\r\n            gcd = Numeric.gcd(this.#a.numerator, this.#b.numerator, this.#c.numerator)\r\n\r\n        this.fromCoefficient(\r\n            this.#a.clone().multiply(lcm).divide(gcd),\r\n            this.#b.clone().multiply(lcm).divide(gcd),\r\n            this.#c.clone().multiply(lcm).divide(gcd),\r\n        )\r\n\r\n        return this\r\n    }\r\n\r\n    get slope(): Fraction {\r\n        return this.#a.clone().opposite().divide(this.#b)\r\n    }\r\n}","import {Fraction} from \"../coefficients\"\r\nimport {Line} from \"./line\"\r\nimport {Vector} from \"./vector\"\r\nimport {Point} from \"./point\"\r\nimport type {InputValue, remarquableLines} from \"../pimath.interface\"\r\n\r\ntype TRIANGLE_SIDES = 'AB' | 'AC' | 'BC'\r\n\r\nexport class Triangle {\r\n    // This defines the triangle\r\n    #A: Point = new Point()\r\n    #B: Point = new Point()\r\n    #C: Point = new Point()\r\n    #isValid = true    // TODO: add a check if it's a triangle or not.\r\n// This is calculated\r\n    #lines: Record<TRIANGLE_SIDES, Line> = {\r\n        'AB': new Line(),\r\n        'AC': new Line(),\r\n        'BC': new Line()\r\n    }\r\n    #radians = true\r\n    #remarquables: remarquableLines | null  = null\r\n\r\n    constructor(...values: unknown[]) {\r\n\r\n\r\n        if (values.length > 0) {\r\n            this.parse(...values)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    parse = (...values: unknown[]): this => {\r\n\r\n        if (values.length === 1) {\r\n            if (values[0] instanceof Triangle) {\r\n                return this.copy(values[0])\r\n            }\r\n        }\r\n\r\n        if (values.length === 3) {\r\n            // Possibilities:\r\n            // - Three points (or part of points, only dict for example, or array\r\n            // - Three lines\r\n            // - Three lines as text.\r\n            if (values.every((x: unknown) => typeof x === 'string')) {\r\n                // Three lines as text.\r\n                return this.parse(\r\n                    ...values.map((x) => {\r\n                        return new Line(x)\r\n                    })\r\n                )\r\n            }\r\n\r\n            if (values.every((x: unknown) => x instanceof Line)) {\r\n                // We have three lines\r\n                return this.fromLines(values[0], values[1], values[2])\r\n            }\r\n\r\n            if (values.every((x: unknown) => (x instanceof Point))) {\r\n                return this.fromPoints(values[0], values[1], values[2])\r\n            }\r\n        }\r\n\r\n        if (values.length === 6) {\r\n            const v: Fraction[] = values.map((x: unknown) => new Fraction(x as string))\r\n\r\n            if (v.some(x => x.isNaN())) {\r\n                throw new Error('One of the values is not a valid number')\r\n            }\r\n\r\n            return this.fromCoordinates(v[0], v[1], v[2], v[3], v[4], v[5])\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Clone the Triangle class\r\n     */\r\n    clone = (): Triangle => {\r\n        return new Triangle(\r\n            this.#A.clone(),\r\n            this.#B.clone(),\r\n            this.#C.clone()\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Copy the values from another triangle\r\n     * @param value\r\n     */\r\n    copy(value: Triangle): this {\r\n        this.#A = value.A.clone()\r\n        this.#B = value.B.clone()\r\n        this.#C = value.C.clone()\r\n\r\n        return this.#updateTriangle()\r\n    }\r\n\r\n    get A(): Point {\r\n        return this.#A\r\n    }\r\n\r\n    get AB(): Vector {\r\n        return this.#getSegment('A', 'B')\r\n    }\r\n\r\n    get AC(): Vector {\r\n        return this.#getSegment('A', 'C')\r\n    }\r\n\r\n    get B(): Point {\r\n        return this.#B\r\n    }\r\n\r\n    get BA(): Vector {\r\n        return this.#getSegment('B', 'A')\r\n    }\r\n\r\n    get BC(): Vector {\r\n        return this.#getSegment('B', 'C')\r\n    }\r\n\r\n    get C(): Point {\r\n        return this.#C\r\n    }\r\n\r\n    get CA(): Vector {\r\n        return this.#getSegment('C', 'A')\r\n    }\r\n\r\n    get CB(): Vector {\r\n        return this.#getSegment('C', 'B')\r\n    }\r\n\r\n    get angleABC(): number {\r\n        return this.getAngle('ABC')\r\n    }\r\n\r\n    get angleBCA(): number {\r\n        return this.getAngle('BCA')\r\n    }\r\n\r\n    get angleCAB(): number {\r\n        return this.getAngle('CAB')\r\n    }\r\n\r\n    get asDegree(): this {\r\n        this.#radians = false\r\n        return this\r\n    }\r\n\r\n    get asRadians(): this {\r\n        this.#radians = true\r\n        return this\r\n    }\r\n\r\n    fromCoordinates(\r\n        x1: InputValue<Fraction>, y1: InputValue<Fraction>,\r\n        x2: InputValue<Fraction>, y2: InputValue<Fraction>,\r\n        x3: InputValue<Fraction>, y3: InputValue<Fraction>): this {\r\n\r\n        return this.fromPoints(\r\n            new Point(x1, y1),\r\n            new Point(x2, y2),\r\n            new Point(x3, y3),\r\n        )\r\n    }\r\n\r\n    fromLines(line1: Line | string, line2: Line | string, line3: Line | string): this {\r\n        const AB: Line = new Line(line1).clone()\r\n        const BC: Line = new Line(line2).clone()\r\n        const AC: Line = new Line(line3).clone()\r\n\r\n        // Get the intersection points -> build the triangle using these intersection points.\r\n        let intersect = AB.intersection(BC)\r\n        if (intersect.hasIntersection) {\r\n            this.#B = intersect.point\r\n        } else {\r\n            throw new Error('Lines do not intersect !')\r\n        }\r\n\r\n        intersect = BC.intersection(AC)\r\n        if (intersect.hasIntersection) {\r\n            this.#C = intersect.point\r\n        } else {\r\n            throw new Error('Lines do not intersect !')\r\n        }\r\n\r\n        intersect = AC.intersection(AB)\r\n        if (intersect.hasIntersection) {\r\n            this.#A = intersect.point\r\n        } else {\r\n            throw new Error('Lines do not intersect !')\r\n        }\r\n\r\n        this.#updateTriangle()\r\n\r\n        // Force the use of the given lines.\r\n        this.#lines = {AB, AC, BC}\r\n\r\n        return this\r\n\r\n    }\r\n\r\n    fromPoints(A: Point, B: Point, C: Point): this {\r\n        // We have three points.\r\n        this.#A = A.clone()\r\n        this.#B = B.clone()\r\n        this.#C = C.clone()\r\n\r\n        this.#updateTriangle()\r\n        return this\r\n    }\r\n\r\n    getAngle(name: 'CAB' | 'ABC' | 'BCA'): number {\r\n        const a = this.BC.norm\r\n        const b = this.AC.norm\r\n        const c = this.AB.norm\r\n\r\n        if (name === 'CAB') {\r\n            return this.#cosThm(a, b, c)\r\n        }\r\n\r\n        if (name === 'BCA') {\r\n            return this.#cosThm(c, b, a)\r\n        }\r\n\r\n        return this.#cosThm(b, a, c)\r\n    }\r\n\r\n    get isEquilateral(): boolean {\r\n        const dAB = this.AB.normSquare.value\r\n        const dBC = this.BC.normSquare.value\r\n        const dAC = this.AC.normSquare.value\r\n\r\n        return (dAB === dBC) && (dAB === dAC)\r\n    }\r\n\r\n    get isIsocele(): boolean {\r\n        const dAB = this.AB.normSquare.value\r\n        const dBC = this.BC.normSquare.value\r\n        const dAC = this.AC.normSquare.value\r\n\r\n        return dAB === dBC ||\r\n            dAB === dAC ||\r\n            dBC === dAC\r\n    }\r\n\r\n    get isRectangle(): boolean {\r\n        return this.AB.isNormalTo(this.BC) ||\r\n            this.AB.isNormalTo(this.AC) ||\r\n            this.BC.isNormalTo(this.AC)\r\n    }\r\n\r\n    get isValid(): boolean {\r\n        return this.#isValid\r\n    }\r\n\r\n    set isValid(value: boolean) {\r\n        this.#isValid = value\r\n    }\r\n\r\n    get lines(): Record<TRIANGLE_SIDES, Line> {\r\n        return this.#lines\r\n    }\r\n\r\n    get remarquables(): remarquableLines | null {\r\n        return this.#remarquables\r\n    }\r\n\r\n    #calculateBisectors = (pt: string): { internal: Line, external: Line } => {\r\n        // TODO: there should be an easier way to get the internal point (and the intersection).\r\n        const tlines = this.lines\r\n        let d1, d2\r\n\r\n        if (pt === 'A') {\r\n            d1 = tlines.AB\r\n            d2 = tlines.AC\r\n        } else if (pt === 'B') {\r\n            d1 = tlines.AB\r\n            d2 = tlines.BC\r\n        } else if (pt === 'C') {\r\n            d1 = tlines.BC\r\n            d2 = tlines.AC\r\n        }\r\n\r\n        if (d1 === undefined || d2 === undefined) {\r\n            throw new Error(`The point ${pt} does not exist`)\r\n        }\r\n\r\n        const d1n = d1.n.simplify().norm\r\n        const d2n = d2.n.simplify().norm\r\n        const d1Equ = d1.getEquation().multiply(d2n)\r\n        const d2Equ = d2.getEquation().multiply(d1n)\r\n\r\n        const b1: Line = new Line(d1Equ.clone().subtract(d2Equ).simplify())\r\n        const b2: Line = new Line(d2Equ.clone().subtract(d1Equ).simplify())\r\n\r\n        // Must determine which bisectors is in the triangle\r\n        if (pt === 'A') {\r\n            return b1.hitSegment(this.B, this.C) ? {internal: b1, external: b2} : {internal: b2, external: b1}\r\n        }\r\n        if (pt === 'B') {\r\n            return b1.hitSegment(this.A, this.C) ? {internal: b1, external: b2} : {internal: b2, external: b1}\r\n        }\r\n        if (pt === 'C') {\r\n            return b1.hitSegment(this.B, this.A) ? {internal: b1, external: b2} : {internal: b2, external: b1}\r\n        }\r\n\r\n        // Default returns the first bisector\r\n        return {internal: b1, external: b2}\r\n    }\r\n\r\n    #calculateRemarquableLines = (): remarquableLines => {\r\n        const middles = {\r\n            'AB': new Point().middleOf(this.#A, this.#B),\r\n            'AC': new Point().middleOf(this.#A, this.#C),\r\n            'BC': new Point().middleOf(this.#B, this.#C)\r\n        }\r\n\r\n        const medians = {\r\n            'A': new Line().fromPoints(this.#A, middles.BC),\r\n            'B': new Line().fromPoints(this.#B, middles.AC),\r\n            'C': new Line().fromPoints(this.#C, middles.AB),\r\n            'intersection': null\r\n        }\r\n\r\n        const mediators = {\r\n            'AB': new Line().fromPointAndNormal(middles.AB, new Vector(this.#A, this.#B).normal()),\r\n            'AC': new Line().fromPointAndNormal(middles.AC, new Vector(this.#A, this.#C).normal()),\r\n            'BC': new Line().fromPointAndNormal(middles.BC, new Vector(this.#B, this.#C).normal()),\r\n            'intersection': null\r\n        }\r\n\r\n        const heights = {\r\n            'A': new Line().fromPointAndNormal(this.#A, new Vector(this.#B, this.#C).normal()),\r\n            'B': new Line().fromPointAndNormal(this.#B, new Vector(this.#A, this.#C).normal()),\r\n            'C': new Line().fromPointAndNormal(this.#C, new Vector(this.#A, this.#B).normal()),\r\n            'intersection': null\r\n        }\r\n\r\n        const bA = this.#calculateBisectors('A'),\r\n            bB = this.#calculateBisectors('B'),\r\n            bC = this.#calculateBisectors('C')\r\n\r\n        const bisectors = {\r\n            'A': bA.internal,\r\n            'B': bB.internal,\r\n            'C': bB.internal,\r\n            'intersection': null\r\n        }\r\n\r\n        const externalBisectors = {\r\n            'A': bA.external,\r\n            'B': bB.external,\r\n            'C': bC.external,\r\n            'intersection': null\r\n        }\r\n\r\n        const remarquables: remarquableLines = {\r\n            medians,\r\n            mediators,\r\n            heights,\r\n            bisectors,\r\n            externalBisectors\r\n        }\r\n\r\n        // As it's a triangle, we assume the lines are intersecting and aren't parallel or superposed.\r\n        remarquables.medians.intersection = remarquables.medians.A.intersection(remarquables.medians.B).point\r\n        remarquables.mediators.intersection = remarquables.mediators.AB.intersection(remarquables.mediators.BC).point\r\n        remarquables.heights.intersection = remarquables.heights.A.intersection(remarquables.heights.B).point\r\n        remarquables.bisectors.intersection = remarquables.bisectors.A.intersection(remarquables.bisectors.B).point\r\n\r\n        // Everything was calculated for the remarquable lines.\r\n        return remarquables\r\n    }\r\n\r\n    #cosThm(opposite: number, adjacent1: number, adjacent2: number): number {\r\n        const ratio = ((adjacent1 ** 2 * adjacent2 ** 2) - opposite ** 2) / (2 * adjacent1 * adjacent2)\r\n\r\n        return this.#radians\r\n            ? Math.acos(ratio)\r\n            : Math.acos(ratio) * 180 / Math.PI\r\n    }\r\n\r\n    /**\r\n     * Get the Point class for the given name\r\n     * @param ptName\r\n     */\r\n    #getPointByName = (ptName: string): Point => {\r\n        switch (ptName.toUpperCase()) {\r\n            case 'A':\r\n                return this.#A\r\n            case 'B':\r\n                return this.#B\r\n            case 'C':\r\n                return this.#C\r\n        }\r\n\r\n        // Something went wrong ! Return the first point\r\n        return this.#A\r\n    }\r\n\r\n    /**\r\n     * Get the vector for the segment given by name.\r\n     * @param ptName1\r\n     * @param ptName2\r\n     */\r\n    #getSegment = (ptName1: string, ptName2: string): Vector => {\r\n        return new Vector(\r\n            this.#getPointByName(ptName1),\r\n            this.#getPointByName(ptName2)\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Generate the Line object for the three segments of the triangle\r\n     */\r\n    #updateTriangle(): this {\r\n        // Create the lines\r\n        this.#lines = {\r\n            'AB': new Line(this.#A, this.#B),\r\n            'BC': new Line(this.#B, this.#C),\r\n            'AC': new Line(this.#A, this.#C)\r\n        }\r\n\r\n        this.#remarquables = this.#calculateRemarquableLines()\r\n\r\n        return this\r\n    }\r\n}","// TODO: remplacer ISolution par Solution, qui sera plus robuste et extensible\r\n\r\nimport type {InputValue} from \"../pimath.interface\"\r\nimport {Fraction} from \"../coefficients\"\r\nimport {Root} from \"../coefficients/root\"\r\n\r\nexport class Solution {\r\n    #display: string\r\n    #exact: boolean\r\n    #fraction: Fraction\r\n    #isZero: boolean\r\n    #root: Root\r\n    #tex: string\r\n    #variable: string\r\n\r\n    constructor() {\r\n        this.#variable = 'x'\r\n        this.#exact = false\r\n        this.#isZero = true\r\n\r\n        this.#display = '?'\r\n        this.#tex = '?'\r\n\r\n        this.#fraction = new Fraction().zero()\r\n        this.#root = new Root()\r\n    }\r\n\r\n    get tex(): string {\r\n        if (this.#root.isZero()) return this.#fraction.tex\r\n\r\n        if (this.#fraction.isZero()) return this.#root.tex\r\n\r\n        const [f] = Fraction.toSameDenominateur(this.#fraction, this.#root.factor)\r\n\r\n        const R = this.#root.clone().multiply(f.denominator).reduce()\r\n        const num = `${f.numerator} ${R.withSign().tex}`\r\n\r\n        if (f.denominator === 1) return num\r\n\r\n        return `\\\\frac{ ${num} }{ ${f.denominator} }`\r\n    }\r\n\r\n    set tex(value: string) {\r\n        this.#tex = value\r\n    }\r\n\r\n    get display(): string {\r\n        return this.#display\r\n    }\r\n\r\n    set display(value: string) {\r\n        this.#display = value\r\n    }\r\n\r\n    static fromFraction(value: InputValue<Fraction>): Solution {\r\n        const sol = new Solution()\r\n        sol.setExact()\r\n\r\n        const F = new Fraction(value)\r\n        sol.display = F.display\r\n        sol.tex = F.tex\r\n\r\n        sol.fraction = F\r\n        sol.root = new Root()\r\n\r\n        return sol\r\n    }\r\n\r\n    static fromQuadratic(A: InputValue<Fraction>, B: InputValue<Fraction>, C: InputValue<Fraction>): Solution[] {\r\n        const [a, b, c] = [A, B, C].map(x => new Fraction(x))\r\n\r\n        // D = b^2-4ac\r\n        const delta2 = b.clone().pow(2).subtract(a.clone().multiply(c).multiply(4))\r\n        if (delta2.isNegative()) {\r\n            return []\r\n        }\r\n\r\n        if (delta2.isSquare()) {\r\n            const delta = delta2.sqrt()\r\n            const root1 = b.clone().opposite().subtract(delta).divide(a.clone().multiply(2))\r\n            const root2 = b.clone().opposite().add(delta).divide(a.clone().multiply(2))\r\n\r\n            return delta.isZero()\r\n                ? [Solution.fromFraction(root1)]\r\n                : [Solution.fromFraction(root1), Solution.fromFraction(root2)]\r\n        }\r\n\r\n        const sol1 = new Solution()\r\n        sol1.fraction = b.clone().opposite().divide(a).divide(2)\r\n        sol1.root = new Root().from(2, delta2, a.clone().multiply(2).inverse().opposite())\r\n        sol1.setExact(false)\r\n\r\n        const sol2 = new Solution()\r\n        sol2.fraction = b.clone().opposite().divide(a).divide(2)\r\n        sol2.root = new Root().from(2, delta2, a.clone().multiply(2).inverse())\r\n        sol2.setExact(false)\r\n\r\n        return [sol1, sol2]\r\n    }\r\n\r\n    get exact(): boolean {\r\n        return this.#exact\r\n    }\r\n\r\n    set exact(value: boolean) {\r\n        this.#exact = value\r\n    }\r\n\r\n    get fraction(): Fraction {\r\n        return this.#fraction\r\n    }\r\n\r\n    set fraction(value: Fraction) {\r\n        this.#fraction = value\r\n    }\r\n\r\n    isAZero(value = true): this {\r\n        this.#isZero = value\r\n        return this\r\n    }\r\n\r\n    get isZero(): boolean {\r\n        return this.#isZero\r\n    }\r\n\r\n    set isZero(value: boolean) {\r\n        this.#isZero = value\r\n    }\r\n\r\n    reduce(): this {\r\n        // Reduce the root\r\n        this.#root.reduce()\r\n        this.#fraction.reduce()\r\n\r\n        return this\r\n    }\r\n\r\n    get root(): Root {\r\n        return this.#root\r\n    }\r\n\r\n    set root(value: Root) {\r\n        this.#root = value\r\n    }\r\n\r\n    setExact(value = true): this {\r\n        this.#exact = value\r\n        return this\r\n    }\r\n\r\n    get value(): number {\r\n        throw new Error(\"To be implemented\")\r\n    }\r\n\r\n    get variable(): string {\r\n        return this.#variable\r\n    }\r\n\r\n    set variable(value: string | undefined) {\r\n        if (value === undefined) {\r\n            return\r\n        }\r\n\r\n        this.#variable = value\r\n    }\r\n}","import {Line} from \"./line\"\r\nimport {Vector} from \"./vector\"\r\nimport {Numeric} from \"../numeric\"\r\nimport {Fraction} from \"../coefficients\"\r\nimport {Equation, Monom, Polynom} from \"../algebra\"\r\nimport {type IPiMathObject} from \"../pimath.interface\"\r\nimport {Point} from \"./point\"\r\nimport {Root} from \"../coefficients/root\"\r\nimport {Triangle} from \"./triangle\"\r\nimport {Solution} from \"../analyze/solution\"\r\n\r\nenum CIRCLE_DISPLAY {\r\n    CANONICAL,\r\n    CENTER_RADIUS,\r\n}\r\n\r\nexport class Circle\r\n    implements IPiMathObject<Circle> {\r\n\r\n    #center: Point | null = null\r\n    #equation: Equation | null = null\r\n    #output_style: CIRCLE_DISPLAY = CIRCLE_DISPLAY.CENTER_RADIUS\r\n    #squareRadius: Fraction | null = null\r\n\r\n    constructor()\r\n    constructor(equation: string | Equation)\r\n    constructor(circle: Circle)\r\n    constructor(center: Point, radius: Fraction | number, square?: boolean)\r\n    constructor(center: Point, pointThrough: Point)\r\n    constructor(A: Point, B: Point, C: Point)\r\n    constructor(...values: unknown[]) {\r\n        if (values.length > 0) {\r\n            this.parse(...values)\r\n        }\r\n    }\r\n\r\n    parse(...values: unknown[]): this {\r\n        // Data can be given in these formats:\r\n        // one value, a string -> make it an Equation\r\n        // one value, an Equation\r\n        // one value, a circle -> clone it\r\n        // two values: two points (center and pointThrough)\r\n        // two values: point and Fraction (center and radius)\r\n        // three values: Vector2D, Fraction, Boolean (center, square radius, true)\r\n\r\n        if (typeof values[0] === 'string') {\r\n            return this.fromString(values[0])\r\n        }\r\n\r\n        if (values[0] instanceof Equation) {\r\n            return this.fromEquation(values[0])\r\n        }\r\n\r\n        if (values[0] instanceof Circle) {\r\n            return this.copy(values[0])\r\n        }\r\n\r\n        if (values.length === 2 &&\r\n            values[0] instanceof Point && values[1] instanceof Point\r\n        ) {\r\n            // Circle center through one point\r\n            return this.fromCenterPoint(values[0], values[1])\r\n        }\r\n\r\n        if (values.length >= 2 && values[0]\r\n            instanceof Point &&\r\n            (values[1] instanceof Fraction || typeof values[1] === 'number')\r\n        ) {\r\n            // Circle center through one point\r\n            return this.fromCenterRadius(\r\n                values[0], values[1],\r\n                (typeof values[2] === \"boolean\") ? values[2] : false\r\n            )\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    clone(): Circle {\r\n        return new Circle().fromCenterRadius(\r\n            this.center.clone(),\r\n            this.squareRadius.clone(),\r\n            true\r\n        )\r\n    }\r\n\r\n    copy(circle: Circle): this {\r\n        this.#center = circle.center.clone()\r\n        this.#squareRadius = circle.squareRadius.clone()\r\n\r\n        this.#calculateCartesian()\r\n\r\n        return this\r\n    }\r\n\r\n    get tex(): string {\r\n        if (this.#output_style === CIRCLE_DISPLAY.CANONICAL) {\r\n            return this.equation.moveLeft().reduce().tex\r\n        }\r\n\r\n        let cx, cy\r\n        if (this.center.x.isZero()) {\r\n            cx = 'x^2'\r\n        } else {\r\n            cx = `\\\\left(x${this.center.x.isNegative() ? '+' : '-'}${this.center.x.clone().abs().tex}\\\\right)^2`\r\n        }\r\n        if (this.center.y.isZero()) {\r\n            cy = 'y^2'\r\n        } else {\r\n            cy = `\\\\left(y${this.center.y.isNegative() ? '+' : '-'}${this.center.y.clone().abs().tex}\\\\right)^2`\r\n        }\r\n        return `${cx}+${cy}=${this.squareRadius.tex}`\r\n    }\r\n\r\n    get display(): string {\r\n        if (this.#output_style === CIRCLE_DISPLAY.CANONICAL) {\r\n            return this.equation.moveLeft().reduce().display\r\n        }\r\n\r\n        let cx, cy\r\n        if (this.center.x.isZero()) {\r\n            cx = 'x^2'\r\n        } else {\r\n            cx = `(x${this.center.x.isNegative() ? '+' : '-'}${this.center.x.clone().abs().tex})^2`\r\n        }\r\n        if (this.center.y.isZero()) {\r\n            cy = 'y^2'\r\n        } else {\r\n            cy = `(y${this.center.y.isNegative() ? '+' : '-'}${this.center.y.clone().abs().tex})^2`\r\n        }\r\n        return `${cx}+${cy}=${this.squareRadius.display}`\r\n    }\r\n\r\n    get asCanonical(): this {\r\n        this.#output_style = CIRCLE_DISPLAY.CANONICAL\r\n        return this\r\n    }\r\n\r\n    get asCenterRadius(): this {\r\n        this.#output_style = CIRCLE_DISPLAY.CENTER_RADIUS\r\n        return this\r\n    }\r\n\r\n    get center(): Point {\r\n        return this.#center ?? new Point()\r\n    }\r\n\r\n    get equation(): Equation {\r\n        return this.#equation?.clone() ?? new Equation('0=0')\r\n    }\r\n\r\n    fromCenterPoint(center: Point, pointThrough: Point): this {\r\n        this.#center = center.clone()\r\n        this.#squareRadius = new Vector(this.#center, pointThrough).normSquare\r\n\r\n        this.#calculateCartesian()\r\n\r\n        return this\r\n    }\r\n\r\n    fromCenterRadius(center: Point, radius: Fraction | number, square?: boolean): this {\r\n        this.#center = center.clone()\r\n        if (square) {\r\n            this.#squareRadius = (new Fraction(radius))\r\n        } else {\r\n            this.#squareRadius = new Fraction(radius).pow(2)\r\n        }\r\n\r\n        this.#calculateCartesian()\r\n\r\n        return this\r\n    }\r\n\r\n    fromEquation(equ: Equation): this {\r\n        // Move everything to the left.\r\n        equ.moveLeft()\r\n\r\n        if (equ.degree('x').value === 2 && equ.degree('y').value === 2) {\r\n            // Both must be of degree 2.\r\n            const x2 = equ.left.monomByDegree(2, 'x'), y2 = equ.left.monomByDegree(2, 'y')\r\n            let x1: Monom, y1: Monom, c: Monom\r\n\r\n            // Both square monoms must have the same coefficient.\r\n            if (x2.coefficient.isEqual(y2.coefficient)) {\r\n                equ.divide(x2.coefficient)\r\n\r\n                x1 = equ.left.monomByDegree(1, 'x')\r\n                y1 = equ.left.monomByDegree(1, 'y')\r\n\r\n                c = equ.left.monomByDegree(0)\r\n\r\n                this.#center = new Point(x1.coefficient.clone().divide(2).opposite(), y1.coefficient.clone().divide(2).opposite())\r\n\r\n                this.#squareRadius = c.coefficient.clone().opposite()\r\n                    .add(this.#center.x.clone().pow(2))\r\n                    .add(this.#center.y.clone().pow(2))\r\n\r\n                this.#calculateCartesian()\r\n\r\n                return this\r\n            } else {\r\n                // The circle is not a valid circle\r\n                this.#reset()\r\n            }\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    fromPoints(A: Point, B: Point, C: Point): this {\r\n        const T = new Triangle(A, B, C)\r\n        if (!T.isValid || !T.remarquables) {\r\n            this.#reset()\r\n            return this\r\n        }\r\n\r\n        const mAB = T.remarquables.mediators.AB.clone()\r\n        const mAC = T.remarquables.mediators.AC.clone()\r\n        this.parse(mAB.intersection(mAC).point, A)\r\n\r\n        return this\r\n    }\r\n\r\n    fromString(str: string): this {\r\n        return this.fromEquation(new Equation(str))\r\n    }\r\n\r\n    getPointsOnCircle(): Point[] {\r\n        // It means searching for pythagorician triples that make a perfect square.\r\n        // (x-4)^2 + (y+3)^2 = 15\r\n        const triplets = Numeric.pythagoreanTripletsWithTarget(this.squareRadius.value, true)\r\n\r\n        const points: Point[] = []\r\n\r\n        triplets.forEach(triplet => {\r\n            // Allow positive / negative values\r\n            // x-a = t  => x = a + t\r\n            // x-a = -t => x = a - t\r\n\r\n            for (const k of [[1, 1], [-1, 1], [-1, -1], [1, -1]]) {\r\n                points.push(new Point(\r\n                        this.center.x.clone().add(k[0] * triplet[0]),\r\n                        this.center.y.clone().add(k[1] * triplet[1])\r\n                    )\r\n                )\r\n            }\r\n        })\r\n        return points\r\n    }\r\n\r\n    isPointOnCircle = (P: Point): boolean => {\r\n        return this.#equation?.test({x: P.x, y: P.y}) ?? false\r\n    }\r\n\r\n    lineIntersection(L: Line): Point[] {\r\n        if (this.#equation === null) {\r\n            return []\r\n        }\r\n\r\n        const center = this.center\r\n        const d = L.d\r\n        const OP = L.OA\r\n\r\n        // A = dx^2+dy^2\r\n        const A = d.normSquare\r\n        // B = 2 ( dx (x0-cx) + dy(y0-cy) )\r\n        const B = OP.x.clone().subtract(center.x).multiply(d.x)\r\n            .add(OP.y.clone().subtract(center.y).multiply(d.y))\r\n            .multiply(2)\r\n        // C = (x0-cx)^2 + (y0-cy)^2 - r^2\r\n        const C = OP.x.clone().subtract(center.x).pow(2)\r\n            .add(OP.y.clone().subtract(center.y).pow(2))\r\n            .subtract(this.squareRadius)\r\n\r\n        const sol = Solution.fromQuadratic(A, B, C)\r\n\r\n        if (sol.length === 0) {\r\n            return []\r\n        }\r\n\r\n        // One intersection point\r\n        if (sol.length === 1) { // means exact answer\r\n            const OX = OP.add(d.clone().multiplyByScalar(sol[0].fraction))\r\n            return [\r\n                new Point(OX.x, OX.y)\r\n            ]\r\n        }\r\n\r\n        // Two intersection points\r\n        if (sol[0].exact && sol[1].exact) {\r\n            // Exact solutions (delta is a perfect square)\r\n            const OX1 = OP.add(d.clone().multiplyByScalar(sol[0].fraction))\r\n            const OX2 = OP.add(d.clone().multiplyByScalar(sol[1].fraction))\r\n            return [\r\n                new Point(OX1.x, OX1.y),\r\n                new Point(OX2.x, OX2.y),\r\n            ]\r\n        }\r\n\r\n        const OX1 = OP.add(d.clone().multiplyByScalar(sol[0].value))\r\n        const OX2 = OP.add(d.clone().multiplyByScalar(sol[1].value))\r\n        return [\r\n            new Point(OX1.x, OX1.y),\r\n            new Point(OX2.x, OX2.y),\r\n        ]\r\n    }\r\n\r\n    get radius(): Root {\r\n        return new Root().from(2, this.#squareRadius ?? 0)\r\n    }\r\n\r\n    /**\r\n     * Get the relative position between circle and line. It corresponds to the number of intersection.\r\n     * @param {Line} L\r\n     * @returns {number}\r\n     */\r\n    public relativePosition(L: Line): number {\r\n        if (this.#center === null || this.#squareRadius === null) {\r\n            return -1\r\n        }\r\n\r\n        const distance = L.distanceTo(this.#center).pow(2).value\r\n        const radius = this.#squareRadius.value\r\n\r\n        if (distance - radius > 0.0000000001) {\r\n            return 0 // external\r\n        }\r\n\r\n        if (Math.abs(distance - radius) < 0.0000000001) {\r\n            return 1 // tangent\r\n        }\r\n\r\n        return 2 // secant\r\n    }\r\n\r\n    setRadius(radius: Fraction | number, square?: boolean): this {\r\n        if (square) {\r\n            this.#squareRadius = new Fraction(radius)\r\n        } else {\r\n            this.#squareRadius = new Fraction(radius).pow(2)\r\n        }\r\n\r\n        this.#calculateCartesian()\r\n        return this\r\n    }\r\n\r\n    get squareRadius(): Fraction {\r\n        return this.#squareRadius?.clone() ?? new Fraction(-1)\r\n    }\r\n\r\n    tangents = (P: Point | Fraction): Line[] => {\r\n        if (P instanceof Fraction) {\r\n            return this.#tangentsWithSlope(P)\r\n        }\r\n\r\n        if (this.isPointOnCircle(P)) {\r\n            return this.#tangentsThroughOnePointOnTheCircle(P)\r\n        }\r\n\r\n        if (this.#center !== null && this.#center.distanceTo(P).value > this.radius.value) {\r\n            //TODO:  Must check it's outside the circle\r\n            return this.#tangentsThroughOnePointOutsideTheCircle(P)\r\n        }\r\n\r\n        console.log('No tangents as the point is inside !')\r\n        return []\r\n    }\r\n\r\n    #calculateCartesian(): void {\r\n        this.#equation = (\r\n            new Equation(\r\n                new Polynom(`(x-(${this.center.x.display}))^2+(y-(${this.center.y.display}))^2`),\r\n                new Polynom(this.squareRadius.display))\r\n        ).moveLeft()\r\n    }\r\n\r\n    #reset() {\r\n        this.#center = null\r\n        this.#squareRadius = null\r\n        this.#equation = null\r\n    }\r\n\r\n    #tangentsThroughOnePointOnTheCircle = (P: Point): Line[] => {\r\n        const CT = new Vector(this.center, P)\r\n        return [new Line().fromPointAndNormal(P, CT)]\r\n    }\r\n\r\n    #tangentsThroughOnePointOutsideTheCircle = (P: Point): Line[] => {\r\n        // y = mx + h\r\n        // px, py => h = -m px + py => mx - y -m.px + py = 0 =>\r\n        // Centre: cx, cy, radius: r\r\n        // (m.cx - cy -m.px + py)^2 = r^2  * (m^2  + 1)\r\n        // (m(cx-py) - (cy - py))^2 = r^2  * (m^2  + 1)\r\n\r\n        const cx_px = this.center.x.clone().subtract(P.x), cy_py = this.center.y.clone().subtract(P.y),\r\n            polyLeft = new Polynom('x'), polyRight = new Polynom('x^2+1')\r\n\r\n        polyLeft.multiply(cx_px).subtract(cy_py).pow(2)\r\n        polyRight.multiply(this.squareRadius)\r\n\r\n        const equ = new Equation(polyLeft, polyRight)\r\n        const solutions = equ.solve()\r\n\r\n        return solutions.map(sol => {\r\n            //  h = -m px + py\r\n            let h: Fraction\r\n            const equ = new Equation('y', 'x')\r\n\r\n            if (sol.exact instanceof Fraction) {\r\n                h = P.x.clone().opposite().multiply(sol.exact).add(P.y)\r\n                equ.right.multiply(sol.exact).add(h)\r\n            } else {\r\n                h = P.x.clone().opposite().multiply(sol.value).add(P.y)\r\n                equ.right.multiply(sol.value).add(h)\r\n            }\r\n\r\n            return new Line(equ)\r\n        })\r\n\r\n    }\r\n\r\n    #tangentsWithSlope = (slope: Fraction): Line[] => {\r\n        // d(C;t)=r => ac1+bc2 + x = +- sqrt(a^2 + b^2)*r\r\n        // x = -ac1-bc2  +-  sqrt(a^2 + b^2)*r\r\n        // y = a/bx + h => ax-by + H = 0\r\n\r\n        const a = slope.numerator, b = -slope.denominator, c1 = this.center.x.clone(), c2 = this.center.y.clone()\r\n\r\n        const sq = this.squareRadius.clone().multiply(slope.numerator ** 2 + slope.denominator ** 2),\r\n            x1 = c1.clone().multiply(a).opposite().subtract(c2.clone().multiply(b)).add(sq.clone().sqrt()),\r\n            x2 = c1.clone().multiply(a).opposite().subtract(c2.clone().multiply(b)).subtract(sq.clone().sqrt())\r\n\r\n        return [new Line(a, b, x1), new Line(a, b, x2)]\r\n    }\r\n\r\n}","/**\r\n * This class works for 2d line in a plane.\r\n */\r\n\r\nimport {Fraction} from \"../coefficients/fraction\"\r\nimport {Polynom} from \"../algebra/polynom\"\r\nimport {Monom} from \"../algebra/monom\"\r\nimport {randomIntSym} from \"../randomization/rndHelpers\"\r\nimport {Vector} from \"./vector\"\r\nimport {Point} from \"./point\"\r\nimport {Line3Propriety} from \"../pimath.interface\"\r\n\r\n\r\nexport class Line3 {\r\n    static PARALLEL = Line3Propriety.Parallel\r\n    // A line is defined as the canonical form\r\n    static PERPENDICULAR = Line3Propriety.Perpendicular\r\n    // ax + by + c = 0\r\n    #OA: Point = new Point()\r\n    #d: Vector = new Vector()\r\n\r\n    /**\r\n     * Value can be a mix of:\r\n     *\r\n     * @param values\r\n     */\r\n    constructor(A: Point, B: Point)\r\n    constructor(A: Point, d: Vector)\r\n    constructor(A: Point, d: Vector | Point) {\r\n        this.#OA = A.clone()\r\n        this.#d = (d instanceof Point) ? new Vector(A, d) : d.clone()\r\n        return this\r\n    }\r\n\r\n    clone = (): this => {\r\n        this.#d = this.#d.clone()\r\n        this.#OA = this.#OA.clone()\r\n\r\n        return this\r\n    }\r\n\r\n    get tex(): { parametric: string, system: string, cartesian: string } {\r\n        return {\r\n            parametric: `${Vector.asTex('x', 'y', 'z')} = ${Vector.asTex(this.#OA.x.tex, this.#OA.y.tex, this.#OA.z.tex)} + k\\\\cdot ${Vector.asTex(this.#d.x.tex, this.#d.y.tex, this.#d.z.tex)}`,\r\n            system: `\\\\left\\\\{\\\\begin{aligned}\r\n    x &= ${(new Polynom(this.#OA.x)\r\n                    .add(new Monom(this.#d.x).multiply(new Monom('k'))))\r\n                    .reorder('k', true)\r\n                    .tex}\\\\\\\\ \r\n    y &= ${(new Polynom(this.#OA.y)\r\n                    .add(new Monom(this.#d.y).multiply(new Monom('k'))))\r\n                    .reorder('k', true)\r\n                    .tex}\\\\\\\\\r\n    z &= ${(new Polynom(this.#OA.z)\r\n                    .add(new Monom(this.#d.z).multiply(new Monom('k'))))\r\n                    .reorder('k', true)\r\n                    .tex}\r\n\\\\end{aligned}\\\\right.`,\r\n            cartesian: `\\\\frac{ ${new Polynom('x', 1, this.#OA.x.clone().opposite()).tex} }{ ${this.direction.x.tex} } = \\\\frac{ ${new Polynom('y', 1, this.#OA.y.clone().opposite()).tex} }{ ${this.direction.y.tex} } = \\\\frac{ ${new Polynom('z', 1, this.#OA.z.clone().opposite()).tex} }{ ${this.direction.z.tex} }`\r\n        }\r\n    }\r\n\r\n    get display(): { parametric: string, system: string, cartesian: string } {\r\n        const OAx = this.#OA.x.display\r\n        const OAy = this.#OA.y.display\r\n        const OAz = this.#OA.z.display\r\n        const n = this.direction.simplify()\r\n        const nx = n.x.display\r\n        const ny = n.y.display\r\n        const nz = n.z.display\r\n\r\n        return {\r\n            parametric: `${Vector.asDisplay('x', 'y', 'z')} = ${Vector.asDisplay(this.#OA.x.display, this.#OA.y.display, this.#OA.z.display)} + k\\\\cdot ${Vector.asDisplay(this.#d.x.display, this.#d.y.display, this.#d.z.display)}`,\r\n            system: '',\r\n            cartesian: `(x-${OAx})/${nx} = (y-${OAy})/${ny} = (z-${OAz})/${nz}`\r\n        }\r\n    }\r\n\r\n    get OA(): Point {\r\n        return this.#OA\r\n    }\r\n\r\n    set OA(value: Point) {\r\n        this.#OA = value\r\n    }\r\n\r\n    get d(): Vector {\r\n        return this.#d\r\n    }\r\n\r\n    set d(value: Vector) {\r\n        this.#d = value\r\n    }\r\n\r\n    get direction(): Vector {\r\n        return this.#d.clone()\r\n    }\r\n\r\n    distanceTo(pt: Point): { value: number, fraction: Fraction, tex: string } {\r\n        // Distance is:\r\n        // |(x - x0) x d| / |d|\r\n        const AP = new Vector(this.#OA, pt),\r\n            d = this.direction,\r\n            d2 = this.direction.normSquare,\r\n            num2 = AP.cross(d).normSquare,\r\n            num2d2 = num2.clone().divide(d2),\r\n            dnum = num2d2.clone().sqrt()\r\n\r\n        console.log('CROSS', AP.cross(d).display)\r\n        return {\r\n            value: Math.sqrt(num2d2.value),\r\n            fraction: num2d2.clone().sqrt(),\r\n            tex: dnum.isExact() ? dnum.tex : `\\\\sqrt{${num2d2.tex}}`\r\n        }\r\n    }\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n\r\n    hitSegment(A: Point, B: Point): boolean {\r\n        const iPt = this.intersection(\r\n            new Line3(A, B)\r\n        )\r\n\r\n        // There is an intersection point\r\n        if (iPt.hasIntersection) {\r\n            return iPt.point.x.value >= Math.min(A.x.value, B.x.value)\r\n                && iPt.point.x.value <= Math.max(A.x.value, B.x.value)\r\n                && iPt.point.y.value >= Math.min(A.y.value, B.y.value)\r\n                && iPt.point.y.value <= Math.max(A.y.value, B.y.value)\r\n                && iPt.point.z.value >= Math.min(A.z.value, B.z.value)\r\n                && iPt.point.z.value <= Math.max(A.z.value, B.z.value)\r\n        }\r\n        return false\r\n    }\r\n\r\n    intersection = (line: Line3): { point: Vector, hasIntersection: boolean, isParallel: boolean, isSame: boolean } => {\r\n\r\n        throw new Error('Method not implemented.')\r\n    }\r\n\r\n    // ------------------------------------------\r\n    isOnLine = (pt: Point): boolean => {\r\n        return false\r\n    }\r\n\r\n    isParallelTo = (line: Line3): boolean => {\r\n        // Do they have the isSame direction ?\r\n        throw new Error('Method not implemented.')\r\n    }\r\n\r\n    isPerpendicularTo = (line: Line3): boolean => {\r\n        throw new Error('Method not implemented.')\r\n    }\r\n\r\n    isSameAs = (line: Line3): boolean => {\r\n        throw new Error('Method not implemented.')\r\n    }\r\n\r\n    isVertical = (): boolean => {\r\n        throw new Error('Method not implemented.')\r\n    }\r\n\r\n    get point(): Point {\r\n        return this.#OA.clone()\r\n    }\r\n\r\n    randomPoint = (max = 5): Point => {\r\n        const A = this.#OA.clone(),\r\n            k = new Fraction(randomIntSym(max, false))\r\n\r\n        return new Point(\r\n            A.x.clone().add(this.#d.x.clone().multiply(k)),\r\n            A.y.clone().add(this.#d.y.clone().multiply(k)),\r\n            A.z.clone().add(this.#d.z.clone().multiply(k))\r\n        )\r\n    }\r\n\r\n    // getValueAtX = (value: Fraction | number): Fraction => {\r\n    //     const equ = this.equation.clone().isolate('y'),\r\n    //         F = new Fraction(value)\r\n\r\n    //     if (equ instanceof Equation) {\r\n    //         return equ.right.evaluate({ x: F }) as Fraction\r\n    //     }\r\n    //     return new Fraction().invalid()\r\n    // }\r\n\r\n    // getValueAtY = (value: Fraction | number): Fraction => {\r\n    //     const equ = this.equation.clone().isolate('x'),\r\n    //         F = new Fraction(value)\r\n\r\n    //     if (equ instanceof Equation) {\r\n    //         return equ.right.evaluate({ y: F }) as Fraction\r\n    //     }\r\n\r\n    //     return new Fraction().invalid()\r\n    // }\r\n\r\n    simplify = (): this => {\r\n        throw new Error('Method not implemented.')\r\n        // const lcm = Numeric.lcm(this.#a.denominator, this.#b.denominator, this.#c.denominator),\r\n        //     gcd = Numeric.gcd(this.#a.numerator, this.#b.numerator, this.#c.numerator)\r\n\r\n        // this.fromCoefficient(\r\n        //     this.#a.clone().multiply(lcm).divide(gcd),\r\n        //     this.#b.clone().multiply(lcm).divide(gcd),\r\n        //     this.#c.clone().multiply(lcm).divide(gcd),\r\n        // )\r\n\r\n        // return this\r\n    }\r\n}","import {Equation} from \"../algebra/equation\"\r\nimport {Polynom} from \"../algebra/polynom\"\r\nimport {Fraction} from \"../coefficients/fraction\"\r\nimport {Line3} from \"./line3\"\r\nimport {Point} from \"./point\"\r\nimport {Vector} from \"./vector\"\r\nimport type {Plane3Config} from \"../pimath.interface\"\r\n\r\n\r\nexport class Plane3 {\r\n    #normal: Vector = new Vector(0, 0, 1)\r\n    #point: Point = new Point(0, 0, 0)\r\n\r\n    constructor(config?: Plane3Config) {\r\n        if (config) {\r\n            this.parse(config)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    parse(config: Plane3Config) {\r\n        if (config.point && config.normal) {\r\n            this.point = config.point\r\n            this.normal = config.normal\r\n            return\r\n        }\r\n\r\n        if (config.point && config.directions?.length === 2) {\r\n            this.point = config.point\r\n            const [v1, v2] = config.directions\r\n            this.normal = v1.cross(v2)\r\n            return\r\n        }\r\n\r\n        if (config.equation) {\r\n            const cartesian = config.equation.moveLeft().reduce().left\r\n\r\n            const a = cartesian.monomByLetter('x').coefficient\r\n            const b = cartesian.monomByLetter('y').coefficient\r\n            const c = cartesian.monomByLetter('z').coefficient\r\n            const d = cartesian.monomByDegree(0).coefficient\r\n\r\n            // Get the normal vector\r\n            this.normal = new Vector(a, b, c)\r\n\r\n            // Get a point on the plane\r\n            if (a.isNotZero()) {\r\n                this.point = new Point(d.clone().divide(a).opposite(), 0, 0)\r\n            } else if (b.isNotZero()) {\r\n                this.point = new Point(0, d.clone().divide(b).opposite(), 0)\r\n            } else {\r\n                this.point = new Point(0, 0, d.clone().divide(c).opposite())\r\n            }\r\n            // Make sure it's considered as point\r\n            return\r\n        }\r\n\r\n        if (config.points?.length === 3 && config.points.every(p => p instanceof Vector)) {\r\n            const A = config.points[0]\r\n            const B = config.points[1]\r\n            const C = config.points[2]\r\n\r\n            const AB = new Vector(A, B)\r\n            const AC = new Vector(A, C)\r\n            this.normal = AB.cross(AC)\r\n            this.point = A\r\n            return\r\n        }\r\n\r\n        if (config.coefficients?.length === 4) {\r\n            const [a, b, c, d] = config.coefficients\r\n            this.normal = new Vector(a, b, c)\r\n            this.point = new Point(0, 0, -d)\r\n            return\r\n        }\r\n    }\r\n\r\n    get tex(): string {\r\n        // return the cartesian equation of the plane\r\n        return new Equation(\r\n            new Polynom('xyz', this.a, this.b, this.c, this.d),\r\n            new Polynom(0)\r\n        ).reduce().tex\r\n    }\r\n\r\n    get display(): string {\r\n        // return the cartesian equation of the plane\r\n        return new Equation(\r\n            new Polynom('xyz', this.a, this.b, this.c, this.d),\r\n            new Polynom(0)\r\n        ).reduce().display\r\n    }\r\n\r\n    get a(): Fraction {\r\n        return this.#normal.x\r\n    }\r\n\r\n    angle(vector: Vector, sharp?: boolean, radian?: boolean): number\r\n\r\n    angle(line: Line3, sharp?: boolean, radian?: boolean): number\r\n\r\n    angle(plane: Plane3, sharp?: boolean, radian?: boolean): number\r\n\r\n    angle(value: Plane3 | Line3 | Vector, sharp?: boolean, radian?: boolean): number {\r\n        if (value instanceof Plane3) {\r\n            return this.normal.angle(value.normal, sharp, radian)\r\n        }\r\n\r\n        let direction: Vector\r\n        if (value instanceof Vector) {\r\n            if (value.dimension !== 3) {\r\n                throw new Error('Vector is not 3D')\r\n            }\r\n\r\n            direction = value\r\n        } else {\r\n            direction = value.direction\r\n        }\r\n\r\n        const a90 = radian ? Math.PI / 2 : 90\r\n        return a90 - this.normal.angle(direction, true, radian)\r\n    }\r\n\r\n    get b(): Fraction {\r\n        return this.#normal.y\r\n    }\r\n\r\n    get c(): Fraction {\r\n        return this.#normal.z\r\n    }\r\n\r\n    get d(): Fraction {\r\n        return this.#normal.dot(this.#point).opposite()\r\n    }\r\n\r\n    distanceTo(point: Vector): number {\r\n        return this.normal.dot(point).add(this.d).abs().value / this.normal.norm\r\n    }\r\n\r\n    intersectWithLine(line: Line3): Point {\r\n        const {point, direction} = line\r\n        const t = this.normal.dot(point).add(this.d).divide(this.normal.dot(direction).opposite())\r\n        return new Point(\r\n            new Vector(point)\r\n                .add(direction.clone().multiplyByScalar(t))\r\n        )\r\n    }\r\n\r\n    intersectWithPlane(plane: Plane3): Line3 {\r\n        const direction = this.normal.cross(plane.normal)\r\n\r\n        // Solve the asSystem:\r\n        // p1 // p2 // z=0\r\n        const pt = new Point(0, 0, 0)\r\n        throw new Error('Intersection with plane  not yet implemented !')\r\n        return new Line3(pt, direction)\r\n    }\r\n\r\n    isPointOnPlane(pt: Point): boolean {\r\n        return this.normal.dot(pt).add(this.d).isZero()\r\n    }\r\n\r\n    get normal(): Vector {\r\n        return this.#normal\r\n    }\r\n\r\n    set normal(value: Vector | Point) {\r\n        this.#normal = new Vector(value)\r\n    }\r\n\r\n    get point(): Point {\r\n        return this.#point\r\n    }\r\n\r\n    set point(value: Point | Vector) {\r\n        this.#point = new Point(value)\r\n    }\r\n}","import {Point} from \"./point\"\r\nimport {Fraction} from \"../coefficients\"\r\nimport {Equation, Polynom} from \"../algebra\"\r\nimport type {InputValue} from \"../pimath.interface\"\r\n\r\nenum SPHERE3_FORMAT {\r\n    DEVELOPPED,\r\n    CENTER_RADIUS\r\n}\r\n\r\nexport enum SPHERE3_RELATIVE_POSITION {\r\n    INTERIOR,\r\n    EXTERIOR,\r\n    SECANT,\r\n    TANGENT_INSIDE,\r\n    TANGENT_OUTSIDE,\r\n    SUPERPOSED,\r\n    CONCENTRIC\r\n}\r\n\r\nexport class Sphere3 {\r\n    #center: Point | undefined = undefined\r\n    #squareRadius: Fraction | undefined = undefined\r\n    #equation: Equation | undefined = undefined\r\n    #format: SPHERE3_FORMAT = SPHERE3_FORMAT.CENTER_RADIUS\r\n\r\n    constructor(center?: Point, radius?: InputValue<Fraction>) {\r\n        if (center && radius) {\r\n            this.#center = center\r\n            this.#squareRadius = new Fraction(radius).clone().pow(2)\r\n            this.#computeEquation()\r\n        }\r\n        return this\r\n    }\r\n\r\n    fromEquation(equation: Equation | string): this {\r\n        const equ = new Equation(equation).moveLeft().reduce()\r\n\r\n        // Check that x, y, z has the same power and same coefficient.\r\n        const letters = ['x', 'y', 'z']\r\n\r\n        if (letters.some((letter) => equ.degree(letter).value !== 2)){\r\n            return this.makeUndefined()\r\n        }\r\n\r\n        const coefficient = equ.left.monomByDegree(2, 'x').coefficient\r\n        if (letters.some((letter) => equ.left.monomByDegree(2, letter).coefficient.isNotEqual(coefficient))) {\r\n            return this.makeUndefined()\r\n        }\r\n\r\n        this.#center = new Point(\r\n            equ.left.monomByDegree(1, 'x').coefficient.clone().opposite().divide(2),\r\n            equ.left.monomByDegree(1, 'y').coefficient.clone().opposite().divide(2),\r\n            equ.left.monomByDegree(1, 'z').coefficient.clone().opposite().divide(2)\r\n        )\r\n\r\n        this.#squareRadius = equ.left.monomByDegree(0)\r\n            .coefficient.clone().opposite()\r\n            .add(this.#center.x.clone().pow(2))\r\n            .add(this.#center.y.clone().pow(2))\r\n            .add(this.#center.z.clone().pow(2))\r\n\r\n        this.#computeEquation()\r\n        return this\r\n    }\r\n\r\n    get center(): Point {\r\n        if (this.#center === undefined) {\r\n            throw new Error('Sphere3 is undefined')\r\n        }\r\n        return this.#center\r\n    }\r\n\r\n    get squareRadius(): Fraction {\r\n        if (this.#squareRadius === undefined) {\r\n            throw new Error('Sphere3 is undefined')\r\n        }\r\n        return this.#squareRadius\r\n    }\r\n\r\n    get radius(): { tex: string, display: string, value: number } {\r\n        if (this.#squareRadius === undefined) {\r\n            throw new Error('Sphere3 is undefined')\r\n        }\r\n\r\n        if (this.#squareRadius.isSquare()) {\r\n            return {\r\n                tex: this.#squareRadius.clone().sqrt().tex,\r\n                display: this.#squareRadius.clone().sqrt().display,\r\n                value: this.#squareRadius.clone().sqrt().value\r\n            }\r\n        } else {\r\n            return {\r\n                tex: `\\\\sqrt{${this.#squareRadius.tex}}`,\r\n                display: `sqrt(${this.#squareRadius.display})`,\r\n                value: this.#squareRadius.clone().sqrt().value\r\n            }\r\n        }\r\n    }\r\n\r\n    get equation(): Equation {\r\n        if (this.#equation === undefined) {\r\n            throw new Error('Sphere3 is undefined')\r\n        }\r\n        return this.#equation\r\n    }\r\n\r\n    makeUndefined(): this {\r\n        this.#center = undefined\r\n        this.#squareRadius = undefined\r\n        this.#equation = undefined\r\n        return this\r\n    }\r\n\r\n    get centerRadius(): this {\r\n        this.#format = SPHERE3_FORMAT.CENTER_RADIUS\r\n        return this\r\n    }\r\n\r\n    get developped(): this {\r\n        this.#format = SPHERE3_FORMAT.DEVELOPPED\r\n        return this\r\n    }\r\n\r\n\r\n    get tex(): string {\r\n        return this.#output(true)\r\n    }\r\n\r\n    get display(): string {\r\n        return this.#output(false)\r\n    }\r\n\r\n    #output = (asTex: boolean): string => {\r\n        if (this.#equation === undefined) {\r\n            throw new Error('Sphere3 is undefined')\r\n        }\r\n\r\n        if (this.#format === SPHERE3_FORMAT.DEVELOPPED) {\r\n            return asTex ? this.#equation.tex : this.#equation.display\r\n        }\r\n\r\n        const output: string[] = []\r\n        const letters: ('x' | 'y' | 'z')[] = ['x', 'y', 'z']\r\n\r\n        letters.forEach((letter: 'x' | 'y' | 'z') => {\r\n            if (this.center[letter].isZero()) {\r\n                output.push(`${letter}^2`)\r\n            } else {\r\n                const P = new Polynom(letter).subtract(this.center[letter])\r\n                output.push(\r\n                    asTex ?\r\n                        `\\\\(${P.tex}\\\\)^2` :\r\n                        `(${P.display})^2`\r\n                )\r\n            }\r\n        })\r\n\r\n        return output.join('+') + '=' + (asTex ? this.squareRadius.tex : this.squareRadius.display)\r\n\r\n    }\r\n\r\n    #computeEquation(): void {\r\n        this.#equation = new Equation(\r\n            new Polynom('x').subtract(this.center.x).pow(2)\r\n                .add(\r\n                    new Polynom('y').subtract(this.center.y).pow(2)\r\n                )\r\n                .add(\r\n                    new Polynom('z').subtract(this.center.z).pow(2)\r\n                ),\r\n            new Polynom(this.squareRadius)\r\n        ).reduce()\r\n    }\r\n\r\n    static RELATIVE_POSITION = SPHERE3_RELATIVE_POSITION\r\n    relativePosition = (S: Sphere3): SPHERE3_RELATIVE_POSITION => {\r\n        const distance = this.center.distanceTo(S.center).value\r\n        const r1 = this.radius.value\r\n        const r2 = S.radius.value\r\n\r\n        if (distance > r1 + r2) {\r\n            return SPHERE3_RELATIVE_POSITION.EXTERIOR\r\n        }\r\n\r\n        if (distance === r1 + r2) {\r\n            return SPHERE3_RELATIVE_POSITION.TANGENT_OUTSIDE\r\n        }\r\n\r\n        if(distance===0) {\r\n            return r1===r2 ? SPHERE3_RELATIVE_POSITION.SUPERPOSED : SPHERE3_RELATIVE_POSITION.CONCENTRIC\r\n        }\r\n\r\n        if (distance === Math.abs(r1 - r2)) {\r\n            return SPHERE3_RELATIVE_POSITION.TANGENT_INSIDE\r\n        }\r\n\r\n\r\n        if (distance < Math.abs(r1 - r2)) {\r\n            return SPHERE3_RELATIVE_POSITION.INTERIOR\r\n        }\r\n\r\n        return SPHERE3_RELATIVE_POSITION.SECANT\r\n\r\n    }\r\n\r\n    isPointOnSphere = (P: Point): boolean => {\r\n        return this.#equation?.test({\r\n            x: P.x,\r\n            y: P.y,\r\n            z: P.z\r\n        }) ?? false\r\n    }\r\n}","import type { randomCoefficientConfig } from \"../rndTypes\"\r\nimport { Fraction } from \"../../coefficients/fraction\"\r\nimport { randomInt, randomIntSym } from \"../rndHelpers\"\r\n\r\nexport function rndFraction(userConfig?: randomCoefficientConfig): Fraction {\r\n    const config = Object.assign(\r\n        {\r\n            negative: true,\r\n            max: 10,\r\n            reduced: true,\r\n            zero: true,\r\n            natural: false\r\n        }, userConfig)\r\n\r\n    // Create a null fraction\r\n    const Q = new Fraction()\r\n\r\n\r\n    if (config.negative) {\r\n        // Allow negative numbers\r\n        Q.numerator = randomIntSym(config.max, config.zero)\r\n    } else {\r\n        // Only positive numbers\r\n        Q.numerator = randomInt(config.zero ? 0 : 1, config.max)\r\n    }\r\n\r\n    if (config.natural) {\r\n        Q.denominator = 1\r\n    } else {\r\n        let securityCount = 0\r\n        while (Q.isRelative() && securityCount < 10) {\r\n            Q.denominator = randomInt(1, config.max)\r\n            securityCount++\r\n        }\r\n    }\r\n\r\n    return config.reduced ? Q.reduce() : Q\r\n}\r\n","import type { randomMonomConfig } from \"../rndTypes\"\r\nimport { Monom } from \"../../algebra/monom\"\r\nimport { rndFraction } from \"../coefficient/rndFraction\"\r\nimport { randomItem } from \"../rndHelpers\"\r\n\r\nexport function rndMonom(userConfig?: randomMonomConfig): Monom {\r\n    const config = Object.assign(\r\n        {\r\n            letters: 'x',\r\n            degree: 2,\r\n            fraction: true,\r\n            zero: false\r\n        }, userConfig)\r\n\r\n    // Create a monom instance\r\n    const M = new Monom()\r\n\r\n    // Generate the coefficient\r\n    M.coefficient = rndFraction({\r\n        zero: config.zero,\r\n        reduced: true,\r\n        natural: !config.fraction\r\n    })\r\n\r\n    if (config.letters.length > 1) {\r\n        // Initialise each items...\r\n        for (const L of config.letters.split('')) {\r\n            M.setLetter(L, 0)\r\n        }\r\n        for (let i = 0; i < config.degree; i++) {\r\n            const L = randomItem(config.letters.split(\"\"))\r\n            M.setLetter(L, M.degree(L).clone().add(1))\r\n        }\r\n    } else {\r\n        M.setLetter(config.letters, config.degree)\r\n    }\r\n\r\n    return M\r\n}","import type { randomPolynomConfig } from \"../rndTypes\"\r\nimport { rndMonom } from \"./rndMonom\"\r\nimport { Polynom, Monom } from \"../../algebra\"\r\nimport { randomInt } from \"../rndHelpers\"\r\n\r\nconst factorableConfig = {\r\n    letters: 'x',\r\n    degree: 2,\r\n    fraction: false,\r\n    zero: false,\r\n    unit: false,\r\n    factorable: false,\r\n    allowNullMonom: true,\r\n    numberOfMonoms: 0,\r\n    positive: true\r\n}\r\n\r\nexport function rndPolynom(userConfig?: randomPolynomConfig): Polynom {\r\n    const config = Object.assign(\r\n        factorableConfig,\r\n        userConfig\r\n    )\r\n\r\n    // TODO: Create a factorable polynom does not work !!!!!\r\n\r\n    // Create the polynom\r\n    const P = new Polynom().empty()\r\n\r\n    let M: Monom\r\n\r\n    for (let i = config.degree; i >= 0; i--) {\r\n        // Create monom of corresponding degree.\r\n        M = rndMonom({\r\n            letters: config.letters,\r\n            degree: i,\r\n            fraction: config.fraction,\r\n            zero: (i === config.degree) ? false : config.allowNullMonom\r\n        })\r\n\r\n        // If degree is the greatest and unit is true, set the monom value to one.\r\n        if (config.unit && config.degree === i) {\r\n            M.coefficient.one()\r\n        }\r\n\r\n        // Add to the polynom\r\n        P.add(M)\r\n    }\r\n\r\n    // Make sure the first monom is positive.\r\n    if (config.positive && P.monomByDegree().coefficient.isNegative()) {\r\n        P.monomByDegree().coefficient.opposite()\r\n    }\r\n\r\n    // If the number of monoms is greater than the allowed value, remove some of them... except the first one !\r\n    if (config.numberOfMonoms\r\n        && config.numberOfMonoms > 0\r\n        && config.numberOfMonoms < P.length) {\r\n        while (P.length > config.numberOfMonoms) {\r\n            // Remove a random monom, except the first one\r\n            const index = randomInt(1, P.length - 1)\r\n\r\n            P.monoms.splice(index, 1)\r\n        }\r\n    }\r\n\r\n    return P.reduce()\r\n}\r\n\r\nexport function rndFactorablePolynom(userConfig?: randomPolynomConfig): Polynom {\r\n    const config = Object.assign(\r\n        factorableConfig,\r\n        userConfig\r\n    )\r\n\r\n    const P = new Polynom().one()\r\n\r\n    const _factorableConfig = { ...config }\r\n    _factorableConfig.degree = 1\r\n    _factorableConfig.factorable = false\r\n\r\n    for (let i = 0; i < config.degree; i++) {\r\n        P.multiply(rndPolynom(_factorableConfig))\r\n    }\r\n\r\n    return P.reduce()\r\n}","import type { randomEquationConfig } from \"../rndTypes\"\r\nimport { Polynom } from \"../../algebra/polynom\"\r\nimport { Equation } from \"../../algebra/equation\"\r\nimport { rndPolynom } from \"./rndPolynom\"\r\n\r\nexport function rndEquation(userConfig?: randomEquationConfig): Equation {\r\n    const config = Object.assign(\r\n        {\r\n            letters: 'x',\r\n            degree: 1,\r\n            fraction: false,\r\n            zero: false,\r\n            unit: false,\r\n            factorable: false,\r\n            allowNullMonom: true,\r\n            numberOfMonoms: 0,\r\n            positive: true,\r\n            solution: {\r\n                allowZero: true,\r\n                fraction: false,\r\n                nothing: false,\r\n                everything: false\r\n            }\r\n        }, userConfig)\r\n\r\n    // Create a polynom\r\n    const P = new Polynom().one()\r\n\r\n    for (let i = 0; i < config.degree; i++) {\r\n        const factor = rndPolynom({\r\n            degree: 1,\r\n            unit: config.unit,\r\n            fraction: config.fraction,\r\n            letters: config.letters,\r\n            zero: config.zero\r\n        })\r\n        P.multiply(factor)\r\n    }\r\n\r\n    return new Equation(P, 0)\r\n}\r\n","import { Fraction } from \"../../coefficients/fraction\"\r\nimport type { randomGeometryPointConfig } from \"../rndTypes\"\r\nimport { rndFraction } from \"../coefficient/rndFraction\"\r\nimport { randomIntSym } from \"../rndHelpers\"\r\nimport { Point } from \"../../geometry/point\"\r\n\r\nexport function rndVector(userConfig?: randomGeometryPointConfig): Point {\r\n    const config: {\r\n        axis: 'x' | 'y' | 'z' | null,\r\n        fraction: boolean,\r\n        max: number,\r\n        quadrant: number | null\r\n    } = Object.assign(\r\n        {\r\n            axis: true,\r\n            fraction: false,\r\n            max: 10,\r\n            quadrant: null\r\n        }, userConfig)\r\n\r\n    const zeroX = config.axis === 'x',\r\n        zeroY = config.axis === 'y'\r\n\r\n\r\n    const x = config.fraction ?\r\n        rndFraction({ max: config.max, zero: zeroX }) :\r\n        new Fraction(randomIntSym(config.max, zeroX))\r\n\r\n    const y = config.fraction ?\r\n        rndFraction({ max: config.max, zero: zeroY }) :\r\n        new Fraction(randomIntSym(config.max, zeroY))\r\n\r\n    if (Number(config.quadrant) === 1) {\r\n        x.abs()\r\n        y.abs()\r\n    }\r\n    if (Number(config.quadrant) === 2) {\r\n        if (x.isPositive()) {\r\n            x.opposite()\r\n        }\r\n        if (y.isNegative()) {\r\n            y.opposite()\r\n        }\r\n    }\r\n    if (Number(config.quadrant) === 3) {\r\n        if (x.isPositive()) {\r\n            x.opposite()\r\n        }\r\n        if (y.isPositive()) {\r\n            y.opposite()\r\n        }\r\n    }\r\n    if (Number(config.quadrant) === 4) {\r\n        if (x.isNegative()) {\r\n            x.opposite()\r\n        }\r\n        if (y.isPositive()) {\r\n            y.opposite()\r\n        }\r\n    }\r\n\r\n    return new Point(x, y)\r\n}\r\n","import { Circle } from \"../../geometry/circle\"\r\nimport { randomInt } from \"../rndHelpers\"\r\nimport type { randomGeometryCircleConfig } from \"../rndTypes\"\r\nimport { rndVector } from \"./rndVector\"\r\n\r\nexport function rndCircle(userConfig?: randomGeometryCircleConfig): Circle {\r\n    const config = Object.assign(\r\n        {\r\n            center: {\r\n                x: { min: -10, max: 10 },\r\n                y: { min: -10, max: 10 }\r\n            },\r\n            pointsOnCircle: 8\r\n        }, userConfig)\r\n\r\n    const center = rndVector(config.center)\r\n\r\n    let rv, r\r\n    if (config.pointsOnCircle === 8) {\r\n        rv = randomInt(1, 3),\r\n            r = rv ** 2 + (rv + 1) ** 2\r\n    } else {\r\n        r = randomInt(1, 20)\r\n    }\r\n\r\n    return new Circle(center, r, true)\r\n}","import { Line } from \"../../geometry/line\"\r\nimport { Vector } from \"../../geometry/vector\"\r\nimport { randomIntSym } from \"../rndHelpers\"\r\nimport type { randomGeometryLineConfig } from \"../rndTypes\"\r\n\r\nexport function rndLine(userConfig?: randomGeometryLineConfig): Line {\r\n    const config = Object.assign(\r\n        {\r\n            A: {\r\n                x: randomIntSym(10),\r\n                y: randomIntSym(10)\r\n            },\r\n        }, userConfig)\r\n\r\n    // The A point exists.\r\n    const d = new Vector(\r\n        randomIntSym(10),\r\n        randomIntSym(10)\r\n    )\r\n\r\n    while (d.isNull) {\r\n        d.x = randomIntSym(10)\r\n        d.y = randomIntSym(10)\r\n    }\r\n\r\n    if (config.slope === 1) {\r\n        if (d.x.sign() !== d.y.sign()) {\r\n            d.y.opposite()\r\n        }\r\n    } else if (config.slope === -1) {\r\n        if (d.x.sign() !== d.y.sign()) {\r\n            d.y.opposite()\r\n        }\r\n    }\r\n\r\n    return new Line().fromPointAndDirection(new Vector(config.A.x, config.A.y), d)\r\n}","import { Line3 } from \"../../geometry/line3\"\r\nimport { Point } from \"../../geometry/point\"\r\nimport { Vector } from \"../../geometry/vector\"\r\nimport { randomIntSym } from \"../rndHelpers\"\r\nimport type { randomGeometryLine3Config } from \"../rndTypes\"\r\n\r\nexport function rndLine3(userConfig?: randomGeometryLine3Config): Line3 {\r\n    const config = Object.assign(\r\n        {\r\n            A: {\r\n                x: randomIntSym(10),\r\n                y: randomIntSym(10),\r\n                z: randomIntSym(10)\r\n            },\r\n            direction: {\r\n                x: randomIntSym(10),\r\n                y: randomIntSym(10),\r\n                z: randomIntSym(10)\r\n            }\r\n        }, userConfig)\r\n\r\n    // The direction vector exists.\r\n    const A = new Point(config.A.x, config.A.y, config.A.z)\r\n    const d = new Vector(config.direction.x, config.direction.y, config.direction.z)\r\n\r\n    return new Line3(A, d)\r\n}","import type {\r\n    randomCoefficientConfig,\r\n    randomEquationConfig,\r\n    randomGeometryCircleConfig,\r\n    randomGeometryLine3Config,\r\n    randomGeometryLineConfig,\r\n    randomGeometryPointConfig,\r\n    randomMonomConfig,\r\n    randomPolynomConfig\r\n} from \"./rndTypes\"\r\n\r\nimport {randomArray, randomBool, randomInt, randomIntSym, randomItem, randomPrime, shuffleArray} from \"./rndHelpers\"\r\nimport {rndFraction} from \"./coefficient/rndFraction\"\r\nimport {rndMonom} from \"./algebra/rndMonom\"\r\nimport {rndPolynom} from \"./algebra/rndPolynom\"\r\nimport {rndEquation} from \"./algebra/rndEquation\"\r\nimport {rndCircle} from \"./geometry/rndCircle\"\r\nimport {rndLine} from \"./geometry/rndLine\"\r\nimport {rndLine3} from \"./geometry/rndLine3\"\r\nimport {rndVector} from \"./geometry/rndVector\"\r\nimport {Point} from \"../geometry\"\r\n\r\nexport type * from \"./rndTypes\"\r\n\r\nexport const Random = {\r\n    equation: (config?: randomEquationConfig) => {\r\n        return rndEquation(config)\r\n    },\r\n\r\n    polynom: (config?: randomPolynomConfig) => {\r\n        return rndPolynom(config)\r\n    },\r\n\r\n    monom: (config?: randomMonomConfig) => {\r\n        return rndMonom(config)\r\n    },\r\n\r\n    fraction: (config?: randomCoefficientConfig) => {\r\n        return rndFraction(config)\r\n    },\r\n\r\n    number: (from: number, to: number, exclude?: number[]): number => {\r\n        return randomInt(from, to, exclude)\r\n    },\r\n\r\n    numberSym: (max: number, allowZero?: boolean): number => {\r\n        return randomIntSym(max, allowZero)\r\n    },\r\n\r\n    prime: (max: number): number => {\r\n        return randomPrime(max)\r\n    },\r\n\r\n    bool: (percent?: number): boolean => {\r\n        return randomBool(percent)\r\n    },\r\n\r\n    array: <T>(arr: T[], number?: number): T[] => {\r\n        return randomArray(arr, number)\r\n    },\r\n\r\n    item: <T>(arr: T[]): T => {\r\n        return randomItem(arr)\r\n    },\r\n\r\n    shuffle: <T>(arr: T[]): T[] => {\r\n        return shuffleArray(arr)\r\n    },\r\n\r\n    line: (config?: randomGeometryLineConfig) => {\r\n        return rndLine(config)\r\n    },\r\n\r\n    line3: (config?: randomGeometryLine3Config) => {\r\n        return rndLine3(config)\r\n    },\r\n\r\n    vector: (config?: randomGeometryPointConfig) => {\r\n        return rndVector(config)\r\n    },\r\n\r\n    point: (config?: randomGeometryPointConfig) => {\r\n        return new Point(rndVector(config))\r\n    },\r\n\r\n    circle: (config?: randomGeometryCircleConfig) => {\r\n        return rndCircle(config)\r\n    }\r\n}","// Expose as global\r\nexport * from \"./coefficients\"\r\nexport * from \"./algebra\"\r\nexport * from \"./geometry\"\r\n\r\n// Import items individually to make a global object\r\n\r\n// Coefficients\r\nimport {Fraction, NthRoot} from \"./coefficients\"\r\n\r\n// Algebra\r\nimport {Equation, Factor, LinearSystem, LogicalSet, Monom, PolyFactor, Polynom, Matrix} from \"./algebra\"\r\n\r\n// Geometry\r\nimport {Circle, Line, Line3, Plane3, Point, Triangle, Vector, Sphere3} from \"./geometry\"\r\n\r\n// Numeric\r\nimport {Numeric} from \"./numeric\"\r\nexport {Numeric}\r\n\r\n// NumExp\r\nimport {NumExp} from \"piexpression\"\r\nexport {NumExp}\r\n\r\n// randomization\r\nimport {Random} from \"./randomization/random\"\r\nexport {Random}\r\n\r\n// Typesetting\r\nexport type * from \"./pimath.interface\"\r\n\r\n// Make a global object\r\nconst PiMath = {\r\n    Numeric,\r\n    Fraction,\r\n    Root: NthRoot,\r\n    Monom,\r\n    Polynom,\r\n    Equation,\r\n    Matrix,\r\n    LinearSystem,\r\n    Factor,\r\n    PolyFactor,\r\n    LogicalSet,\r\n    Random,\r\n    Geometry: {\r\n        Vector,\r\n        Point,\r\n        Line,\r\n        Triangle,\r\n        Circle,\r\n        Line3,\r\n        Plane3,\r\n        Sphere3\r\n    },\r\n    NumExp\r\n}\r\n\r\n// Export as default value\r\nexport default PiMath\r\n"],"names":["decompose","value","divs","dividers","arr","u","v","divideNumbersByGCD","values","g","greatestCommonDivisor","x","absV","maxV","D","i","a","b","gcd2","leastCommonMultiple","numberCorrection","number_of_digits","periodic","primes","nb","primesValues","pythagoreanTripletsWithTarget","target","targetIsSquare","triplets","targetValue","round","decimals","greatestPower","index","search_value","radical","factor","pow","Numeric","FRAC_TYPE","Fraction","#approximative","#denominator","#digits","#numerator","#type","#withSign","denominatorOrPeriodic","S","decimal","p","power","F","plus","fractions","M","f","num","den","m","compare","reverse","sorted","lcm","unique","distinct","R","N","k","sign","compareFraction","Q","n","than","controlNumerator","controlDenominator","result","NthRoot","#radical","#nth","#coefficient","#isValid","C","nthroot","coefficient","V","EquationSolver","#bissectionCompexityCounter","#bissectionDeltaX","#leftPolynom","#variable","left","right","variable","equ","degree","#solveLinear","#solveQuadratic","solutions","polynom","#solveByFactorization","#solveByBissection","#solveCubic_CardanFormula","#makeApproximativeSolution","output","#makeSolution","fraction","B","evaluatedPoints","#solveByBissection_evaluatePoints","#solveByBissection_getCouples","couple","bissection","#solveByBissection_algorithm","fa","fb","mid","fmid","bounds","slice","dx","searchValue","couples","previous","min","curr","dividersA","dividersB","testingSolutions","da","db","s","zeroPolynom","solver","c","d","an","bn","cn","q","P","delta","x1","x2","pv","qv","anv","delta2","f1","f2","#solveQuadratic_Output","deltaFactor","gcd","b2","a2","deltaGcd","deltaTex","deltaDisplay","texOutput","displayOutput","T","e","o","O","r","t","l","E","h","I","#i","#s","#e","#n","#t","A","Monom","#literal","inputStr","#cloneLiteral","#shutingYardToReducedMonom","L","letters","letter","monoms","mAsMonom","dM","literals","monomDividers","asNumeric","#evaluateAsNumeric","tmpValues","primitive","div","M1","M2","K","item","key","rpn","ShutingYard","stack","element","ShutingyardType","#shutingYard_AddToken","q1","q2","tmpList","litt","currentLetter","wrapParenthesis","str","tex","stripParenthesis","replace_in_array","haystack","search","start","end","operation_pow","Polynom","#defaultVariable","#factors","#monoms","#roots","#rootsCache","polynomString","#parseString","#genDisplay","numerator","denominator","dP","#divideByFraction","#divideByInteger","quotient","reminder","maxMP","degreeP","newM","MaxIteration","monom","factors","tempPolynom","securityLoop","maxDegree","allDividers","#getAllPotentialFactors","pX","pC","dX","dC","coeff","orderedPolynom","length","coeffs","denominators","numerators","valuesA","valuesB","pString","zero","#compare","Ms","#multiplyByPolynom","#multiplyByFraction","#multiplyByMonom","#multiplyByInteger","j","revert","otherLetters","resultPolynom","roots","signs","_x","_root","test","cP1","cP2","m1","nbF","#factorize2ndDegree","P1","P2","xFactors","xyzPolynom","forceSign","wrapParentheses","withAllMultiplicationSign","m2","m1d","m2d","#shutingYardToReducedPolynom","#shutingYard_addToken","Equation","#left","#right","#sign","equationString","strSign","#findSign","pStr","#formatSign","solutionAsTex","uniqueSolutions","sol","p1","p2","mMove","cMove","#reverseSign","allLeft","move","signStr","Factor","#displayMode","#polynom","#power","#singleMode","base","tos","FACTOR_DISPLAY","LinearSystem","#equations","#steps","#variables","equations","#findLetters","LS","matrix","cols","row","vars","operators","equStr","equArray","operatorsColumns","#makeMatrix","equation1","equation2","eq1multiplied","eq2multiplied","emptyLS","vector","augmentedMatrix","pivot","row_to_add","coefficients","reference","acc","LogicalSet","#rpn","ShutingyardMode","token","varStack","second","first","#evaluateAsVenn","tokenSets","referenceSet","PolyFactor","#extractNumeratorAndDenominator","numTeX","denTeX","#gcdWith","PF1","PF2","factors1","keyFactors","factors2","power2","#lcmWith","PF","remainingPolynom","pf","dPF","derivativeFactor","newFactors","self","aPower","bPower","aLength","bLength","aDegree","bDegree","roots_key","empty_signs","root","aligned_signs","_sign","rootSign","k_numerator","k_denominator","kF","Matrix","#matrix_parenthesis","#values","rowCount","colCount","duplicates","dup_row","wrapper","aij","rows","rows2","cols2","column","coMatrix","det","callback","rowItems","vectors","cofactors_matrix","_","determinant","aij_are_equals","col","areVectorsEquals","v1","v2","areVectorsColinears","dotProduct","determinantFromVectors","TupleN","#array","components","Root","#factor","#index","#parse_sqrt","#parse_root","rad","rt","greatest","index_radical","Point","nbs","distance2","V1","V2","Vector","sharp","radian","scalar","y","norm","LinePropriety","Line3Propriety","randomBool","percent","randomInt","exclude","randomIntSym","max","randomPrime","randomItem","randomArray","number","shuffleArray","temp","Line","#OA","#a","#b","#c","#outputMode","canonical","pt","d2","elem","orientation","iPt","line","Pt","isParallel","isSame","maxIterationTest","Triangle","#A","#B","#C","#lines","#radians","#remarquables","#updateTriangle","#getSegment","y1","y2","x3","y3","line1","line2","line3","AB","BC","AC","intersect","name","#cosThm","dAB","dBC","dAC","#calculateBisectors","tlines","d1","d1n","d2n","d1Equ","d2Equ","b1","#calculateRemarquableLines","middles","medians","mediators","heights","bA","bB","bC","bisectors","externalBisectors","remarquables","opposite","adjacent1","adjacent2","ratio","#getPointByName","ptName","ptName1","ptName2","Solution","#display","#exact","#fraction","#isZero","#root","#tex","root1","root2","sol1","sol2","Circle","#center","#equation","#output_style","#squareRadius","circle","#calculateCartesian","cx","cy","center","pointThrough","radius","square","#reset","mAB","mAC","points","triplet","OP","OX","OX1","OX2","distance","#tangentsWithSlope","#tangentsThroughOnePointOnTheCircle","#tangentsThroughOnePointOutsideTheCircle","CT","cx_px","cy_py","polyLeft","polyRight","slope","c1","c2","sq","Line3","#d","OAx","OAy","OAz","nx","ny","nz","AP","num2","num2d2","dnum","Plane3","#normal","#point","config","cartesian","direction","point","plane","SPHERE3_RELATIVE_POSITION","Sphere3","#format","#computeEquation","equation","#output","asTex","r1","r2","rndFraction","userConfig","securityCount","rndMonom","factorableConfig","rndPolynom","rndEquation","rndVector","zeroX","zeroY","rndCircle","rv","rndLine","rndLine3","Random","from","to","allowZero","PiMath","NumExp"],"mappings":"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AAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,IAAI;AACviO,SAAID,MAAO,SACAC,IAEAA,EAAa,MAAM,GAAG,KAAK,IAAIA,EAAa,QAAQD,CAAE,CAAC;AAEtE;AAEA,SAASE,GAA8BC,GAAgBC,GAAsC;AAEzF,QAAMC,IAAW,CAAA,GACbC,IAAcF,MAAmB,KAAO,CAACD,IAASA,KAAU;AAChE,WAAStB,IAAI,GAAGA,KAAKsB,GAAQtB;AACzB,aAASC,IAAI,GAAGA,KAAKqB,GAAQrB;AACzB,MAAID,KAAK,IAAIC,KAAK,MAAMwB,KACpBD,EAAS,KAAK,CAACxB,GAAGC,GAAGqB,CAAM,CAAC;AAKxC,SAAOE;AACX;AAEA,SAASE,GAAM9B,GAAe+B,IAAW,GAAW;AAGhD,SAAO,CAAO,GAFM,KAAK,MAAM,CAAO,GAAG/B,CAAK,IAAI+B,CAAQ,EAAG,CAEzC,KAAKA,CAAQ;AACrC;AAEA,SAASC,GAAchC,GAAeiC,GAAuB;AACzD,MAAIC,IAAe,KAAK,MAAM,KAAK,IAAIlC,GAAO,IAAIiC,CAAK,CAAC;AAExD,QAAME,IAAUnC,GACVoC,IAAS;AAEf,SAAOF,IAAe,KAAG;AACrB,UAAMG,IAAM,KAAK,IAAIH,GAAcD,CAAK;AACxC,QAAIE,IAAUE,MAAQ;AAClB,aAAOA;AAGX,IAAAH;AAAA,EACJ;AAEA,SAAOE;AACX;AAGO,MAAME,IAAU;AAAA,EACnB,WAAAvC;AAAA,EACA,UAAAG;AAAA,EACA,oBAAAI;AAAA,EACA,KAAKG;AAAA,EACL,KAAKS;AAAA,EACL,kBAAAC;AAAA,EACA,UAAAE;AAAA,EACA,QAAAC;AAAA,EACA,+BAAAG;AAAA,EACA,OAAAK;AAAA,EACA,eAAAE;AACJ;AChMO,IAAKO,uBAAAA,OACRA,EAAA,OAAO,QACPA,EAAA,QAAQ,SACRA,EAAA,QAAQ,SAHAA,IAAAA,MAAA,CAAA,CAAA;AAWL,MAAMC,EAAmE;AAAA,EAC5EC,KAAiB;AAAA,EACjBC,KAAe;AAAA,EACfC,KAAU;AAAA,EACVC,KAAa;AAAA,EACbC,KAAmB;AAAA,EACnBC,KAAY;AAAA,EAMZ,YAAY9C,GAA8B+C,GAAgC;AAEtE,WAAI/C,MAAU,UACV,KAAK,MAAMA,GAAO+C,CAAqB,GAGpC;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,QAAQ,CAAC/C,GAA6B+C,MAA6C;AACtF,QAAIC;AAGJ,QAAIhD,MAAU;AACV,kBAAK4C,KAAa,GAClB,KAAKF,KAAe,GACb;AAGX,YAAQ,OAAO1C,GAAA;AAAA,MACX,KAAK;AAcD,YAZAgD,IAAIhD,EAAM,MAAM,GAAG,GAGfgD,EAAE,SAAS,MACX,KAAKJ,KAAa,MAGlBI,EAAE,IAAI,CAAAtC,MAAKA,MAAM,MAAM,MAAM,OAAOA,CAAC,CAAC,CAAC,EAAE,SAAS,EAAI,MACtD,KAAKkC,KAAa,MAIlBI,EAAE,WAAW;AAEb,iBAAO,KAAK,MAAM,CAACA,EAAE,CAAC,CAAC;AAC3B,QAAWA,EAAE,WAAW,IAGhBA,EAAE,CAAC,MAAM,OACT,KAAKJ,KAAa,KAClB,KAAKF,KAAe,MAEpB,KAAKE,KAAa,CAACI,EAAE,CAAC,GACtB,KAAKN,KAAe,CAACM,EAAE,CAAC,MAK5B,KAAKJ,KAAa,KAClB,KAAKF,KAAe;AAExB;AAAA,MACJ,KAAK;AACD,YAAI,OAAO,cAAc1C,CAAK;AAE1B,eAAK4C,KAAa,CAAC5C,GAEf+C,MAA0B,UAAa,CAAC,OAAO,cAAcA,CAAqB,IAClF,KAAKL,KAAe,IAEpB,KAAKA,KAAe,CAACK;AAAA,aAEtB;AAGH,gBAAM,CAAA,EAAGE,CAAO,IAAKjD,EAAM,SAAA,EAAY,MAAM,GAAG,GAC1CkD,IAAYD,IAAUA,EAAQ,SAAS,GACvCE,IAAQ,KAAK,IAAI,IAAID,CAAC;AAG5B,UAAIH,MAA0B,UAG1B,KAAKH,KAAa5C,IAAQmD,GAC1B,KAAKT,KAAeS,KACb,OAAO,cAAcJ,CAAqB,MACjD,KAAKH,KAAa5C,IAAQmD,IAAQ,KAAK,MAAMnD,IAAQ,KAAK,IAAI,IAAIkD,IAAIH,CAAqB,CAAC,GAC5F,KAAK,cAAcI,IAAQ,KAAK,IAAI,IAAID,IAAIH,CAAqB,IAGrE,KAAKH,KAAaN,EAAQ,iBAAiB,KAAKM,EAAU,GAC1D,KAAKF,KAAeJ,EAAQ,iBAAiB,KAAKI,EAAY,GAE9D,KAAK,OAAA;AAAA,QACT;AACA;AAAA,MACJ,KAAK;AACD,QAAI1C,aAAiBwC,MACjB,KAAKI,KAAa,CAAC5C,EAAM,WACzB,KAAK0C,KAAe,CAAC1C,EAAM;AAE/B;AAAA,IAAA;AAER,WAAO;AAAA,EACX;AAAA,EAEO,QAAQ,MAAgB;AAC3B,UAAMoD,IAAI,IAAIZ,EAAA;AACd,WAAAY,EAAE,YAAY,KAAKR,IACnBQ,EAAE,cAAc,KAAKV,IACrBU,EAAE,gBAAgB,KAAK,eAChBA;AAAA,EACX;AAAA,EAEA,IAAW,MAAc;AACrB,QAAI,KAAK;AACL,aAAO,GAAG,KAAK,KAAA,MAAW,IAAI,MAAM,GAAG;AAG3C,UAAMC,IAAO,KAAKP,MAAa,KAAK,WAAA,IAAe,MAAM;AAIzD,WAAI,KAAK,YACD,KAAKJ,OAAiB,IACf,GAAGW,CAAI,GAAG,KAAKT,EAAU,KACzB,KAAKA,KAAa,IAClB,MAAM,KAAKC,EAAK,KAAK,CAAC,KAAKD,EAAU,OAAO,KAAKF,EAAY,OAE7D,GAAGW,CAAI,KAAK,KAAKR,EAAK,KAAK,KAAKD,EAAU,OAAO,KAAKF,EAAY,OAGtEW,IAAO,KAAK,MAAM,QAAQ,KAAKV,EAAO;AAAA,EAErD;AAAA,EAEA,IAAW,UAAkB;AACzB,QAAI,KAAK;AACL,aAAO,GAAG,KAAK,KAAA,MAAW,IAAI,MAAM,GAAG;AAG3C,UAAMU,IAAO,KAAKP,MAAa,KAAK,WAAA,IAAe,MAAM;AAEzD,WAAI,KAAK,YACD,KAAKJ,OAAiB,IACf,GAAGW,CAAI,GAAG,KAAKT,EAAU,KAEzB,GAAGS,CAAI,GAAG,KAAKT,EAAU,IAAI,KAAKF,EAAY,KAGlDW,IAAO,KAAK,MAAM,QAAQ,KAAKV,EAAO;AAAA,EAErD;AAAA,EAEA,OAAc,UAAU,IAAIW,MAAkD;AAC1E,UAAMC,IAAI,IAAIf,EAAA,EAAW,KAAA;AAEzB,eAAWgB,KAAKF;AACZ,MAAAC,EAAE,IAAIC,CAAC;AAGX,WAAAD,EAAE,OAAOD,EAAU,MAAM,GAElBC;AAAA,EACX;AAAA,EAEA,OAAc,WAAWvD,GAA6B;AAClD,QAAIA,aAAiBwC,KAChB,OAAOxC,KAAU,YAAY,CAAC,MAAM,CAACA,CAAK;AAE3C,aAAO;AAGX,QAAI,OAAOA,KAAU,UAAU;AAC3B,YAAM,CAACyD,GAAKC,CAAG,IAAI1D,EAAM,MAAM,GAAG;AAElC,aAAO,CAAC,MAAM,CAACyD,CAAG,KAAK,CAAC,MAAM,CAACC,CAAG;AAAA,IACtC;AAEA,WAAO;AAAA,EAEX;AAAA,EAEA,OAAc,MAAM,IAAIJ,MAAgD;AACpE,QAAIC,IAAI,IAAIf,EAASc,EAAU,CAAC,CAAC;AAEjC,eAAWK,KAAKL,GAAW;AACvB,YAAMM,IAAU,IAAIpB,EAASmB,CAAC;AAC9B,MAAIC,EAAQ,UAAUL,CAAC,MACnBA,IAAIK,EAAQ,MAAA;AAAA,IAEpB;AAEA,WAAOL;AAAA,EACX;AAAA,EAEA,OAAc,MAAM,IAAID,MAAkD;AACtE,QAAIC,IAAI,IAAIf,EAASc,EAAU,CAAC,CAAC;AAEjC,eAAWK,KAAKL,GAAW;AACvB,YAAMM,IAAU,IAAIpB,EAASmB,CAAC;AAC9B,MAAIC,EAAQ,SAASL,CAAC,MAClBA,IAAIK,EAAQ,MAAA;AAAA,IAEpB;AAEA,WAAOL;AAAA,EACX;AAAA,EAEA,OAAc,OAAO,CAACD,GAAqCO,MAAkC;AAGzF,UAAMC,IAF8BR,EAAU,IAAI,CAAAE,MAAKA,aAAahB,IAAWgB,IAAI,IAAIhB,EAASgB,CAAC,CAAC,EAEnE,KAAK,CAACzC,GAAGC,MAAMD,EAAE,QAAQC,EAAE,KAAK;AAE/D,WAAI6C,KACAC,EAAO,QAAA,GAGJA;AAAA,EACX;AAAA,EAEA,OAAc,sBAAsBR,GAA+C;AAC/E,UAAMF,IAAIE,EAAU,IAAI,OAAK,IAAId,EAAS9B,CAAC,CAAC,GACtCqD,IAAMzB,EAAQ,IAAI,GAAGc,EAAE,IAAI,CAAA1C,MAAKA,EAAE,WAAW,CAAC;AAEpD,WAAA0C,EAAE,QAAQ,CAAA1C,MAAKA,EAAE,QAAQqD,IAAMrD,EAAE,WAAW,CAAC,GAEtC0C;AAAA,EACX;AAAA,EAEA,OAAc,SAAS,CAACE,MAAoD;AACxE,UAAMU,IAAkC,IACpCC,IAAuB,CAAA;AAE3B,WAAAX,EAAU,QAAQ,CAAA5C,MAAK;AACnB,MAAMA,aAAa8B,MACf9B,IAAI,IAAI8B,EAAS9B,CAAC,IAGjBsD,EAAOtD,EAAE,MAAA,EAAQ,OAAA,EAAS,GAAG,MAC9BuD,EAAS,KAAKvD,EAAE,OAAO,GACvBsD,EAAOtD,EAAE,GAAG,IAAI;AAAA,IAExB,CAAC,GAEMuD;AAAA,EACX;AAAA,EAEA,OAAc,YAAY,IAAI1D,MAA+C;AACzE,UAAM2D,IAAI,IAAI1B,EAAA;AAId,eAAWxC,KAASO,GAAQ;AAExB,YAAM6C,IAAI,IAAIZ,EAASxC,CAAK;AAC5B,MAAAkE,EAAE,YAAYA,EAAE,YAAYd,EAAE,WAC9Bc,EAAE,cAAcA,EAAE,cAAcd,EAAE;AAAA,IACtC;AAEA,WAAOc;AAAA,EACX;AAAA,EAEO,MAAM,OACT,KAAKtB,KAAa,KAAK,IAAI,KAAKA,EAAU,GAC1C,KAAKF,KAAe,KAAK,IAAI,KAAKA,EAAY,GACvC;AAAA,EAGJ,MAAM,CAACU,MAAsC;AAChD,QAAIA,aAAaZ,GAAU;AACvB,YAAM2B,IAAY,KAAKvB,IACnB/B,IAAY,KAAK6B;AAErB,WAAKE,KAAauB,IAAIf,EAAE,cAAcA,EAAE,YAAYvC,GACpD,KAAK6B,KAAe7B,IAAIuC,EAAE,aAC1B,KAAK,gBAAgB,KAAK,iBAAiBA,EAAE;AAAA,IACjD;AACI,aAAO,KAAK,IAAI,IAAIZ,EAASY,CAAC,CAAC;AAGnC,WAAO,KAAK,OAAA;AAAA,EAChB;AAAA,EAEO,UAAU,CAACgB,OACV,OAAO,cAAcA,CAAC,MACtB,KAAKxB,MAAcwB,GACnB,KAAK1B,MAAgB0B,IAElB;AAAA,EAGX,IAAI,gBAAyB;AACzB,WAAO,KAAK3B;AAAA,EAChB;AAAA,EAEA,IAAI,cAAczC,GAAgB;AAC9B,SAAKyC,KAAiBzC;AAAA,EAC1B;AAAA,EAEO,YAAY,IAAIoD,MACZA,EAAE,MAAM,CAAAI,MAAKA,EAAE,QAAQJ,EAAE,CAAC,CAAC,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQhC,UAAU,CAACA,GAAyBiB,MAAgC;AACvE,IAAAA,MAAS;AAET,QAAIC;AAOJ,YANIlB,aAAaZ,IACb8B,IAAkBlB,EAAE,MAAA,IAEpBkB,IAAkB,IAAI9B,EAASY,CAAC,GAG5BiB,GAAA;AAAA,MACJ,KAAK;AACD,eAAO,KAAK,QAAQC,EAAgB;AAAA,MACxC,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACD,eAAO,KAAK,SAASA,EAAgB;AAAA,MACzC,KAAK;AACD,eAAO,KAAK,QAAQA,EAAgB;AAAA,MACxC,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACD,eAAO,KAAK,SAASA,EAAgB;AAAA,MACzC,KAAK;AACD,eAAO,KAAK,UAAUA,EAAgB;AAAA,MAC1C,KAAK;AACD,eAAO,KAAK,UAAUA,EAAgB;AAAA,MAC1C;AACI,eAAO;AAAA,IAAA;AAAA,EAEnB;AAAA,EAEA,IAAW,cAAsB;AAC7B,WAAO,KAAK5B;AAAA,EAChB;AAAA,EAEA,IAAW,YAAY1C,GAAe;AAClC,SAAK0C,KAAe1C;AAAA,EACxB;AAAA,EAEA,IAAW,QAAc;AACrB,gBAAK6C,KAAQ,SACN;AAAA,EACX;AAAA,EAEA,OAAO7C,GAAqB;AACxB,gBAAK2C,KAAU3C,GACR;AAAA,EACX;AAAA,EAEO,SAAS,CAACoD,MAAmC;AAChD,UAAMmB,IAAI,IAAI/B,EAASY,CAAC;AAExB,QAAImB,EAAE,cAAc;AAChB,aAAO,IAAI/B,EAAA,EAAW,SAAA;AAG1B,UAAM2B,IAAY,KAAKvB,IACnB/B,IAAY,KAAK6B;AAErB,gBAAKE,KAAauB,IAAII,EAAE,aACxB,KAAK7B,KAAe7B,IAAI0D,EAAE,WAE1B,KAAK,gBAAgB,KAAK,iBAAiBA,EAAE,eACtC,KAAK,OAAA;AAAA,EAChB;AAAA,EAEA,IAAW,OAAa;AACpB,gBAAK1B,KAAQ,QACN;AAAA,EACX;AAAA,EAEO,WAAW,OACd,KAAKD,KAAa,OAClB,KAAKF,KAAe,GACpB,KAAK,gBAAgB,IACd;AAAA,EAGJ,UAAU,OACb,KAAKE,KAAa,KAClB,KAAKF,KAAe,GACpB,KAAK,gBAAgB,IACd;AAAA,EAGJ,UAAU,MAAY;AACzB,UAAM2B,IAAO,KAAK,KAAA,GACZG,IAAI,KAAK,IAAI,KAAK5B,EAAU;AAClC,gBAAKA,KAAa,KAAK,IAAI,KAAKF,EAAY,IAAI2B,GAChD,KAAK3B,KAAe8B,GAEb;AAAA,EACX;AAAA,EAEO,kBAAkB,MACd,KAAK/B,MACR,KAAKG,GAAW,SAAA,EAAW,UAAU,MAAM,KAAKF,GAAa,SAAA,EAAW,UAAU;AAAA,EAGnF,UAAU,CAAC+B,MACP,KAAK,QAAQA,GAAM,GAAG;AAAA,EAG1B,SAAS,MACL,KAAK,WAAA,KAAgB,KAAK,QAAQ,MAAM;AAAA,EAG5C,UAAU,MACN,CAAC,KAAK,gBAAA;AAAA,EAGV,WAAW,MACP,CAAC,KAAK,WAAA,KAAgB,CAAC,KAAK,MAAA;AAAA,EAGhC,QAAQ,CAACA,MACL,KAAK,QAAQA,GAAM,IAAI;AAAA,EAG3B,YAAY,CAACA,MACT,KAAK,QAAQA,GAAM,GAAG;AAAA,EAG1B,aAAa,MACT,KAAK,IAAI,KAAK7B,EAAU,MAAM;AAAA,EAGlC,QAAQ,CAAC6B,MACL,KAAK,QAAQA,GAAM,IAAI;AAAA,EAG3B,WAAW,CAACA,MACR,KAAK,QAAQA,GAAM,GAAG;AAAA,EAG1B,QAAQ,MACJ,MAAM,KAAK7B,EAAU;AAAA,EAGzB,YAAY,MACR,KAAK,gBAAgB,KAAK,WAAA;AAAA,EAG9B,aAAa,MACT,KAAK,WAAW;AAAA,EAGpB,aAAa,CAAC6B,MACV,KAAK,QAAQA,GAAM,IAAI;AAAA,EAG3B,YAAY,MACR,KAAK7B,OAAe;AAAA,EAGxB,QAAQ,MACJ,KAAK,WAAA,KAAgB,KAAK,QAAQ,MAAM;AAAA,EAG5C,QAAQ,MACJ,KAAKA,OAAe,KAAK,KAAKF,OAAiB;AAAA,EAGnD,aAAa,MACT,KAAK,WAAW;AAAA,EAGpB,aAAa,MACT,CAAC,KAAK,gBAAA,KAAqB,CAAC,KAAK,WAAA;AAAA,EAGrC,YAAY,MACR,KAAK,IAAIJ,EAAQ,IAAI,KAAKM,IAAY,KAAKF,EAAY,CAAC,MAAM;AAAA,EAGlE,aAAa,MACT,CAAC,KAAK,qBAAqB,KAAK,QAAQ,SAAS,gBAAgB;AAAA,EAGrE,WAAW,MACP,KAAK,KAAK,KAAKE,EAAU,IAAI,MAAM,KAAK,KAAK,KAAK,KAAKF,EAAY,IAAI,MAAM;AAAA,EAGjF,qBAAqB,MACjB,KAAK,QAAQ;AAAA,EAGjB,qBAAqB,MACjB,KAAK,QAAQ;AAAA,EAGjB,SAAkB;AACrB,WAAO,KAAK,IAAI,KAAKE,EAAU,MAAM,KAAK,KAAKF,OAAiB;AAAA,EACpE;AAAA;AAAA,EAGO,SAAS,MACL,KAAKE,OAAe;AAAA,EAGxB,WAAW,CAACQ,MAA+B;AAI9C,UAAMmB,IAAI,IAAI/B,EAASY,CAAC;AAExB,gBAAKR,KAAa,KAAKA,KAAa2B,EAAE,WACtC,KAAK7B,KAAe,KAAKA,KAAe6B,EAAE,aAE1C,KAAK,gBAAgB,KAAK,iBAAiBA,EAAE,eAEtC,KAAK,OAAA;AAAA,EAChB;AAAA;AAAA,EAGA,IAAW,YAAoB;AAC3B,WAAO,KAAK3B;AAAA,EAChB;AAAA,EAEA,IAAW,UAAU5C,GAAe;AAChC,SAAK4C,KAAa5C;AAAA,EACtB;AAAA,EAEO,MAAM,OACT,KAAKyC,KAAiB,IACtB,KAAKG,KAAa,GAClB,KAAKF,KAAe,GACb;AAAA,EAGJ,WAAW,OACd,KAAKE,KAAa,CAAC,KAAKA,IACjB;AAAA,EAGJ,MAAM,CAACM,MAAmC;AAC7C,QAAIA,aAAaV;AACb,aAAO,KAAK,IAAIU,EAAE,KAAK;AAG3B,SAAK,OAAA,GACDA,IAAI,KACJ,KAAK,QAAA;AAKT,UAAMwB,IAAmB,KAAK,MAAM,KAAK,IAAI,KAAK9B,IAAY,KAAK,IAAIM,CAAC,CAAC,CAAC,GACtEyB,IAAqB,KAAK,MAAM,KAAK,IAAI,KAAKjC,IAAc,KAAK,IAAIQ,CAAC,CAAC,CAAC;AAE5E,WAAIwB,KAAoB,KAAK,IAAIxB,CAAC,MAAM,KAAKN,MAEzC+B,KAAsB,KAAK,IAAIzB,CAAC,MAAM,KAAKR,MAC3C,KAAKE,KAAa,KAAKA,MAAc,KAAK,IAAIM,CAAC,GAC/C,KAAKR,KAAe,KAAKA,MAAgB,KAAK,IAAIQ,CAAC,MAEnD,KAAKN,KAAa,KAAKA,MAAc,KAAK,IAAIM,CAAC,GAC/C,KAAKR,KAAe,KAAKA,MAAgB,KAAK,IAAIQ,CAAC,IAGhD;AAAA,EACX;AAAA,EAEO,SAAS,MAAY;AACxB,UAAM1C,IAAI8B,EAAQ,IAAI,KAAKM,IAAY,KAAKF,EAAY;AACxD,gBAAKE,KAAa,KAAKA,KAAapC,GACpC,KAAKkC,KAAe,KAAKA,KAAelC,GAEpC,KAAKkC,KAAe,MACpB,KAAKA,KAAe,CAAC,KAAKA,IAC1B,KAAKE,KAAa,CAAC,KAAKA,KAErB;AAAA,EACX;AAAA,EAEO,OAAO,CAACM,MAAoB;AAG/B,QAAIA,MAAM;AACN,aAAO;AASX,QALIA,IAAI,KACJ,KAAK,QAAA,GAIL,CAAC,OAAO,cAAcA,CAAC;AACvB,YAAM,IAAI,MAAM,8BAA8B;AAIlD,QAAI,KAAK,WAAA,KAAgBA,IAAI,MAAM;AAC/B,YAAM,IAAI,MAAM,4CAA4C;AAIhE,UAAMmB,IAAO,KAAK,KAAA;AAClB,SAAK,IAAA,GAGL,KAAK,OAAA;AAIL,UAAMK,IAAmB,KAAK,MAAM,KAAK,IAAI,KAAK9B,IAAY,KAAK,IAAI,IAAIM,CAAC,CAAC,CAAC,GAC1EyB,IAAqB,KAAK,MAAM,KAAK,IAAI,KAAKjC,IAAc,KAAK,IAAI,IAAIQ,CAAC,CAAC,CAAC;AAEhF,gBAAKN,KAAa,KAAK,IAAI,KAAKA,IAAY,KAAK,IAAI,IAAIM,CAAC,CAAC,GAC3D,KAAKR,KAAe,KAAK,IAAI,KAAKA,IAAc,KAAK,IAAI,IAAIQ,CAAC,CAAC,IAE3DwB,MAAqB,KAAK9B,MAE1B+B,MAAuB,KAAKjC,QAE5B,KAAKE,KAAa,KAAKA,KAAa,KAAKF,IACzC,KAAKA,KAAe,GACpB,KAAKD,KAAiB,KAI1B,KAAK,SAAS4B,CAAI,GAEX;AAAA,EACX;AAAA,EAEO,OAAO,MACF,KAAKzB,KAAa,KAAKF,MAAgB,IAAK,IAAI;AAAA,EAGrD,OAAO,MACH,KAAK,KAAK,CAAC;AAAA,EAGf,WAAW,CAACU,MACXA,aAAaZ,IACN,KAAK,IAAIY,EAAE,MAAA,EAAQ,UAAU,IAE7B,KAAK,IAAI,CAACA,CAAC;AAAA,EAI1B,IAAW,cAAsB;AAC7B,WAAO,KAAK,WAAA,IAAe,IAAI,KAAK,GAAG,KAAK,KAAK;AAAA,EACrD;AAAA,EAEA,IAAW,QAAc;AACrB,gBAAKP,KAAQ,SACN;AAAA,EACX;AAAA,EAEA,IAAW,QAAgB;AACvB,UAAM+B,IAAS,KAAKhC,KAAa,KAAKF;AACtC,WAAOkC,MAAW,IAAI,IAAIA;AAAA,EAC9B;AAAA,EAEA,SAAS5E,IAAQ,IAAY;AACzB,gBAAK8C,KAAY9C,GACV;AAAA,EACX;AAAA,EAEO,OAAO,OACV,KAAKyC,KAAiB,IACtB,KAAKG,KAAa,GAClB,KAAKF,KAAe,GACb;AAEf;AC1rBO,MAAMmC,GAAQ;AAAA,EACjBC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC;AAAA,EAEA,eAAe1E,GAAkB;AAC7B,SAAKuE,KAAW,GAChB,KAAKE,KAAe,GACpB,KAAKD,KAAO,GACZ,KAAKE,KAAW,IAEZ1E,EAAO,SAAS,KAChB,KAAK,MAAMA,EAAO,CAAC,GAAGA,EAAO,CAAC,GAAGA,EAAO,CAAC,CAAC;AAAA,EAElD;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAAkB;AAClB,WAAO,KAAKuE;AAAA,EAChB;AAAA,EAEA,IAAI,QAAQ9E,GAAe;AACvB,SAAK8E,KAAW9E;AAAA,EACpB;AAAA,EAEA,IAAI,MAAc;AACd,WAAO,KAAK+E;AAAA,EAChB;AAAA,EAEA,IAAI,IAAI/E,GAAe;AACnB,IAAI,OAAO,cAAcA,CAAK,KAAKA,KAAS,IACxC,KAAK+E,KAAO/E,KAGZ,QAAQ,IAAI,4BAA4B,GACxC,KAAK+E,KAAO;AAAA,EAEpB;AAAA,EAEA,IAAI,cAAsB;AACtB,WAAO,KAAKC;AAAA,EAChB;AAAA,EAEA,IAAI,YAAYhF,GAAe;AAC3B,SAAKgF,KAAehF;AAAA,EACxB;AAAA,EAEA,IAAI,MAAc;AACd,QAAIkF;AAUJ,WARI,KAAKF,OAAiB,IACtBE,IAAI,KACG,KAAKF,OAAiB,KAC7BE,IAAI,MAEJA,IAAI,KAAKF,GAAa,SAAA,GAGtB,KAAKF,OAAa,IACX,GAAG,KAAKE,EAAY,KAEvB,KAAKD,OAAS,IACP,GAAGG,CAAC,UAAU,KAAKJ,EAAQ,MAE3B,GAAGI,CAAC,UAAU,KAAKH,EAAI,KAAK,KAAKD,EAAQ;AAAA,EAG5D;AAAA,EAEA,IAAI,UAAkB;AAClB,QAAII;AAUJ,WARI,KAAKF,OAAiB,IACtBE,IAAI,KACG,KAAKF,OAAiB,KAC7BE,IAAI,MAEJA,IAAI,KAAKF,GAAa,SAAA,GAGtB,KAAKF,OAAa,IACX,GAAG,KAAKE,EAAY,KAEvB,KAAKD,OAAS,IACP,GAAGG,CAAC,QAAQ,KAAKJ,EAAQ,MAEzB,GAAGI,CAAC,QAAQ,KAAKH,EAAI,KAAK,KAAKD,EAAQ;AAAA,EAG1D;AAAA,EAEA,IAAI,QAAgB;AAChB,WAAO,KAAKE,KAAe,KAAK,IAAI,KAAKF,IAAU,IAAI,KAAKC,EAAI;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ,CAAC5C,GAAiBgD,GAAkBC,OACxC,KAAKJ,KAAeI,KAAe,GACnC,KAAKL,KAAOI,KAAW,GACvB,KAAKL,KAAW3C,GAEZ,KAAK4C,KAAO,MAAM,KAAK,KAAKD,KAAW,MACvC,KAAKG,KAAW,KAEb;AAAA;AAAA;AAAA;AAAA,EAMX,SAAS,MAAY;AAEjB,QAAII,IAAI,KAAK,MAAM,KAAK,IAAI,KAAKP,IAAU,IAAI,KAAKC,EAAI,CAAC;AACzD,WAAOM,IAAI,KAAG;AACV,UAAI,KAAKP,KAAW,KAAK,IAAIO,GAAG,KAAKN,EAAI,MAAM,GAAG;AAE9C,aAAKC,MAAgBK,GACrB,KAAKP,KAAW,KAAKA,KAAW,KAAK,IAAIO,GAAG,KAAKN,EAAI,GAGrDM,IAAI,KAAK,MAAM,KAAK,IAAI,KAAKP,IAAU,IAAI,KAAKC,EAAI,CAAC;AACrD;AAAA,MACJ;AACA,MAAAM;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EAEA,WAAW,CAAClB,OACR,KAAKW,MAAYX,EAAE,SACZ,KAAK,OAAA;AAAA;AAAA;AAAA;AAAA,EAMhB,aAAa,MACF,EAAE,KAAKW,OAAa,KAAK,KAAKA,OAAa,KAAK,CAAC,KAAKG;AAErE;AC9IO,MAAMK,EAAe;AAAA,EACxBC;AAAA,EACAC;AAAA,EACSC;AAAA,EACAC;AAAA,EAET,YAAYC,GAA0BC,GAAiBC,IAAW,KAAK;AAKnE,QAJA,KAAKH,KAAYG,GACjB,KAAKL,KAAoB,MACzB,KAAKD,KAA8B,GAE/B,OAAO,OAAOI,GAAM,UAAU,GAAG;AACjC,YAAMG,IAAMH;AACZ,WAAKF,KAAeK,EAAI,KAAK,QAAQ,SAASA,EAAI,KAAK;AAAA,IAC3D;AACI,WAAKL,KAAgBE,EAAiB,MAAA,EAAQ,SAASC,KAAS,CAAC;AAAA,EAEzE;AAAA,EAEA,IAAI,6BAA4B;AAC5B,WAAO,KAAKL;AAAA,EAChB;AAAA,EAEA,IAAI,mBAAmB;AACnB,WAAO,KAAKC;AAAA,EAChB;AAAA,EAEA,IAAI,iBAAiBxF,GAAe;AAChC,SAAKwF,KAAoBxF;AAAA,EAC7B;AAAA,EAEO,QAAqB;AACxB,UAAM+F,IAAS,KAAKN,GAAa,OAAA,EAAS;AAE1C,QAAIM,MAAW;AACX,aAAO,CAAA;AAGX,QAAIA,MAAW;AACX,aAAO,KAAKC,GAAA;AAGhB,QAAID,MAAW;AACX,aAAO,KAAKE,GAAA;AAIhB,UAAM,EAAC,WAAAC,GAAW,SAAAC,MAAW,KAAKC,GAAA;AAGlC,WAAID,EAAQ,SAAS,WACVD,IAIPC,EAAQ,SAAS,SAAS,IACnBD,EAAU;AAAA,MACb,IAAIZ,EAAea,EAAQ,MAAA,CAAO,EAAE,MAAA;AAAA,IAAM,KAMlD,KAAKZ,KAA8B,GAC5BW,EAAU;AAAA,MACb,KAAKG,GAAmBF,CAAO;AAAA,IAAA,EACjC,KAAK,CAACpF,GAAGC,MAAMD,EAAE,QAAQC,EAAE,KAAK;AAAA,EACtC;AAAA,EAEO,gBAA6B;AAChC,QAAI,KAAKyE,GAAa,OAAA,EAAS,UAAU;AACrC,YAAM,IAAI,MAAM,4BAA4B;AAEhD,WAAO,KAAKa,GAAA;AAAA,EAChB;AAAA,EAEAC,GAA2BvG,GAAewG,GAAsD;AAC5F,WAAO;AAAA,MACH,UAAU,KAAKd;AAAA,MACf,OAAO;AAAA,MACP,OAAO,CAAC1F,EAAM,QAAQ,EAAE;AAAA,MACxB,KAAKwG,GAAQ,OAAO;AAAA,MACpB,SAASA,GAAQ,WAAW;AAAA,IAAA;AAAA,EAEpC;AAAA,EAEAC,GAAczG,GAAwC;AAClD,QAAIA,aAAiBwC,KAAYxC,EAAM,gBAAA;AACnC,aAAO,KAAKuG,GAA2BvG,EAAM,KAAK;AAGtD,UAAM0G,IAAW,IAAIlE,EAASxC,CAAK;AACnC,WAAO;AAAA,MACH,UAAU,KAAK0F;AAAA,MACf,OAAOgB;AAAA,MACP,OAAOA,EAAS;AAAA,MAChB,KAAKA,EAAS;AAAA,MACd,SAASA,EAAS;AAAA,IAAA;AAAA,EAE1B;AAAA;AAAA,EAGAL,GAAmBF,GAA+B;AAC9C,UAAMD,IAAyB,CAAA,GACzBH,IAASI,EAAQ,OAAA,EAAS,OAG1B,CAACpF,GAAG,GAAGR,CAAM,IAAI4F,EAAQ,gBAAA,GACzBQ,IAAI,IAAI,KAAK,IAAI,GAAGpG,EAAO,IAAI,CAAAG,MAAKA,EAAE,QAAQK,EAAE,KAAK,CAAC,GAKtD6F,IAAkB,KAAKC,GAAkCV,GAASQ,GAAG,GAAG;AAM9E,WAHgB,KAAKG,GAA8BF,GAAiBb,CAAM,EAGlE,QAAQ,CAAAgB,MAAU;AACtB,YAAM,CAAChG,GAAGC,CAAC,IAAI+F;AAEf,UAAIhG,MAAMC;AAEN,QAAAkF,EAAU,KAAK,KAAKO,GAAc1F,CAAC,CAAC;AAAA,WACjC;AACH,cAAMiG,IAAa,KAAKC,GAA6Bd,GAASpF,GAAGC,CAAC;AAElE,QAAIgG,MAAe,QACfd,EAAU,KAAK,KAAKK,GAA2BS,CAAU,CAAC;AAAA,MAElE;AAAA,IACJ,CAAC,GAED,QAAQ,IAAI,gBAAgB,KAAKzB,EAA2B,GACrDW;AAAA,EACX;AAAA,EAEAe,GAA6Bd,GAAkBpF,GAAWC,GAA0B;AAChF,QAAIkG,IAAKf,EAAQ,SAASpF,GAAG,EAAI,GAC7BoG,IAAKhB,EAAQ,SAASnF,GAAG,EAAI;AAEjC,QAAIkG,IAAKC,IAAK;AACV,qBAAQ,IAAI,uCAAuC,GAC5C;AAGX,QAAIC;AACJ,YAAQpG,IAAID,KAAK,IAAI,KAAKyE,MAAmB;AACzC,WAAKD,MAEL6B,KAAOrG,IAAIC,KAAK;AAChB,YAAMqG,IAAOlB,EAAQ,SAASiB,GAAK,EAAI;AAEvC,UAAIC,MAAS;AACT,eAAOD;AACX,MAAWF,IAAKG,IAAO,KACnBrG,IAAIoG,GACJD,IAAKE,MAELtG,IAAIqG,GACJF,IAAKG;AAAA,IAEb;AACA,YAAQtG,IAAIC,KAAK;AAAA,EACrB;AAAA,EAEA6F,GAAkCV,GAAkBmB,GAAgBC,GAA4C;AAE5G,UAAMX,IAA+C,CAAA,GAE/CY,IAAK,IAAIF,IAASC;AAExB,aAASE,IAAc,CAACH,GAAQG,KAAeH,GAAQG,KAAeD,GAAI;AAEtE,YAAM9G,IAAI4B,EAAQ,iBAAiBmF,CAAW;AAC9C,MAAAb,EAAgB;AAAA,QACZ;AAAA,UACI,GAAAlG;AAAA,UACA,IAAIyF,EAAQ,SAASzF,GAAG,EAAI;AAAA,QAAA;AAAA,MAChC;AAAA,IAER;AAEA,WAAOkG;AAAA,EACX;AAAA,EAEAE,GAA8BF,GAA8Cb,GAAoC;AAC5G,UAAM2B,IAA8B,CAAA;AAEpC,aAASzF,IAAQ,GAAGA,IAAQ2E,EAAgB,QAAQ3E,KAAS;AAEzD,YAAMjC,IAAQ4G,EAAgB3E,CAAK,GAC7B0F,IAAWf,EAAgB3E,IAAQ,CAAC;AAU1C,UARIjC,EAAM,OAAO,IAEb0H,EAAQ,KAAK,CAAC1H,EAAM,GAAGA,EAAM,CAAC,CAAC,IACxBA,EAAM,KAAK2H,EAAS,KAAK,KAEhCD,EAAQ,KAAK,CAACC,EAAS,GAAG3H,EAAM,CAAC,CAAC,GAGlC0H,EAAQ,WAAW3B;AAEnB,eAAO2B;AAAA,IAEf;AAEA,WAAOA;AAAA,EACX;AAAA,EAEAtB,KAAsE;AAIlE,UAAMT,IAAO,KAAKF,GAAa,MAAA,GAGzBS,IAAyB,CAAA,GAIzBnC,IAAM4B,EAAK,eAAA;AACjB,IAAI5B,MAAQ,KACR4B,EAAK,SAAS5B,CAAG;AAMrB,UAAMhD,IAAI4E,EAAK,cAAA,EAAgB,aACzB3E,IAAI2E,EAAK,cAAc,CAAC,EAAE;AAChC,QAAI3E,EAAE,UAAU;AACZ,MAAAkF,EAAU,KAAK,KAAKO,GAAc,CAAC,CAAC;AAEpC,YAAM9C,IAAIgC,EAAK,OAAO,OAAO,CAACiC,GAAKC,MAASA,EAAK,OAAA,EAAS,QAAQD,EAAI,OAAA,EAAS,QAAQC,IAAOD,CAAG,GAC3FxD,IAAIT,EAAE;AACZ,MAAAA,EAAE,MAAA,EAAQ,OAAOS,CAAC,GAClBuB,EAAK,OAAOhC,CAAC;AAAA,IACjB;AAGA,UAAMmE,IAAYxF,EAAQ,SAASvB,EAAE,KAAK,GACpCgH,IAAYzF,EAAQ,SAAStB,EAAE,KAAK,GAGpCgH,IAA+B,CAAA;AACrC,eAAWC,KAAMH;AACb,iBAAWI,KAAMH,GAAW;AACxB,cAAMvE,IAAI,IAAIhB,EAAS0F,GAAID,CAAE;AAC7B,QAAKD,EAAiB,KAAK,CAAAG,MAAKA,EAAE,UAAU3E,EAAE,KAAK,MAC/CwE,EAAiB,KAAKxE,EAAE,OAAO,GAC/BwE,EAAiB,KAAKxE,EAAE,SAAA,EAAW,OAAO;AAAA,MAGlD;AAIJ,IAAAwE,EAAiB,QAAQ,CAAAxE,MAAK;AAC1B,MAAKmC,EAAK,SAASnC,CAAC,EAAe,YAC/B0C,EAAU,KAAK,KAAKO,GAAcjD,CAAC,CAAC;AAAA,IAE5C,CAAC;AAID,eAAW2E,KAAKjC,GAAW;AAGvB,UAAKiC,EAAE,MAAmB;AACtB;AAQJ,YAAMjF,IAAIyC,EAAK,MAAA,EAAQ;AAAA,QAClBwC,EAAE,MAAmB;AAAA,QACtB,CAAEA,EAAE,MAAmB;AAAA,MAAA;AAK3B,aAAOxC,EAAK,cAAczC,CAAC;AACvB,QAAAyC,EAAK,OAAOzC,CAAC;AAAA,IAErB;AAIA,QAAIyC,EAAK,SAAS,OAAA,KAAYA,EAAK,OAAA,EAAS,QAAQ;AAEhD,aAAAO,EAAU,KAAK,CAACnF,GAAGC,MAAMD,EAAE,QAAQC,EAAE,KAAK,GACnC,EAAC,WAAAkF,GAAW,SAASP,EAAA;AAIhC,UAAMyC,IAAczC,EAAK,MAAA,EAAQ,KAAA,GAE3B0C,IAAS,IAAI/C,EAAeK,GAAMyC,GAAa,KAAK1C,EAAS;AACnE,WAAO;AAAA,MACH,WAAWQ,EACN,OAAOmC,EAAO,OAAO,EACrB,KAAK,CAACtH,GAAGC,MAAMD,EAAE,QAAQC,EAAE,KAAK;AAAA,MACrC,SAASoH;AAAA,IAAA;AAAA,EAEjB;AAAA,EAEA9B,KAAyC;AAErC,UAAMX,IAAO,KAAKF,IAGZ1E,IAAI4E,EAAK,cAAc,CAAC,EAAE,aAC1B3E,IAAI2E,EAAK,cAAc,CAAC,EAAE,aAC1B2C,IAAI3C,EAAK,cAAc,CAAC,EAAE,aAC1B4C,IAAI5C,EAAK,cAAc,CAAC,EAAE,aAG1B6C,IAAKxH,EAAE,MAAA,EAAQ,OAAOD,CAAC,GACvB0H,IAAKH,EAAE,MAAA,EAAQ,OAAOvH,CAAC,GACvB2H,IAAKH,EAAE,MAAA,EAAQ,OAAOxH,CAAC,GAIvBmC,IAAIuF,EAAG,MAAA,EAAQ,SAASD,EAAG,MAAA,EAAQ,IAAI,CAAC,EAAE,OAAO,CAAC,CAAC,GACnDG,IAAID,EAAG,MAAA,EACR,SAASF,EAAG,QAAQ,SAASC,CAAE,EAAE,OAAO,CAAC,CAAC,EAC1C,IAAID,EAAG,MAAA,EAAQ,IAAI,CAAC,EAAE,SAAS,CAAC,EAAE,OAAO,EAAE,CAAC,GAS3CxF,IAAI2F,EAAE,MAAA,EAAQ,SAAA,GACdC,IAAI1F,EAAE,QAAQ,WAAW,IAAI,CAAC,EAAE,OAAO,EAAE,GAMzC2F,IAAQ7F,EAAE,MAAA,EAAQ,IAAI,CAAC,EAAE,SAAS4F,EAAE,QAAQ,SAAS,CAAC,CAAC,EAAE,SAAA;AAO/D,QAAIC,EAAM,cAAc;AACpB,YAAMzI,IAAIuI,EAAE,MAAA,EAAQ,SAAA,EAAW,IAAIE,EAAM,MAAA,EAAQ,SAAA,EAAW,MAAM,EAAE,OAAO,CAAC,EAAE,KAAK,CAAC,GAC9ExI,IAAIsI,EAAE,MAAA,EAAQ,SAAA,EAAW,SAASE,EAAM,MAAA,EAAQ,SAAA,EAAW,MAAM,EAAE,OAAO,CAAC,EAAE,KAAK,CAAC,GAEnFnI,IAAIN,EAAE,MAAA,EAAQ,IAAIC,CAAC,EAAE,SAASmI,EAAG,MAAA,EAAQ,OAAO,CAAC,CAAC;AAExD,aAAO,CAAC,KAAK/B,GAAc/F,CAAC,CAAC;AAAA,IACjC;AAGA,QAAImI,EAAM,UAAU;AAChB,YAAMzI,IAAIuI,EAAE,QAAQ,WAAW,OAAO,CAAC,EAAE,KAAK,CAAC,GAEzCG,IAAK1I,EAAE,MAAA,EAAQ,SAAA,EAAW,SAASoI,EAAG,MAAA,EAAQ,OAAO,CAAC,CAAC,GACvDO,IAAK3I,EAAE,MAAA,EAAQ,SAAS,CAAC,EAAE,SAASoI,EAAG,MAAA,EAAQ,OAAO,CAAC,CAAC;AAG9D,aAAIM,EAAG,QAAQC,CAAE,IACN,CAAC,KAAKtC,GAAcqC,CAAE,CAAC,IAG3B;AAAA,QACH,KAAKrC,GAAcsC,CAAE;AAAA,QACrB,KAAKtC,GAAcqC,CAAE;AAAA,MAAA,EACvB,KAAK,CAAC/H,GAAGC,MAAMD,EAAE,QAAQC,EAAE,KAAK;AAAA,IACtC;AAGA,QAAI6H,EAAM,cAAc;AACpB,YAAMnI,IAAc,CAAA,GACdsI,IAAK9F,EAAE,OACT+F,IAAKN,EAAE,OACPO,IAAMV,EAAG;AAEb,eAAS1H,IAAI,GAAGA,IAAI,GAAGA;AACnB,QAAAJ,EAAE,KAAK,IAAI,KAAK,KAAK,CAACsI,IAAK,CAAC,IAAI,KAAK,IAAI,KAAK,KAAK,IAAIC,KAAM,IAAID,KAAM,KAAK,KAAK,KAAKA,CAAE,CAAC,IAAI,IAAI,IAAI,KAAK,KAAKlI,IAAI,CAAC,IAAIoI,IAAM,CAAC;AAGnI,aAAOxI,EACF,IAAI,CAAAL,MAAK,KAAKkG,GAA2BlG,CAAC,CAAC,EAC3C,KAAK,CAACU,GAAGC,MAAMD,EAAE,QAAQC,EAAE,KAAK;AAAA,IAEzC;AAEA,WAAO,CAAA;AAAA,EACX;AAAA,EAEAgF,KAA4B;AAExB,UAAM,CAACjF,GAAGC,CAAC,IAAI,KAAKyE,GAAa,gBAAA,GAG3BjC,IAAIxC,EAAE,SAAA,EAAW,OAAOD,CAAC;AAE/B,WAAO;AAAA,MACH,KAAK0F,GAAcjD,CAAC;AAAA,IAAA;AAAA,EAE5B;AAAA,EAEAyC,KAA+B;AAM3B,UAAMN,IAAO,KAAKF;AAClB,IAAIE,EAAK,cAAA,EAAgB,YAAY,gBACjCA,EAAK,SAAA;AAIT,UAAM,CAAC5E,GAAGC,GAAGsH,CAAC,IAAI3C,EAAK,gBAAA,GAGjBwD,IAASnI,EAAE,MAAA,EAAQ,IAAI,CAAC,EAAE,SAASD,EAAE,MAAA,EAAQ,SAASuH,CAAC,EAAE,SAAS,CAAC,CAAC;AAG1E,QAAIa,EAAO;AACP,aAAO,CAAA;AAOX,QAAIA,EAAO,YAAY;AAGnB,YAAMN,IAAQM,EAAO,KAAA,GACfC,IAAKpI,EAAE,MAAA,EAAQ,WAAW,SAAS6H,CAAK,EAAE,OAAO9H,EAAE,MAAA,EAAQ,SAAS,CAAC,CAAC,GACtEsI,IAAKrI,EAAE,MAAA,EAAQ,WAAW,IAAI6H,CAAK,EAAE,OAAO9H,EAAE,MAAA,EAAQ,SAAS,CAAC,CAAC;AAGvE,aAAI8H,EAAM,WACC,CAAC,KAAKpC,GAAc2C,CAAE,CAAC,IAI3B;AAAA,QACH,KAAK3C,GAAc2C,CAAE;AAAA,QACrB,KAAK3C,GAAc4C,CAAE;AAAA,MAAA,EACvB,KAAK,CAACtI,GAAGC,MAAMD,EAAE,QAAQC,EAAE,KAAK;AAAA,IACtC;AAQA,WAAO,KAAKsI,GAAuBvI,GAAGC,GAAGmI,CAAM;AAAA,EACnD;AAAA,EAEAG,GAAuBvI,GAAaC,GAAa6H,GAA8B;AAK3E,UAAMU,IAAsBjH,EACvB,SAASuG,EAAM,KAAK,EACpB,OAAO,CAAAnI,MAAK,KAAK,KAAKA,CAAC,IAAI,MAAM,CAAC,EAClC,IAAI,CAAAA,MAAK,KAAK,KAAKA,CAAC,CAAC,EAAE,IAAA,KAAS,GAG/B8I,IAAMlH,EAAQ,IAAI,IAAIvB,EAAE,OAAOC,EAAE,OAAOuI,CAAW,KAAKxI,EAAE,WAAA,IAAe,KAAK,IAG9E0I,IAAKzI,EAAE,MAAA,EAAQ,OAAOwI,CAAG,EAAE,SAAA,GAC3BE,IAAK3I,EAAE,MAAA,EAAQ,OAAOyI,CAAG,EAAE,SAAS,CAAC,GACrCG,IAAW,KAAK,IAAIJ,IAAcC,CAAG,GACrCI,IAAW,GAAGL,MAAgB,IAAI,KAAKI,IAAW,GAAG,WAAWd,EAAM,QAAQ,OAAOU,KAAe,CAAC,EAAE,GAAG,MAC1GM,IAAe,GAAGN,MAAgB,IAAI,KAAKI,CAAQ,QAAQd,EAAM,MAAA,EAAQ,OAAOU,KAAe,CAAC,EAAE,OAAO;AAI/G,aAASO,EAAU/I,GAAWC,GAAWqD,GAAcwE,GAAe;AAElE,YAAMlC,IAAI3F,MAAM,MAAM,KAAKA,GACrBgC,IAAKqB,MAAS,OAAOsC,MAAM,KAAM,IAAItC,CAAI,MAAM;AAErD,aAAItD,MAAM,MACC,GAAG4F,CAAC,GAAG3D,CAAC,GAAG6F,CAAK,KAEpB,WAAW7F,CAAC,GAAGA,CAAC,GAAG6F,CAAK,OAAO9H,CAAC;AAAA,IAC3C;AAEA,aAASgJ,EAAchJ,GAAWC,GAAWqD,GAAcwE,GAAe;AAEtE,YAAMlC,IAAI3F,MAAM,MAAM,KAAKA,GACrBgC,IAAKqB,MAAS,OAAOsC,MAAM,KAAMtC,IAAO;AAG9C,aAAItD,MAAM,MACC,GAAG4F,CAAC,GAAG3D,CAAC,GAAG6F,CAAK,KAEpB,IAAIlC,CAAC,GAAG3D,CAAC,GAAG6F,CAAK,KAAK9H,CAAC;AAAA,IAClC;AAEA,UAAMwH,IAAIM,EAAM,SAAS,KACnBO,KAAM,CAACpI,EAAE,QAAQuH,MAAM,IAAIxH,EAAE,QAC7BsI,KAAM,CAACrI,EAAE,QAAQuH,MAAM,IAAIxH,EAAE;AAEnC,WAAO;AAAA,MACH,KAAKwF;AAAA,QAA2B6C;AAAA,QAC5B;AAAA,UACI,KAAKU,EAAUJ,EAAG,KAAKD,EAAG,KAAK,KAAKG,CAAQ;AAAA,UAC5C,SAASG,EAAcL,EAAG,SAASD,EAAG,SAAS,KAAKI,CAAY;AAAA,QAAA;AAAA,MACpE;AAAA,MAEJ,KAAKtD;AAAA,QAA2B8C;AAAA,QAC5B;AAAA,UACI,KAAKS,EAAUJ,EAAG,KAAKD,EAAG,KAAK,KAAKG,CAAQ;AAAA,UAC5C,SAASG,EAAcL,EAAG,SAASD,EAAG,SAAS,KAAKI,CAAY;AAAA,QAAA;AAAA,MACpE;AAAA,IACJ,EACF,KAAK,CAAC9I,GAAGC,MAAMD,EAAE,QAAQC,EAAE,KAAK;AAAA,EACtC;AACJ;AC1hBA,MAAMgJ,KAAI;AAAA,EACR,IAAI,KAAK;AAAA,EACT,GAAG,KAAK,IAAI,CAAC;AACf;AACA,IAAIC,IAAqB,kBAACC,OAAOA,EAAE,WAAW,YAAYA,EAAE,cAAc,eAAeA,EAAE,YAAY,aAAaA,EAAE,WAAW,YAAYA,EAAE,WAAW,YAAYA,EAAE,oBAAoB,qBAAqBA,EAAE,QAAQ,SAASA,EAAE,mBAAmB,KAAKA,EAAE,oBAAoB,KAAKA,IAAID,KAAK,EAAE,GAAG9F,IAAqB,kBAAC+F,OAAOA,EAAE,aAAa,cAAcA,EAAE,UAAU,WAAWA,EAAE,MAAM,OAAOA,EAAE,UAAU,WAAWA,IAAI/F,KAAK,CAAA,CAAE;AACza,SAASgG,GAAED,GAAG5B,GAAG;AACf,MAAI4B,EAAE,UAAU;AACd,WAAOA;AACT,QAAMpJ,IAAI,OAAO,KAAKwH,CAAC,EAAE,OAAO,CAAC8B,MAAM9B,EAAE8B,CAAC,EAAE,SAASH,EAAE,QAAQ,EAAE,IAAI,CAACG,MAAMA,CAAC;AAC7E,EAAAtJ,EAAE,KAAK,CAACsJ,GAAGlH,MAAMA,EAAE,SAASkH,EAAE,MAAM;AACpC,QAAM5F,IAAI,IAAI,OAAO,KAAK1D,EAAE,KAAK,GAAG,CAAC,MAAM,GAAGuJ,IAAI,OAAO,KAAKL,EAAC;AAC/D,EAAAK,EAAE,KAAK,CAACD,GAAGlH,MAAMA,EAAE,SAASkH,EAAE,MAAM;AACpC,QAAMjC,IAAI,IAAI,OAAO,KAAKkC,EAAE,KAAK,GAAG,CAAC,GAAG,GAAG7G,IAAI;AAC/C,MAAI8G,IAAI,IAAIC,GAAGxJ,GAAGyJ;AAClB,OAAK1J,EAAE,QAAQ,CAACsJ,MAAM;AACpB,QAAIF,EAAE,SAASE,CAAC,GAAG;AACjB,YAAMlH,IAAI,IAAI,OAAO,GAAGkH,CAAC,aAAa,GAAG;AACzC,MAAAF,IAAIA,EAAE,WAAWhH,GAAG,GAAGkH,CAAC,MAAM;AAAA,IAChC;AAAA,EACF,CAAC,GAAGF,EAAE,SAAS,KAAK;AAClB,QAAIK,IAAIxJ,GAAGyJ,IAAI,QAAQ1J,EAAE,SAAS,KAAK0D,EAAE,KAAK0F,CAAC,GAAG;AAChD,YAAME,IAAItJ,EAAE,KAAK,CAACoC,MAAMgH,EAAE,WAAWhH,CAAC,CAAC;AACvC,MAAAkH,MAAMI,IAAIJ,IAAI,KAAKF,IAAIA,EAAE,MAAME,EAAE,SAAS,CAAC,GAAGrJ,IAAIkJ,EAAE;AAAA,IACtD,WAAWI,EAAE,SAAS,KAAKlC,EAAE,KAAK+B,CAAC,GAAG;AACpC,YAAME,IAAIC,EAAE,KAAK,CAACnH,MAAMgH,EAAE,WAAWhH,CAAC,CAAC;AACvC,MAAAkH,MAAMI,IAAIJ,GAAGF,IAAIA,EAAE,MAAME,EAAE,MAAM,GAAGrJ,IAAIkJ,EAAE;AAAA,IAC5C,WAAWzG,EAAE,KAAK0G,CAAC,GAAG;AACpB,YAAME,IAAI5G,EAAE,KAAK0G,CAAC;AAClB,MAAAE,MAAMI,IAAIJ,EAAE,CAAC,GAAGF,IAAIA,EAAE,MAAME,EAAE,CAAC,EAAE,MAAM,GAAGrJ,IAAIkJ,EAAE;AAAA,IAClD;AACE,cAAQO,IAAIN,EAAE,CAAC,GAAGA,IAAIA,EAAE,MAAM,CAAC,GAAGM,GAAC;AAAA,QACjC,KAAK;AACH,UAAAzJ,IAAIkJ,EAAE;AACN;AAAA,QACF,KAAK;AACH,UAAAlJ,IAAIkJ,EAAE;AACN;AAAA,QACF,KAAK;AACH,UAAAlJ,IAAIkJ,EAAE;AACN;AAAA,QACF,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACH,UAAAlJ,IAAIkJ,EAAE;AACN;AAAA,QACF;AACE,UAAAlJ,IAAIkJ,EAAE;AAAA,MAChB;AACI,QAAIO,MAAM,UAAUzJ,MAAM;AACxB,YAAM,IAAI,MAAM,wBAAwB;AAC1C,IAAAuJ,KAAKG,GAAEF,GAAGxJ,CAAC,GAAGuJ,KAAKE;AAAA,EACrB;AACA,SAAOF;AACT;AACA,SAASG,GAAEP,GAAG5B,GAAG;AACf,SAAO4B,MAAM,UAAUA,MAAMD,EAAE,aAAa3B,MAAM2B,EAAE,aAAaC,MAAMD,EAAE,oBAAoBC,MAAMD,EAAE,YAAYC,MAAMD,EAAE,qBAAqB3B,MAAM2B,EAAE,qBAAqB3B,MAAM2B,EAAE,oBAAoB,KAAK;AAC9M;AACA,MAAM1B,KAAI;AAAA,EACR,KAAK,EAAE,YAAY,GAAG,aAAa,SAAS,MAAM0B,EAAE,UAAS;AAAA,EAC7D,KAAK,EAAE,YAAY,GAAG,aAAa,QAAQ,MAAMA,EAAE,UAAS;AAAA,EAC5D,KAAK,EAAE,YAAY,GAAG,aAAa,QAAQ,MAAMA,EAAE,UAAS;AAAA,EAC5D,KAAK,EAAE,YAAY,GAAG,aAAa,QAAQ,MAAMA,EAAE,UAAS;AAAA,EAC5D,KAAK,EAAE,YAAY,GAAG,aAAa,QAAQ,MAAMA,EAAE,UAAS;AAC9D,GAAG7F,KAAI;AAAA,EACL,KAAK,EAAE,YAAY,GAAG,aAAa,SAAS,MAAM6F,EAAE,UAAS;AAAA,EAC7D,KAAK,EAAE,YAAY,GAAG,aAAa,QAAQ,MAAMA,EAAE,UAAS;AAAA,EAC5D,KAAK,EAAE,YAAY,GAAG,aAAa,QAAQ,MAAMA,EAAE,UAAS;AAAA,EAC5D,KAAK,EAAE,YAAY,GAAG,aAAa,QAAQ,MAAMA,EAAE,UAAS;AAAA,EAC5D,KAAK,EAAE,YAAY,GAAG,aAAa,QAAQ,MAAMA,EAAE,UAAS;AAAA,EAC5D,KAAK,EAAE,YAAY,GAAG,aAAa,SAAS,MAAMA,EAAE,UAAS;AAAA,EAC7D,KAAK,EAAE,YAAY,GAAG,aAAa,SAAS,MAAMA,EAAE,SAAQ;AAAA,EAC5D,KAAK,EAAE,YAAY,GAAG,aAAa,SAAS,MAAMA,EAAE,SAAQ;AAAA,EAC5D,KAAK,EAAE,YAAY,GAAG,aAAa,SAAS,MAAMA,EAAE,SAAQ;AAAA,EAC5D,MAAM,EAAE,YAAY,GAAG,aAAa,SAAS,MAAMA,EAAE,SAAQ;AAAA,EAC7D,OAAO,EAAE,YAAY,GAAG,aAAa,SAAS,MAAMA,EAAE,SAAQ;AAAA,EAC9D,KAAK,EAAE,YAAY,GAAG,aAAa,QAAQ,MAAMA,EAAE,kBAAiB;AACtE,GAAG7J,KAAI;AAAA,EACL,KAAK,EAAE,YAAY,GAAG,aAAa,SAAS,MAAM6J,EAAE,UAAS;AAAA,EAC7D,KAAK,EAAE,YAAY,GAAG,aAAa,QAAQ,MAAMA,EAAE,UAAS;AAAA,EAC5D,KAAK,EAAE,YAAY,GAAG,aAAa,QAAQ,MAAMA,EAAE,UAAS;AAAA,EAC5D,KAAK,EAAE,YAAY,GAAG,aAAa,QAAQ,MAAMA,EAAE,UAAS;AAAA,EAC5D,KAAK,EAAE,YAAY,GAAG,aAAa,QAAQ,MAAMA,EAAE,UAAS;AAAA,EAC5D,KAAK,EAAE,YAAY,GAAG,aAAa,SAAS,MAAMA,EAAE,UAAS;AAAA,EAC7D,KAAK,EAAE,YAAY,GAAG,aAAa,SAAS,MAAMA,EAAE,SAAQ;AAAA,EAC5D,KAAK,EAAE,YAAY,GAAG,aAAa,SAAS,MAAMA,EAAE,SAAQ;AAAA,EAC5D,KAAK,EAAE,YAAY,GAAG,aAAa,SAAS,MAAMA,EAAE,SAAQ;AAAA,EAC5D,MAAM,EAAE,YAAY,GAAG,aAAa,SAAS,MAAMA,EAAE,SAAQ;AAAA,EAC7D,OAAO,EAAE,YAAY,GAAG,aAAa,SAAS,MAAMA,EAAE,SAAQ;AAAA,EAC9D,IAAI,EAAE,YAAY,GAAG,aAAa,SAAS,MAAMA,EAAE,SAAQ;AAAA,EAC3D,KAAK,EAAE,YAAY,GAAG,aAAa,SAAS,MAAMA,EAAE,SAAQ;AAC9D,GAAG/F,KAAI;AAAA,EACL,KAAK,EAAE,YAAY,GAAG,aAAa,QAAQ,MAAM+F,EAAE,UAAS;AAAA,EAC5D,KAAK,EAAE,YAAY,GAAG,aAAa,QAAQ,MAAMA,EAAE,UAAS;AAAA,EAC5D,KAAK,EAAE,YAAY,GAAG,aAAa,SAAS,MAAMA,EAAE,UAAS;AAAA,EAC7D,KAAK,EAAE,YAAY,GAAG,aAAa,QAAQ,MAAMA,EAAE,UAAS;AAC9D;AACA,MAAMzJ,EAAE;AAAA,EACNkK;AAAA,EACAC,KAAK,CAAA;AAAA,EACLC,KAAK,CAAA;AAAA,EACLC,KAAK,CAAA;AAAA,EACLC;AAAA,EACA,YAAYxC,GAAG;AACb,SAAKoC,KAAK,OAAOpC,IAAI,MAAMnE,EAAE,UAAUmE,GAAG,KAAK,0BAAyB;AAAA,EAC1E;AAAA;AAAA,EAEA,IAAI,MAAM;AACR,WAAO,KAAKqC;AAAA,EACd;AAAA,EACA,IAAI,WAAW;AACb,WAAO,KAAKA,GAAG,IAAI,CAACrC,MAAMA,EAAE,KAAK;AAAA,EACnC;AAAA,EACA,4BAA4B;AAC1B,WAAO,KAAKoC,OAAOvG,EAAE,OAAO,KAAKyG,KAAK1G,IAAG,KAAK4G,KAAK,MAAM,KAAKJ,OAAOvG,EAAE,WAAW,KAAKyG,KAAKxK,IAAG,KAAK0K,KAAK,MAAM,KAAKJ,OAAOvG,EAAE,cAAc,KAAKyG,KAAKxG,IAAG,KAAK0G,KAAK,OAAO,KAAKF,KAAKrC,IAAG,KAAKuC,KAAK,KAAK,KAAKD,KAAK,OAAO,KAAK,KAAKD,EAAE,EAAE,KAAK,CAACtC,GAAGxH,MAAMA,EAAE,SAASwH,EAAE,MAAM,GAAG,KAAKsC;AAAA,EAChR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAUtC,GAAGxH,GAAG;AACd,QAAI0D,GAAG6F;AACP,QAAI7F,IAAI,IAAI6F,IAAI,QAAQ/B,EAAExH,CAAC,MAAM;AAC/B,MAAA0D,IAAI,KAAK6F,IAAIJ,EAAE;AAAA,aACR3B,EAAExH,CAAC,MAAM;AAChB,MAAA0D,IAAI,KAAK6F,IAAIJ,EAAE;AAAA,aACR3B,EAAExH,CAAC,MAAM;AAChB,MAAA0D,IAAI,KAAK6F,IAAIJ,EAAE;AAAA,SACZ;AACH,iBAAW9B,KAAK,KAAK0C;AACnB,YAAIvC,EAAE,UAAUxH,GAAGA,IAAIqH,EAAE,MAAM,MAAMA,GAAG;AACtC,UAAA3D,KAAK2D,GAAGkC,IAAI,KAAKO,GAAGzC,CAAC,EAAE;AACvB;AAAA,QACF;AACF,iBAAWA,KAAK6B;AACd,YAAI1B,EAAE,UAAUxH,GAAGA,IAAIqH,EAAE,MAAM,MAAMA,GAAG;AACtC,UAAA3D,KAAK2D,GAAGkC,IAAIJ,EAAE;AACd;AAAA,QACF;AACF,UAAIzF,MAAM;AACR,YAAI,SAAS,KAAK8D,EAAExH,CAAC,CAAC,GAAG;AACvB,gBAAMqH,IAAI,aAAa,KAAKG,EAAE,UAAUxH,CAAC,CAAC;AAC1C,UAAA0D,IAAI2D,IAAIA,EAAE,CAAC,IAAI,IAAIkC,IAAIJ,EAAE;AAAA,QAC3B,WAAW,WAAW,KAAK3B,EAAExH,CAAC,CAAC,GAAG;AAChC,gBAAMqH,IAAI,cAAc,KAAKG,EAAE,UAAUxH,CAAC,CAAC;AAC3C,UAAA0D,IAAI2D,IAAIA,EAAE,CAAC,IAAI,IAAIkC,IAAIJ,EAAE;AAAA,QAC3B;AACE,kBAAQ,IAAI,sBAAsB3B,EAAExH,CAAC,GAAGwH,GAAGxH,CAAC,GAAG0D,IAAI8D,EAAExH,CAAC,GAAGuJ,IAAIJ,EAAE;AAAA,IACrE;AACA,QAAII,MAAM;AACR,YAAM,IAAI,MAAM,qCAAqC7F,CAAC,EAAE;AAC1D,WAAO,CAACA,GAAG1D,IAAI0D,EAAE,QAAQ6F,CAAC;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM/B,GAAGxH,GAAG;AACV,UAAM0D,IAAI,IAAI6F,IAAI,CAAA;AAClB,QAAIlC,IAAI,IAAI3E,IAAI,GAAG8G;AACnB,KAACxJ,KAAK,KAAKgK,QAAQxC,IAAI6B,GAAE7B,GAAG,KAAKsC,EAAE;AACnC,QAAIL,IAAI,IAAIxJ;AACZ,WAAOyC,IAAI8E,EAAE,UAAU;AACrB,UAAIiC,KAAKA,MAAM,GAAG;AAChB,gBAAQ,IAAI,uBAAuB;AACnC;AAAA,MACF;AACA,cAAQ,CAACpC,GAAG3E,GAAG8G,CAAC,IAAI,KAAK,UAAUhC,GAAG9E,CAAC,GAAG8G,GAAC;AAAA,QACzC,KAAKL,EAAE;AAAA,QACP,KAAKA,EAAE;AAAA,QACP,KAAKA,EAAE;AAAA,QACP,KAAKA,EAAE;AACL,UAAAzF,EAAE,KAAK;AAAA,YACL,OAAO2D;AAAA,YACP,WAAWmC;AAAA,UACvB,CAAW;AACD;AAAA,QACF,KAAKL,EAAE;AACL,cAAII,EAAE,SAAS,GAAG;AAChB,gBAAIG,IAAIH,EAAEA,EAAE,SAAS,CAAC;AACtB,iBAAKtJ,IAAI,IAAIyJ,EAAE,SAAS,KAAKI;AAAA,aAC5B,KAAKA,GAAGzC,CAAC,EAAE,gBAAgB,UAAU,KAAKyC,GAAGzC,CAAC,EAAE,cAAc,KAAKyC,GAAGJ,EAAE,KAAK,EAAE;AAAA,YAChF,KAAKI,GAAGzC,CAAC,EAAE,gBAAgB,WAAW,KAAKyC,GAAGzC,CAAC,EAAE,aAAa,KAAKyC,GAAGJ,EAAE,KAAK,EAAE,eAAe;AAC5F,kBAAIzJ,KAAKA,MAAM,GAAG;AAChB,wBAAQ,IAAI,iCAAiC;AAC7C;AAAA,cACF;AACA,kBAAIyD,EAAE,KAAK6F,EAAE,IAAG,KAAM,EAAE,OAAO,IAAI,WAAWJ,EAAE,UAAS,CAAE,GAAGI,EAAE,WAAW;AACzE;AACF,cAAAG,IAAIH,EAAEA,EAAE,SAAS,CAAC;AAAA,YACpB;AAAA,UACF;AACA,UAAAA,EAAE,KAAK,EAAE,OAAOlC,GAAG,WAAWmC,GAAG;AACjC;AAAA,QACF,KAAKL,EAAE;AACL,eAAKlJ,IAAI,IAAIsJ,EAAEA,EAAE,SAAS,CAAC,EAAE,UAAU,OAAOA,EAAE,SAAS,KAAK;AAC5D,gBAAItJ,KAAKA,MAAM,GAAG;AAChB,sBAAQ,IAAI,yCAAyC;AACrD;AAAA,YACF;AACA,YAAAyD,EAAE,KAAK6F,EAAE,IAAG,KAAM,EAAE,OAAOlC,GAAG,WAAWmC,GAAG;AAAA,UAC9C;AACA;AAAA,QACF,KAAKL,EAAE;AACL,UAAAI,EAAE,KAAK,EAAE,OAAOlC,GAAG,WAAWmC,EAAC,CAAE,GAAGhC,EAAE9E,CAAC,MAAM,OAAOgB,EAAE,KAAK,EAAE,OAAO,KAAK,WAAWyF,EAAE,aAAa;AACnG;AAAA,QACF,KAAKA,EAAE;AACL,eAAKlJ,IAAI,IAAIsJ,EAAEA,EAAE,SAAS,CAAC,EAAE,UAAU,OAAOA,EAAE,SAAS,KAAK;AAC5D,gBAAItJ,KAAKA,MAAM,GAAG;AAChB,sBAAQ,IAAI,2CAA2C;AACvD;AAAA,YACF;AACA,YAAAyD,EAAE,KAAK6F,EAAE,IAAG,KAAM,EAAE,OAAOlC,GAAG,WAAWmC,GAAG;AAAA,UAC9C;AACA,UAAAD,EAAE,IAAG;AACL;AAAA,QACF,KAAKJ,EAAE;AACL,UAAAI,EAAE,KAAK,EAAE,OAAOlC,GAAG,WAAWmC,GAAG;AACjC;AAAA,QACF;AACE,gBAAM,IAAI,MAAM,cAAcnC,CAAC,iBAAiB;AAAA,MAC1D;AAAA,IACI;AACA,WAAO,KAAKwC,KAAKnG,EAAE,OAAO6F,EAAE,QAAO,CAAE,GAAG;AAAA,EAC1C;AACF;AACA,MAAMU,GAAE;AAAA,EACN;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAYzC,GAAGxH,GAAG;AAChB,SAAK,cAAcwH;AACnB,QAAI;AACF,WAAK,OAAO,IAAI9H,EAAE2D,EAAE,OAAO,EAAE,MAAMmE,GAAGxH,CAAC,EAAE;AAAA,IAC3C,SAAS0D,GAAG;AACV,YAAM,KAAK,OAAO,MAAM,KAAK,WAAW,IAAI,QAAQ,KAAKA,CAAC,GAAG,IAAI,MAAM,gCAAgC8D,CAAC,EAAE;AAAA,IAC5G;AAAA,EACF;AAAA,EACA,IAAI,MAAM;AACR,WAAO,KAAK,QAAQ,CAAA;AAAA,EACtB;AAAA,EACA,IAAI,UAAU;AACZ,QAAI,KAAK,aAAa;AACpB,UAAI;AACF,aAAK,SAAS,EAAE,GAAG,EAAC,CAAE;AAAA,MACxB,QAAQ;AACN,aAAK,WAAW;AAAA,MAClB;AACF,WAAO,KAAK,YAAY;AAAA,EAC1B;AAAA,EACA,IAAI,QAAQA,GAAG;AACb,SAAK,WAAWA;AAAA,EAClB;AAAA,EACA,IAAI,aAAa;AACf,WAAO,KAAK;AAAA,EACd;AAAA,EACA,SAASA,GAAG;AACV,UAAMxH,IAAI,CAAA;AACV,QAAI,KAAK,SAAS;AAChB,aAAO,KAAK,WAAW,IAAI;AAC7B,SAAK,WAAW;AAChB,eAAW0D,KAAK,KAAK;AACnB,UAAIA,EAAE,cAAcyF,EAAE;AACpB,YAAI,CAAC,MAAM,CAACzF,EAAE,KAAK;AACjB,UAAA1D,EAAE,KAAK,CAAC0D,EAAE,KAAK;AAAA,aACZ;AACH,gBAAM6F,IAAI7F,EAAE,MAAM,MAAM,GAAG;AAC3B,cAAI6F,EAAE,WAAW;AACf,kBAAM,KAAK,WAAW,IAAI,IAAI,MAAM,oCAAoC;AAC1E,UAAAvJ,EAAE,KAAK,CAACuJ,EAAE,CAAC,IAAI,CAACA,EAAE,CAAC,CAAC;AAAA,QACtB;AAAA,eACO7F,EAAE,cAAcyF,EAAE,YAAY3B,MAAM;AAC3C,eAAO,OAAOA,GAAG9D,EAAE,KAAK,KAAK1D,EAAE,KAAK,CAACwH,EAAE9D,EAAE,KAAK,CAAC;AAAA,eACxCA,EAAE,cAAcyF,EAAE;AACzB,QAAAnJ,EAAE,KAAKkJ,GAAExF,EAAE,KAAK,CAAC;AAAA,eACVA,EAAE,cAAcyF,EAAE;AACzB,YAAIzF,EAAE,UAAU,KAAK;AACnB,gBAAM6F,IAAIvJ,EAAE,IAAG,GAAIqH,IAAIrH,EAAE,IAAG;AAC5B,cAAIqH,MAAM,UAAUkC,MAAM;AACxB,kBAAM,KAAK,WAAW,IAAI,IAAI,MAAM,8BAA8BlC,KAAK,GAAG,OAAOkC,KAAK,GAAG,kBAAkB;AAC7G,UAAAvJ,EAAE,KAAKqH,IAAIkC,CAAC;AAAA,QACd,WAAW7F,EAAE,UAAU,KAAK;AAC1B,gBAAM6F,IAAIvJ,EAAE,IAAG,GAAIqH,IAAIrH,EAAE,IAAG;AAC5B,cAAIqH,MAAM,UAAUkC,MAAM;AACxB,kBAAM,KAAK,WAAW,IAAI,IAAI,MAAM,uBAAuBlC,KAAK,GAAG,OAAOkC,KAAK,GAAG,kBAAkB;AACtG,UAAAvJ,EAAE,KAAKqH,IAAIkC,CAAC;AAAA,QACd,WAAW7F,EAAE,UAAU,KAAK;AAC1B,gBAAM6F,IAAIvJ,EAAE,IAAG,GAAIqH,IAAIrH,EAAE,IAAG;AAC5B,cAAIqH,MAAM,UAAUkC,MAAM;AACxB,kBAAM,KAAK,WAAW,IAAI,IAAI,MAAM,uBAAuBlC,KAAK,GAAG,OAAOkC,KAAK,GAAG,kBAAkB;AACtG,UAAAvJ,EAAE,KAAK,CAACqH,IAAI,CAACkC,CAAC;AAAA,QAChB,WAAW7F,EAAE,UAAU,KAAK;AAC1B,gBAAM6F,IAAIvJ,EAAE,IAAG,GAAIqH,IAAIrH,EAAE,IAAG,KAAM;AAClC,cAAIuJ,MAAM;AACR,kBAAM,KAAK,WAAW,IAAI,IAAI,MAAM,yCAAyC;AAC/E,UAAAvJ,EAAE,KAAKqH,IAAIkC,CAAC;AAAA,QACd,WAAW7F,EAAE,UAAU,KAAK;AAC1B,gBAAM6F,IAAIvJ,EAAE,IAAG,GAAIqH,IAAIrH,EAAE,IAAG;AAC5B,cAAIqH,MAAM,UAAUkC,MAAM;AACxB,kBAAM,KAAK,WAAW,IAAI,IAAI,MAAM,kBAAkBlC,KAAK,GAAG,gBAAgBkC,KAAK,GAAG,kBAAkB;AAC1G,UAAAvJ,EAAE,KAAK,KAAK,IAAIqH,GAAGkC,CAAC,CAAC;AAAA,QACvB;AAAA,iBACS7F,EAAE,cAAcyF,EAAE,UAAU;AACrC,cAAMI,IAAIvJ,EAAE,IAAG;AACf,YAAIuJ,MAAM;AACR,gBAAM,KAAK,WAAW,IAAI,IAAI,MAAM,sBAAsB7F,EAAE,KAAK,iBAAiB;AACpF,YAAIA,EAAE,UAAU;AACd,UAAA1D,EAAE,KAAK,KAAK,IAAIuJ,CAAC,CAAC;AAAA,iBACX7F,EAAE,UAAU;AACnB,UAAA1D,EAAE,KAAK,KAAK,IAAIuJ,CAAC,CAAC;AAAA,iBACX7F,EAAE,UAAU;AACnB,UAAA1D,EAAE,KAAK,KAAK,IAAIuJ,CAAC,CAAC;AAAA,iBACX7F,EAAE,UAAU;AACnB,UAAA1D,EAAE,KAAK,KAAK,KAAKuJ,CAAC,CAAC;AAAA,iBACZ7F,EAAE,UAAU,SAAS;AAC5B,gBAAM2D,IAAIrH,EAAE,IAAG;AACf,cAAIqH,MAAM;AACR,kBAAM,KAAK,WAAW,IAAI,IAAI,MAAM,4CAA4C;AAClF,UAAAkC,IAAI,MAAM,KAAKlC,IAAI,IAAIrH,EAAE,KAAK,GAAG,IAAIA,EAAE,MAAMqH,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK,IAAIA,CAAC,GAAG,IAAIkC,CAAC,CAAC;AAAA,QAC7F,MAAO,CAAA7F,EAAE,UAAU,OAAO1D,EAAE,KAAK,KAAK,IAAIuJ,CAAC,CAAC,IAAI7F,EAAE,UAAU,SAAS1D,EAAE,KAAK,KAAK,MAAMuJ,CAAC,CAAC;AAAA,MAC3F;AACF,QAAIvJ,EAAE,WAAW;AACf,aAAO,KAAK,kBAAkBA,EAAE,CAAC,CAAC;AACpC,UAAM,IAAI,MAAM,gCAAgC,KAAK,WAAW,EAAE;AAAA,EACpE;AAAA,EACA,kBAAkBwH,GAAGxH,IAAI,GAAG;AAC1B,WAAO,CAACwH,EAAE,QAAQxH,CAAC;AAAA,EACrB;AACF;AC3TO,MAAMkK,EAA4F;AAAA,EACrGhG;AAAA,EACAiG;AAAA,EAIA,YAAYjL,GAAgC;AACxC,gBAAKgF,KAAe,IAAIxC,EAAA,EAAW,KAAA,GACnC,KAAKyI,KAAW,CAAA,GAEZjL,MAAU,UAEV,KAAK,MAAMA,CAAK,GAGb;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,MAAMkL,GAAqC;AAK9C,WAHA,KAAKlG,KAAe,IAAIxC,EAAA,GACxB,KAAKyI,KAAW,CAAA,GAEZC,aAAoBF,KACpB,KAAKhG,KAAekG,EAASlG,GAAa,MAAA,GAG1C,KAAKmG,GAAcD,CAAQ,GACpB,QAGPA,aAAoB1I,KACpB,KAAKwC,KAAekG,EAAS,MAAA,GACtB,QAGP,OAAOA,KAAa,YACpB,KAAKlG,KAAe,IAAIxC,EAAS0I,CAAQ,GAClC,SAIN,MAAM,OAAOA,CAAQ,CAAC,IAGvB,KAAKE,GAA2BF,CAAQ,IAFxC,KAAKlG,KAAe,IAAIxC,EAAS,OAAO0I,CAAQ,CAAC,GAI9C;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKO,QAAQ,MAAa;AACxB,UAAM9H,IAAW,IAAI4H,EAAA;AAErB,IAAA5H,EAAE,cAAc,KAAK4B,GAAa,MAAA;AAGlC,eAAWZ,KAAK,KAAK6G;AACjB,MAAA7H,EAAE,UAAUgB,GAAG,KAAK6G,GAAS7G,CAAC,EAAE,OAAO;AAE3C,WAAOhB;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,IAAW,MAAc;AACrB,QAAIiI,IAAI;AACR,UAAMC,IAAU,OAAO,KAAK,KAAKL,EAAQ,EAAE,KAAA;AAE3C,eAAWM,KAAUD;AACjB,MAAI,KAAKL,GAASM,CAAM,EAAE,gBACtBF,KAAKE,GACD,KAAKN,GAASM,CAAM,EAAE,WAAW,CAAC,MAClCF,KAAK,MAAM,KAAKJ,GAASM,CAAM,EAAE,MAAM,GAAG;AAKtD,WAAIF,MAAM,KAEF,KAAKrG,GAAa,SAAS,IACpB,KAAKA,GAAa,KAAK,MAEvB,MAGP,KAAKA,GAAa,UAAU,IACrBqG,IACA,KAAKrG,GAAa,UAAU,KAC5B,IAAIqG,CAAC,KACL,KAAKrG,GAAa,UAAU,IAC5B,MAEA,GAAG,KAAKA,GAAa,KAAK,GAAG,GAAGqG,CAAC;AAAA,EAGpD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,UAAkB;AACzB,QAAIA,IAAI;AACR,UAAMC,IAAU,OAAO,KAAK,KAAKL,EAAQ,EAAE,KAAA;AAC3C,eAAWM,KAAUD;AACjB,MAAI,KAAKL,GAASM,CAAM,EAAE,gBACtBF,KAAKE,GACD,KAAKN,GAASM,CAAM,EAAE,WAAW,CAAC,MAClCF,KAAK,KAAK,KAAKJ,GAASM,CAAM,EAAE,OAAO;AAKnD,WAAIF,MAAM,KAEF,KAAKrG,GAAa,SAAS,IACpB,KAAKA,GAAa,UAElB,KAGP,KAAKA,GAAa,UAAU,IACrBqG,IACA,KAAKrG,GAAa,UAAU,KAC5B,IAAIqG,CAAC,KACL,KAAKrG,GAAa,UAAU,IAC5B,MAEA,GAAG,KAAKA,GAAa,OAAO,GAAGqG,CAAC;AAAA,EAGnD;AAAA,EAEA,OAAc,MAAM,IAAIG,MAA2B;AAE/C,eAAW7H,KAAK6H;AACZ,UAAI7H,EAAE;AACF,eAAO,IAAIqH,EAAA,EAAQ,KAAA;AAI3B,UAAMzH,IAAI,IAAIyH,EAAA,GACVxG,IAAYlC,EAAQ,IAAI,GAAGkJ,EAAO,IAAI,CAAAxL,MAASA,EAAM,YAAY,SAAS,CAAC,GAC3EuI,IAAYjG,EAAQ,IAAI,GAAGkJ,EAAO,IAAI,CAAAxL,MAASA,EAAM,YAAY,WAAW,CAAC;AAGjF,IAAAuD,EAAE,cAAc,IAAIf,EAASgC,GAAG+D,CAAC,EAAE,OAAA;AAGnC,eAAW5E,KAAK6H,GAAQ;AAEpB,iBAAWD,KAAUhI,EAAE;AACnB,QAAMgI,KAAU5H,EAAE,WACdJ,EAAE,QAAQgI,CAAM,EAAE,KAAA;AAG1B,iBAAWA,KAAU5H,EAAE;AACnB,QAAI,CAACJ,EAAE,YAAYgI,CAAM,KAAK5H,EAAE,QAAQ4H,CAAM,EAAE,uBAC5ChI,EAAE,QAAQgI,CAAM,IAAI5H,EAAE,QAAQ4H,CAAM,EAAE,MAAA,IAEtChI,EAAE,QAAQgI,CAAM,IAAI,IAAI/I,EAAS,KAAK,IAAImB,EAAE,QAAQ4H,CAAM,EAAE,OAAOhI,EAAE,QAAQgI,CAAM,EAAE,KAAK,CAAC;AAAA,IAGvG;AAEA,WAAOhI;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAc,YAAY,IAAIiI,MAA2B;AACrD,UAAMjI,IAAI,IAAIyH,EAAA,EAAQ,IAAA;AAEtB,eAAWrH,KAAK6H;AACZ,MAAAjI,EAAE,SAASI,CAAC;AAGhB,WAAOJ;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,MAAM,IAAIA,MAAsC;AACnD,eAAWI,KAAKJ,GAAG;AAEf,YAAMkI,IAAc9H,aAAaqH,IAAyBrH,IAAf,IAAIqH,EAAMrH,CAAC;AAEtD,MAAI,KAAK,SAAS8H,CAAQ,KAClB,KAAK,YACL,KAAKN,GAAcM,CAAQ,GAG/B,KAAKzG,GAAa,IAAIyG,EAAS,WAAW,KAE1C,QAAQ,IAAI,gBAAgB,KAAK,UAAU,yBAAyBA,EAAS,OAAO;AAAA,IAE5F;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,cAAwB;AAC/B,WAAO,KAAKzG;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,YAAY5B,GAAyB;AAC5C,SAAK4B,KAAe,IAAIxC,EAASY,CAAC;AAAA,EACtC;AAAA,EAEO,wBAAwB,MACpB,OAAO,OAAO,KAAK6H,EAAQ,EAAE,KAAK,CAACjL,MAAUA,EAAM,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA,EAOnE,SAAS,CAACuL,MACT,KAAK,UAAU,WAAW,IACnB,IAAI/I,EAAA,EAAW,KAAA,IAEtB+I,MAAW,SAEJ,OAAO,OAAO,KAAKN,EAAQ,EAAE,OAAO,CAAC,GAAGzG,MAAM,EAAE,MAAA,EAAQ,IAAIA,CAAC,CAAC,IAG7D,KAAK,YAAY+G,CAAM,IAA4B,KAAKN,GAASM,CAAM,EAAE,MAAA,IAA9C,IAAI/I,EAAA,EAAW,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQnD,aAAa,CAAC+I,IAAS,QAAe;AAEzC,QAAI,KAAK,YAAYA,CAAM,GAAG;AAC1B,YAAMhD,IAAI,KAAK0C,GAASM,CAAM,EAAE,SAC5BG,IAAK,KAAK,MAAA;AAGd,aAAAA,EAAGT,GAASM,CAAM,EAAE,SAAS,CAAC,GAG9BG,EAAG1G,GAAa,SAAS,IAAIxC,EAAS+F,EAAE,MAAA,CAAO,CAAC,GACzCmD;AAAA,IACX;AACI,aAAO,IAAIV,EAAA,EAAQ,KAAA;AAAA,EAE3B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,SAAS,IAAIzH,MAAsC;AAEtD,eAAWI,KAAKJ,GAAG;AAEf,YAAMkI,IAAc9H,aAAaqH,IAAyBrH,IAAf,IAAIqH,EAAMrH,CAAC;AAGtD,WAAKqB,GAAa,OAAOyG,EAAS,WAAW;AAG7C,iBAAWF,KAAUE,EAAS;AAE1B,aAAKR,GAASM,CAAM,IAAI,KAAK,YAAYA,CAAM,IAC3C,KAAKN,GAASM,CAAM,EAAE,SAASE,EAAS,QAAQF,CAAM,CAAC,IACvDE,EAAS,QAAQF,CAAM,EAAE,MAAA,EAAQ,SAAA,GAIjC,KAAKN,GAASM,CAAM,EAAE,YACtB,KAAK,eAAeA,CAAM;AAAA,IAGtC;AACA,WAAO;AAAA,EACX;AAAA,EAEA,IAAW,WAAoB;AAE3B,QAAI,CAAC,KAAK,YAAY;AAClB,aAAO,CAAC,KAAK,OAAO;AAIxB,QAAI,KAAK;AACL,aAAO,CAAC,KAAK,OAAO;AAIxB,QAAI,KAAK,YAAY,YAAY;AAC7B,aAAO,CAAC,KAAK,OAAO;AAGxB,UAAMrL,IAAWoC,EAAQ,SAAS,KAAK,IAAI,KAAK,YAAY,SAAS,CAAC;AAGtE,QAAIqJ,IAAoC,CAAA;AACxC,eAAWN,KAAK,KAAK;AAEjB,MAAAM,IAAW,KAAK,oBAAoBA,GAAUN,CAAC;AAGnD,UAAMO,IAAyB,CAAA;AAC/B,QAAID,EAAS,SAAS,KAAKzL,EAAS,SAAS;AACzC,iBAAWiE,KAAKjE;AACZ,mBAAWmL,KAAKM,GAAU;AACtB,gBAAMpI,IAAI,IAAIyH,EAAA;AACd,UAAAzH,EAAE,cAAc,IAAIf,EAAS2B,CAAC,GAC9BZ,EAAE,UAAU8H,GACZO,EAAc,KAAKrI,CAAC;AAAA,QACxB;AAAA,aAEGrD,EAAS,WAAW;AAC3B,iBAAWmL,KAAKM,GAAU;AACtB,cAAMpI,IAAI,IAAIyH,EAAA;AACd,QAAAzH,EAAE,cAAc,IAAIf,EAAA,EAAW,IAAA,GAC/Be,EAAE,UAAU8H,GACZO,EAAc,KAAKrI,CAAC;AAAA,MACxB;AAAA;AAEA,iBAAWY,KAAKjE,GAAU;AACtB,cAAMqD,IAAI,IAAIyH,EAAA;AACd,QAAAzH,EAAE,cAAc,IAAIf,EAAS2B,CAAC,GAC9ByH,EAAc,KAAKrI,CAAC;AAAA,MACxB;AAGJ,WAAOqI,EAAc,WAAW,IAAI,CAAC,IAAIZ,IAAQ,IAAA,CAAK,IAAIY;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,WAAW,CAACrL,GAA+DsL,MAA2C;AAEzH,QAAIA,MAAc,IAAM;AAGpB,UAAItL,aAAkBiC;AAClB,eAAO,KAAKsJ,GAAmBvL,EAAO,KAAK;AAI/C,UAAI,OAAOA,KAAW;AAClB,eAAO,KAAKuL,GAAmBvL,CAAM;AAIzC,UAAI,OAAOA,KAAW,UAAU;AAE5B,cAAMwL,IAAiC,CAAA;AACvC,mBAAWV,KAAK9K;AACZ,UAAAwL,EAAUV,CAAC,IAAI,IAAI7I,EAASjC,EAAO8K,CAAC,CAAC,EAAE;AAG3C,eAAO,KAAKS,GAAmBC,CAAS;AAAA,MAC5C;AAAA,IACJ;AAGA,UAAM3B,IAAI,KAAK,YAAY,MAAA;AAE3B,QAAI,OAAO7J,KAAW,YAAYA,aAAkBiC,GAAU;AAC1D,YAAMuJ,IAAmC,CAAA;AACzC,aAAAA,EAAU,KAAK,UAAU,CAAC,CAAC,IAAI,IAAIvJ,EAASjC,CAAM,GAC3C,KAAK,SAASwL,CAAS;AAAA,IAClC;AAEA,QAAI,OAAOxL,KAAW,UAAU;AAC5B,UAAI,KAAK,UAAU,WAAW;AAC1B,eAAO,KAAK;AAGhB,iBAAW8K,KAAK,KAAKJ,IAAU;AAC3B,cAAMjL,IAAQ,IAAIwC,EAASjC,EAAO8K,CAAC,CAAC;AAEpC,QAAAjB,EAAE,SAASpK,EAAM,IAAI,KAAKiL,GAASI,CAAC,CAAC,CAAC;AAAA,MAC1C;AAAA,IACJ;AAEA,WAAOjB;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,cAAc,CAACmB,MAEX,OAAO,OAAO,KAAKN,IAAUM,KAAU,GAAG;AAAA,EAG9C,UAAUxK,GAAyBC,GAAyBuK,GAA2B;AAC1F,UAAMS,IAAY,KAAK,UAAUT,CAAM;AAEvC,WAAQS,EAAU,SAAShL,CAAC,EACvB,SAASgL,EAAU,SAASjL,CAAC,CAAa;AAAA,EACnD;AAAA,EAEO,UAAU,MAAY;AACzB,SAAKiE,GAAa,SAAA;AAClB,eAAWuG,KAAU,KAAKN;AACtB,WAAKA,GAASM,CAAM,EAAE,SAAA;AAE1B,WAAO;AAAA,EACX;AAAA,EAEO,cAAc,CAACU,MAAwB;AAE1C,QAAIA,EAAI,SAAS;AACb,iBAAWV,KAAUU,EAAI;AACrB,YAAI,CAAC,KAAK,OAAOV,CAAM,EAAE,MAAMU,EAAI,OAAOV,CAAM,CAAC;AAC7C,iBAAO;AAAA;AAMnB,WAAI,KAAK,YAAY,WAAA,KAAgBU,EAAI,YAAY,eAC1C,KAGJ,KAAK,YAAY,MAAA,EAAQ,OAAOA,EAAI,WAAW,EAAE,WAAA;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,UAAU,CAAC1I,MACP,KAAK,SAASA,CAAC,KAAK,KAAKyB,GAAa,QAAQzB,EAAE,WAAW;AAAA,EAG/D,kBAAkB,MAAe;AACpC,eAAWgI,KAAU,KAAK;AAOtB,UALI,KAAK,QAAQA,CAAM,EAAE,gBAKrB,KAAK,QAAQA,CAAM,EAAE;AACrB,eAAO;AAIf,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKO,QAAQ,MACJ,KAAKvG,GAAa,UAAU,KAAK,KAAK,UAAU,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,EAO/D,WAAW,CAACzB,MAAsB;AAErC,UAAM2I,IAAe,KAAK,WACpBC,IAAe5I,EAAE,WAGjB6I,IAAcF,EAAG,OAAOC,EAAG,OAAO,CAACE,MAAS,CAACH,EAAG,SAASG,CAAI,CAAC,CAAC;AAQrE,QALI,KAAK,OAAA,KAAY9I,EAAE,YAKnB2I,EAAG,WAAW,KAAKC,EAAG,WAAW;AACjC,aAAO;AAIX,QAAID,EAAG,WAAWC,EAAG;AACjB,aAAO;AAIX,QAAI,CAAC,KAAK,OAAA,KAAY,CAAC5I,EAAE;AACrB,iBAAW+I,KAAOF;AAOd,YALI,CAAC,KAAK,YAAYE,CAAG,KAAK,CAAC/I,EAAE,YAAY+I,CAAG,KAK5C,CAAC,KAAKrB,GAASqB,CAAG,EAAE,QAAQ/I,EAAE,QAAQ+I,CAAG,CAAC;AAC1C,iBAAO;AAAA;AAMnB,WAAO;AAAA,EACX;AAAA,EAEO,WAAW,MACT,KAAK,YAAY,aAGf,KAAK,gBAAA,IAFD;AAAA;AAAA;AAAA;AAAA,EAQR,SAAS,MACL,KAAKtH,GAAa,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA,EAOvC,IAAW,UAAiC;AACxC,WAAO,KAAKiG;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,QAAQI,GAA0B;AACzC,SAAKJ,KAAWI;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,cAAqC;AAE5C,QAAI,KAAK,mBAAmB;AACxB,YAAMA,IAA2B,CAAA;AACjC,iBAAWiB,KAAO,KAAKrB;AACnB,QAAAI,EAAEiB,CAAG,IAAI,KAAKrB,GAASqB,CAAG,EAAE,MAAA,EAAQ,KAAA;AAExC,aAAOjB;AAAA,IACX;AACI,aAAO,KAAKJ;AAAA,EAEpB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,WAAWC,GAAkB;AAIpC,eAAW7K,KAAK,CAAC,GAAG6K,EAAS,SAAS,yBAAyB,CAAC;AAE5D,MAAM7K,EAAE,CAAC,KAAK,KAAK4K,OACf,KAAKA,GAAS5K,EAAE,CAAC,CAAC,IAAI,IAAImC,EAAA,EAAW,KAAA,IAKzC,KAAKyI,GAAS5K,EAAE,CAAC,CAAC,EAAE,IAAI,CAACA,EAAE,CAAC,CAAC;AAIjC,eAAWA,KAAK,CAAC,GAAG6K,EAAS,SAAS,gBAAgB,CAAC;AAEnD,MAAM7K,EAAE,CAAC,KAAK,KAAK4K,OACf,KAAKA,GAAS5K,EAAE,CAAC,CAAC,IAAI,IAAImC,EAAA,EAAW,KAAA,IAIzC,KAAKyI,GAAS5K,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC;AAAA,EAEjC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,WAAW,IAAIkD,MAAsC;AACxD,eAAWI,KAAKJ,GAAG;AAEf,YAAMkI,IAAc9H,aAAaqH,IAAyBrH,IAAf,IAAIqH,EAAMrH,CAAC;AAGtD,WAAKqB,GAAa,SAASyG,EAAS,WAAW;AAG/C,iBAAWF,KAAUE,EAAS;AAC1B,QAAK,KAAK,YAAYF,CAAM,IAGxB,KAAKN,GAASM,CAAM,EAAE,IAAIE,EAAS,QAAQF,CAAM,CAAC,IAFlD,KAAKN,GAASM,CAAM,IAAIE,EAAS,QAAQF,CAAM,EAAE,MAAA;AAAA,IAK7D;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKO,MAAM,OACT,KAAKvG,KAAe,IAAIxC,EAAA,EAAW,IAAA,GACnC,KAAKyI,KAAW,CAAA,GACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAOJ,WAAW,OACd,KAAKjG,GAAa,SAAA,GACX;AAAA,EAGX,IAAW,eAAuB;AAC9B,QAAIqG,IAAI;AACR,UAAMC,IAAU,OAAO,KAAK,KAAKL,EAAQ,EAAE,KAAA;AAE3C,eAAWM,KAAUD;AACjB,MAAI,KAAKL,GAASM,CAAM,EAAE,gBACtBF,MAAMA,MAAM,KAAK,KAAK,OAAOE,GACzB,KAAKN,GAASM,CAAM,EAAE,WAAW,CAAC,MAClCF,KAAK,KAAK,KAAKJ,GAASM,CAAM,EAAE,OAAO;AAMnD,WAAIF,MAAM,KAEF,KAAKrG,GAAa,SAAS,IACpB,KAAKA,GAAa,UAElB,KAGP,KAAKA,GAAa,UAAU,IACrBqG,IACA,KAAKrG,GAAa,UAAU,KAC5B,IAAIqG,CAAC,KACL,KAAKrG,GAAa,UAAU,IAC5B,MAEA,GAAG,KAAKA,GAAa,OAAO,IAAIqG,CAAC;AAAA,EAGpD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,MAAM,CAAC9J,MAAgC;AAC1C,SAAKyD,GAAa,IAAIzD,CAAE;AACxB,eAAWgK,KAAU,KAAKN;AACtB,WAAKA,GAASM,CAAM,EAAE,SAAShK,CAAE;AAErC,WAAO;AAAA,EACX;AAAA,EAEO,YAAY,CAACgK,IAAS,QAAe;AAIxC,UAAMhI,IAAI,KAAK,MAAA;AACf,QAAIwC;AAEJ,WAAIxC,EAAE,YAAYgI,CAAM,KACpBxF,IAASxC,EAAE,OAAOgI,CAAM,EAAE,MAAA,EAAQ,IAAI,CAAC,GACvChI,EAAE,cAAcA,EAAE,YAAY,MAAA,EAAQ,OAAOwC,CAAM,GACnDxC,EAAE,UAAUgI,GAAQxF,CAAM,MAKtBxC,EAAE,YAAY,aACdA,EAAE,cAAc,IAAIf,EAAA,EAAW,IAAA,IAEnCe,EAAE,UAAUgI,GAAQ,CAAC,IAGlBhI;AAAA,EACX;AAAA,EAEO,SAAS,MAAY;AAExB,SAAK,YAAY,OAAA;AAGjB,eAAWgI,KAAU,KAAKN;AACtB,MAAI,KAAKA,GAASM,CAAM,EAAE,YACtB,KAAK,eAAeA,CAAM;AAGlC,WAAO;AAAA,EACX;AAAA,EAEO,eAAeA,GAAgB;AAElC,WAAO,KAAKN,GAASM,CAAM;AAAA,EAE/B;AAAA;AAAA;AAAA;AAAA,EAKO,OAAO,MAAY;AACtB,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,YAAY,CAACA,GAAgBlJ,MAC1BA,aAAeG,KAKjB,KAAK,YAAY+I,CAAM,KAAKlJ,EAAI,YAChC,KAAK,eAAekJ,CAAM,GAI9B,KAAKN,GAASM,CAAM,IAAIlJ,EAAI,MAAA,GAErB,QAXI,KAAK,UAAUkJ,GAAQ,IAAI/I,EAASH,CAAG,CAAC;AAAA;AAAA;AAAA;AAAA,EAiBhD,OAAO,MAAY;AACtB,QAAI,KAAK,YAAY;AACjB,WAAK2C,GAAa,KAAA;AAClB,iBAAWuG,KAAU,KAAKN;AACtB,aAAKA,GAASM,CAAM,EAAE,MAAA,EAAQ,OAAO,CAAC;AAAA,IAE9C;AAEA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,WAAW,IAAIhI,MAAsC;AACxD,eAAWI,KAAKJ,GAAG;AAEf,YAAMkI,IAAc9H,aAAaqH,IAAyBrH,IAAf,IAAIqH,EAAMrH,CAAC;AAEtD,MAAI,KAAK,SAAS8H,CAAQ,KAClB,KAAK,YACL,KAAKN,GAAcM,CAAQ,GAG/B,KAAKzG,GAAa,IAAIyG,EAAS,QAAQ,YAAY,UAAU,KAE7D,QAAQ,IAAI,8BAA8BA,EAAS,OAAO;AAAA,IAElE;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAW,YAAsB;AAG7B,UAAMJ,IAAc,CAAA;AACpB,kBAAO,QAAQ,KAAK,OAAO,EAAE;AAAA,MACzB,CAAC,CAACiB,GAAKtM,CAAK,MAAM;AACd,QAAKA,EAAM,YACPqL,EAAE,KAAKiB,CAAG;AAAA,MAElB;AAAA,IAAA,GACJjB,EAAE,KAAA,GACKA;AAAA,EAEX;AAAA;AAAA;AAAA;AAAA,EAKO,OAAO,OACV,KAAKrG,KAAe,IAAIxC,EAAA,EAAW,KAAA,GACnC,KAAKyI,KAAW,CAAA,GACT;AAAA,EAGXE,GAAcD,GAAiB;AAC3B,eAAW9G,KAAK8G,EAAS;AACrB,WAAKD,GAAS7G,CAAC,IAAI8G,EAAS,QAAQ9G,CAAC,EAAE,MAAA;AAAA,EAE/C;AAAA,EAEA0H,KAAqB,CAACvL,MAA0E;AAC5F,QAAI6J,IAAI,KAAK,YAAY;AAEzB,QAAI,OAAO7J,KAAW,UAAU;AAC5B,YAAMwL,IAAiC,CAAA,GACjCO,IAAM,KAAK,UAAU,CAAC;AAC5B,aAAAP,EAAUO,CAAG,IAAI/L,GAEV,KAAKuL,GAAmBC,CAAS;AAAA,IAC5C;AAEA,QAAIxL,aAAkBiC,GAAU;AAC5B,YAAMuJ,IAAiC,CAAA;AACvC,aAAAA,EAAU,KAAK,UAAU,CAAC,CAAC,IAAI,IAAIvJ,EAASjC,CAAM,EAAE,OAC7C,KAAKuL,GAAmBC,CAAS;AAAA,IAC5C;AAEA,QAAI,OAAOxL,KAAW,UAAU;AAC5B,UAAI,KAAK,UAAU,WAAW;AAC1B,eAAO,KAAK,YAAY;AAG5B,iBAAW8K,KAAK,KAAKJ,IAAU;AAC3B,cAAM5K,IAAIE,EAAO8K,CAAC;AAElB,QAAIhL,aAAamC,IACb4H,KAAK/J,EAAE,SAAU,KAAK4K,GAASI,CAAC,EAAE,QAElCjB,KAAK/J,KAAM,KAAK4K,GAASI,CAAC,EAAE;AAAA,MAEpC;AAAA,IACJ;AAEA,WAAOjB;AAAA,EACX;AAAA,EAEAgB,KAA6B,CAACF,MAA2B;AAGrD,UAAMqB,IADkB,IAAIC,IAAc,MAAMtB,CAAQ,EACQ,KAE1DuB,IAAiB,CAAA;AAEvB,QAAIF,EAAI,WAAW;AACf,kBAAK,KAAA,GACE;AACX,QAAWA,EAAI,WAAW,GAAG;AACzB,YAAMG,IAAUH,EAAI,CAAC;AAErB,kBAAK,IAAA,GACDG,EAAQ,cAAcC,EAAgB,cACtC,KAAK,cAAc,IAAInK,EAASkK,EAAQ,KAAK,IACtCA,EAAQ,cAAcC,EAAgB,YAC7C,KAAK,UAAUD,EAAQ,OAAO,CAAC,GAE5B;AAAA,IACX;AAEI,iBAAWA,KAAWH;AAClB,aAAKK,GAAsBH,GAAOC,CAAO;AAIjD,gBAAK,IAAA,GACL,KAAK,SAASD,EAAM,CAAC,CAAC,GACf;AAAA,EACX;AAAA,EAEAG,KAAwB,CAACH,GAAgBC,MAAyB;AAC9D,QAAIG,GAAWC,GAAWnJ,GAAU4H,GAAgBlJ;AAEpD,QAAIqK,EAAQ,cAAcC,EAAgB;AACtC,MAAAF,EAAM,KAAK,IAAIzB,EAAM,IAAIxI,EAASkK,EAAQ,KAAK,CAAC,CAAC;AAAA,aAE1CA,EAAQ,cAAcC,EAAgB,UAAU;AACvD,YAAMpJ,IAAI,IAAIyH,EAAA,EAAQ,IAAA;AACtB,MAAAzH,EAAE,UAAUmJ,EAAQ,OAAO,CAAC,GAC5BD,EAAM,KAAKlJ,EAAE,OAAO;AAAA,IAExB,WAAWmJ,EAAQ,cAAcC,EAAgB;AAC7C,cAAQD,EAAQ,OAAA;AAAA,QACZ,KAAK;AAED,UAAAI,IAAML,EAAM,IAAA,KAAU,IAAIzB,EAAA,EAAQ,KAAA,GAClC6B,IAAMJ,EAAM,IAAA,KAAU,IAAIzB,EAAA,EAAQ,KAAA,GAElCyB,EAAM,KAAKI,EAAG,SAASC,CAAE,CAAC;AAE1B;AAAA,QACJ,KAAK;AAED,UAAAA,IAAML,EAAM,IAAA,KAAU,IAAIzB,EAAA,EAAQ,IAAA,GAClC6B,IAAMJ,EAAM,IAAA,KAAU,IAAIzB,EAAA,EAAQ,IAAA,GAElCyB,EAAM,KAAKI,EAAG,SAASC,CAAE,CAAC;AAC1B;AAAA,QACJ,KAAK;AAED,UAAAA,IAAML,EAAM,IAAA,KAAU,IAAIzB,EAAA,EAAQ,IAAA,GAClC6B,IAAMJ,EAAM,IAAA,KAAU,IAAIzB,EAAA,EAAQ,IAAA,GAElCyB,EAAM,KAAKI,EAAG,OAAOC,CAAE,CAAC;AACxB;AAAA,QACJ,KAAK,KAAK;AAGN,UAAAzK,IAD0BoK,EAAM,IAAA,GAAO,eACZ,IAAIjK,EAAA,EAAW,IAAA,GAC1CmB,IAAI8I,EAAM,IAAA,KAAS,IAAIzB,EAAA,EAAQ,IAAA,GAE/BO,IAAS5H,EAAE,UAAU,CAAC,GAElB4H,KACA5H,EAAE,UAAU4H,GAAQlJ,CAAG,GAG3BoK,EAAM,KAAK9I,CAAC;AAEZ;AAAA,QACJ;AAAA,MAAA;AAAA,EAGZ;AAAA,EAEQ,oBAAoBxD,GAA8BoL,GAAyC;AAC/F,UAAMwB,IAAsC,CAAA;AAG5C,aAASxE,IAAI,GAAGA,KAAK,KAAK,QAAQgD,CAAM,EAAE,OAAOhD;AAC7C,UAAIpI,EAAI,WAAW,GAAG;AAClB,cAAM6M,IAA8B,CAAA;AACpC,QAAAA,EAAKzB,CAAM,IAAI,IAAI/I,EAAS+F,CAAC,GAC7BwE,EAAQ,KAAKC,CAAI;AAAA,MACrB;AACI,mBAAWX,KAAQlM,GAAK;AACpB,gBAAM6M,IAA8B,CAAA;AACpC,qBAAWC,KAAiBZ;AACxB,YAAAW,EAAKC,CAAa,IAAIZ,EAAKY,CAAa;AAE5C,UAAAD,EAAKzB,CAAM,IAAI,IAAI/I,EAAS+F,CAAC,GAC7BwE,EAAQ,KAAKC,CAAI;AAAA,QACrB;AAGR,WAAOD;AAAA,EACX;AACJ;ACt+BO,SAASG,GAAgBC,GAAaC,IAAM,IAAc;AAC7D,SAAOA,IAAM,WAAWD,CAAG,cAAc,IAAIA,CAAG;AACpD;AAEO,SAASE,EAAiBF,GAAqB;AAClD,SAAGA,EAAI,WAAW,GAAG,MACjBA,IAAMA,EAAI,UAAU,CAAC,IAGtBA,EAAI,SAAS,GAAG,MACfA,IAAMA,EAAI,UAAU,GAAGA,EAAI,SAAO,CAAC,IAGhCA;AACX;AAUO,SAASG,EAAoBC,GAAoBC,GAAgB9L,GAAgB+L,GAAgBC,GAAiB;AACrH,SAAOH,EAAS,IAAI,CAAC7M,GAAGuB,MAObvB,MAAM8M,IAAS9L,IAAShB,CAClC;AACL;AC/BO,SAASiN,GAAmEtB,GAASrM,GAAkB;AAE1G,MAAI,CAAC,OAAO,cAAcA,CAAK;AAC3B,UAAM,IAAI,MAAM,mCAAmC;AAGvD,MAAIA,IAAQ;AACR,UAAM,IAAI,MAAM,2CAA2C;AAG/D,MAAIA,MAAU;AACV,WAAOqM,EAAK,IAAA;AAGhB,QAAMzD,IAAIyD,EAAK,MAAA;AACf,WAAS,IAAI,GAAG,IAAIrM,GAAO;AACvB,IAAAqM,EAAK,SAASzD,CAAC;AAGnB,SAAOyD;AACX;ACcO,MAAMuB,EAGS;AAAA,EAElBC,KAAmB;AAAA,EACnBC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC,KAAc;AAAA,EAQd,YAAYC,MAA0C3N,GAAkC;AACpF,gBAAKwN,KAAU,CAAA,GACf,KAAKD,KAAW,CAAA,GAChB,KAAKE,KAAS,CAAA,GAEVE,MAAkB,UAClB,KAAK,MAAMA,GAAe,GAAG3N,CAAM,GAEhC;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,QAAQ,CAAC2K,MAAiC3K,MAAwC;AAKrF,QAHA,KAAKwN,KAAU,CAAA,GACf,KAAKD,KAAW,CAAA,GAEZ,OAAO5C,KAAa;AACpB,aAAO,KAAKiD,GAAajD,GAAU,GAAG3K,CAAM;AAChD,SACK,OAAO2K,KAAa,YAAYA,aAAoB1I,KAAY0I,aAAoBF,MACjFzK,EAAO,WAAW;AAEtB,WAAKwN,GAAQ,KAAK,IAAI/C,EAAME,CAAiB,CAAC;AAAA,aACvCA,aAAoBF,KAASzK,EAAO,SAAS;AACpD,WAAKwN,GAAQ,KAAK,IAAI/C,EAAME,CAAQ,CAAC,GACrC3K,EAAO,QAAQ,CAAAoD,MAAK;AAChB,aAAKoK,GAAQ,KAAK,IAAI/C,EAAMrH,CAAU,CAAC;AAAA,MAC3C,CAAC;AAAA,aACMuH,aAAoB0C;AAC3B,iBAAWjK,KAAKuH,EAAS;AACrB,aAAK6C,GAAQ,KAAKpK,EAAE,MAAA,CAAO;AAKnC,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKO,QAAQ,MAAe;AAC1B,UAAMiF,IAAI,IAAIgF,EAAA,GACRrK,IAAa,CAAA;AAEnB,eAAWI,KAAK,KAAKoK;AACjB,MAAAxK,EAAE,KAAKI,EAAE,OAAO;AAIpB,WAAAiF,EAAE,SAASrF,GAEJqF;AAAA,EACX;AAAA,EAEA,IAAW,MAAc;AACrB,WAAO,KAAKwF,GAAY,KAAK;AAAA,EACjC;AAAA,EAEA,IAAW,UAAkB;AACzB,WAAO,KAAKA,GAAA;AAAA,EAChB;AAAA,EAEO,MAAM,IAAI7N,MAA6C;AAE1D,eAAWP,KAASO;AAChB,MAAIP,aAAiB4N,IACjB,KAAKG,KAAU,KAAKA,GAAQ,OAAO/N,EAAM,MAAM,IACxCA,aAAiBgL,IACxB,KAAK+C,GAAQ,KAAK/N,EAAM,MAAA,CAAO,IACxB,OAAOA,KAAU,YAAY,OAAO,cAAcA,CAAK,IAC9D,KAAK+N,GAAQ,KAAK,IAAI/C,EAAMhL,EAAM,SAAA,CAAU,CAAC,IAE7C,KAAK+N,GAAQ,KAAK,IAAI/C,EAAMhL,CAAK,CAAC;AAK1C,WAAO,KAAK,OAAA;AAAA,EAChB;AAAA,EAEO,cAAc,MAAa;AAC9B,UAAMuD,IAAI,IAAIyH,EAAA,EAAQ,IAAA,GAChBqD,IAAoB,KAAK,aAAA,GACzBC,IAAsB,KAAK,eAAA,GAC3BvI,IAAS,KAAK,OAAA;AAEpB,IAAAxC,EAAE,cAAc,IAAIf,EAAS6L,GAAWC,CAAW;AACnD,eAAWjD,KAAK,KAAK,WAAW;AAE5B,MAAA9H,EAAE,UAAU8H,GAAGtF,CAAM;AACrB,iBAAWpC,KAAK,KAAKoK;AAEjB,YADAxK,EAAE,UAAU8H,GAAG7I,EAAS,IAAImB,EAAE,OAAO0H,CAAC,GAAG9H,EAAE,OAAO8H,CAAC,CAAC,CAAC,GACjD9H,EAAE,OAAO8H,CAAC,EAAE;AACZ;AAAA,IAIZ;AACA,WAAO9H;AAAA,EACX;AAAA,EAEO,SAAS,CAACgI,MAA8B;AAC3C,QAAIhD,IAAc,IAAI/F,EAAA,EAAW,KAAA;AACjC,eAAWmB,KAAK,KAAKoK;AACjB,MAAAxF,IAAI/F,EAAS,IAAImB,EAAE,OAAO4H,CAAM,EAAE,OAAOhD,CAAC;AAG9C,WAAOA;AAAA,EACX;AAAA,EAEO,aAAa,CAACgD,MAA6B;AAC9C,UAAMgD,IAAK,IAAIX,EAAA;AAEf,eAAWjK,KAAK,KAAKoK;AACjB,MAAAQ,EAAG,IAAI5K,EAAE,WAAW4H,CAAM,CAAC;AAG/B,WAAOgD,EAAG,OAAA;AAAA,EACd;AAAA,EAEO,SAAS,CAACvO,MAA0C;AAEvD,QAAIA,aAAiBwC;AACjB,aAAO,KAAKgM,GAAkBxO,CAAK;QAC5B,OAAOA,KAAU,YAAY,OAAO,cAAcA,CAAK;AAC9D,aAAO,KAAKyO,GAAiBzO,CAAK;AACtC,QAAWA,aAAiBgL;AACxB,aAAO,KAAK,OAAO,IAAI4C,EAAQ5N,CAAK,CAAC;AACzC,QAAWA,aAAiB4N,GAAS;AACjC,UAAI5N,EAAM,OAAO,WAAW,KAAKA,EAAM,UAAU,WAAW;AACxD,eAAO,KAAKwO,GAAkBxO,EAAM,OAAO,CAAC,EAAE,WAAW;AACtD;AACH,cAAM,EAAC,UAAA0O,GAAU,UAAAC,EAAA,IAAY,KAAK,UAAU3O,CAAK;AACjD,YAAI2O,EAAS;AACT,sBAAKZ,KAAUW,EAAS,QACjB;AAAA,MAEf;AAAA,IACJ,WAAW,OAAO1O,KAAU;AACxB,aAAO,KAAK,OAAO,IAAI4N,EAAQ5N,CAAK,CAAC;AAGzC,UAAM,IAAI,MAAM,oBAAoBA,CAA0B,EAAE;AAAA,EACpE;AAAA,EAEO,QAAQ,OACX,KAAK+N,KAAU,CAAA,GACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQJ,YAAY,CAACnF,MAA2B;AAC3C,UAAM2C,IAAiB3C,EAAE,UAAU,CAAC,GAC9B8F,IAAoB,IAAId,EAAA,EAAU,KAAA,GAClCe,IAAoB,KAAK,MAAA,EAAQ,QAAQpD,CAAM;AAGrD,QAAI3C,EAAE,UAAU,WAAW;AAGvB,aAAO;AAAA,QACH,UAHM,KAAK,MAAA,EAAQ,OAAOA,CAAC,EAGf,OAAA;AAAA,QACZ,UAAU,IAAIgF,EAAA,EAAU,KAAA;AAAA,MAAK;AAKrC,UAAMgB,IAAehG,EAAE,cAAc,QAAW2C,CAAM,GAChDsD,IAAoBjG,EAAE,OAAO2C,CAAM;AAEzC,QAAIuD,GAGAC,IAAe,KAAK,OAAOxD,CAAM,EAAE,QAAQ;AAC/C,WAAOoD,EAAS,OAAOpD,CAAM,EAAE,MAAMsD,CAAO,KAAKE,IAAe,MAC5DA,KAGAD,IAAOH,EAAS,cAAc,QAAWpD,CAAM,EAAE,MAAA,EAAQ,OAAOqD,CAAK,GAEjE,GAAAE,EAAK,aAKTJ,EAAS,IAAII,CAAI,GACjBH,EAAS,SAAS/F,EAAE,MAAA,EAAQ,SAASkG,CAAI,CAAC,EAAE,OAAA,GAGxCA,EAAK,OAAOvD,CAAM,EAAE;AATxB;AAcJ,WAAAmD,EAAS,OAAA,GACTC,EAAS,OAAA,GACF,EAAC,UAAAD,GAAU,UAAAC,EAAA;AAAA,EACtB;AAAA,EAEO,WAAW,CAACpO,GAA+DsL,MAA2C;AAEzH,QAAIA;AACA,aAAO,KAAKC,GAAmBvL,CAAM;AAIzC,UAAM6J,IAAI,IAAI5H,EAAA,EAAW,KAAA;AACzB,gBAAKuL,GAAQ,QAAQ,CAAAiB,MAAS;AAE1B,MAAA5E,EAAE,IAAI4E,EAAM,SAASzO,GAAQsL,CAAS,CAAC;AAAA,IAC3C,CAAC,GAEMzB;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,YAAY,CAACmB,MAA+B;AAC/C,QAAI0D,IAAqB,CAAA,GACrBrG,IAAI,KAAK,MAAA,EAAQ,QAAA;AAIrB,UAAMrF,IAAIqF,EAAE,YAAA;AAOZ,QALIA,EAAE,gBAAgB,YAAY,mBAAA,KAAwBrF,EAAE,YAAY,mBAAA,KAAwB,CAACA,EAAE,WAC/FA,EAAE,SAAA,GAIF,CAACA,EAAE,SAAS;AACZ,YAAM2L,IAAuB,IAAItB,EAAQrK,CAAC;AAC1C,MAAA0L,IAAU,CAACC,EAAY,OAAO,GAC9BtG,IAAIA,EAAE,UAAUsG,CAAW,EAAE;AAAA,IACjC;AAGA,QAAIC,IAAevG,EAAE,OAAA,EAAS,MAAA,EAAQ,SAAS,CAAC,EAAE,OAC9CwG,IAAY;AAChB,WAAOD,KAAgB;AAEnB,UADAA,KACIvG,EAAE,OAAO,SAAS,GAAG;AAGrB,QAAKA,EAAE,YACHqG,EAAQ,KAAKrG,EAAE,OAAO,GACtBA,EAAE,IAAA;AAEN;AAAA,MACJ,WAAWA,EAAE,OAAO2C,CAAM,EAAE,SAAS;AAGjC,QAAA0D,EAAQ,KAAKrG,EAAE,OAAO,GACtBA,EAAE,IAAA;AACF;AAAA,MACJ,OAAO;AAEH,YAAIyG,IAAyB,KAAKC,GAAwB1G,GAAGwG,GAAW7D,KAAU,GAAG;AAIrF,aAHA6D,IAAYxG,EAAE,OAAO2C,CAAM,EAAE,OAGtB8D,EAAY,SAAS,KAAG;AAC3B,gBAAMpD,IAAMoD,EAAY,CAAC;AAEzB,cAAI,CAACzG,EAAE,cAAcqD,CAAG;AAGpB,YAAAoD,EAAY,MAAA;AAAA,eACT;AAEH,kBAAMzK,IAASgE,EAAE,UAAUqD,CAAG;AAG9B,YAAAgD,EAAQ,KAAKhD,CAAG,GAGhBrD,IAAIhE,EAAO,SAAS,MAAA,GAGpByK,IAAcA,EAAY,OAAO,CAAA3O,MAAK;AAClC,oBAAM6O,IAAK3G,EAAE,OAAO,CAAC,GACjB4G,IAAK5G,EAAE,OAAOA,EAAE,OAAO,SAAS,CAAC,GACjC6G,IAAK/O,EAAE,OAAO,CAAC,GACfgP,IAAKhP,EAAE,OAAOA,EAAE,OAAO,SAAS,CAAC;AAGrC,qBAAK8O,EAAG,YAAYE,CAAE,IAKfH,EAAG,YAAYE,CAAE,IAJb;AAAA,YAKf,CAAC;AAAA,UACL;AAAA,QACJ;AAAA,MACJ;AAIJ,WAAK7G,EAAE,WACHqG,EAAQ,KAAKrG,EAAE,OAAO,GAK1B,KAAKkF,KAAWmB,GAET,KAAKnB;AAAA,EAChB;AAAA,EAEO,oBAAoBvN,GAAgC;AAEvD,SAAKwN,KAAU,CAAA;AACf,UAAMxC,IAAS,KAAKsC,MAAoB;AACxC,WAAAtN,EAAO,QAAA,EAAU,QAAQ,CAACoP,GAAO1N,MAAU;AACvC,YAAM+M,IAAQ,IAAIhE,EAAA;AAClB,MAAAgE,EAAM,cAAc,IAAIxM,EAASmN,CAAK,GACtCX,EAAM,UAAUzD,GAAQtJ,CAAK,GAE7B,KAAK8L,GAAQ,KAAKiB,CAAK;AAAA,IAC3B,CAAC,GAEM,KAAK,QAAA;AAAA,EAChB;AAAA,EAEO,iBAAiB,MACb1M,EAAQ,IAAI,GAAG,KAAK,iBAAiB;AAAA,EAGzC,eAAe,MACXA,EAAQ,IAAI,GAAG,KAAK,eAAe;AAAA,EAGvC,kBAA8B;AAEjC,UAAMsN,IAAiB,KAAK,MAAA,EAAQ,QAAA,GAE9BC,IAAS,KAAK,OAAA,EAAS,QAAQ,GAC/BC,IAAS,IAAI,MAAMD,CAAM,EAAE,KAAK,IAAIrN,EAAS,CAAC,CAAC;AAErD,WAAAoN,EAAe,OAAO,QAAQ,CAAAZ,MAAS;AACnC,YAAM/M,IAAQ4N,IAASb,EAAM,OAAA,EAAS,QAAQ;AAC9C,MAAAc,EAAO7N,CAAK,IAAI+M,EAAM,YAAY,MAAA;AAAA,IACtC,CAAC,GAGMc;AAAA,EACX;AAAA;AAAA,EAGO,kBAAkB,MAAgB;AACrC,UAAMC,IAAyB,CAAA;AAC/B,eAAWpM,KAAK,KAAKoK;AACjB,MAAAgC,EAAa,KAAKpM,EAAE,YAAY,WAAW;AAG/C,WAAOoM;AAAA,EACX;AAAA,EAEO,gBAAgB,MAAgB;AACnC,UAAMC,IAAuB,CAAA;AAC7B,eAAWrM,KAAK,KAAKoK;AACjB,MAAAiC,EAAW,KAAKrM,EAAE,YAAY,SAAS;AAG3C,WAAOqM;AAAA,EACX;AAAA,EAEO,YAAY,MACX,KAAK,SAAS,WACP,CAAA,KAGX,KAAK,QAAQ,IAAI1K,EAAe,KAAK,MAAA,CAAO,EAAE,MAAA,GACvC,KAAK;AAAA,EAGT,YAAYiG,GAAyB;AACxC,WAAO,KAAK,UAAU,SAASA,CAAM;AAAA,EACzC;AAAA,EAEO,YAAY,CAACxK,GAAyBC,GAAyBuK,IAAS,QAAkB;AAC7F,UAAMS,IAAY,KAAK,UAAUT,CAAM,GAEjC0E,IAAiC,IACnCC,IAAiC,CAAA;AAErC,WAAAD,EAAQ1E,CAAM,IAAI,IAAI/I,EAASzB,CAAC,GAChCmP,EAAQ3E,CAAM,IAAI,IAAI/I,EAASxB,CAAC,GAExBgL,EAAU,SAASkE,CAAO,EAAe,SAASlE,EAAU,SAASiE,CAAO,CAAC;AAAA,EACzF;AAAA,EAEO,UAA+B;AAAA,EAEtC;AAAA,EAEO,cAAc,CAAC/B,MAAmC;AACrD,QAAItF;AAGJ,UAAMuH,IAAUjC,EAAc,WAAW,qBAAqB,IAAI;AAGlE,QAAIiC,EAAQ,SAAS,GAAG,KAAKA,EAAQ,SAAS,GAAG;AAC7C,aAAO;AAKX,QAAI;AAEA,MAAAvH,IAAI,IAAIgF,EAAQM,CAAa;AAAA,IACjC,QAAQ;AACJ,aAAO;AAAA,IACX;AAGA,WAAK,OAAK,QAAQtF,CAAC;AAAA,EAOvB;AAAA,EAEO,gBAAgB,CAACqD,MAA0B;AAE9C,QAAIA,EAAI,SAAS,SAAS;AACtB,YAAMmE,IAAOnE,EAAI,UAAA,EAAY,CAAC;AAE9B,aAAImE,EAAK,iBAAiB5N,IACd,KAAK,SAAS4N,EAAK,KAAK,EAAe,OAAA,IAExC;AAAA,IAGf,OAAO;AACH,YAAM,EAAC,UAAAzB,EAAA,IAAY,KAAK,UAAU1C,CAAG;AACrC,aAAO0C,EAAS,OAAA;AAAA,IACpB;AAAA,EACJ;AAAA,EAEO,UAAU,CAAC/F,MACP,KAAKyH,GAASzH,GAAG,GAAG;AAAA,EAG/B,IAAW,kBAA2B;AAElC,WAAO,KAAKmF,GAAQ,KAAK,OAAKpK,EAAE,UAAU,SAAS,CAAC;AAAA,EACxD;AAAA,EAEO,QAAiB;AACpB,WAAO,KAAKoK,GAAQ,WAAW,KAAK,KAAKA,GAAQ,CAAC,EAAE,YAAY,MAAA,KAAW,KAAK,OAAA,EAAS,OAAA;AAAA,EAC7F;AAAA,EAEO,eAAe,CAACnF,MACZ,KAAKyH,GAASzH,EAAE,QAAQ,SAAA,GAAY,GAAG;AAAA,EAG3C,YAAY,CAACsF,MAAmC;AAEnD,QAAI,CAAC,KAAK,YAAYA,CAAa;AAC/B,aAAO;AAIX,UAAMtF,IAAI,IAAIgF,EAAQM,CAAa;AACnC,QAAItF,EAAE,OAAO,SAAS,KAAK,OAAO;AAC9B,aAAO;AAKX,eAAWjF,KAAKiF,EAAE;AACd,UAAI,CAACjF,EAAE,YAAY;AACf,eAAO;AAKf,WAAO;AAAA,EACX;AAAA,EAEO,WAAW,CAACiF,MACR,KAAKyH,GAASzH,GAAG,MAAM;AAAA,EAG3B,SAAkB;AACrB,WAAQ,KAAKmF,GAAQ,WAAW,KAAK,KAAKA,GAAQ,CAAC,EAAE,YAAY,OAAA,KAAa,KAAKA,GAAQ,WAAW;AAAA,EAC1G;AAAA,EAEO,iBAAiB,MACbzL,EAAQ,IAAI,GAAG,KAAK,iBAAiB;AAAA,EAGzC,eAAe,MACXA,EAAQ,IAAI,GAAG,KAAK,eAAe;AAAA,EAG9C,IAAW,SAAS;AAChB,WAAO,KAAKyL,GAAQ;AAAA,EACxB;AAAA,EAEO,UAAU,MAAgB;AAC7B,QAAI/K,wBAAQ,IAAA;AAEZ,eAAWW,KAAK,KAAKoK;AACjB,MAAA/K,IAAI,oBAAI,IAAI,CAAC,GAAGA,GAAG,GAAGW,EAAE,SAAS,CAAC;AAItC,WAAO,CAAC,GAAGX,CAAC;AAAA,EAChB;AAAA,EAEO,kBAAkB,CAACuI,MAA8B;AACpD,UAAMhI,IAAI,KAAK,cAAc,QAAWgI,CAAM,GAC1ClH,IAAOd,EAAE,YAAY,KAAA,GACrBwC,IAASxC,EAAE,OAAOgI,CAAM;AAE5B,WAAIxF,EAAO,uBACA1B,MAAS,IAAK,IAAI7B,IAAY,aAAc,IAAIA,EAAA,EAAY,SAAA,EAAW,SAAA,IACvEuD,EAAO,WACPxC,EAAE,cAKL,IAAIf,EAAA,EAAY,KAAA;AAAA,EAC5B;AAAA,EAEO,0BAA0B,CAAC+I,MAA8B;AAC5D,UAAMhI,IAAI,KAAK,cAAc,QAAWgI,CAAM,GAC1ClH,IAAOd,EAAE,YAAY,KAAA,GACrBwC,IAASxC,EAAE,OAAOgI,CAAM;AAE5B,WAAIxF,EAAO,uBACA1B,MAAS,KAAM,IAAI7B,IAAY,aAAc,IAAIA,EAAA,EAAY,SAAA,EAAW,SAAA,IACxEuD,EAAO,WACPxC,EAAE,cAKL,IAAIf,EAAA,EAAY,KAAA;AAAA,EAC5B;AAAA,EAEO,gBAAgB,CAACuD,GAA4BwF,MAA2B;AAC3E,QAAIxF,MAAW;AAGX,aAAO,KAAK,cAAc,KAAK,OAAOwF,CAAM,GAAGA,CAAM;AAKzD,UAAMhI,IAAI,KAAK,MAAA,EAAQ,OAAA;AACvB,eAAWI,KAAKJ,EAAEwK;AACd,UAAIpK,EAAE,OAAO4H,CAAM,EAAE,QAAQxF,CAAM;AAC/B,eAAOpC,EAAE,MAAA;AAMjB,WAAO,IAAIqH,EAAA,EAAQ,KAAA;AAAA,EACvB;AAAA;AAAA,EAGO,gBAAgB,CAACO,MAA0B;AAC9C,UAAMhI,IAAI,KAAK,MAAA,EAAQ,OAAA;AACvB,eAAWI,KAAKJ,EAAEwK;AACd,UAAIpK,EAAE,YAAY4H,CAAM;AACpB,eAAO5H,EAAE,MAAA;AAKjB,WAAO,IAAIqH,EAAA,EAAQ,KAAA;AAAA,EACvB;AAAA;AAAA,EAGA,IAAW,SAAS;AAChB,WAAO,KAAK+C;AAAA,EAChB;AAAA,EAEA,IAAW,OAAOxK,GAAY;AAC1B,SAAKwK,KAAUxK;AAAA,EACnB;AAAA,EAEO,iBAAiB,CAACwC,GAA4BwF,MAA6B;AAC9E,QAAIxF,MAAW;AAGX,aAAO,KAAK,eAAe,KAAK,OAAOwF,CAAM,CAAC;AAIlD,UAAM+E,IAAc,CAAA,GAEd/M,IAAI,KAAK,MAAA,EAAQ,OAAA;AACvB,eAAWI,KAAKJ,EAAEwK;AACd,MAAIpK,EAAE,OAAO4H,CAAM,EAAE,QAAQxF,CAAM,KAC/BuK,EAAG,KAAK3M,EAAE,OAAO;AAKzB,WAAO2M;AAAA,EAEX;AAAA,EAEO,WAAW,CAACtQ,MAA0C;AAEzD,QAAIA,aAAiB4N;AACjB,aAAO,KAAK2C,GAAmBvQ,CAAK;AACxC,QAAWA,aAAiBwC;AACxB,aAAO,KAAKgO,GAAoBxQ,CAAK;AACzC,QAAWA,aAAiBgL;AACxB,aAAO,KAAKyF,GAAiBzQ,CAAK;QAC3B,OAAO,cAAcA,CAAK,KAAK,OAAOA,KAAU;AACvD,aAAO,KAAK0Q,GAAmB1Q,CAAK;AACxC,QAAW,OAAOA,KAAU;AACxB,UAAI;AACA,cAAMoE,IAAI,IAAI5B,EAASxC,CAAK;AAC5B,eAAO,KAAKwQ,GAAoBpM,CAAC;AAAA,MACrC,QAAQ;AACJ,cAAM,IAAI,MAAM,gCAAgC;AAAA,MACpD;AAOJ,UAAM,IAAI,MAAM,gCAAgC;AAAA,EACpD;AAAA,EAEA,IAAW,eAAuB;AAC9B,WAAO,KAAK,UAAU;AAAA,EAC1B;AAAA,EAEO,MAAM,OACT,KAAK2J,KAAU,CAAA,GACf,KAAKA,GAAQ,KAAK,IAAI/C,EAAA,EAAQ,KAAK,GAC5B;AAAA;AAAA,EAIJ,WAAW,OACd,KAAK+C,KAAU,KAAKA,GAAQ,IAAI,CAAApK,MAAKA,EAAE,UAAU,GAC1C;AAAA,EAGX,IAAW,eAAuB;AAC9B,WAAO,KAAKyK,GAAY,OAAO,IAAO,IAAO,EAAI;AAAA,EACrD;AAAA,EAEO,MAAM,CAAC7M,MACHoM,GAAc,MAAiBpM,CAAE,EAAE,OAAA;AAAA,EAGvC,YAAY,CAACgK,MAA6B;AAC7C,UAAMgD,IAAK,IAAIX,EAAA;AAEf,eAAWjK,KAAK,KAAKoK;AACjB,MAAAQ,EAAG,IAAI5K,EAAE,UAAU4H,CAAM,CAAC;AAG9B,WAAOgD;AAAA,EACX;AAAA,EAEO,SAAS,MAAe;AAI3B,QAAIzN,IAAI;AACR,WAAOA,IAAI,KAAKiN,GAAQ,UAAQ;AAC5B,eAAS4C,IAAI7P,IAAI,GAAG6P,IAAI,KAAK5C,GAAQ,QAAQ4C;AACzC,QAAI,KAAK5C,GAAQjN,CAAC,EAAE,SAAS,KAAKiN,GAAQ4C,CAAC,CAAC,MACxC,KAAK5C,GAAQjN,CAAC,EAAE,IAAI,KAAKiN,GAAQ4C,CAAC,CAAC,GACnC,KAAK5C,GAAQ,OAAO4C,GAAG,CAAC,GACpB,KAAK5C,GAAQjN,CAAC,EAAE,aAChB,KAAKiN,GAAQjN,CAAC,IAAI,IAAIkK,EAAA,EAAQ,KAAA,IAGlC2F;AAKR,MAAA7P;AAAA,IACJ;AAGA,SAAKiN,KAAU,KAAKA,GAAQ,OAAO,CAACpK,MACzB,CAACA,EAAE,YAAY,OAAA,CACzB;AAGD,eAAWA,KAAK,KAAKoK;AACjB,MAAApK,EAAE,YAAY,OAAA;AAIlB,WAAI,KAAK,WAAW,IACT,IAAIiK,EAAA,EAAU,KAAA,IAIlB,KAAK,QAAA;AAAA,EAChB;AAAA,EAEO,UAAU,CAACrC,IAAS,KAAKqF,IAAS,OAAgB;AACrD,UAAMC,IAAe,KAAK,UAAU,OAAO,CAAAnQ,MAAKA,MAAM6K,CAAM;AAC5D,gBAAKwC,GAAQ,KAAK,SAAUhN,GAAGC,GAAG;AAC9B,YAAMiH,IAAKlH,EAAE,OAAOwK,CAAM,EAAE,OACxBrD,IAAKlH,EAAE,OAAOuK,CAAM,EAAE;AAG1B,UAAItD,MAAOC;AACP,eAAO0I,IAAS3I,IAAKC,IAAKA,IAAKD;AAInC,UAAI4I,EAAa,SAAS;AACtB,mBAAWxF,KAAKwF,GAAc;AAC1B,gBAAM5I,IAAKlH,EAAE,OAAOsK,CAAC,EAAE,OACnBnD,IAAKlH,EAAE,OAAOqK,CAAC,EAAE;AAGrB,cAAIpD,MAAOC;AACP,mBAAO0I,IAAS3I,IAAKC,IAAKA,IAAKD;AAAAA,QAEvC;AAIJ,aAAO;AAAA,IACX,CAAC,GAEM;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,YAAY,CAACsD,GAAgB3C,MAAqB;AACrD,QAAIvG;AACJ,UAAMyO,IAAyB,IAAIlD,EAAA,EAAU,KAAA;AAE7C,eAAWjK,KAAK,KAAK;AACjB,MAAI,CAACA,EAAE,YAAY4H,CAAM,KAAK5H,EAAE,QAAQ4H,CAAM,EAAE,WAC5CuF,EAAc,IAAInN,EAAE,OAAO,KAK3BtB,IAAMsB,EAAE,QAAQ4H,CAAM,EAAE,MAAA,GAGxB5H,EAAE,eAAe4H,CAAM,GAGvBuF,EAAc,IAAIlI,EAAE,MAAA,EAAQ,IAAI,KAAK,IAAIvG,EAAI,SAAS,CAAC,EAAE,SAASsB,CAAC,CAAC;AAM5E,gBAAKoK,KAAU+C,EAAc,OAAA,EAAS,QAC/B;AAAA,EACX;AAAA;AAAA,EAIO,OAAgB;AACnB,UAAM,IAAI,MAAM,qCAAqC;AAAA,EACzD;AAAA,EAEA,IAAI,QAAqB;AACrB,WAAO,KAAK7C,KAAc,KAAKD,KAAS,KAAK,UAAA;AAAA,EACjD;AAAA,EAEA,IAAI,MAAMhO,GAAoB;AAC1B,SAAKiO,KAAc,IACnB,KAAKD,KAAShO;AAAA,EAClB;AAAA,EAEO,YAAYA,GAAqB;AACpC,gBAAK6N,KAAmB7N,GAEjB;AAAA,EACX;AAAA,EAEO,OAAgB;AACnB,UAAM,IAAI,MAAM,4CAA4C;AAAA,EAChE;AAAA,EAEO,WAAW,IAAIO,MAA6C;AAC/D,eAAWP,KAASO;AAChB,MAAIP,aAAiB4N,IACjB,KAAK,IAAI5N,EAAM,MAAA,EAAQ,UAAU,IAC1BA,aAAiBgL,IACxB,KAAK+C,GAAQ,KAAK/N,EAAM,MAAA,EAAQ,UAAU,IAE1C,KAAK+N,GAAQ,KAAK,IAAI/C,EAAMhL,CAAK,EAAE,UAAU;AAKrD,WAAO,KAAK,OAAA;AAAA,EAChB;AAAA,EAEO,eAA+B;AAIlC,UAAM+Q,IAAqB,KAAK;AAIhC,QAAIC,IAAiC,IAAI,MAAM,IAAID,EAAM,SAAS,CAAC,EAC9D,KAAK,EAAE,EACP,IAAI,CAACE,GAAIhP,MACCA,IAAQ,MAAM,IAAI,KAAK,GACjC;AAGL,QAAI+O,EAAM,WAAW,GAAG;AAEpB,YAAM,CAACjQ,CAAC,IAAI,KAAK,kBAAkB,IAAI,CAAAL,MAAKA,EAAE,KAAK;AACnD,MAAAsQ,IAAQ1D,EAAiB0D,GAAO,IAAIjQ,IAAI,IAAI,MAAM,GAAG;AAAA,IACzD,WAAW,KAAK,OAAA,EAAS,SAAS;AAE9B,YAAM,CAACA,CAAC,IAAI,KAAK,kBAAkB,IAAI,CAAAL,MAAKA,EAAE,KAAK;AAGnD,MAAAsQ,EAAM,CAAC,IAAIjQ,IAAI,IAAI,MAAM,KACzBiQ,EAAM,CAAC,IAAI,KACXA,EAAM,CAAC,IAAIjQ,IAAI,IAAI,MAAM;AAAA,IAC7B;AAUI,MATqB;AAAA,QACjBgQ,EAAM,CAAC,EAAE,QAAQ;AAAA,QACjB,GAAGA,EAAM,IAAI,CAACG,GAAOjP,MACVA,MAAU8O,EAAM,SAAS,IAC5BA,EAAM9O,CAAK,EAAE,QAAQ,KACpB8O,EAAM9O,CAAK,EAAE,QAAQ8O,EAAM9O,IAAQ,CAAC,EAAE,SAAS,CACvD;AAAA,MAAA,EAGQ,QAAQ,CAACkP,GAAMlP,MAAU;AAClC,cAAMoC,IAAO,KAAK,SAAS,EAAC,GAAG8M,EAAA,GAAO,EAAI;AAC1C,QAAAH,EAAM/O,IAAQ,CAAC,IAAIoC,IAAO,IAAI,MAAM;AAAA,MACxC,CAAC;AAGL,WAAO,EAAC,OAAA0M,GAAO,OAAAC,EAAA;AAAA,EACnB;AAAA,EAEA,IAAW,QAA4B;AACnC,QAAI,KAAK,SAAS;AACd,aAAO,KAAK,OAAO,CAAC,GAAG,YAAY,SAAS;AAAA,EAIpD;AAAA,EAEA,IAAW,YAAsB;AAC7B,QAAI3L,IAAc,CAAA;AAElB,eAAW1B,KAAK,KAAKoK;AACjB,MAAA1I,IAAIA,EAAE,OAAO1B,EAAE,SAAS;AAK5B,WAAA0B,IAAI,CAAC,GAAG,IAAI,IAAIA,CAAC,CAAC,GAClBA,EAAE,KAAA,GACKA;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,OAAO,OACV,KAAK0I,KAAU,CAAA,GACf,KAAKA,GAAQ,KAAK,IAAI/C,EAAA,EAAQ,MAAM,GAC7B;AAAA,EAGX,IAAW,SAAsB;AAC7B,WAAO,KAAK,UAAA;AAAA,EAChB;AAAA,EAEAqF,KAAW,CAACzH,GAAYvE,MAA2B;AAC/C,IAAAA,MAAS;AAGT,UAAM+M,IAAM,KAAK,MAAA,EAAQ,OAAA,EAAS,QAAA,GAC5BC,IAAMzI,EAAE,MAAA,EAAQ,OAAA,EAAS,QAAA;AAE/B,YAAQvE,GAAA;AAAA,MACJ,KAAK;AAED,eAAI+M,EAAI,WAAWC,EAAI,UAAU,CAACD,EAAI,OAAA,EAAS,QAAQC,EAAI,OAAA,CAAQ,IACxD,KAIJD,EAAI,OACN,MAAM,CAACE,GAAIrP,MAAUqP,EAAG,QAAQD,EAAI,OAAOpP,CAAK,CAAC,CAAC;AAAA,MAE3D,KAAK;AAED,eAAImP,EAAI,WAAWC,EAAI,UAAU,CAACD,EAAI,OAAA,EAAS,QAAQC,EAAI,OAAA,CAAQ,IACxD,KAGJD,EAAI,OACN,MAAM,CAACE,GAAIrP,MAAUqP,EAAG,SAASD,EAAI,OAAOpP,CAAK,CAAC,CAAC;AAAA,MAE5D;AACI,eAAO;AAAA,IAAA;AAAA,EAEnB;AAAA,EAGAuM,KAAoB,CAACpL,MAAsB;AACvC,eAAWO,KAAK,KAAKoK;AACjB,MAAApK,EAAE,YAAY,OAAOP,CAAC;AAG1B,WAAO;AAAA,EACX;AAAA,EAEAqL,KAAmB,CAAClN,MAAqB;AACrC,UAAMgQ,IAAM,IAAI/O,EAASjB,CAAE;AAC3B,eAAWoC,KAAK,KAAKoK;AACjB,MAAApK,EAAE,YAAY,OAAO4N,CAAG;AAG5B,WAAO;AAAA,EACX;AAAA,EAEAzF,KAAqB,CAACvL,MAA0E;AAC5F,QAAI6J,IAAI;AACR,gBAAK2D,GAAQ,QAAQ,CAAAiB,MAAS;AAC1B,MAAA5E,KAAK4E,EAAM,SAASzO,GAAQ,EAAI;AAAA,IACpC,CAAC,GAEM6J;AAAA,EACX;AAAA,EAEAoH,KAAsB,CAACjG,MAA8B;AACjD,QAAIkG,GAAaC,GACb3Q,GAAGC,GAAGsH,GAAGO,GAAOC,GAAIC,GAAI3G;AAG5B,QAAI,KAAK,iBAAiB;AAMtB,aALArB,IAAI,KAAK,cAAc,GAAGwK,CAAM,EAAE,aAClCvK,IAAI,KAAK,cAAc,GAAGuK,CAAM,EAAE,aAClCjD,IAAI,KAAK,cAAc,GAAGiD,CAAM,EAAE,aAClC1C,IAAQ7H,EAAE,MAAA,EAAQ,IAAI,CAAC,EAAE,SAASD,EAAE,MAAA,EAAQ,SAASuH,CAAC,EAAE,SAAS,CAAC,CAAC,GAE/DO,EAAM,YACNC,IAAK9H,EAAE,MAAA,EAAQ,SAAA,EAAW,OAAOD,EAAE,MAAA,EAAQ,SAAS,CAAC,CAAC,GACtD0Q,IAAK,IAAI7D,EAAQrC,CAAM,EAAE,SAASzC,EAAG,OAAO,EAAE,SAASA,EAAG,WAAW,GACrE4I,IAAK,IAAI9D,EAAQrC,CAAM,EAAE,SAASzC,EAAG,OAAO,EAAE,SAASA,EAAG,WAAW,GACrE1G,IAASrB,EAAE,OAAO+H,EAAG,WAAW,EAAE,OAAOA,EAAG,WAAW,GAElD1G,EAAO,UAGD,CAACqP,GAAIC,CAAE,IAFP,CAAC,IAAI9D,EAAQxL,EAAO,OAAO,GAAGqP,GAAIC,CAAE,KAKxC7I,EAAM,WAAA,KAAgBA,EAAM,cACnCC,IAAK9H,EAAE,MAAA,EAAQ,WACV,IAAI6H,EAAM,MAAA,EAAQ,KAAA,CAAM,EACxB,OAAO9H,EAAE,QAAQ,SAAS,CAAC,CAAC,GACjCgI,IAAK/H,EAAE,MAAA,EAAQ,WACV,SAAS6H,EAAM,MAAA,EAAQ,KAAA,CAAM,EAC7B,OAAO9H,EAAE,QAAQ,SAAS,CAAC,CAAC,GAQjCqB,IAASrB,EAAE,OAAO+H,EAAG,WAAW,EAAE,OAAOC,EAAG,WAAW,GACnD3G,EAAO,UACA;AAAA,QACH,IAAIwL,EAAQrC,CAAM,EAAE,SAASzC,EAAG,OAAO,EAAE,SAASA,EAAG,WAAW;AAAA,QAChE,IAAI8E,EAAQrC,CAAM,EAAE,SAASxC,EAAG,OAAO,EAAE,SAASA,EAAG,WAAW;AAAA,MAAA,IAG7D;AAAA,QACH,IAAI6E,EAAQxL,EAAO,OAAO;AAAA,QAC1B,IAAIwL,EAAQrC,CAAM,EAAE,SAASzC,EAAG,OAAO,EAAE,SAASA,EAAG,WAAW;AAAA,QAChE,IAAI8E,EAAQrC,CAAM,EAAE,SAASxC,EAAG,OAAO,EAAE,SAASA,EAAG,WAAW;AAAA,MAAA,KAQjE,CAAC,KAAK,OAAO;AASxB,QAJAhI,IAAI,KAAK,cAAc,GAAGwK,CAAM,GAChCvK,IAAI,KAAK,cAAc,GAAGuK,CAAM,GAChCjD,IAAI,KAAK,cAAc,GAAGiD,CAAM,GAE5BxK,EAAE,gBAAA,KAAqBuH,EAAE,qBAKrBtH,EAAE,QAAQ,IAAI,CAAC,EAAE,SAASD,EAAE,MAAA,EAAQ,SAASuH,CAAC,CAAC,GAAG;AAOlD,YAAMqJ,IADW,IAAI/D,EAAQ,KAAK7M,EAAE,aAAaC,EAAE,aAAasH,EAAE,WAAW,EACnDkJ,GAAoB,GAAG,GAE3CvC,IAAU,CAAA;AAChB,UAAI2C;AAEJ,UAAID,EAAS,UAAU,GAAG;AACtB,mBAAWzO,KAAKyO;AACZ,UAAIzO,EAAE,SAAS,WACX+L,EAAQ,KAAK/L,EAAE,OAAO,KAEtB0O,IAAa1O,EAAE,MAAA,GACf0O,EAAW,OAAO,CAAC,EAAE,UAAU7Q,EAAE,aACjC6Q,EAAW,OAAO,CAAC,EAAE,UAAUtJ,EAAE,aACjC2G,EAAQ,KAAK2C,EAAW,OAAO;AAKvC,eAAO3C;AAAA,MACX;AAAA,IACJ;AAIJ,WAAO,CAAC,KAAK,OAAO;AAAA,EAE5B;AAAA,EAEAb,KAAc,CAAC5H,GAAiBqL,GAAqBC,GAA2BC,MAAgD;AAC5H,QAAInJ,IAAI;AAER,eAAWxE,KAAK,KAAK2J,IAAS;AAC1B,UAAI3J,EAAE,YAAY,UAAU;AACxB;AAKJ,UAAIT;AACJ,MAAIoO,IACApO,IAAIS,EAAE,eAENT,IAAK6C,MAAW,QAASpC,EAAE,MAAMA,EAAE,SAGvCwE,KAAK,GAAIxE,EAAE,YAAY,KAAA,MAAW,MAAMwE,MAAM,MAAMiJ,MAAc,MAAS,MAAM,EAAE,GAAGlO,CAAC;AAAA,IAC3F;AAEA,WAAImO,MAAoB,MAAQ,KAAK,SAAS,MACtCtL,MAAW,QACXoC,IAAI,WAAWA,CAAC,cAEhBA,IAAI,IAAIA,CAAC,MAKbA,MAAM,OACNA,IAAI,MAGDA;AAAA,EACX;AAAA,EAEA0G,KAA0B,CAAC1G,GAAYwG,GAAmB7D,MAA8B;AACpF,UAAM+F,IAAK1I,EAAE,OAAO,CAAC,EAAE,UACnBoJ,IAAKpJ,EAAE,OAAOA,EAAE,OAAO,SAAS,CAAC,EAAE,UAEjCyG,IAAyB,CAAA;AAC/B,WAAAiC,EAAG,QAAQ,CAAAW,MAAO;AAEd,MAAIA,EAAI,OAAO1G,CAAM,EAAE,MAAM6D,CAAS,KAClC4C,EAAG,QAAQ,CAAAE,MAAO;AACd,QAAID,EAAI,OAAO1G,CAAM,EAAE,WAAW2G,EAAI,OAAO3G,CAAM,CAAC,MAChD8D,EAAY,KAAK,IAAIzB,EAAQqE,GAAKC,CAAG,CAAC,GACtC7C,EAAY,KAAK,IAAIzB,EAAQqE,GAAKC,EAAI,MAAA,EAAQ,SAAA,CAAU,CAAC;AAAA,MAEjE,CAAC;AAAA,IAIT,CAAC,GAEM7C;AAAA,EACX;AAAA,EAEAmB,KAAsB,CAACpN,MAAyB;AAC5C,eAAWO,KAAK,KAAKoK;AACjB,MAAApK,EAAE,YAAY,SAASP,CAAC;AAI5B,WAAO,KAAK,OAAA;AAAA,EAChB;AAAA,EAEAsN,KAAqB,CAACnP,MACX,KAAKiP,GAAoB,IAAIhO,EAASjB,CAAE,CAAC;AAAA,EAGpDkP,KAAmB,CAAClN,MAAsB;AACtC,eAAWI,KAAK,KAAKoK;AACjB,MAAApK,EAAE,SAASJ,CAAC;AAGhB,WAAO,KAAK,OAAA;AAAA,EAChB;AAAA,EAEAgN,KAAqB,CAAC3H,MAAwB;AAC1C,UAAMrF,IAAa,CAAA;AACnB,eAAW+N,KAAM,KAAKvD;AAClB,iBAAWiE,KAAMpJ,EAAE;AACf,QAAArF,EAAE,KAAKyH,EAAM,UAAUsG,GAAIU,CAAE,CAAC;AAKtC,gBAAKjE,KAAUxK,GACR,KAAK,OAAA;AAAA,EAChB;AAAA,EAEA4K,GAAajD,MAAqB3K,GAAyB;AACvD,QAAIA,EAAO,WAAW,GAAG;AAErB,UAAI2K,MAAa,MAAM,CAAC,MAAM,OAAOA,CAAQ,CAAC,GAAG;AAC7C,aAAK,MAAA;AAEL,cAAMvH,IAAI,IAAIqH,EAAM,OAAOE,CAAQ,CAAC;AAGpC,oBAAK,IAAIvH,CAAC,GACH;AAAA,MACX;AAGA,aAAO,KAAKwO,GAA6BjH,CAAQ;AAAA,IACrD,WAAW,UAAU,KAAKA,CAAQ,GAAG;AAEjC,WAAK,MAAA;AAEL,YAAM5H,IAAY/C,EAAO,IAAI,OAAK,IAAIiC,EAAS9B,CAAyB,CAAC;AAGzE,UAAIwK,EAAS,SAAS,GAAG;AACrB,cAAMI,IAAUJ,EAAS,MAAM,EAAE;AAEjC,YAAII,EAAQ,SAAS/K,EAAO,SAAS;AACjC,gBAAM,IAAI,MAAM,0CAA0C;AAG9D,YAAIO,IAAI;AAER,mBAAWsC,KAAKE,GAAW;AACvB,gBAAMK,IAAI,IAAIqH,EAAA;AACd,UAAArH,EAAE,cAAcP,EAAE,MAAA,GAClBO,EAAE,aAAa2H,EAAQxK,CAAC,KAAK,IAC7B,KAAK,IAAI6C,CAAC,GACV7C;AAAA,QACJ;AAAA,MACJ,OAEK;AACD,YAAI0D,IAAIlB,EAAU,SAAS;AAC3B,mBAAWF,KAAKE,GAAW;AACvB,gBAAMK,IAAI,IAAIqH,EAAA;AACd,UAAArH,EAAE,cAAcP,EAAE,MAAA,GAClBO,EAAE,aAAa,GAAGuH,CAAQ,IAAI1G,CAAC,IAC/B,KAAK,IAAIb,CAAC,GACVa;AAAA,QACJ;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AACI,aAAO,KAAK,KAAA;AAAA,EAGpB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA2N,KAA+B,CAACjH,MAA2B;AAGvD,UAAMqB,IADkB,IAAIC,IAAc,MAAMtB,CAAQ,EACQ;AAGhE,SAAK,KAAA;AAEL,UAAMuB,IAAmB,CAAA;AAGzB,eAAWC,KAAWH;AAClB,WAAK6F,GAAsB3F,GAAOC,CAAO;AAI7C,WAAID,EAAM,WAAW,KACjB,KAAK,IAAIA,EAAM,CAAC,CAAC,GAId,KAAK,QAAA;AAAA,EAChB;AAAA,EAEA2F,KAAwB,CAAC3F,GAAkBC,MAAyB;AAChE,YAAQA,EAAQ,WAAA;AAAA,MACZ,KAAKC,EAAgB;AACjB,QAAAF,EAAM,KAAK,IAAImB,EAAQlB,EAAQ,KAAK,CAAC;AACrC;AAAA,MAEJ,KAAKC,EAAgB;AACjB,QAAAF,EAAM,KAAK,IAAImB,IAAU,IAAI,IAAI5C,EAAM0B,EAAQ,KAAK,CAAC,CAAC;AACtD;AAAA,MAEJ,KAAKC,EAAgB;AAEjB,gBAAQ,IAAI,iDAAiD;AAC7D;AAAA,MAEJ,KAAKA,EAAgB;AACjB,YAAIF,EAAM,UAAU,GAAG;AACnB,gBAAMzL,IAAIyL,EAAM,IAAA,GACZ1L,IAAI0L,EAAM,IAAA;AAGd,cAAI1L,MAAM,UAAaC,MAAM;AACzB;AAGJ,cAAI0L,EAAQ,UAAU;AAClB,YAAAD,EAAM,KAAK1L,EAAE,IAAIC,CAAC,CAAC;AAAA,mBACZ0L,EAAQ,UAAU;AACzB,YAAAD,EAAM,KAAK1L,EAAE,SAASC,CAAC,CAAC;AAAA,mBACjB0L,EAAQ,UAAU;AACzB,YAAAD,EAAM,KAAK1L,EAAE,SAASC,CAAC,CAAC;AAAA,mBACjB0L,EAAQ,UAAU;AACzB,YAAI1L,EAAE,SAAS,uBACX,QAAQ,IAAI,2DAA2D,IAGvEyL,EAAM,KAAK1L,EAAE,OAAOC,EAAE,OAAO,CAAC,EAAE,WAAW,CAAC;AAAA,mBAEzC0L,EAAQ,UAAU,KAAK;AAC9B,gBAAI1L,EAAE,SAAS;AACX,oBAAM,IAAI,MAAM,iDAAiD;gBAC1DA,EAAE,OAAO,CAAC,EAAE,YAAY;AAG/B,cAAAyL,EAAM,KAAK1L,EAAE,IAAIC,EAAE,OAAO,CAAC,EAAE,YAAY,KAAK,CAAC;AAAA,qBAG3CD,EAAE,OAAO,WAAW,KAAKA,EAAE,OAAO,CAAC,EAAE,YAAY,SAAS;AAC1D,yBAAWwK,KAAUxK,EAAE,OAAO,CAAC,EAAE;AAC7B,gBAAAA,EAAE,OAAO,CAAC,EAAE,QAAQwK,CAAM,EAAE,SAASvK,EAAE,OAAO,CAAC,EAAE,WAAW;AAGhE,cAAAyL,EAAM,KAAK1L,CAAC;AAAA,YAChB;AACI,sBAAQ,MAAM,iCAAiC;AAAA,UAG3D;AAAA,QAEJ,WAAW2L,EAAQ,UAAU,KAAK;AAC9B,gBAAM3L,IAAI0L,EAAM,IAAA;AAChB,UAAI1L,KACA0L,EAAM,KAAK1L,EAAE,UAAU;AAAA,QAE/B;AACI,gBAAM,IAAI,MAAM,2BAA2B;AAI/C;AAAA,MAEJ,KAAK4L,EAAgB;AAEjB,gBAAQ,MAAM,wCAAwC;AACtD;AAAA,MAEJ,KAAKA,EAAgB;AAEjB,gBAAQ,MAAM,wEAAwE;AACtF;AAAA,IAAA;AAAA,EAIZ;AAEJ;ACj2CO,MAAM0F,EAGU;AAAA;AAAA,EAGnBC;AAAA;AAAA,EAEAC;AAAA;AAAA,EAEAC;AAAA,EAKA,YAAY7M,GAAyCC,GAA+BvB,GAAsB;AAOtG,QALA,KAAKiO,KAAQ,IAAI1E,EAAA,EAAU,KAAA,GAC3B,KAAK2E,KAAS,IAAI3E,EAAA,EAAU,KAAA,GAC5B,KAAK4E,KAAQ,KAGT7M,MAAS,UAAaC,MAAU,QAAW;AAC3C,UAAID,aAAgB0M;AAChB,eAAO1M,EAAK,MAAA;AAChB,MAAW,OAAOA,KAAS,YAEvB,KAAK,MAAMA,CAAI;AAAA,IAGvB,MAAA,CAAWA,MAAS,UAAaC,MAAU,WAEvC,KAAK,OAAO,IAAIgI,EAAQjI,CAA6B,GACrD,KAAK,QAAQ,IAAIiI,EAAQhI,CAAK;AAGlC,WAAIvB,MAAS,WACT,KAAK,OAAOA,IAGT;AAAA,EACX;AAAA;AAAA,EAGO,QAAQ,CAACoO,MAAiC;AAE7C,UAAMC,IAA0B,KAAKC,GAAUF,CAAc;AAE7D,QAAIC,MAAY;AACZ,YAAM,IAAI,MAAM,2CAA2C;AAI/D,UAAME,IAAiBH,EAAe,MAAMC,CAAO;AAEnD,WAAO,KAAK,OAAO,IAAI9E,EAAQgF,EAAK,CAAC,CAAC,GAAG,IAAIhF,EAAQgF,EAAK,CAAC,CAAC,GAAG,KAAKC,GAAYH,CAAO,CAAC;AAAA,EAC5F;AAAA,EAEO,QAAQ,MACJ,IAAIL,EAAS,KAAKC,GAAM,MAAA,GAAS,KAAKC,GAAO,SAAS,KAAKC,EAAK;AAAA,EAG3E,IAAW,MAAc;AACrB,WAAO,GAAG,KAAKF,GAAM,GAAG,GAAG,KAAK,SAAS,GAAG,KAAKC,GAAO,GAAG;AAAA,EAC/D;AAAA,EAEA,IAAW,UAAkB;AACzB,WAAO,GAAG,KAAKD,GAAM,OAAO,GAAG,KAAK,SAAS,GAAG,KAAKC,GAAO,OAAO;AAAA,EACvE;AAAA,EAEA,OAAc,iBAAiBE,GAAiC;AAI5D,WAAOA,EAAe,SAAS,GAAG,KAC9BA,EAAe,SAAS,GAAG,KAC3BA,EAAe,SAAS,GAAG,KAC3BA,EAAe,SAAS,IAAI,KAC5BA,EAAe,SAAS,IAAI;AAAA,EACpC;AAAA,EAEA,OAAc,oBAAoBvM,GAAwBpC,GAA+B;AACrF,UAAMgP,IAA0B,CAAA,GAC5BC,IAAkB7M,EAAU,OAAO,CAAA8M,MAC1BF,EAAc,SAASE,EAAI,GAAG,IAIxB,MAHPF,EAAc,KAAKE,EAAI,GAAG,GACnB,GAId;AAEL,WAAIlP,MAAW,MACXiP,EAAgB,KAAK,CAAChS,GAAGC,MAAMD,EAAE,QAAQC,EAAE,KAAK,GAG7C+R;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUO,IAAI/S,GAA6C;AAEpD,QAAIA,aAAiBqS;AAEjB,kBAAKC,GAAM,IAAItS,EAAM,IAAI,GAEzB,KAAKuS,GAAO,IAAIvS,EAAM,KAAK,GAEpB;AAGX,QAAI,OAAOA,KAAU,YACjB,CAACqS,EAAS,iBAAiBrS,CAAK;AAEhC,aAAO,KAAK,IAAI,IAAIqS,EAASrS,CAAK,CAAC;AAGvC,UAAMkD,IAAI,IAAI0K,EAAQ5N,CAAK;AAC3B,gBAAKsS,GAAM,IAAIpP,CAAC,GAChB,KAAKqP,GAAO,IAAIrP,CAAC,GAEV;AAAA,EACX;AAAA,EAEO,SAAS,CAACyC,GAAeC,GAAgBvB,OAC5C,KAAKiO,KAAQ3M,GACb,KAAK4M,KAAS3M,GACd,KAAK4M,KAAQ,KAAKK,GAAYxO,KAAQ,GAAG,GAClC;AAAA;AAAA;AAAA;AAAA;AAAA,EAOJ,SAAS,CAACkH,MACN/I,EAAS,IAAI,KAAK8P,GAAM,OAAO/G,CAAM,GAAG,KAAKgH,GAAO,OAAOhH,CAAM,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBtE,SAAS,CAACvL,MAAsC;AAEnD,UAAMoD,IAAc,IAAIZ,EAASxC,CAAK;AAEtC,WAAIoD,EAAE,WACK,OAEA,KAAK,SAASA,EAAE,QAAA,CAAS;AAAA,EAExC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,SAAS7C,GAA+DsL,GAAgC;AAK3G,UAAMlG,IAAO,KAAK2M,GAAM,SAAS/R,GAAQsL,CAAS,GAC9CjG,IAAQ,KAAK2M,GAAO,SAAShS,GAAQsL,CAAS;AAGlD,WAAIA,IACOlG,MAASC,IAGZD,EAAkB,QAAQC,CAAiB;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,cAAc,CAAC2F,MACX,KAAK,UAAU,SAASA,CAAM;AAAA,EAGlC,QAAQvL,GAAsC;AACjD,UAAM8F,IAAM,IAAIuM,EAASrS,CAAK;AAC9B,WAAO8F,EAAI,KAAK,QAAQ,KAAKwM,EAAK,KAAKxM,EAAI,MAAM,QAAQ,KAAKyM,EAAM;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA,EAMO,YAAY,CAACzM,MAA2B;AAC3C,UAAMmN,IAAKnN,EAAI,MAAA,EAAQ,SAAA,EAAW,MAC9BoN,IAAK,KAAK,QAAQ,SAAA,EAAW;AAGjC,WAAOD,EAAG,QAAQC,CAAE,KAAKD,EAAG,aAAaC,CAAE;AAAA,EAC/C;AAAA,EAEO,aAAa,CAACpN,MAA2B;AAE5C,UAAMmN,IAAKnN,EAAI,MAAA,EAAQ,SAAA,EAAW,SAAA,EAAW,MACzCoN,IAAK,KAAK,MAAA,EAAQ,SAAA,EAAW,WAAW;AAG5C,WAAOD,EAAG,QAAQC,CAAE,KAAKD,EAAG,aAAaC,CAAE;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA,EAKO,kBAAkB,MACd,KAAKZ,GAAM,mBAAmB,KAAKC,GAAO;AAAA;AAAA;AAAA;AAAA;AAAA,EAO9C,UAAU,CAAChH,MAAkC;AAShD,QALI,CAAC,KAAK,OAAOA,CAAM,EAAE,WAKrB,KAAK;AACL,aAAO;AAIX,QAAI4H;AAEJ,SAAKb,GAAM,SAAS,KAAKC,EAAM,GAC/B,KAAKA,GAAO,KAAA;AACZ,UAAMhS,IAAS,CAAC,GAAG,KAAK+R,GAAM,MAAM;AACpC,eAAW3O,KAAKpD;AACZ,MAAKoD,EAAE,YAAY4H,CAAM,MACrB4H,IAAQxP,EAAE,MAAA,GACV,KAAK2O,GAAM,SAASa,CAAK,GACzB,KAAKZ,GAAO,SAASY,CAAK;AAKlC,QAAI,KAAKb,GAAM,WAAW;AACtB,aAAO;AAGX,UAAMc,IAAkB,KAAKd,GAAM,OAAO,CAAC,EAAE,YAAY,MAAA;AACzD,gBAAKA,GAAM,OAAOc,CAAK,GACvB,KAAKb,GAAO,OAAOa,CAAK,GACjB;AAAA,EACX;AAAA;AAAA,EAGA,IAAW,OAAgB;AACvB,WAAO,KAAKd;AAAA,EAChB;AAAA,EAEA,IAAW,KAAKtS,GAAgB;AAC5B,SAAKsS,KAAQtS;AAAA,EACjB;AAAA;AAAA,EAGO,UAAU,MACN,CAAC,GAAG,oBAAI,IAAI,CAAC,GAAG,KAAKsS,GAAM,QAAA,GAAW,GAAG,KAAKC,GAAO,QAAA,CAAS,CAAC,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,EAOpE,WAAW,OACd,KAAKD,GAAM,SAAS,KAAKC,EAAM,GAC/B,KAAKA,GAAO,KAAA,GACL;AAAA;AAAA;AAAA;AAAA;AAAA,EAOJ,WAAW,CAACvS,MAAsC;AAErD,UAAMoD,IAAc,IAAIZ,EAASxC,CAAK;AAGtC,gBAAKsS,GAAM,SAASlP,CAAC,GACrB,KAAKmP,GAAO,SAASnP,CAAC,GAGlB,KAAKoP,OAAU,OAAOpP,EAAE,KAAA,MAAW,MACnC,KAAKiQ,GAAA,GAGF;AAAA,EACX;AAAA,EAEA,IAAW,eAAuB;AAC9B,WAAO,KAAK,UAAU;AAAA,EAC1B;AAAA,EAEO,WAAW,OACd,KAAKf,KAAQ,KAAKA,GAAM,SAAA,GACxB,KAAKC,KAAS,KAAKA,GAAO,SAAA,GACnB;AAAA,EAGJ,IAAIvS,GAAqB;AAC5B,gBAAKsS,GAAM,IAAItS,CAAK,GACpB,KAAKuS,GAAO,IAAIvS,CAAK,GACd;AAAA,EACX;AAAA,EAEO,SAAe;AAQlB,gBAAK,SAAA,GAGL,KAAKsS,GAAM,OAAA,GAGX,KAAK,SAAA,GAGD,KAAKA,GAAM,OAAO,CAAC,EAAE,YAAY,gBACjC,KAAK,SAAS,EAAE,GAGb;AAAA,EACX;AAAA,EAEO,UAAU,CAACgB,OAGd,KAAKhB,GAAM,SAAS,KAAKC,EAAM,GAC/B,KAAKA,GAAO,KAAA,GACZ,KAAKD,GAAM,QAAA,GAGPgB,IACO,QAIX,KAAKhB,GAAM,OACN,OAAO,CAAA3O,MAAKA,EAAE,OAAA,EAAS,OAAA,CAAQ,EAC/B,QAAQ,CAAAA,MAAK;AACV,UAAM4P,IAAO5P,EAAE,MAAA;AACf,SAAK2O,GAAM,SAASiB,CAAI,GACxB,KAAKhB,GAAO,SAASgB,CAAI;AAAA,EAC7B,CAAC,GAGL,KAAKjB,GAAM,QAAA,GACX,KAAKC,GAAO,QAAA,GACL;AAAA;AAAA,EAIJ,YAAY,CAAChH,GAAgB3C,OAChC,KAAK0J,GAAM,UAAU/G,GAAQ3C,CAAC,GAC9B,KAAK2J,GAAO,UAAUhH,GAAQ3C,CAAC,GACxB;AAAA,EAGX,IAAW,QAAiB;AACxB,WAAO,KAAK2J;AAAA,EAChB;AAAA,EAEA,IAAW,MAAMvS,GAAgB;AAC7B,SAAKuS,KAASvS;AAAA,EAClB;AAAA;AAAA,EAGA,IAAW,OAAe;AACtB,WAAO,KAAKwS;AAAA,EAChB;AAAA,EAEA,IAAW,KAAKxS,GAAe;AAE3B,SAAKwS,KAAQ,KAAKK,GAAY7S,CAAK;AAAA,EACvC;AAAA,EAEA,IAAW,YAAoB;AAC3B,WAAI,KAAKwS,OAAU,OACR,UAGP,KAAKA,OAAU,OACR,UAGJ,KAAKA;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKO,WAAW,OACd,KAAK,SAASlQ,EAAQ,IAAI,GAAG,KAAKgQ,GAAM,gBAAA,GAAmB,GAAG,KAAKC,GAAO,gBAAA,CAAiB,CAAC,GAC5F,KAAK,OAAOjQ,EAAQ,IAAI,GAAG,KAAKgQ,GAAM,cAAA,GAAiB,GAAG,KAAKC,GAAO,cAAA,CAAe,CAAC,GAC/E;AAAA;AAAA,EAIJ,QAAQ,MACI,IAAIjN,EAAe,KAAK,OAAO,EAChC,MAAA;AAAA,EAGX,QAA4B;AAC/B,WAAO,CAAC,KAAKgN,GAAM,MAAA,GAAS,KAAKC,GAAO,OAAO;AAAA,EACnD;AAAA,EAEO,SAASvS,GAA6C;AACzD,QAAIA,aAAiBqS;AACjB,kBAAKC,GAAM,SAAStS,EAAM,IAAI,GAC9B,KAAKuS,GAAO,SAASvS,EAAM,KAAK,GAEzB;AAGX,QAAI,OAAOA,KAAU,YACjB,CAACqS,EAAS,iBAAiBrS,CAAK;AAChC,aAAO,KAAK,SAAS,IAAIqS,EAASrS,CAAK,CAAC;AAG5C,UAAMkD,IAAI,IAAI0K,EAAQ5N,CAAK;AAC3B,gBAAKsS,GAAM,SAASpP,CAAC,GACrB,KAAKqP,GAAO,SAASrP,CAAC,GAEf;AAAA,EACX;AAAA,EAEO,OAAO,CAAC3C,MACH,KAAK,KAAK,SAASA,CAAM,EAAe,QAAQ,KAAK,MAAM,SAASA,CAAM,CAAC;AAAA,EAGvF,IAAW,YAAsB;AAC7B,WAAO,CAAC,GAAG,IAAI,IAAI,KAAKgS,GAAO,UAAU,OAAO,KAAKD,GAAM,SAAS,CAAC,CAAC;AAAA,EAC1E;AAAA,EAEAK,KAAY,CAACF,MAA2C;AACpD,QAAIA,EAAe,SAAS,KAAK;AAC7B,aAAQA,EAAe,SAAS,OAAO,IAAK,UAAU;AAC1D,QAAWA,EAAe,SAAS,KAAK;AACpC,aAAQA,EAAe,SAAS,OAAO,IAAK,UAAU;AAC1D,QAAWA,EAAe,SAAS,IAAI;AACnC,aAAO;AACX,QAAWA,EAAe,SAAS,IAAI;AACnC,aAAO;AACX,QAAWA,EAAe,SAAS,GAAG;AAClC,aAAO;AACX,QAAWA,EAAe,SAAS,IAAI;AACnC,aAAO;AACX,QAAWA,EAAe,SAAS,IAAI;AACnC,aAAO;AACX,QAAWA,EAAe,SAAS,GAAG;AAClC,aAAO;AACX,QAAWA,EAAe,SAAS,GAAG;AAClC,aAAO;AAGX,UAAM,IAAI,MAAM,2CAA2C;AAAA,EAC/D;AAAA;AAAA;AAAA,EAIAI,KAAc,CAACW,MACPA,MAAY,SACL,MAGPA,EAAQ,SAAS,KAAK,KAEfA,EAAQ,SAAS,IAAI,KAErBA,EAAQ,SAAS,IAAI,IAHrB,OAKAA,EAAQ,SAAS,GAAG,IACpB,MACAA,EAAQ,SAAS,KAAK,KAEtBA,EAAQ,SAAS,IAAI,KAErBA,EAAQ,SAAS,IAAI,IAHrB,OAKAA,EAAQ,SAAS,GAAG,IACpB,MAEA;AAAA,EAIfH,KAAe,MACP,KAAKb,OAAU,MACR,OAGP,KAAKA,GAAM,SAAS,GAAG,KACvB,KAAKA,GAAM,QAAQ,KAAK,GAAG,GACpB,QAEP,KAAKA,GAAM,SAAS,GAAG,KACvB,KAAKA,GAAM,QAAQ,KAAK,GAAG,GACpB,QAGJ;AAEf;AC/hBO,MAAMiB,EAEQ;AAAA,EACjBC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC,KAAc;AAAA,EAEd,YAAY7T,GAAwCmD,GAA8B;AAG9E,WAAInD,aAAiByT,KACjB,KAAKE,KAAW3T,EAAM,QAAQ,MAAA,GAC9B,KAAK4T,KAAS5T,EAAM,MAAM,MAAA,GAEvBmD,MAAU,UACT,KAAKyQ,GAAO,SAAS,IAAIpR,EAASW,CAAK,CAAC,KAEtCnD,MAAU,UAChB,KAAK2T,KAAW,IAAI/F,EAAQ5N,CAAK,GACjC,KAAK4T,KAAS,IAAIpR,EAASW,KAAS,CAAC,MAErC,KAAKwQ,KAAW,IAAI/F,EAAA,GACpB,KAAKgG,KAAS,IAAIpR,EAAS,CAAC,IAGhC,KAAKkR,KAAe,GAEb;AAAA,EACX;AAAA,EAEO,QAA6C;AAChD,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC7C;AAAA,EAEO,QAAgB;AACnB,WAAO,IAAID,EAAO,IAAI;AAAA,EAC1B;AAAA,EAEO,YAAYtN,GAAoC;AACnD,gBAAKwN,KAAW,IAAI/F,EAAQzH,CAAO,GACnC,KAAKyN,KAAS,IAAIpR,EAAS,CAAC,GACrB;AAAA,EACX;AAAA,EACA,IAAW,MAAc;AACrB,UAAMiB,IAAM,KAAK,MAAM,WACjBC,IAAM,KAAK,MAAM;AAEvB,QAAIoQ,GACA3Q;AAEJ,WAAI,KAAKuQ,OAAiB,KAAuBhQ,IAAM,KACnDoQ,IAAO,SAASpQ,MAAQ,IAAI,KAAK,KAAKA,CAAG,IAAI,KAAK,KAAK,QAAQ,GAAG,MAClEP,IAAQM,MAAQ,IAAI,KAAK,MAAMA,CAAG,SAElCqQ,IAAO,KAAKD,MAAe,KAAK,MAAM,MAAA,IAAU,KAAK,QAAQ,MAAM3G,GAAgB,KAAK,QAAQ,GAAG,GACnG/J,IAASO,MAAQ,KAAKD,MAAQ,IAAK,KAAK,MAAM,KAAK,MAAM,GAAG,OAIhEqQ,IAAO,GAAGA,CAAI,GAAG3Q,CAAK,IAGlB,KAAKuQ,OAAiB,KAAuBjQ,IAAM,MACnDqQ,IAAO,gBAAgBA,CAAI,OAIxBA;AAAA,EACX;AAAA,EAEA,IAAW,UAAkB;AACzB,UAAMrQ,IAAM,KAAK,MAAM,WACjBC,IAAM,KAAK,MAAM;AAEvB,QAAIoQ,GACA3Q;AAEJ,WAAI,KAAKuQ,OAAiB,KAAuBhQ,IAAM,KACnDoQ,IAAO,GAAGpQ,MAAQ,IAAI,SAAS,QAAQA,CAAG,GAAG,IAAI,KAAK,QAAQ,OAAO,KACrEP,IAAQM,MAAQ,IAAI,KAAK,KAAKA,CAAG,QAEjCqQ,IAAO,KAAKD,MAAe,KAAK,MAAM,MAAA,IAAU,KAAK,QAAQ,UAAU3G,GAAgB,KAAK,QAAQ,SAAS,EAAK,GAClH/J,IAASO,MAAQ,KAAKD,MAAQ,IAAK,KAAK,KAAK,KAAK,MAAM,OAAO,MAInEqQ,IAAO,GAAGA,CAAI,GAAG3Q,CAAK,IAGlB,KAAKuQ,OAAiB,KAAuBjQ,IAAM,MACnDqQ,IAAO,MAAMA,CAAI,MAIdA;AAAA,EACX;AAAA,EAEO,MAAc;AACjB,UAAM,IAAI,MAAM,oCAAoC;AAAA,EACxD;AAAA,EAEA,IAAW,WAAiB;AACxB,gBAAKD,KAAc,IACZ;AAAA,EACX;AAAA,EAEO,OAAOtI,GAA2B;AACrC,WAAO,KAAK,QAAQ,OAAOA,CAAM,EAAE,SAAS,KAAK,KAAK;AAAA,EAC1D;AAAA,EAEO,aAAuB;AAE1B,WAAI,KAAK,MAAM,WACJ,CAAC,IAAIkI,EAAO,GAAG,CAAC,IAIvB,KAAK,MAAM,UACJ,CAAC,IAAIA,EAAO,KAAK,QAAQ,MAAA,EAAQ,WAAA,CAAY,CAAC,IAKlD;AAAA,MACH,IAAIA,EAAO,KAAK,MAAM,OAAO;AAAA,MAC7B,IAAIA,EAAO,KAAK,QAAQ,MAAA,EAAQ,YAAY;AAAA,MAC5C,IAAIA,EAAO,KAAK,QAAQ,MAAA,GAAS,KAAK,MAAM,MAAA,EAAQ,SAAS,CAAC,CAAC;AAAA,IAAA;AAAA,EAEvE;AAAA,EAEO,UAAmB;AACtB,QAAI,KAAK,MAAM;AACX,aAAO,KAAK,QAAQ,MAAA,EAAQ,IAAI,KAAK,MAAM,KAAK;AAGpD,UAAM,IAAI,MAAM,oCAAoC;AAAA,EACxD;AAAA,EAEO,OAAOzT,GAA6C;AACvD,QAAIA,aAAiByT,KACb,KAAK,SAASzT,CAAK;AACnB,kBAAK,MAAM,SAASA,EAAM,KAAK,GACxB;AAKf,UAAM4I,IAAI,IAAIgF,EAAQ5N,CAAgB;AACtC,QAAI,KAAK,SAAS4I,CAAC;AACf,kBAAK,MAAM,SAAS,CAAC,GACd;AAGX,UAAM,IAAI,MAAM,kCAAkC;AAAA,EACtD;AAAA,EAEO,SAASrI,GAA+DsL,GAAwC;AACnH,WAAIA,IACQ,KAAK,QAAQ,SAAStL,GAAQ,EAAI,KAAgB,KAAK,MAAM,QAIjE,KAAK,QAAQ,SAASA,CAAM,EAAe,IAAI,KAAK,KAAK;AAAA,EACrE;AAAA,EAEO,YAAYgL,GAAyB;AACxC,WAAO,KAAK,QAAQ,YAAYA,CAAM;AAAA,EAC1C;AAAA,EAEO,UAAgB;AACnB,gBAAK,MAAM,SAAA,GACJ;AAAA,EACX;AAAA,EAEO,QAAQvL,GAAwB;AAGnC,WAAO,KAAK,SAASA,CAAK,KACtB,KAAK,MAAM,QAAQA,EAAM,KAAK;AAAA,EACtC;AAAA,EAEO,QAAiB;AACpB,WAAO,KAAK,QAAQ,MAAA,KAAW,KAAK,MAAM,OAAA;AAAA,EAC9C;AAAA,EAEO,SAASA,GAAuC;AACnD,QAAI4I;AACJ,WAAI5I,aAAiByT,IACjB7K,IAAI5I,EAAM,UACHA,aAAiB4N,IACxBhF,IAAI5I,IAEJ4I,IAAI,IAAIgF,EAAQ5N,CAAK,GAIlB,KAAK,QAAQ,QAAQ4I,CAAC;AAAA,EACjC;AAAA,EAEO,SAAkB;AACrB,WAAO,KAAK,QAAQ,OAAA;AAAA,EACxB;AAAA,EAEO,SAAS5I,GAA6C;AACzD,QAAIA,aAAiByT,KACb,KAAK,SAASzT,CAAK;AACnB,kBAAK,MAAM,IAAIA,EAAM,KAAK,GACnB;AAKf,UAAM4I,IAAI,IAAIgF,EAAQ5N,CAAgB;AACtC,QAAI,KAAK,SAAS4I,CAAC;AACf,kBAAK,MAAM,IAAI,CAAC,GACT;AAGX,UAAM,IAAI,MAAM,kCAAkC;AAAA,EACtD;AAAA,EAEO,MAAY;AACf,gBAAK+K,GAAS,IAAA,GACd,KAAKC,GAAO,IAAA,GACL;AAAA,EACX;AAAA,EAEO,WAAmB;AACtB,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC7C;AAAA,EAEA,IAAW,UAAmB;AAC1B,WAAO,KAAKD;AAAA,EAChB;AAAA,EAEA,IAAW,QAAQ3T,GAAgB;AAC/B,SAAK2T,KAAW3T;AAAA,EACpB;AAAA,EAEO,IAAIA,GAAgC;AACvC,gBAAK,MAAM,SAASA,CAAK,GAClB;AAAA,EACX;AAAA,EAEA,IAAW,QAAkB;AACzB,WAAO,KAAK4T;AAAA,EAChB;AAAA,EAEA,IAAW,MAAM5T,GAA6B;AAC1C,SAAK4T,KAAS,IAAIpR,EAASxC,CAAK;AAAA,EACpC;AAAA,EAEO,YAAoB;AACvB,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC7C;AAAA,EAEO,SAAiB;AACpB,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC7C;AAAA,EAEO,KAAKA,GAAqB;AAC7B,gBAAK,MAAM,OAAOA,CAAK,GAChB;AAAA,EACX;AAAA,EAEO,OAAa;AAChB,WAAO,KAAK,KAAK,CAAC;AAAA,EACtB;AAAA,EAEO,WAAmB;AACtB,UAAM,IAAI,MAAM,yCAAyC;AAAA,EAC7D;AAAA,EAEO,eAA+B;AAClC,UAAMqC,IAAM,KAAK,MAAM,MAAA,EAAQ,OAAA,GACzB0R,IAAM,KAAK,QAAQ,aAAA;AAGzB,WAAI1R,EAAI,yBACJ0R,EAAI,QAAQzG,EAAiByG,EAAI,OAAO,KAAK,GAAG,IAMhD1R,EAAI,cAAc,MAAM,IAExB0R,EAAI,QAAQzG,EAAiByG,EAAI,OAAO,KAAK,GAAG,IACzC1R,EAAI,YAAY,MAAM,MAE7B0R,EAAI,QAAQzG,EAAiByG,EAAI,OAAO,KAAK,GAAG,IAI7C,EAAC,OAAOA,EAAI,OAAO,OAAOA,EAAI,MAAA;AAAA,EACzC;AAAA,EAEA,IAAW,YAAsB;AAC7B,WAAO,KAAK,QAAQ;AAAA,EACxB;AAAA,EAEA,IAAW,YAAkB;AACzB,gBAAKL,KAAe,GACb;AAAA,EACX;AAAA,EAEA,IAAW,WAAiB;AACxB,gBAAKA,KAAe,GACb;AAAA,EACX;AAAA,EAEO,OAAa;AAChB,gBAAKC,GAAS,KAAA,GACd,KAAKC,GAAO,IAAA,GACL;AAAA,EACX;AAEJ;AAEO,IAAKI,sBAAAA,OACRA,EAAAA,EAAA,OAAA,CAAA,IAAA,QACAA,EAAAA,EAAA,QAAA,CAAA,IAAA,SAFQA,IAAAA,KAAA,CAAA,CAAA;ACvUL,MAAMC,EAEc;AAAA,EAEvBC;AAAA;AAAA,EAEAC,KAAmB,CAAA;AAAA;AAAA,EAEnBC;AAAA,EAEA,eAAe7T,GAA+B;AAC1C,gBAAK2T,KAAa,CAAA,GAClB,KAAKE,KAAa,CAAA,GAEd7T,EAAO,SAAS,KAChB,KAAK,MAAM,GAAGA,CAAM,GAGjB;AAAA,EACX;AAAA,EAEO,QAAQ,IAAI8T,OAEf,KAAKH,KAAaG,EAAU,IAAI,OAAS,IAAIhC,EAASrS,CAAK,CAAC,GAG5D,KAAKsU,GAAA,GACE;AAAA,EAGJ,QAAQ,MACJ,IAAIL,EAAA,EACN,MAAM,GAAG,KAAKC,GAAW,IAAI,CAAApO,MAAOA,EAAI,MAAA,CAAO,CAAC;AAAA,EAGzD,IAAW,MAAc;AAKrB,UAAMyO,IAAK,KAAK,MAAA,EAAQ,QAAA;AAExB,WAAO,KAAK,SAASA,EAAG,SAAS;AAAA,EACrC;AAAA,EAEA,IAAI,UAAU;AAEV,WAAO,KAAK,MAAM;AAAA,EACtB;AAAA,EAEA,OAAc,WACVC,GACAlJ,IAAU,OAAqB;AAE/B,UAAMmJ,IAAOD,EAAO,CAAC,EAAE;AACvB,QAAIA,EAAO,KAAK,CAAAE,MAAOA,EAAI,WAAWD,CAAI;AACtC,YAAM,IAAI,MAAM,+CAA+C;AAInE,UAAME,IAAOrJ,EAAQ,MAAM,EAAE,EACxB,OAAO,GAAGmJ,IAAO,CAAC;AAGvB,WAAO,IAAIR;AAAA,MACP,GAAGO,EAAO,IAAI,CAAAE,MAAO;AACjB,cAAM9L,IAAI,IAAIgF,EAAQ+G,EAAK,KAAK,EAAE,GAAG,GAAGD,CAAG;AAC3C,eAAO,IAAIrC,EAASzJ,GAAG,CAAC;AAAA,MAC5B,CAAC;AAAA,IAAA;AAAA,EAGT;AAAA,EAEO,IAAI5I,GAAsDiC,GAAsB;AACnF,QAAIjC,aAAiBiU,GAAc;AAC/B,YAAMpE,IAAS7P,EAAM,UAAU;AAC/B,UAAI6P,MAAW,KAAKqE,GAAW;AAC3B,cAAM,IAAI,MAAM,0CAA0C;AAG9D,eAASpT,IAAI,GAAGA,IAAI+O,GAAQ/O;AACxB,aAAKoT,GAAWpT,CAAC,EAAE,IAAId,EAAM,UAAUc,CAAC,CAAC;AAAA,IAEjD,OAAO;AACH,UAAImB,MAAU,UAAaA,IAAQ,KAAKA,KAAS,KAAKiS,GAAW;AAC7D,cAAM,IAAI,MAAM,oBAAoB;AAExC,YAAMpO,IAAM,IAAIuM,EAASrS,CAAK;AAC9B,WAAKkU,GAAWjS,CAAK,EAAE,IAAI6D,CAAG;AAAA,IAClC;AAEA,WAAO;AAAA,EACX;AAAA,EAEO,WAAW,CAACuO,GAAuBO,MAAqC;AAC3E,QAAIC,GACAlR,GACA2H,IAAoB,CAAA;AACxB,UAAMwJ,IAAqB,CAAA;AAG3B,eAAWhP,KAAOuO;AACd,MAAA/I,IAAUA,EAAQ,OAAOxF,EAAI,QAAA,CAAS;AAG1C,IAAAwF,IAAU,CAAC,GAAG,IAAI,IAAIA,CAAO,CAAC,GAC9BA,EAAQ,KAAA;AAER,aAASxK,IAAI,GAAGA,IAAIuT,EAAU,QAAQvT,KAAK;AACvC,YAAMgF,IAAMuO,EAAUvT,CAAC;AAEvB,MAAA+T,IAAS,CAAA;AACT,iBAAWxJ,KAAKC;AACZ,QAAA3H,IAAImC,EAAI,KAAK,cAAcuF,CAAC,GAExBwJ,EAAO,WAAW,IAClBA,EAAO,KAAKlR,EAAE,OAAA,IAAW,KAAKA,EAAE,GAAG,IAEnCkR,EAAO,KAAKlR,EAAE,OAAA,IAAW,MAAOA,EAAE,YAAY,KAAA,MAAW,IAAK,MAAM,MAAMA,EAAE,GAAG;AAWvF,UANAkR,EAAO,KAAK,GAAG,GAGfA,EAAO,KAAK/O,EAAI,MAAM,GAAG,GAGrB8O,IAAY9T,CAAC,MAAM,QAAW;AAE9B,QAAA+T,EAAOA,EAAO,SAAS,CAAC,IAAIA,EAAOA,EAAO,SAAS,CAAC,IAAI;AACxD,mBAAW3K,KAAK0K,EAAU9T,CAAC;AACvB,UAAA+T,EAAO,KAAK,eAAe3K,EAAE,WAAW,GAAG,IAAI,YAAYA,IAAI,aAAaA,CAAC,EAAE;AAAA,MAEvF;AAGA,MAAA4K,EAAS,KAAKD,EAAO,KAAK,GAAG,CAAC;AAAA,IAClC;AAEA,QAAIE,IAAmB;AACvB,WAAIH,MAAc,UAAaA,EAAU,SAAS,MAC9CG,IAAmBH,EAAU,CAAC,EAAE,SAG7B,2BAA2B,IAAI,OAAOtJ,EAAQ,MAAM,CAAC,MAAM,KAAK,OAAOyJ,CAAgB,CAAC,IAAID,EAAS,KAAK,OAAO,CAAC;AAAA,EAC7H;AAAA,EAEO,OAAOvJ,GAA2B;AACrC,WAAO/I,EAAS,IAAI,GAAG,KAAK0R,GAAW,IAAI,CAAApO,MAAOA,EAAI,OAAOyF,CAAM,CAAC,CAAC;AAAA,EACzE;AAAA;AAAA,EAGA,IAAW,YAAwB;AAC/B,WAAO,KAAK2I;AAAA,EAChB;AAAA,EAEA,IAAW,UAAUlU,GAAO;AACxB,SAAKkU,KAAalU,GAGlB,KAAKsU,GAAA;AAAA,EACT;AAAA,EAEO,SAAS/T,GAA+DsL,GAAwC;AACnH,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC7C;AAAA,EAEO,YAAYN,GAAyB;AACxC,WAAO,KAAK6I,GAAW,SAAS7I,CAAM;AAAA,EAC1C;AAAA,EAEO,QAAQvL,GAA8B;AACzC,WAAO,KAAK,UAAU,MAAM,CAAC8F,GAAK7D,MAAU6D,EAAI,QAAQ9F,EAAM,UAAUiC,CAAK,CAAC,CAAC;AAAA,EACnF;AAAA,EAEA,IAAW,aAAsB;AAI7B,WAHU,KAAK,UAGT,WAAW,KAAKiS,GAAW;AAAA,EAOrC;AAAA,EAEA,IAAW,SAAqC;AAE5C,WAAO,KAAKc,GAAA;AAAA,EAChB;AAAA,EAEO,eAAeC,GAAyDC,GAGlE;AAET,UAAMC,IAAgB,KAAK,UAAUF,EAAU,EAAE,EAAE,QAAQ,SAASA,EAAU,MAAM,GAC9EG,IAAgB,KAAK,UAAUF,EAAU,EAAE,EAAE,QAAQ,SAASA,EAAU,MAAM;AAGpF,WAAOC,EAAc,IAAIC,CAAa;AAAA,EAC1C;AAAA,EAEO,SAASpV,GAAsDiC,GAAsB;AAIxF,QAAI,MAAM,QAAQjC,CAAK,GAAG;AACtB,UAAIA,EAAM,WAAW,KAAKkU,GAAW;AACjC,cAAM,IAAI,MAAM,kEAAkE;AAGtF,eAAS,IAAI,GAAG,IAAIlU,EAAM,QAAQ;AAC9B,aAAKkU,GAAW,CAAC,EAAE,SAASlU,EAAM,CAAC,CAAC;AAExC,aAAO;AAAA,IACX;AAEA,QAAIiC,MAAU,UAAaA,IAAQ,KAAKA,KAAS,KAAKiS,GAAW;AAC7D,YAAM,IAAI,MAAM,oBAAoB;AAGxC,gBAAKA,GAAWjS,CAAK,EAAE,SAASjC,CAAK,GAE9B;AAAA,EACX;AAAA,EAEO,SAAe;AAElB,gBAAK,UAAU,QAAQ,CAAA8F,MAAKA,EAAI,QAAQ,GACjC;AAAA,EACX;AAAA;AAAA,EAGO,UAAU,MAAY;AACzB,eAAWyE,KAAK,KAAK2J;AACjB,MAAA3J,EAAE,QAAA;AAGN,WAAO;AAAA,EACX;AAAA,EAEA,QAAqB;AAOjB,UAAM/D,IAAmB,CAAC,KAAK,GAAG,GAE5B+N,IAAK,KAAK,MAAA;AAEhB,WAAOA,EAAG,UAAU,SAAO,KAAE;AACzB,YAAMhJ,IAASgJ,EAAG,UAAUA,EAAG,UAAU,SAAO,CAAC,GAC3Cc,IAAU,IAAIpB,EAAA;AAEpB,MADgBM,EAAG,sBAAsBhJ,CAAM,EAAE,MAAM,GAAGgJ,EAAG,UAAU,SAAO,CAAC,EACvE,QAAQ,CAAAnS,MAAS;AACrB,QAAAiT,EAAQ,UAAU,KAAKd,EAAG,eAAe,GAAGnS,CAAM,CAAC;AAAA,MACvD,CAAC,GAEDmS,EAAG,YAAYc,EAAQ,WAEvB7O,EAAO,KAAK+N,EAAG,GAAG,GAGlBA,EAAG,OAAA,GACH/N,EAAO,KAAK+N,EAAG,GAAG;AAAA,IACtB;AAGA,mBAAQ,IAAI,qBAAqB/N,EAAO,KAAK,WAAW,IAAI,gBAAgB,GAErE,CAAA;AAAA,EACX;AAAA,EAEO,cAAc,MAAkB;AACnC,UAAM,CAACgO,GAAQc,CAAM,IAAI,KAAK,QAIxBC,IAAgCf,EAAO,IAAI,CAACE,GAAKzS,MAAU,CAAC,GAAGyS,GAAKY,EAAOrT,CAAK,CAAC,CAAC;AAGxF,aAASnB,IAAI,GAAGA,IAAI0T,EAAO,QAAQ1T,KAAK;AAEpC,UAAI0U,IAAQD,EAAgBzU,CAAC,EAAEA,CAAC,EAAE,MAAA;AAClC,UAAI0U,EAAM,UAAU;AAGhB,cAAMC,IAAaF,EACd,KAAK,CAACb,GAAKzS,MACDA,IAAQnB,KAAK,CAAC4T,EAAI5T,CAAC,EAAE,OAAA,CAC/B;AAEL,YAAI2U;AACA,UAAAF,EAAgBzU,CAAC,EAAE,QAAQ,CAACd,GAAOiC,MAAUjC,EAAM,IAAIyV,EAAWxT,CAAK,CAAC,CAAC,GACzEuT,IAAQD,EAAgBzU,CAAC,EAAEA,CAAC,EAAE,MAAA;AAAA;AAE9B,gBAAM,IAAI,MAAM,eAAe;AAAA,MAIvC;AAIA,MAAAyU,EAAgBzU,CAAC,IAAIyU,EAAgBzU,CAAC,EAAE,IAAI,CAAAJ,MAAKA,EAAE,OAAO8U,CAAK,CAAC;AAGhE,eAAS7E,IAAI,GAAGA,IAAI6D,EAAO,QAAQ7D,KAAK;AACpC,YAAIA,MAAM7P;AACN;AAGJ,cAAMsB,IAASmT,EAAgB5E,CAAC,EAAE7P,CAAC,EAAE,MAAA,EAAQ,SAAA;AAC7C,iBAASsD,IAAI,GAAGA,IAAImR,EAAgB5E,CAAC,EAAE,QAAQvM;AAC3C,UAAAmR,EAAgB5E,CAAC,EAAEvM,CAAC,EAAE,IAAImR,EAAgBzU,CAAC,EAAEsD,CAAC,EAAE,MAAA,EAAQ,SAAShC,CAAM,CAAC;AAO5E,YAAImT,EAAgB5E,CAAC,EAAE,MAAM,GAAG4E,EAAgB5E,CAAC,EAAE,SAAS,CAAC,EAAE,MAAM,CAAAjQ,MAAKA,EAAE,OAAA,CAAQ;AAChF,iBAAI6U,EAAgB5E,CAAC,EAAE4E,EAAgB5E,CAAC,EAAE,SAAS,CAAC,EAAE,WAC3C,CAAC,IAAInO,IAAW,UAAU,IAE1B,CAAA;AAAA,MAGnB;AAAA,IACJ;AAEA,WAAO+S,EAAgB,IAAI,CAAA7U,MAAKA,EAAEA,EAAE,SAAS,CAAC,CAAC;AAAA,EACnD;AAAA,EAEA,sBAAsB6K,GACiD;AAGnE,UAAM3G,IAA6E,CAAA,GAC7E8Q,IAAe,KAAK,UAAU,IAAI,CAAA5P,MAAOA,EAAI,KAAK,cAAcyF,CAAM,EAAE,YAAY,KAAK;AAG/F,WAAAmK,EAAa,QAAQ,CAACC,GAAW1T,MAAU;AACvC,eAASnB,IAAImB,IAAQ,GAAGnB,IAAI4U,EAAa,QAAQ5U,KAAK;AAClD,cAAMiD,IAAMzB,EAAQ,IAAIqT,GAAWD,EAAa5U,CAAC,CAAC,GAE5CuD,IAAOsR,IAAY,IAAI,KAAK;AAClC,QAAA/Q,EAAO,KAAK;AAAA,UACR;AAAA,YACI,IAAI3C;AAAA,YAAO,QAAQoC,IAAON,IAAM4R;AAAA,UAAA;AAAA,UACjC;AAAA,YACC,IAAI7U;AAAA,YAAG,QAAQ,CAACuD,IAAON,IAAM2R,EAAa5U,CAAC;AAAA,UAAA;AAAA,QAC/C,CAAE;AAAA,MACV;AAAA,IACJ,CAAC,GAGM8D,EAAO,KAAK,CAAC7D,GAAGC,MACX,KAAK,IAAID,EAAE,CAAC,EAAE,MAAM,IAAI,KAAK,IAAIA,EAAE,CAAC,EAAE,MAAM,KAAM,KAAK,IAAIC,EAAE,CAAC,EAAE,MAAM,IAAI,KAAK,IAAIA,EAAE,CAAC,EAAE,MAAM,EACzG;AAAA,EACL;AAAA,EAEO,SAAShB,GAAsDiC,GAAsB;AACxF,QAAIjC,aAAiBiU,GAAc;AAC/B,YAAMpE,IAAS7P,EAAM,UAAU;AAC/B,UAAI6P,MAAW,KAAKqE,GAAW;AAC3B,cAAM,IAAI,MAAM,0CAA0C;AAG9D,eAASpT,IAAI,GAAGA,IAAI+O,GAAQ/O;AACxB,aAAKoT,GAAWpT,CAAC,EAAE,SAASd,EAAM,UAAUc,CAAC,CAAC;AAAA,IAEtD,OAAO;AACH,UAAImB,MAAU,UAAaA,IAAQ,KAAKA,KAAS,KAAKiS,GAAW;AAC7D,cAAM,IAAI,MAAM,oBAAoB;AAExC,YAAMpO,IAAM,IAAIuM,EAASrS,CAAK;AAC9B,WAAKkU,GAAWjS,CAAK,EAAE,SAAS6D,CAAG;AAAA,IACvC;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,IAAW,YAAsB;AAC7B,WAAO,KAAKsO;AAAA,EAChB;AAAA,EAEA,IAAW,UAAUpU,GAA0B;AAC3C,UAAM2U,IAAQ,OAAO3U,KAAU,WAAYA,EAAM,MAAM,EAAE,IAAI,CAAC,GAAGA,CAAK;AACtE,IAAA2U,EAAK,KAAA,GACL,KAAKP,KAAaO;AAAA,EACtB;AAAA,EAEAL,KAAe,OACX,KAAKF,KAAa,KAAKF,GAAW,OAAO,CAAC0B,GAAe9P,MAC9C,CAAC,GAAG,oBAAI,IAAI,CAAC,GAAG8P,GAAK,GAAG9P,EAAI,SAAS,CAAC,CAAC,GAC/C,CAAA,CAAE,GAEL,KAAKsO,GAAW,KAAA,GACT;AAAA,EAGXY,KAAc,MAAkC;AAE5C,UAAMR,IAAuB,CAAA,GACvBc,IAAqB,CAAA;AAE3B,eAAW/K,KAAK,KAAK2J,IAAY;AAC7B,YAAMQ,IAAkB,CAAA,GAElB5O,IAAMyE,EAAE,MAAA,EAAQ,QAAA;AACtB,iBAAWc,KAAK,KAAK,WAAW;AAC5B,cAAM1H,IAAImC,EAAI,KAAK,cAAcuF,CAAC;AAClC,QAAAqJ,EAAI,KAAK/Q,EAAE,WAAW;AAAA,MAC1B;AAGA,MAAA2R,EAAO,KAAKxP,EAAI,MAAM,OAAO,CAAC,EAAE,WAAW,GAG3C0O,EAAO,KAAKE,CAAG;AAAA,IACnB;AAEA,WAAO,CAACF,GAAQc,CAAM;AAAA,EAC1B;AAEJ;AC/aO,MAAMO,GAAW;AAAA,EACpBC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY9V,GAAgB;AACxB,gBAAK8V,KAAO,CAAA,GAER9V,MAAU,UACV,KAAK,MAAMA,CAAK,GAGb;AAAA,EACX;AAAA,EAEA,QAAQ,CAACA,OAEL,KAAK8V,KAAO,IAAItJ,EAAYuJ,EAAgB,GAAG,EAC1C,MAAM/V,CAAK,EACX,KAEE;AAAA,EAGX,SAASO,GAA0C;AAE/C,SAAK,UAAU,QAAQ,CAAA+L,MAAO;AAC1B,MAAK,OAAO,OAAO/L,GAAQ+L,CAAG,MAC1B/L,EAAO+L,CAAG,IAAI;AAAA,IAEtB,CAAC;AAED,UAAMG,IAAmB,CAAA;AACzB,eAAWuJ,KAAS,KAAKF;AAErB,UADA,QAAQ,IAAIE,CAAK,GACbA,EAAM,cAAc;AACpB,QAAAvJ,EAAM,KAAKlM,EAAOyV,EAAM,KAAK,CAAC;AAAA,eACvBA,EAAM,cAAc;AAC3B,YAAIA,EAAM,UAAU;AAEhB,cAAIvJ,EAAM,UAAU,GAAG;AACnB,kBAAM1L,IAAI0L,EAAM,IAAA;AAChB,YAAAA,EAAM,KAAK,CAAC1L,CAAC;AAAA,UACjB;AACI,mBAAO;AAAA,aAER;AAEH,gBAAMA,IAAI0L,EAAM,IAAA,GACVzL,IAAIyL,EAAM,IAAA;AAChB,cAAI1L,MAAM,UAAaC,MAAM;AACzB,oBAAQgV,EAAM,OAAA;AAAA,cACV,KAAK;AACD,gBAAAvJ,EAAM,KAAK1L,KAAKC,CAAC;AACjB;AAAA,cACJ,KAAK;AACD,gBAAAyL,EAAM,KAAK1L,KAAKC,CAAC;AACjB;AAAA,cACJ,KAAK;AACD,uBAAO;AAAA,YAAA;AAAA;AAIf,mBAAO;AAAA,QAEf;AAIR,WAAOyL,EAAM,WAAW,KAAKA,EAAM,CAAC;AAAA,EACxC;AAAA,EAEA,IAAI,MAA8C;AAC9C,WAAO,KAAKqJ;AAAA,EAChB;AAAA,EAEA,IAAI,MAAc;AACd,UAAMG,IAAmD,CAAA;AAEzD,eAAWD,KAAS,KAAKF;AACrB,UAAIE,EAAM,cAAc;AACpB,QAAAC,EAAS,KAAKD,CAAK;AAAA;AAEnB,gBAAQA,EAAM,OAAA;AAAA,UACV,KAAK;AACD,gBAAIC,EAAS,UAAU,GAAG;AACtB,oBAAMC,IAASD,EAAS,IAAA,GACpBE,IAAQF,EAAS,IAAA;AAErB,cAAIC,KAAUC,MACNA,EAAM,cAAc,UACpBA,EAAM,QAAQ,KAAKA,EAAM,KAAK,OAE9BD,EAAO,cAAc,UACrBA,EAAO,QAAQ,KAAKA,EAAO,KAAK,OAEpCD,EAAS,KAAK,EAAC,OAAO,GAAGE,EAAM,KAAK,UAAUD,EAAO,KAAK,IAAI,WAAW,MAAA,CAAM;AAAA,YAEvF;AACA;AAAA,UACJ,KAAK;AACD,gBAAID,EAAS,UAAU,GAAG;AACtB,oBAAMC,IAASD,EAAS,IAAA,GACpBE,IAAQF,EAAS,IAAA;AAErB,cAAIC,KAAUC,MACNA,EAAM,cAAc,UACpBA,EAAM,QAAQ,KAAKA,EAAM,KAAK,OAE9BD,EAAO,cAAc,UACrBA,EAAO,QAAQ,KAAKA,EAAO,KAAK,OAEpCD,EAAS,KAAK,EAAC,OAAO,GAAGE,EAAM,KAAK,UAAUD,EAAO,KAAK,IAAI,WAAW,MAAA,CAAM;AAAA,YAEvF;AACA;AAAA,UACJ,KAAK;AACD,gBAAID,EAAS,UAAU,GAAG;AACtB,oBAAMC,IAASD,EAAS,IAAA,GACpBE,IAAQF,EAAS,IAAA;AAErB,cAAIC,KAAUC,MACNA,EAAM,cAAc,UACpBA,EAAM,QAAQ,KAAKA,EAAM,KAAK,OAE9BD,EAAO,cAAc,UACrBA,EAAO,QAAQ,KAAKA,EAAO,KAAK,OAEpCD,EAAS,KAAK,EAAC,OAAO,GAAGE,EAAM,KAAK,eAAeD,EAAO,KAAK,IAAI,WAAW,MAAA,CAAM;AAAA,YAE5F;AACA;AAAA,UACJ,KAAK;AACD,gBAAID,EAAS,UAAU,GAAG;AACtB,oBAAME,IAAQF,EAAS,IAAA;AAEvB,cAAIE,KACAF,EAAS,KAAK,EAAC,OAAO,eAAeE,EAAM,KAAK,MAAM,WAAW,WAAA,CAAW;AAAA,YAEpF;AACA;AAAA,QAAA;AAKhB,WAAOF,EAAS,CAAC,EAAE;AAAA,EACvB;AAAA,EAEA,IAAI,YAAsB;AACtB,WAAO,KAAKH,GACP,OAAO,CAAA9V,MAASA,EAAM,cAAc,UAAU,EAC9C,IAAI,CAAAA,MAASA,EAAM,KAAK;AAAA,EACjC;AAAA,EAEA,SAAmB;AACf,WAAO,KAAKoW;AAAA,MAAgB;AAAA,QACpB,GAAG,CAAC,KAAK,IAAI;AAAA,QACb,GAAG,CAAC,KAAK,IAAI;AAAA,MAAA;AAAA,MAEjB,CAAC,KAAK,KAAK,MAAM,GAAG;AAAA,IAAA;AAAA,EAE5B;AAAA,EAEA,UAAoB;AAChB,WAAO,KAAKA;AAAA,MAAgB;AAAA,QACpB,GAAG,CAAC,KAAK,MAAM,MAAM,KAAK;AAAA,QAC1B,GAAG,CAAC,KAAK,MAAM,MAAM,KAAK;AAAA,QAC1B,GAAG,CAAC,KAAK,MAAM,MAAM,KAAK;AAAA,MAAA;AAAA,MAE9B,CAAC,KAAK,KAAK,KAAK,MAAM,MAAM,MAAM,OAAO,GAAG;AAAA,IAAA;AAAA,EAEpD;AAAA,EAEAA,GAAgBC,GAAiDV,GAAgC;AAC7F,UAAMM,IAA4B,CAAA;AAElC,QAAIK;AACJ,QAAIX,MAAc,QAAW;AACzB,MAAAW,wBAAmB,IAAA;AACnB,iBAAWhK,KAAO+J;AACd,QAAAC,wBAAmB,IAAI;AAAA,UACnB,GAAGA;AAAA,UACH,GAAID,EAAU/J,CAAG,KAAK,CAAA;AAAA,QAAC,CAC1B;AAAA,IAET;AACI,MAAAgK,IAAe,IAAI,IAAIX,CAAS;AAGpC,eAAWK,KAAS,KAAKF;AACrB,UAAIE,EAAM,cAAc;AAEpB,QAAIK,EAAUL,EAAM,KAAK,MAAM,SAC3BC,EAAS,KAAK,oBAAI,KAAK,IAEvBA,EAAS,KAAK,IAAI,IAAII,EAAUL,EAAM,KAAK,CAAC,CAAC;AAAA;AAIjD,gBAAQA,EAAM,OAAA;AAAA,UACV,KAAK;AACD,gBAAIC,EAAS,UAAU,GAAG;AACtB,oBAAMC,IAASD,EAAS,IAAA,GACpBE,IAAQF,EAAS,IAAA;AAErB,cAAIE,KAASD,KACTD,EAAS,KAAK,IAAI,IAAI,CAAC,GAAGE,CAAK,EAAE,OAAO,CAAAzV,MAAKwV,EAAO,IAAIxV,CAAC,CAAC,CAAC,CAAC;AAAA,YAEpE;AACA;AAAA,UACJ,KAAK;AACD,gBAAIuV,EAAS,UAAU,GAAG;AACtB,oBAAMC,IAASD,EAAS,IAAA,GACpBE,IAAQF,EAAS,IAAA;AACrB,cAAIE,KAASD,KACTD,EAAS,yBAAS,IAAI,CAAC,GAAGE,GAAO,GAAGD,CAAM,CAAC,CAAC;AAAA,YAEpD;AACA;AAAA,UACJ,KAAK;AACD,gBAAID,EAAS,UAAU,GAAG;AACtB,oBAAMC,IAASD,EAAS,IAAA,GACpBE,IAAQF,EAAS,IAAA;AAErB,cAAIE,KAASD,KACTD,EAAS,KAAK,IAAI,IAAI,CAAC,GAAGE,CAAK,EAAE,OAAO,CAAAzV,MAAK,CAACwV,EAAO,IAAIxV,CAAC,CAAC,CAAC,CAAC;AAAA,YAErE;AACA;AAAA,UACJ,KAAK;AACD,gBAAIuV,EAAS,UAAU,GAAG;AACtB,oBAAME,IAAQF,EAAS,IAAA;AAEvB,cAAIE,KACAF,EAAS,KAAK,IAAI,IAAI,CAAC,GAAGK,CAAY,EAAE,OAAO,CAAA5V,MAAK,CAACyV,EAAM,IAAIzV,CAAC,CAAC,CAAC,CAAC;AAAA,YAE3E;AACA;AAAA,QAAA;AAKhB,WAAO,CAAC,GAAGuV,EAAS,CAAC,CAAC,EAAE,KAAA;AAAA,EAC5B;AACJ;AC5OO,MAAMM,EAEY;AAAA,EAErB7C,KAA+BM,EAAe;AAAA,EAC9ClG,KAAqB,CAAA;AAAA,EAErB,eAAevN,GAAyD;AACpE,gBAAK,MAAM,GAAGA,CAAM,GACb;AAAA,EACX;AAAA,EAEO,SAASA,GAA+D;AAK3E,WAHA,KAAKuN,KAAW,CAAA,GAGZvN,EAAO,WAAW,IACX,QAGXA,EAAO,QAAQ,CAAAP,MAAS;AACpB,MAAIA,aAAiBuW,IACjB,KAAKzI,GAAS,KAAK,GAAG9N,EAAM,QAAQ,IAAI,CAAAwD,MAAKA,EAAE,MAAA,CAAO,CAAC,IAEvD,KAAKsK,GAAS,KAAK,IAAI2F,EAAOzT,CAAK,CAAC;AAAA,IAE5C,CAAC,GAEM;AAAA,EACX;AAAA,EAEO,QAAoB;AACvB,WAAO,IAAIuW,EAAW,GAAG,KAAKzI,GAAS,IAAI,CAAAtK,MAAKA,EAAE,MAAA,CAAO,CAAC;AAAA,EAC9D;AAAA,EAEA,IAAW,MAAc;AACrB,UAAM,EAAC,KAAAC,GAAK,KAAAC,MAAO,KAAK8S,GAAA;AAExB,QAAI9S,EAAI,WAAW;AACf,aAAID,EAAI,WAAW,IACRA,EAAI,CAAC,EAAE,SAAS,MAGpBA,EAAI,IAAI,CAAAD,MAAKA,EAAE,GAAG,EAAE,KAAK,EAAE;AAItC,UAAMiT,IAAShT,EAAI,WAAW,IAAIA,EAAI,CAAC,EAAE,SAAS,MAAMA,EAAI,IAAI,CAAAD,MAAKA,EAAE,GAAG,EAAE,KAAK,EAAE,GAC7EkT,IAAShT,EAAI,WAAW,IAAIA,EAAI,CAAC,EAAE,SAAS,MAAMA,EAAI,IAAI,CAAAF,MAAKA,EAAE,GAAG,EAAE,KAAK,EAAE;AAEnF,WAAO,WAAWiT,CAAM,OAAOC,CAAM;AAAA,EAEzC;AAAA,EAEA,IAAW,UAAkB;AACzB,UAAM,EAAC,KAAAjT,GAAK,KAAAC,MAAO,KAAK8S,GAAA;AAExB,QAAI9S,EAAI,WAAW;AACf,aAAID,EAAI,WAAW,IACRA,EAAI,CAAC,EAAE,SAAS,UAGpBA,EAAI;AAAA,QAAI,CAACD,GAAGvB,MACfA,MAAU,KAAKuB,EAAE,QAAQ,OAAO,WAAW,IAAIA,EAAE,SAAS,UAAUA,EAAE;AAAA,MAAA,EACxE,KAAK,EAAE;AAIb,UAAMiT,IAAShT,EAAI,WAAW,IAAIA,EAAI,CAAC,EAAE,SAAS,UAAUA,EAAI,IAAI,CAAAD,MAAKA,EAAE,OAAO,EAAE,KAAK,EAAE,GACrFkT,IAAShT,EAAI,WAAW,IAAIA,EAAI,CAAC,EAAE,SAAS,UAAUA,EAAI,IAAI,CAAAF,MAAKA,EAAE,OAAO,EAAE,KAAK,EAAE;AAE3F,WAAO,IAAIiT,CAAM,MAAMC,CAAM;AAAA,EAEjC;AAAA,EAEA,OAAOC,GAASC,GAAiBC,GAA6B;AAG1D,UAAMC,IAAWC,EAAWH,CAAG,GAEzBI,IAAWD,EAAWF,CAAG,GAKzB5H,IAHS,OAAO,KAAK6H,CAAQ,EAAE,OAAO,CAAA1S,MAAK,OAAO,OAAO4S,GAAU5S,CAAC,CAAC,EAGpD,IAAI,CAAAA,MAAK;AAC5B,YAAMjB,IAAQ2T,EAAS1S,CAAC,EAAE,OAAO,CAACwR,GAAKpS,MAAMoS,EAAI,IAAIpS,EAAE,KAAK,GAAG,IAAIhB,EAAS,GAAG,CAAC,GAC1EyU,IAASD,EAAS5S,CAAC,EAAE,OAAO,CAACwR,GAAKpS,MAAMoS,EAAI,IAAIpS,EAAE,KAAK,GAAG,IAAIhB,EAAS,GAAG,CAAC;AACjF,aAAO,IAAIiR,EAAOrP,GAAG5B,EAAS,IAAIW,GAAO8T,CAAM,CAAC;AAAA,IACpD,CAAC;AAED,WAAO,IAAIV,EAAW,GAAGtH,CAAO;AAAA,EACpC;AAAA,EAEA,OAAOiI,GAASN,GAAiBC,GAA6B;AAE1D,UAAMC,IAAWC,EAAWH,CAAG,GAEzBI,IAAWD,EAAWF,CAAG,GAKzB5H,IAHS,CAAC,GAAG,oBAAI,IAAI,CAAC,GAAG,OAAO,KAAK6H,CAAQ,GAAG,GAAG,OAAO,KAAKE,CAAQ,CAAC,CAAC,CAAC,EAGzD,IAAI,CAAA5S,MAAK;AAC5B,YAAMjB,IACF,OAAO,OAAO2T,GAAU1S,CAAC,IACrB0S,EAAS1S,CAAC,EAAE,OAAO,CAACwR,GAAKpS,MAAMoS,EAAI,IAAIpS,EAAE,KAAK,GAAG,IAAIhB,EAAS,GAAG,CAAC,IAClE,IAAIA,EAAS,CAAC,GAChByU,IAAS,OAAO,OAAOD,GAAU5S,CAAC,IACpC4S,EAAS5S,CAAC,EAAE,OAAO,CAACwR,GAAKpS,MAAMoS,EAAI,IAAIpS,EAAE,KAAK,GAAG,IAAIhB,EAAS,GAAG,CAAC,IAClE,IAAIA,EAAS,CAAC;AAClB,aAAO,IAAIiR,EAAOrP,GAAG5B,EAAS,IAAIW,GAAO8T,CAAM,CAAC;AAAA,IACpD,CAAC;AAED,WAAO,IAAIV,EAAW,GAAGtH,CAAO;AAAA,EACpC;AAAA,EAEA,OAAc,OAAO1O,GAAkC;AACnD,QAAIA,EAAO,WAAW;AAClB,aAAO,IAAIgW,EAAA,EAAa,IAAA;AAE5B,QAAIhW,EAAO,WAAW;AAClB,aAAOA,EAAO,CAAC;AAEnB,QAAIA,EAAO,WAAW;AAClB,aAAOgW,EAAWI,GAASpW,EAAO,CAAC,GAAGA,EAAO,CAAC,CAAC;AAInD,QAAI4W,IAAK5W,EAAO,CAAC;AACjB,WAAAA,EAAO,MAAA,GACPA,EAAO,QAAQ,CAAAP,MAASmX,IAAKZ,EAAWI,GAASQ,GAAInX,CAAK,CAAC,GAEpDmX;AAAA,EACX;AAAA,EAEA,OAAc,OAAO5W,GAAkC;AACnD,QAAIA,EAAO,WAAW;AAClB,aAAO,IAAIgW,EAAA,EAAa,IAAA;AAE5B,QAAIhW,EAAO,WAAW;AAClB,aAAOA,EAAO,CAAC;AAGnB,QAAI4W,IAAK5W,EAAO,CAAC;AACjB,WAAAA,EAAO,MAAA,GACPA,EAAO,QAAQ,CAAAP,MAASmX,IAAKZ,EAAWW,GAASC,GAAInX,CAAK,CAAC,GACpDmX;AAAA,EACX;AAAA,EAEO,OAAO5W,GAA4B;AAKtC,UAAMyP,IAA2B,CAAC,KAAK,WAAW,GAAGzP,EAAO,IAAI,CAAAG,MAAKA,EAAE,SAAS,CAAC,GAC3EqP,IAA6B,CAAC,KAAK,aAAa,GAAGxP,EAAO,IAAI,CAAAG,MAAKA,EAAE,WAAW,CAAC;AAEvF,QAAI4N;AACJ,QAAIyB,EAAa,KAAK,CAAAxH,MAAKA,EAAE,QAAQ,SAAS,CAAC,GAAG;AAE9C,YAAMxE,IAAMwS,EAAW,IAAI,GAAGxG,CAAY;AAG1C,MAAAC,EAAW,QAAQ,CAACxL,GAAGvC,MAAU;AAC7B,QAAAuC,EAAE,SAAST,EAAI,MAAA,EAAQ,OAAOgM,EAAa9N,CAAK,CAAC,CAAC;AAAA,MACtD,CAAC,GAGDqM,IAAcvK;AAAA,IAClB;AAGA,UAAMyF,IAAM+M,EAAW,IAAI,GAAGvG,CAAU,GAClCoH,IAAmB,IAAIxJ,EAAQ,CAAC,EACjC;AAAA,MAAI,GAAGoC,EAAW,IAAI,CAAAqH,MACRA,EACF,OAAO7N,CAAG,EAAE,SACZ,UACA,QAAQ,CAAC,EACT,OACR;AAAA,IAAA,EACH,OAAA;AAEN,gBAAKsE,KAAW;AAAA,MACZ,GAAGtE,EAAI;AAAA,MACP,IAAIiK,EAAO2D,CAAgB;AAAA,IAAA,GAG3B9I,KACA,KAAK,OAAOA,CAAW,GAI3B,KAAKR,KAAW,KAAKA,GAAS,OAAO,OAAK,CAACpN,EAAE,MAAM,QAAQ,GAEpD;AAAA,EACX;AAAA,EAEA,IAAI,UAAgB;AAChB,gBAAKgT,KAAeM,EAAe,OAC5B;AAAA,EACX;AAAA,EAEA,IAAI,SAAe;AACf,gBAAKN,KAAeM,EAAe,MAC5B;AAAA,EACX;AAAA,EAEO,OAAOzI,GAA2B;AACrC,WAAO,KAAKuC,GAAS,OAAO,CAAC8H,GAAKpS,MAAMoS,EAAI,IAAIpS,EAAE,OAAO+H,CAAM,CAAC,GAAG,IAAI/I,EAAS,GAAG,CAAC;AAAA,EACxF;AAAA,EAEA,IAAI,cAA0B;AAC1B,WAAO,IAAI+T;AAAA,MAAW,GAAG,KAAKzI,GACzB,OAAO,CAAAtK,MAAKA,EAAE,MAAM,WAAA,CAAY,EAChC,IAAI,CAAAA,MAAKA,EAAE,MAAA,EAAQ,SAAS;AAAA,IAAA;AAAA,EAErC;AAAA,EAEO,aAAmB;AAGtB,UAAM8T,IAAoB,CAAA,GAEpBzH,IAAS,KAAK/B,GAAS;AAE7B,aAAShN,IAAI,GAAGA,IAAI+O,GAAQ/O,KAAK;AAE7B,YAAMmO,IAAU,KAAKnB,GAAS,MAAA,GAExByJ,IAAmBtI,EAAQ,OAAOnO,GAAG,CAAC,EAAE,CAAC,EAAE,WAAA;AAEjD,MAAAwW,EAAI;AAAA,QACA,IAAIf,EAAW,GAAGtH,GAAS,GAAGsI,CAAgB;AAAA,MAAA;AAAA,IACtD;AAGA,IAAAD,EAAI,QAAQ,CAAAD,MAAMA,EAAG,OAAA,CAAQ;AAE7B,UAAMlB,IAAQmB,EAAI,MAAA;AAClB,WAAInB,MAAU,WACV,KAAKrI,KAAWqI,EAAM,UAInB,KAAK,IAAI,GAAGmB,CAAG;AAAA,EAC1B;AAAA,EAEO,UAAsB;AAEzB,UAAMnT,IAAI,IAAIyJ,EAAQ,GAAG,GACnB/M,IAAI,IAAI+M,EAAQ,GAAG;AAEzB,gBAAK,UAAU,QAAQ,QAAQ,CAAApK,MAAK;AAChC,MAAAW,EAAE,SAASX,EAAE,SAAS;AAAA,IAC1B,CAAC,GACD,KAAK,YAAY,QAAQ,QAAQ,CAAAA,MAAK;AAClC,MAAA3C,EAAE,SAAS2C,EAAE,SAAS;AAAA,IAC1B,CAAC,GAEM,IAAI+S,EAAA,EAAa,YAAYpS,GAAGtD,CAAC;AAAA,EAC5C;AAAA,EAEO,OAAOb,GAAyB;AACnC,gBAAK8N,KAAW,KAAKA,GAAS,OAAO9N,EAAM,MAAA,EAAQ,QAAQ,IAAI,CAAAwD,MAAKA,EAAE,QAAA,CAAS,CAAC,GACzE;AAAA,EACX;AAAA,EAEO,SAASjD,GAA+DsL,GAAwC;AACnH,WAAIA,IACO,KAAKiC,GACP,OAAO,CAAC8H,GAAKpS,MAAMoS,IAAOpS,EAAE,SAASjD,GAAQsL,CAAS,GAAc,CAAC,IAGvE,KAAKiC,GACP,OAAO,CAAC8H,GAAKpS,MAAMoS,EAAI,SAASpS,EAAE,SAASjD,CAAM,CAAC,GAAG,IAAIiC,EAAS,GAAG,CAAC;AAAA,EAC/E;AAAA,EAEO,UAAU+I,GAA6B;AAG1C,UAAMiM,IAAuB,CAAA;AAE7B,SAAK1J,GAAS,QAAQ,CAAA1L,MAAU;AAC5B,YAAM6M,IAAU7M,EAAO,QAAQ,UAAUmJ,CAAM;AAC/C,UAAI0D,EAAQ,SAAS,GAAG;AACpB,cAAM5M,IAAMD,EAAO,MAAM,MAAA;AACzB,QAAAoV,EAAW,KAAK,GAAGvI,EAAQ,IAAI,CAAAvO,MAAK,IAAI+S,EAAO/S,GAAG2B,CAAG,CAAC,CAAC;AAAA,MAC3D;AACI,QAAAmV,EAAW,KAAKpV,EAAO,OAAO;AAAA,IAEtC,CAAC;AAED,UAAMwC,IAAS,IAAI2R,EAAW,GAAGiB,CAAU,GACrCnJ,IAAYzJ,EAAO,UAAU,OAAA,GAC7B0J,IAAc1J,EAAO,YAAY,OAAA;AAEvC,WAAOyJ,EAAU,OAAOC,CAAW;AAAA,EACvC;AAAA,EAEA,IAAW,UAAoB;AAC3B,WAAO,KAAKR;AAAA,EAChB;AAAA,EAEA,IAAW,QAAQ9N,GAAiB;AAChC,SAAK8N,KAAW9N;AAAA,EACpB;AAAA,EAEO,YAAYqO,GAAkCC,GAA2C;AAI5F,QAFA,KAAKR,KAAW,CAAC,IAAI2F,EAAO,IAAI7F,EAAQS,CAAS,CAAC,CAAC,GAE/CC,GAAa;AACb,YAAMnI,IAAU,IAAIyH,EAAQU,CAAW;AAEvC,UAAInI,EAAQ;AACR,eAAO;AAEX,UAAIA,EAAQ;AACR,cAAM,IAAI,MAAM,uBAAuB;AAE3C,WAAK2H,GAAS,KAAK,IAAI2F,EAAOtN,GAAS,EAAE,CAAC;AAAA,IAC9C;AAYA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKO,WAAuB;AAC1B,WAAO,CAAA;AAAA,EACX;AAAA,EAEO,YAAyB;AAE5B,UAAM4K,IAAsB,CAAA,EACvB,OAAO,GAAG,KAAKjD,GAAS,IAAI,CAAApN,MAAKA,EAAE,QAAQ,UAAA,CAAW,CAAC;AAI5D,WAAAqQ,EAAM,KAAK,CAAChQ,GAAGC,MAAMD,EAAE,QAAQC,EAAE,KAAK,GAE/B+P,EACF;AAAA,MAAO,CAAC/Q,GAAOiC,GAAOwV,MACfxV,MAAUwV,EAAK;AAAA,QAAU,CAACpN,MACtBA,EAAE,UAAUrK,EAAM;AAAA,MAAA;AAAA,IACtB;AAAA,EAEhB;AAAA,EAEO,YAAYuL,GAAyB;AACxC,WAAO,KAAKuC,GAAS,KAAK,OAAKtK,EAAE,YAAY+H,CAAM,CAAC;AAAA,EACxD;AAAA,EAEO,UAAgB;AACnB,gBAAKuC,KAAW,KAAKA,GAAS,IAAI,CAAAtK,MAAKA,EAAE,SAAS,GAC3C;AAAA,EACX;AAAA,EAEO,QAAQxD,GAA4B;AACvC,UAAMwJ,IAAM+M,EAAW,IAAI,MAAMvW,CAAK,GAEhC4W,IAAM,KAAK,MAAA,EAAQ,OAAOpN,CAAG,EAAE,OAAA,GAC/BqN,IAAM7W,EAAM,MAAA,EAAQ,OAAOwJ,CAAG,EAAE,OAAA;AAEtC,WAAOoN,EAAI,WAAWC,EAAI,MAAA;AAAA,EAC9B;AAAA,EAEO,QAAiB;AACpB,WAAO,KAAK/I,GAAS,MAAM,CAAAtK,MAAKA,EAAE,OAAO;AAAA,EAC7C;AAAA,EAEO,SAAkB;AACrB,WAAO,KAAKsK,GAAS,MAAM,CAAAtK,MAAKA,EAAE,QAAQ;AAAA,EAC9C;AAAA,EAEO,YAAYjD,GAA4B;AAC3C,WAAAA,EAAO,QAAQ,CAAAP,MAAS;AACpB,WAAK8N,KAAW,KAAKA,GAAS,OAAO9N,EAAM,MAAA,EAAQ,OAAO;AAAA,IAC9D,CAAC,GAEM;AAAA,EACX;AAAA,EAEA,IAAI,YAAwB;AACxB,WAAO,IAAIuW,EAAW,GAAG,KAAKzI,GAAS,OAAO,CAAAtK,MAAKA,EAAE,MAAM,WAAA,CAAY,CAAC;AAAA,EAC5E;AAAA,EAEO,MAAY;AACf,gBAAKsK,KAAW,CAAC,IAAI2F,EAAO,KAAK,GAAG,CAAC,GAC9B;AAAA,EACX;AAAA,EAEO,WAAiB;AAEpB,UAAMxR,IAAQ,KAAK6L,GAAS,UAAU,CAAAtK,MAAKA,EAAE,YAAY,MAAM;AAE/D,WAAIvB,KAAS,IACT,KAAK6L,GAAS,OAAO7L,GAAO,CAAC,IAE7B,KAAK6L,GAAS,KAAK,IAAI2F,EAAO,MAAM,GAAG,CAAC,GAGrC;AAAA,EACX;AAAA,EAEO,IAAIzT,GAAgC;AACvC,gBAAK8N,KAAW,KAAKA,GAAS,IAAI,OAAKtK,EAAE,IAAIxD,CAAK,CAAC,GAC5C;AAAA,EACX;AAAA,EAEO,YAAwB;AAC3B,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC7C;AAAA,EAEO,SAAe;AAElB,UAAMiP,IAAU8H,EAAW,IAAI;AAG/B,gBAAKjJ,KAAW,OAAO,OAAOmB,CAAO,EAChC,IAAI,CAAAzL,MAAK;AACN,YAAMsQ,IAAOtQ,EAAE,CAAC,EAAE,SACZL,IAAQK,EAAE,OAAO,CAACoS,GAAKpS,MAAMoS,EAAI,IAAIpS,EAAE,KAAK,GAAG,IAAIhB,EAAS,GAAG,CAAC;AACtE,aAAO,IAAIiR,EAAOK,GAAM3Q,EAAM,QAAQ;AAAA,IAC1C,CAAC,EACA,OAAO,CAAAK,MAAK,CAACA,EAAE,MAAM,QAAQ,GAE3B;AAAA,EACX;AAAA,EAEO,KAAKxD,GAAqB;AAC7B,gBAAK8N,KAAW,KAAKA,GAAS,IAAI,OAAKtK,EAAE,KAAKxD,CAAK,CAAC,GAC7C;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,KAAKuL,GAAuB;AAC/B,gBAAKuC,GAAS,KAAK,CAAC/M,GAAGC,MAAM;AAEzB,YAAM0W,IAAS3W,EAAE,MAAM,OACjB4W,IAAS3W,EAAE,MAAM;AACvB,UAAI0W,IAASC,IAAS;AAClB,eAAO,CAACD;AAKZ,YAAME,IAAU7W,EAAE,QAAQ,OAAO,QAC3B8W,IAAU7W,EAAE,QAAQ,OAAO;AACjC,UAAI4W,MAAYC;AACZ,eAAOD,IAAUC;AAIrB,YAAMC,IAAU/W,EAAE,QAAQ,OAAOwK,CAAM,EAAE,OACnCwM,IAAU/W,EAAE,QAAQ,OAAOuK,CAAM,EAAE;AACzC,aAAIuM,MAAYC,IACLD,IAAUC,IAIjBL,MAAWC,IACJD,IAASC,IAGb5W,EAAE,SAAS,MAAMC,EAAE,OAAA,CAAQ,IAAI,KAAK;AAAA,IAC/C,CAAC,GAEM;AAAA,EACX;AAAA,EAEO,OAAa;AAChB,gBAAK8M,KAAW,KAAKA,GAAS,IAAI,CAAAtK,MAAKA,EAAE,MAAM,GACxC;AAAA,EACX;AAAA,EAEO,YAAYjD,GAA4B;AAC3C,WAAO,KAAK,IAAI,GAAGA,EAAO,IAAI,CAAAiD,MAAKA,EAAE,SAAA,CAAU,CAAC;AAAA,EACpD;AAAA,EAEO,eAA0C;AAE7C,UAAMuN,IAAQ,KAAK,UAAA,GACbiH,IAAYjH,EAAM,IAAI,CAAArQ,MAAKA,EAAE,KAAK,GAMlCuO,IAAmC,KAAK,UAAA,EAAY,QACrD,IAAI,CAAA7M,OACM,EAAC,QAAQ,IAAIqR,EAAOrR,CAAM,GAAG,GAAGA,EAAO,eAAa,EAC9D;AAGL,WAAA6M,EAAQ,QAAQ,CAAA5C,MAAQ;AAEpB,YAAM4L,IAAuC,IAAI,MAAM,IAAIlH,EAAM,SAAS,CAAC,EAAE,KAAK,EAAE;AAEpF,UAAI1M,IAAOgI,EAAK,MAAM,MAAA,GAClB6L,IAAO7L,EAAK,MAAM,MAAA;AAEtB,YAAM8L,IAAgBF,EAAY,IAAI,CAACG,GAAOnW,MAAU;AACpD,YAAIA,IAAQ,MAAM;AACd,iBAAOoC;AAIX,YAAI6T,MAAS,UAAaA,EAAK,UAAUF,GAAW/V,IAAQ,KAAK,CAAC;AAC9D,iBAAO;AAIX,cAAMoW,IAAWhM,EAAK,MAAM,MAAA;AAG5B,eAAAhI,IAAOgI,EAAK,MAAM,MAAA,GAClB6L,IAAO7L,EAAK,MAAM,MAAA,GACXgM;AAAA,MACX,CAAC;AAGD,MAAAhM,EAAK,QAAQ0E,GACb1E,EAAK,QAAQ8L;AAAA,IACjB,CAAC,GAiCM,EAAC,OA9B+BlJ,EAClC,IAAI,CAAC5C,MAAS,CAAC,GAAGA,EAAK,KAAK,CAAC,EAC7B,OAAgC,CAACtL,GAAGC,MAC7BD,EAAE,WAAW,IACNC,KAIXA,EAAE,QAAQ,CAAChB,GAAOiC,MAAU;AAGxB,cAAQjC,GAAA;AAAA,QACJ,KAAK;AACD,UAAAe,EAAEkB,CAAK,IAAI;AACX;AAAA,QACJ,KAAK;AACD,UAAAlB,EAAEkB,CAAK,IAAIlB,EAAEkB,CAAK,MAAM,MAAM,MAAM;AACpC;AAAA,QACJ,KAAK;AACD,UAAAlB,EAAEkB,CAAK,IAAI;AACX;AAAA,QACJ,KAAK;AACD,UAAAlB,EAAEkB,CAAK,IAAIlB,EAAEkB,CAAK,MAAM,MAAM,MAAMlB,EAAEkB,CAAK,MAAM,MAAM,MAAM;AAC7D;AAAA,MAAA;AAAA,IAEZ,CAAC,GAEMlB,IACR,CAAA,CAAE,GAEM,OAAAgQ,GAAO,SAAA9B,EAAA;AAAA,EAC1B;AAAA,EAEA,IAAW,YAAsB;AAC7B,WAAO,KAAKnB,GACP,OAAO,CAAC8H,GAAepS,MAAcoS,EAAI,OAAOpS,EAAE,SAAS,GAAG,CAAA,CAAE;AAAA,EACzE;AAAA,EAEO,OAAa;AAChB,gBAAKsK,KAAW,CAAC,IAAI2F,EAAO,KAAK,GAAG,CAAC,GAC9B;AAAA,EACX;AAAA,EAEA+C,KAAkC;AAC9B,QAAI/S,GACAC,IAAgB,CAAA;AAEpB,WAAI,KAAKgQ,OAAiBM,EAAe,QAErCvQ,IAAM,KAAK,UAAU,SACrBC,IAAM,KAAK,YAAY,WAEvBD,IAAM,KAAKqK,IAIXrK,EAAI,WAAW,MACfA,IAAM,CAAC,IAAIgQ,EAAO,GAAG,CAAC,IAEnB,EAAC,KAAAhQ,GAAK,KAAAC,EAAA;AAAA,EACjB;AAEJ;AAEA,SAASqT,EAAW/W,GAA6C;AAC7D,QAAMsY,IAAc,IAAI9V,EAAA,EAAW,IAAA,GAC7B+V,IAAgB,IAAI/V,EAAA,EAAW,IAAA,GAE/BgW,IAAKxY,EAAM,QACZ,OAAO,CAAC4V,GAA+BpS,MAAM;AAE1C,QAAIA,EAAE,QAAQ,OAAA,EAAS;AACnB,aAAIA,EAAE,MAAM,eACR8U,EAAY,SAAS9U,EAAE,QAAQ,OAAO,CAAC,EAAE,WAAW,IAEpD+U,EAAc,SAAS/U,EAAE,QAAQ,OAAO,CAAC,EAAE,WAAW,GAGnDoS;AAIX,UAAM9B,IAAOtQ,EAAE,QAAQ;AACvB,WAAI,OAAO,OAAOoS,GAAK9B,CAAI,IACvB8B,EAAI9B,CAAI,EAAE,KAAKtQ,CAAC,IAEhBoS,EAAI9B,CAAI,IAAI,CAACtQ,CAAC,GAGXoS;AAAA,EACX,GAAG,CAAA,CAAE,GAGH,EAAC,WAAAvH,GAAW,aAAAC,EAAA,IAAegK,EAAY,OAAOC,CAAa,EAAE,OAAA;AACnE,SAAGlK,MAAY,MACXmK,EAAGnK,EAAU,UAAU,IAAI,CAAC,IAAIoF,EAAOpF,GAAW,CAAC,CAAC,IAErDC,MAAc,MACbkK,EAAGlK,EAAY,UAAU,IAAI,CAAC,IAAImF,EAAOnF,GAAa,EAAE,CAAC,IAGtDkK;AACX;ACppBO,MAAMC,EACmB;AAAA,EAC5B9V,KAAyB;AAAA,EACzB+V,KAAsB;AAAA,EACtBC,KAAuB,CAAA;AAAA,EAEvB,YAAYC,GAAmBC,GAAmB;AAC9C,WAAID,MACAC,IAAWA,KAAYD,GACvB,KAAK,eAAeA,GAAUC,CAAQ,IAGnC;AAAA,EACX;AAAA,EAEO,MAAMtY,GAA6B;AACtC,WAAO,KAAK,WAAWA,CAAM;AAAA,EAGjC;AAAA,EAEO,QAAgB;AAEnB,UAAMuY,IAA4B,CAAA;AAElC,gBAAKH,GAAQ,QAAQ,CAAAjE,MAAO;AACxB,YAAMqE,IAAqB,CAAA;AAC3B,MAAArE,EAAI,QAAQ,CAAA1U,MAAS;AACjB,QAAA+Y,EAAQ,KAAK/Y,EAAM,OAAO;AAAA,MAC9B,CAAC,GAED8Y,EAAW,KAAKC,CAAO;AAAA,IAC3B,CAAC,GAEM,IAAIN,EAAA,EAAS,WAAWK,CAAU;AAAA,EAC7C;AAAA,EAEA,IAAI,MAAc;AACd,QAAI,KAAKH,GAAQ,WAAW;AACxB,aAAO;AAGX,UAAMK,IAAU,KAAKN,KAAsB,YAAY,WAGjDlS,IAAS;AAAA,MACX,WAAWwS,CAAO;AAAA,MAClB,GAAG,KAAK,KACH;AAAA,QAAI,CAAAtE,MAAO,MAAOA,EACd,IAAI,OAAK,KAAK/R,OAAY,QAAQO,EAAE,QAAQ,CAACA,EAAE,MAAM,QAAQ,KAAKP,EAAO,IAAEO,EAAE,GAAG,EAChF,KAAK,KAAK,IAAI;AAAA,MAAA;AAAA,MAEvB,SAAS8V,CAAO;AAAA,IAAA,EAClB,KAAK;AAAA,CAAI;AAEX,gBAAKrW,KAAU,MAER6D;AAAA,EACX;AAAA,EAEA,IAAI,UAAkB;AAClB,QAAI,KAAKmS,GAAQ,WAAW;AACxB,aAAO;AAGX,UAAMK,IAAU,KAAKN,KAAsB,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,GAAG,GAE3DlS,IAASwS,EAAQ,CAAC,IACpB,KAAK,IAAI,CAAAC,MAAO,KAAKtW,OAAY,QAAQsW,EAAI,QAAQ,CAACA,EAAI,MAAM,QAAQ,KAAKtW,EAAO,IAAGsW,EAAI,OAAO,EAC7F,IAAI,CAAAvE,MAAO,IAAIA,EAAI,KAAK,GAAG,CAAC,GAAG,EAC/B,KAAK,GAAG,IACbsE,EAAQ,CAAC;AAEb,gBAAKrW,KAAU,MAER6D;AAAA,EACX;AAAA,EAEO,IAAIxG,GAAqB;AAC5B,QAAI,CAAC,KAAK,WAAWA,CAAK;AACtB,YAAM,IAAI,MAAM,gDAAgD;AAEpE,gBAAK,QAAQ,CAACiZ,GAAK,GAAGtI,MAAM;AACxB,MAAAsI,EAAI,IAAIjZ,EAAM,OAAO,CAAC,EAAE2Q,CAAC,CAAC;AAAA,IAC9B,CAAC,GAEM;AAAA,EACX;AAAA,EAEO,IAAI7P,GAAW6P,GAAW;AAC7B,WAAI7P,IAAI,KAAKA,IAAI,KAAK,UAAU,QAAQ6P,IAAI,KAAKA,IAAI,KAAK,UAAU,OACzD,OAGJ,KAAKgI,GAAQ7X,CAAC,EAAE6P,CAAC;AAAA,EAC5B;AAAA,EAEA,IAAI,UAAgB;AAChB,gBAAK+H,KAAsB,IACpB;AAAA,EACX;AAAA,EAEO,WAAWlE,GAAyB;AACvC,UAAM,EAAC,MAAA0E,GAAM,MAAAzE,EAAA,IAAQ,KAAK,WACpB,EAAC,MAAM0E,GAAO,MAAMC,EAAA,IAAS5E,EAAO;AAE1C,WAAO0E,MAASC,KAAS1E,MAAS2E;AAAA,EACtC;AAAA,EAEO,gBAAyB;AAM5B,WALI,GAAC,KAAK,cAIU,KAAK,YAAA,EACT;EAKpB;AAAA,EAEO,gBAAgB5E,GAAyB;AAC5C,WAAO,KAAK,UAAU,SAASA,EAAO,UAAU;AAAA,EACpD;AAAA,EAEO,uBAAuBjJ,GAA0B;AACpD,WAAAA,MAAW,KAEJ,KAAK,QAAQ;AAAA,MAChB,IAAIkN,EAAO,KAAK,UAAU,IAAI,EAAE,IAAA,EAAM,SAAS,IAAI7K,EAAQrC,CAAM,CAAC;AAAA,IAAA,EACpE,YAAA;AAAA,EACN;AAAA,EAEO,SAASmJ,GAAa2E,GAAyB;AAElD,UAAMC,IAAW,KAAK,MAAA;AAEtB,WAAAA,EAAS,OAAO,OAAO5E,GAAK,CAAC,GAG7B4E,EAAS,OAAO,QAAQ,CAAA5E,MAAO;AAC3BA,MAAAA,EAAI,OAAO2E,GAAQ,CAAC;AAAA,IACxB,CAAC,GAEMC,EAAS,cAAc,SAAU,SAAQ5E,IAAM2E,EAAO;AAAA,EACjE;AAAA,EAEA,IAAI,OAAoB;AAEpB,UAAMlZ,IAAM,MAAM,KAAK,EAAC,QAAQ,KAAK,UAAU,KAAA,GAAO,MAC3C,MAAM,KAAK,EAAC,QAAQ,KAAK,UAAU,KAAA,GAAO,MAAM,IAAIyN,GAAS,CACvE;AAED,gBAAK,QAAQ,CAACqL,GAAK,GAAGtI,MAAM;AACxB,MAAAxQ,EAAIwQ,CAAC,EAAE,CAAC,IAAIsI;AAAA,IAChB,CAAC,GAEM9Y;AAAA,EACX;AAAA,EAEO,cAAuB;AAC1B,QAAI,CAAC,KAAK;AACN,YAAM,IAAI,MAAM,sBAAsB;AAK1C,UAAMoZ,IAAM,IAAI3L,EAAA;AAGhB,WAAI,KAAK+K,GAAQ,WAAW,IACjB,KAAKA,GAAQ,CAAC,EAAE,CAAC,EAAE,MAAA,KAI9B,KAAK,OAAO,CAAC,EAAE,QAAQ,CAACM,GAAKI,MAAW;AACpC,YAAMnU,IAAI,KAAK,SAAS,GAAGmU,CAAM;AACjC,MAAAE,EAAI,IAAIN,EAAI,MAAA,EAAQ,SAAS/T,CAAC,CAAC;AAAA,IACnC,CAAC,GAEMqU;AAAA,EACX;AAAA,EAEA,IAAI,YAA4C;AAC5C,WAAO;AAAA,MACH,MAAM,KAAKZ,GAAQ;AAAA,MACnB,MAAM,KAAKA,GAAQ,CAAC,EAAE;AAAA,IAAA;AAAA,EAE9B;AAAA,EAEO,OAAkB;AACrB,WAAO,KAAKA,GAAQ,KAAA;AAAA,EACxB;AAAA,EAEO,QAAQa,GAAqE;AAChF,SAAKb,GAAQ,QAAQ,CAACjE,GAAK,MAAM;AAC7B,MAAAA,EAAI,QAAQ,CAACuE,GAAKtI,MAAM;AACpB,QAAA6I,EAASP,GAAK,GAAGtI,CAAC;AAAA,MACtB,CAAC;AAAA,IACL,CAAC;AAAA,EACL;AAAA,EAEO,eAAeuI,GAAczE,GAAoB;AACpD,gBAAKkE,KAAU,MAAM,KAAK,EAAC,QAAQO,EAAA,GAAO,MAC/B,MAAM,KAAK,EAAC,QAAQzE,KAAO,MAAM,IAAI7G,GAAS,CACxD,GAEM;AAAA,EACX;AAAA,EAEO,WAAW5N,GAAqB;AAEnC,QAAIA,EAAM,WAAW,IAAI,KAAKA,EAAM,SAAS,IAAI;AAC7C,aAAO,KAAK,WAAWA,EAAM,UAAU,GAAGA,EAAM,SAAS,CAAC,CAAC;AAI/D,UAAMG,IAAMH,EAAM,MAAM,KAAK;AAE7B,gBAAK2Y,KAAUxY,EACV,IAAI,CAACuU,GAAKzS,MAEHA,MAAU,IACHyS,EAAI,UAAU,CAAC,EAAE,MAAM,GAAG,IAC1BzS,MAAU9B,EAAI,SAAS,IACvBuU,EAAI,UAAU,GAAGA,EAAI,SAAS,CAAC,EAAE,MAAM,GAAG,IAG9CA,EAAI,MAAM,GAAG,CACvB,EACA;AAAA,MAAI,OACD+E,EAAS,IAAI,OAAQ,IAAI7L,EAAQvB,CAAI,CAAC;AAAA,IAAA,GAGvC;AAAA,EACX;AAAA,EAEO,WAAW9L,GAA6B;AAC3C,SAAKoY,KAAU,CAAA;AAGf,UAAMtN,IAAI9K,EAAO,CAAC,EAAE;AACpB,QAAIA,EAAO,KAAK,CAAAmU,MAAOA,EAAI,WAAWrJ,CAAC;AACnC,YAAM,IAAI,MAAM,mCAAmC;AAGvD,WAAA9K,EAAO,QAAQ,CAAAmU,MAAO;AAClB,YAAMqE,IAAqB,CAAA;AAC3B,MAAArE,EAAI,QAAQ,CAAA1U,MAAS;AACjB,QAAA+Y,EAAQ,KAAK,IAAInL,EAAQ5N,CAAK,CAAC;AAAA,MACnC,CAAC,GAED,KAAK2Y,GAAQ,KAAKI,CAAO;AAAA,IAC7B,CAAC,GAEM;AAAA,EACX;AAAA,EAEO,eAAeW,GAAyB;AAE3C,SAAKf,KAAU,CAAA;AAGf,UAAMtN,IAAIqO,EAAQ,CAAC,EAAE;AACrB,QAAIA,EAAQ,KAAK,CAAArZ,MAAKA,EAAE,cAAcgL,CAAC;AACnC,YAAM,IAAI,MAAM,yCAAyC;AAG7D,gBAAK,eAAeqO,EAAQ,CAAC,EAAE,WAAWA,EAAQ,MAAM,GAExDA,EAAQ,QAAQ,CAACpE,GAAQ+D,MAAW;AAChC,MAAA/D,EAAO,MAAM,QAAQ,CAACtV,GAAO0U,MAAQ;AACjC,aAAKiE,GAAQjE,CAAG,EAAE2E,CAAM,IAAI,IAAIzL,EAAQ5N,CAAK;AAAA,MACjD,CAAC;AAAA,IACL,CAAC,GAEM;AAAA,EACX;AAAA,EAEO,UAAgB;AACnB,QAAI,CAAC,KAAK;AACN,YAAM,IAAI,MAAM,gCAAgC;AAGpD,UAAM2Z,IAAmB,IAAIlB,EAAA,EAAS,eAAe,KAAK,UAAU,MAAM,KAAK,UAAU,IAAI;AAC7F,IAAAkB,EAAiB,QAAQ,CAACC,GAAGlF,GAAK2E,MAAW;AACzC,MAAAM,EAAiB,SAASjF,GAAK2E,GAAQ,KAAK,SAAS3E,GAAK2E,CAAM,CAAC;AAAA,IACrE,CAAC,GAEDM,EAAiB,UAAA;AAGjB,UAAME,IAAc,KAAK,YAAA;AACzB,WAAAF,EAAiB,QAAQ,CAACV,GAAKnY,GAAG6P,MAAM,KAAK,SAAS7P,GAAG6P,GAAGsI,EAAI,OAAOY,CAAW,EAAE,OAAA,CAAQ,CAAC,GAEtF;AAAA,EACX;AAAA,EAEO,QAAQ7Z,GAAwB;AAEnC,QAAI,CAAC,KAAK,WAAWA,CAAK;AACtB,aAAO;AAGX,QAAI8Z,IAAiB;AACrB,gBAAK,QAAQ,CAACb,GAAKvE,GAAK2E,MAAW;AAC/B,MAAAS,MAAmBb,EAAI,QAAQjZ,EAAM,OAAO0U,CAAG,EAAE2E,CAAM,CAAC;AAAA,IAC5D,CAAC,GAEMS;AAAA,EACX;AAAA,EAEO,QAAiB;AACpB,aAASpF,IAAM,GAAGA,IAAM,KAAKiE,GAAQ,QAAQjE;AACzC,eAASqF,IAAM,GAAGA,IAAM,KAAKpB,GAAQjE,CAAG,EAAE,QAAQqF;AAI9C,YAHIA,MAAQrF,KAAO,CAAC,KAAKiE,GAAQjE,CAAG,EAAEqF,CAAG,EAAE,WAGvCA,MAAQrF,KAAO,CAAC,KAAKiE,GAAQjE,CAAG,EAAEqF,CAAG,EAAE;AACvC,iBAAO;AAKnB,WAAO;AAAA,EACX;AAAA,EAEO,WAAoB;AACvB,WAAO,KAAK,UAAU,SAAS,KAAK,UAAU;AAAA,EAClD;AAAA,EAEO,SAAkB;AACrB,WAAO,KAAK,OAAO,MAAM,CAAA1Z,MAAKA,EAAE,QAAQ;AAAA,EAC5C;AAAA,EAEO,IAAOmZ,GAAmE;AAC7E,UAAM,EAAC,MAAAN,GAAM,MAAAzE,EAAA,IAAQ,KAAK,WAEpBtU,IAAM,MAAM,KAAK,EAAC,QAAQ+Y,EAAA,GAAO,MAC5B,MAAM,KAAK,EAAC,QAAQzE,EAAA,GAAO,MAAA;AAAA,KAAoB,CACzD;AAED,gBAAKkE,GAAQ,QAAQ,CAACjE,GAAK5T,MAAM;AAC7B,MAAA4T,EAAI,QAAQ,CAACuE,GAAKtI,MAAM;AACpB,QAAAxQ,EAAIW,CAAC,EAAE6P,CAAC,IAAI6I,EAASP,GAAKnY,GAAG6P,CAAC;AAAA,MAClC,CAAC;AAAA,IACL,CAAC,GAEMxQ;AAAA,EACX;AAAA,EAEO,SAASH,GAA2C;AACvD,QAAIA,aAAiByY,GAAQ;AACzB,UAAI,CAAC,KAAK,gBAAgBzY,CAAK;AAC3B,cAAM,IAAI,MAAM,wDAAwD;AAI5E,YAAM4E,IAAS,IAAI6T,EAAO,KAAK,UAAU,MAAMzY,EAAM,UAAU,IAAI;AACnE,aAAA4E,EAAO,QAAQ,CAACgV,GAAG9Y,GAAG6P,MAAM;AAExB,cAAM+D,IAAM,KAAK,KAAK5T,CAAC,GACjBiZ,IAAM/Z,EAAM,KAAK2Q,CAAC,GAElBtQ,IAAI,IAAIuN,EAAA;AAEd,QAAA8G,EAAI,QAAQ,CAAC/O,GAAMvB,MAAM;AACrB,UAAA/D,EAAE,IAAIsF,EAAK,MAAA,EAAQ,SAASoU,EAAI3V,CAAC,CAAC,CAAC;AAAA,QACvC,CAAC,GAEDQ,EAAO,SAAS9D,GAAG6P,GAAGtQ,CAAC;AAAA,MAC3B,CAAC,GAED,KAAKsY,KAAU/T,EAAO,QACf;AAAA,IACX;AAGA,gBAAK,QAAQ,CAACqU,GAAK,GAAGtI,MAAM;AACxB,WAAK,SAAS,GAAGA,GAAGsI,EAAI,SAASjZ,CAAK,CAAC;AAAA,IAC3C,CAAC,GACM;AAAA,EACX;AAAA,EAEO,MAAY;AACf,gBAAK,QAAQ,CAACiZ,GAAKvE,GAAK2E,MAAW;AAC/B,MAAI3E,MAAQ2E,IACRJ,EAAI,IAAA,IAEJA,EAAI,KAAA;AAAA,IAEZ,CAAC,GACM;AAAA,EACX;AAAA,EAEO,WAAiB;AACpB,gBAAK,QAAQ,CAACA,MAAQ;AAClB,MAAAA,EAAI,SAAA;AAAA,IACR,CAAC,GACM;AAAA,EACX;AAAA,EAEA,IAAI,UAAgB;AAChB,gBAAKP,KAAsB,IACpB;AAAA,EACX;AAAA,EAEO,IAAI1Y,GAAqB;AAC5B,WAAO2N,GAAc,MAAgB3N,CAAK;AAAA,EAC9C;AAAA,EAEO,SAAiB;AACpB,UAAM,IAAI,MAAM,qBAAqB;AAAA,EACzC;AAAA,EAEA,IAAI,OAAoB;AACpB,WAAO,KAAK2Y;AAAA,EAChB;AAAA,EAEO,SAASjE,GAAa2E,GAAgBrZ,GAAoC;AAC7E,UAAM,EAAC,MAAAkZ,GAAM,MAAAzE,EAAA,IAAQ,KAAK;AAC1B,QAAKC,IAAM,KAAKA,KAAOwE,KACnBG,IAAS,KAAKA,KAAU5E;AACxB,YAAM,IAAI,MAAM,GAAGC,CAAG,IAAI2E,CAAM,qBAAqBH,CAAI,IAAIzE,CAAI,GAAG;AAGxE,gBAAKkE,GAAQjE,CAAG,EAAE2E,CAAM,IAAI,IAAIzL,EAAQ5N,CAAK,GACtC;AAAA,EACX;AAAA,EAEO,SAASA,GAAqB;AACjC,QAAI,CAAC,KAAK,WAAWA,CAAK;AACtB,YAAM,IAAI,MAAM,qDAAqD;AAGzE,gBAAK,QAAQ,CAACiZ,GAAK,GAAGtI,MAAM;AACxB,MAAAsI,EAAI,SAASjZ,EAAM,OAAO,CAAC,EAAE2Q,CAAC,CAAC;AAAA,IACnC,CAAC,GAEM;AAAA,EACX;AAAA,EAEA,QAAQ3Q,GAAqB;AACzB,gBAAK2C,KAAU3C,GACR;AAAA,EACX;AAAA,EAEO,YAAkB;AAGrB,WAFa,KAAK,MAAA,EAEb,QAAQ,CAACiZ,GAAK,GAAGtI,MAAM;AACxB,WAAK,SAASA,GAAG,GAAGsI,EAAI,OAAO;AAAA,IACnC,CAAC,GAEM;AAAA,EACX;AAAA,EAEA,IAAI,SAAsB;AACtB,WAAO,KAAKN;AAAA,EAChB;AAAA,EAEO,OAAa;AAChB,gBAAK,QAAQ,CAAAM,MAAOA,EAAI,KAAA,CAAM,GACvB;AAAA,EACX;AACJ;ACpdO,SAASe,GAAiBC,GAAOC,GAAgB;AACpD,SAAOD,EAAG,cAAcC,EAAG,aACvBD,EAAG,MAAM;AAAA,IACL,CAACja,GAAOiC,MACGiY,EAAG,MAAMjY,CAAK,EAAE,QAAQjC,CAAK;AAAA,EACxC;AACZ;AAEO,SAASma,GAAoBF,GAAOC,GAAgB;AACvD,MAAID,EAAG,cAAcC,EAAG;AAAa,WAAO;AAG5C,QAAM9V,IAAI8V,EAAG,MAAM,CAAC,EAAE,QAAQD,EAAG,MAAM,CAAC,EAAE;AAC1C,SAAOA,EAAG,MAAM;AAAA,IACZ,CAACja,GAAOiC,MACGiY,EAAG,MAAMjY,CAAK,EAAE,UAAUjC,EAAM,QAAQoE;AAAA,EACnD;AACR;AAGO,SAASgW,GAAWH,GAAOC,GAAiB;AAC/C,SAAID,EAAG,cAAcC,EAAG,YAAoB,IAAI1X,EAAA,EAAW,QAAA,IAKpDyX,EAAG,MAAM;AAAA,IACZ,CAACrE,GAAK5V,GAAOiC,MACF2T,EAAI,IAAI5V,EAAM,MAAA,EAAQ,SAASka,EAAG,MAAMjY,CAAK,CAAC,CAAC;AAAA,IACvD,IAAIO,EAAS,CAAC;AAAA,EAAA;AACzB;AAEO,SAAS6X,MAA0B9Z,GAAuB;AAG7D,MAAIA,EAAO,KAAK,CAACP,MAAUA,EAAM,cAAcO,EAAO,CAAC,EAAE,SAAS;AAC9D,UAAM,IAAI,MAAM,0CAA0C;AAI9D,MAAIA,EAAO,CAAC,EAAE,cAAcA,EAAO;AAC/B,UAAM,IAAI,MAAM,gCAAgCA,EAAO,CAAC,EAAE,SAAS,0CAA0CA,EAAO,MAAM,SAAS;AAIvI,SAAIA,EAAO,CAAC,EAAE,cAAc,IACjBA,EAAO,CAAC,EAAE,MAAM,CAAC,EAAE,QAAQ,SAASA,EAAO,CAAC,EAAE,MAAM,CAAC,CAAC,EACxD,SAASA,EAAO,CAAC,EAAE,MAAM,CAAC,EAAE,MAAA,EAAQ,SAASA,EAAO,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,IAIlEA,EAAO,CAAC,EAAE,MAAM,CAAC,EAAE,QACrB;AAAA,IACGA,EAAO,CAAC,EAAE,MAAM,CAAC,EAAE,MAAA,EAAQ,SAASA,EAAO,CAAC,EAAE,MAAM,CAAC,CAAC,EACjD,SAASA,EAAO,CAAC,EAAE,MAAM,CAAC,EAAE,MAAA,EAAQ,SAASA,EAAO,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC;AAAA,EAAA,EAExE;AAAA,IAASA,EAAO,CAAC,EAAE,MAAM,CAAC,EAAE,QACxB;AAAA,MACGA,EAAO,CAAC,EAAE,MAAM,CAAC,EAAE,MAAA,EAAQ,SAASA,EAAO,CAAC,EAAE,MAAM,CAAC,CAAC,EACjD,SAASA,EAAO,CAAC,EAAE,MAAM,CAAC,EAAE,MAAA,EAAQ,SAASA,EAAO,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC;AAAA,IAAA;AAAA,EACzE,EAEH,IAAIA,EAAO,CAAC,EAAE,MAAM,CAAC,EAAE,QACnB,SAASA,EAAO,CAAC,EAAE,MAAM,CAAC,EAAE,MAAA,EAAQ,SAASA,EAAO,CAAC,EAAE,MAAM,CAAC,CAAC,EAC3D,SAASA,EAAO,CAAC,EAAE,MAAM,CAAC,EAAE,QAAQ,SAASA,EAAO,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AACnF;AC7DO,MAAe+Z,EAAO;AAAA,EACzBC,KAAqB,CAAA;AAAA,EAErB,eAAeha,GAAgC;AAC3C,SAAKga,KAASha,EAAO,IAAI,OAAG,IAAIiC,EAAS9B,CAAC,CAAC;AAAA,EAC/C;AAAA,EAIO,OAAmB;AACtB,WAAO,KAAK6Z,GAAO,IAAI,CAAA7Z,MAAKA,EAAE,OAAO;AAAA,EACzC;AAAA,EAMA,IAAI,QAAoB;AACpB,WAAO,KAAK6Z;AAAA,EAChB;AAAA,EAEA,IAAI,MAAMva,GAAmB;AACzB,SAAKua,KAASva;AAAA,EAClB;AAAA,EAEA,IAAI,YAAoB;AACpB,WAAO,KAAK,MAAM;AAAA,EACtB;AAAA,EAIO,WAAWA,GAAqB;AAEnC,IAAIA,EAAM,WAAW,GAAG,MACpBA,IAAQA,EAAM,UAAU,CAAC,IAIzBA,EAAM,SAAS,GAAG,MAClBA,IAAQA,EAAM,UAAU,GAAGA,EAAM,SAAS,CAAC;AAI/C,UAAMwa,IAAaxa,EAAM,MAAM,SAAS,EACnC,OAAO,CAACK,MAAMA,EAAE,KAAA,MAAW,EAAE;AAGlC,WAAIma,EAAW,SAAS,IACb,QAIX,KAAKD,KAASC,EAAW,IAAI,OAAK,IAAIhY,EAAS9B,CAAC,CAAC,GAC1C;AAAA,EACX;AAAA,EAEA,aAAaV,IAAQ,GAAS;AAC1B,QAAIA,IAAQ;AACR,YAAM,IAAI,MAAM,8BAA8B;AAGlD,QAAIA,IAAQ,KAAK;AACb,WAAKua,KAAS,KAAKA,GAAO,MAAM,GAAGva,CAAK;AAAA,aACjCA,IAAQ,KAAK;AACpB,eAASc,IAAI,KAAK,WAAWA,IAAId,GAAOc;AACpC,aAAKyZ,GAAO,KAAK,IAAI/X,EAAS,CAAC,CAAC;AAIxC,WAAO;AAAA,EACX;AAAA,EAEA,IAAI,IAAc;AACd,WAAO,KAAK+X,GAAO,CAAC;AAAA,EACxB;AAAA,EAEA,IAAI,EAAEva,GAAmC;AACrC,SAAKua,GAAO,CAAC,IAAI,IAAI/X,EAASxC,CAAK;AAAA,EACvC;AAAA,EAEA,IAAI,IAAc;AACd,WAAO,KAAKua,GAAO,CAAC;AAAA,EACxB;AAAA,EAEA,IAAI,EAAEva,GAAmC;AACrC,SAAKua,GAAO,CAAC,IAAI,IAAI/X,EAASxC,CAAK;AAAA,EACvC;AAAA,EAEA,IAAI,IAAc;AACd,QAAI,KAAK,YAAY;AACjB,YAAM,IAAI,MAAM,kBAAkB;AAEtC,WAAO,KAAKua,GAAO,CAAC;AAAA,EACxB;AAAA,EAEA,IAAI,EAAEva,GAAmC;AACrC,QAAI,KAAK,YAAY;AACjB,YAAM,IAAI,MAAM,kBAAkB;AAEtC,SAAKua,GAAO,CAAC,IAAI,IAAI/X,EAASxC,CAAK;AAAA,EACvC;AAAA,EAEA,OAAO,OACH,KAAKua,GAAO,QAAQ,CAAA7Z,MAAKA,EAAE,MAAM,GAC1B;AAGf;AC/GO,MAAM+Z,EAAuD;AAAA,EAChEC;AAAA,EACAC;AAAA,EACA7V;AAAA,EACAhC,KAAY;AAAA,EAEZ,YAAY9C,GAAqC;AAC7C,gBAAK2a,KAAS,GACd,KAAKD,KAAU,IAAIlY,EAAA,EAAW,KAAA,GAC9B,KAAKsC,KAAW,IAAItC,EAAA,EAAW,KAAA,GAE3BxC,KACA,KAAK,MAAMA,CAAK,GAIb;AAAA,EACX;AAAA,EAEA,MAAMA,GAA0C;AAO5C,QAAIA,aAAiBya;AACjB,kBAAK,QAAQza,EAAM,OACnB,KAAK,UAAUA,EAAM,QAAQ,MAAA,GAC7B,KAAK,SAASA,EAAM,OAAO,MAAA,GAEpB;AAGX,QAAIA,aAAiBwC;AACjB,kBAAK,QAAQ,GACb,KAAK,SAASxC,EAAM,MAAA,GACpB,KAAK,QAAQ,IAAA,GAEN;AAGX,QAAI,OAAOA,KAAU,UAAU;AAC3B,UAAIA,EAAM,SAAS,MAAM;AACrB,eAAO,KAAK4a,GAAY5a,CAAK;AAGjC,UAAIA,EAAM,SAAS,MAAM;AACrB,eAAO,KAAK6a,GAAY7a,CAAK;AAAA,IAErC;AAEA,gBAAK,QAAQ,GACb,KAAK,SAAS,IAAIwC,EAASxC,CAAK,GAChC,KAAK,QAAQ,IAAA,GAEN;AAAA,EACX;AAAA,EAEA,QAAc;AACV,WAAO,IAAIya,IAAO,KAAK,KAAK,OAAO,KAAK,SAAS,KAAK,MAAM;AAAA,EAChE;AAAA,EAEA,IAAI,MAAc;AAOd,UAAMpX,IAAO,KAAKP,MAAa,KAAK,OAAO,WAAA,IAAe,MAAM;AAGhE,QAAI,KAAKgC,GAAS,OAAA,EAAU,QAAO,GAAGzB,CAAI,GAAG,KAAKqX,GAAQ,GAAG;AAG7D,QAAG,KAAK,UAAQ,EAAG,QAAO,GAAGrX,CAAI,GAAG,KAAK,OAAO,QAAQ,SAAS,KAAK,OAAO,EAAE,GAAG;AAGlF,UAAMyX,IAAM,KAAK,UAAU,IACjB,WAAW,KAAKhW,GAAS,GAAG,OAC5B,WAAW,KAAK,KAAK,OAAO,KAAKA,GAAS,GAAG;AAEvD,WAAG,KAAK4V,GAAQ,WACL,KAAK5X,KACN,GAAG,KAAK4X,GAAQ,MAAA,IAAQrX,IAAK,GAAG,IAAIyX,CAAG,KACvC,GAAG,KAAKJ,GAAQ,MAAA,IAAQ,KAAG,GAAG,GAAGI,CAAG,KAGvC,GAAGzX,CAAI,GAAG,KAAKqX,GAAQ,GAAG,IAAII,CAAG;AAAA,EAC5C;AAAA,EAEA,IAAI,UAAkB;AAClB,UAAMzX,IAAO,KAAKP,MAAa,KAAK,OAAO,WAAA,IAAe,MAAM;AAGhE,QAAI,KAAKgC,GAAS,OAAA,EAAU,QAAO,GAAGzB,CAAI,GAAG,KAAKqX,GAAQ,OAAO;AAGjE,QAAG,KAAK,UAAQ,EAAG,QAAO,GAAGrX,CAAI,GAAG,KAAK,OAAO,QAAQ,SAAS,KAAK,OAAO,EAAE,OAAO;AAGtF,UAAMyX,IAAM,KAAK,UAAU,IACrB,QAAQ,KAAKhW,GAAS,GAAG,MACzB,QAAQ,KAAK,KAAK,KAAK,KAAKA,GAAS,OAAO;AAElD,WAAG,KAAK4V,GAAQ,OAAA,IAAiB,GAAG,KAAKA,GAAQ,MAAA,IAAQrX,IAAK,GAAG,GAAGyX,CAAG,KAEhE,GAAGzX,CAAI,GAAG,KAAKqX,GAAQ,OAAO,GAAGI,CAAG;AAAA,EAC/C;AAAA,EAEA,IAAI9a,GAA+B;AAC/B,UAAM+a,IAAK,IAAIN,EAAKza,CAAK;AAEzB,QACI,KAAK,UAAU+a,EAAG,SAClB,CAAC,KAAK,QAAQ,QAAQA,EAAG,OAAO;AAEhC,YAAM,IAAI,MAAM,sDAAsD;AAG1E,gBAAK,OAAO,IAAIA,EAAG,MAAM,GAElB;AAAA,EACX;AAAA,EAEA,OAAO/a,GAA+B;AAClC,WAAO,KAAK,SAAS,IAAIya,EAAKza,CAAK,EAAE,SAAS;AAAA,EAClD;AAAA,EAEA,IAAI,SAAmB;AACnB,WAAO,KAAK0a;AAAA,EAChB;AAAA,EAEA,IAAI,OAAO1a,GAAiB;AACxB,SAAK0a,KAAU1a;AAAA,EACnB;AAAA,EAEA,KAAKiC,GAAeE,GAA+BC,GAAqC;AAEpF,gBAAK,QAAQH,GAGb,KAAK,UAAU,IAAIO,EAASL,CAAO,GAGnC,KAAK,SAASC,IAAS,IAAII,EAASJ,CAAM,IAAI,IAAII,EAAA,EAAW,IAAA,GAEtD;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,QAAc;AACV,gBAAK,QAAQ,SAAS,KAAK,OAAO,IAAI,KAAK,KAAK,CAAC,GACjD,KAAK,OAAO,IAAA,GAEL;AAAA,EACX;AAAA,EAEA,IAAI,QAAgB;AAChB,WAAO,KAAKmY;AAAA,EAChB;AAAA,EAEA,IAAI,MAAM3a,GAAe;AACrB,QAAI,CAAC,OAAO,cAAcA,CAAK,KAAKA,KAAS;AACzC,YAAM,IAAI,MAAM,4CAA4C;AAEhE,SAAK2a,KAAS3a;AAAA,EAClB;AAAA,EAEA,IAAI,aAAuB;AACvB,WAAO,IAAIwC,EAAS,KAAK,KAAK,EAAE,QAAA;AAAA,EACpC;AAAA,EAEA,UAAgB;AACZ,gBAAK,OAAO,QAAA,GACZ,KAAK,QAAQ,QAAA,GACN;AAAA,EACX;AAAA,EAEA,QAAQ0V,GAAqB;AACzB,WAAO,KAAK,UAAUA,EAAK;AAAA,EAC/B;AAAA,EAEA,QAAiB;AACb,WAAO,KAAK,OAAO,MAAA,KAAW,KAAK,QAAQ,MAAA;AAAA,EAC/C;AAAA,EAEA,SAAkB;AACd,WAAO,KAAK,OAAO,OAAA,KAAY,KAAK,QAAQ,OAAA;AAAA,EAChD;AAAA,EAEA,SAASlY,GAA+B;AACpC,UAAM+a,IAAK,IAAIN,EAAKza,CAAK;AAIzB,QAFA,KAAK,OAAO,SAAS+a,EAAG,MAAM,GAE1B,KAAK,UAAUA,EAAG;AAClB,kBAAK,QAAQ,SAASA,EAAG,OAAO,GACzB;AAGX,QAAI,KAAK,QAAQ,QAAQA,EAAG,OAAO,GAAG;AAClC,YAAM3X,IAAI,KAAK,WAAW,IAAI2X,EAAG,UAAU,EAAE,OAAA;AAC7C,kBAAK,QAAQ3X,EAAE,aACf,KAAK,UAAU,KAAK,QAAQ,IAAIA,EAAE,SAAS,GACpC;AAAA,IACX;AAEA,UAAM,IAAI,MAAM,0DAA0D;AAAA,EAC9E;AAAA,EAEA,MAAY;AACR,gBAAK,QAAQ,IAAA,GACb,KAAK,OAAO,IAAA,GAEL;AAAA,EACX;AAAA,EAEA,WAAiB;AACb,gBAAK,OAAO,SAAA,GACL;AAAA,EACX;AAAA,EAEA,IAAIpD,GAAqB;AACrB,SAAK,OAAO,IAAIA,CAAK;AAErB,UAAMQ,IAAI8B,EAAQ,IAAI,KAAK,OAAOtC,CAAK;AACvC,gBAAK,QAAQ,KAAK,QAAQQ,GAC1B,KAAK,QAAQ,IAAIR,IAAQQ,CAAC,GAEnB;AAAA,EACX;AAAA,EAEA,IAAI,UAAoB;AACpB,WAAO,KAAKsE;AAAA,EAChB;AAAA,EAEA,IAAI,QAAQ9E,GAAiB;AACzB,SAAK8E,KAAW9E;AAAA,EACpB;AAAA,EAEA,SAAe;AAKX,QAAI,KAAK,QAAQ,cAAc;AAC3B,YAAM0D,IAAM,KAAK,QAAQ;AACzB,WAAK,QAAQ,cAAc,GAC3B,KAAK,QAAQ,aAAaA,GAE1B,KAAK,OAAO,OAAOA,CAAG;AAAA,IAC1B;AAGA,UAAMsX,IAAW1Y,EAAQ,cAAc,KAAK,QAAQ,OAAO,KAAK,KAAK;AAErE,gBAAK,OAAO,SAAS,KAAK,IAAI0Y,GAAU,IAAI,KAAK,KAAK,CAAC,GACvD,KAAK,QAAQ,OAAOA,CAAQ,GAErB;AAAA,EACX;AAAA,EAEA,KAAKhb,GAAqB;AACtB,gBAAK,MAAA,GACL,KAAK,QAAQ,KAAK,QAAQA,GACnB;AAAA,EACX;AAAA,EAEA,OAAa;AACT,WAAO,KAAK,KAAK,CAAC;AAAA,EACtB;AAAA,EAEA,SAASA,GAA+B;AACpC,UAAM+a,IAAK,IAAIN,EAAKza,CAAK;AAEzB,WAAO,KAAK,IAAI+a,EAAG,SAAA,CAAU;AAAA,EACjC;AAAA,EAEA,IAAW,QAAgB;AACvB,WAAOzY,EAAQ,iBAAiB,KAAK,OAAO,QAAQ,KAAK,IAAI,KAAK,QAAQ,OAAO,IAAI,KAAK,KAAK,CAAC;AAAA,EACpG;AAAA,EAEA,SAAStC,IAAQ,IAAY;AACzB,gBAAK8C,KAAY9C,GACV;AAAA,EACX;AAAA,EAEA,OAAa;AACT,gBAAK,QAAQ,KAAA,GACb,KAAK,OAAO,KAAA,GACL;AAAA,EACX;AAAA,EAEA6a,GAAY7a,GAAqB;AAE7B,UAAM,CAACoC,GAAQ6Y,CAAa,IAAIjb,EAAM,MAAM,MAAM,GAC5C,CAACiC,GAAOE,CAAO,IAAI8Y,EAAc,MAAM,GAAG;AAEhD,gBAAK,QAAQ,CAAC5N,EAAiBpL,CAAK,GAEpC,KAAK,UAAU,IAAIO,EAAS6K,EAAiBlL,CAAO,CAAC,GAErD,KAAK,SAASC,MAAW,KAAK,IAAII,EAAA,EAAW,IAAA,IAAQ,IAAIA,EAASJ,CAAM,GAEjE;AAAA,EACX;AAAA,EAEAwY,GAAY5a,GAAqB;AAE7B,UAAM,CAACoC,GAAQD,CAAO,IAAInC,EAAM,MAAM,MAAM;AAE5C,gBAAK,QAAQ,GAEb,KAAK,UAAU,IAAIwC,EAAS6K,EAAiBlL,CAAO,CAAC,GAErD,KAAK,SAASC,MAAW,KAAK,IAAII,EAAA,EAAW,IAAA,IAAQ,IAAIA,EAASJ,CAAM,GAEjE;AAAA,EACX;AACJ;AC5TO,MAAM8Y,UAAcZ,EAAO;AAAA,EAC9B,eAAe/Z,GAAmD;AAC9D,UAAA,GAGIA,EAAO,SAAS,KAChB,KAAK,MAAM,GAAGA,CAAM;AAAA,EAE5B;AAAA,EAEO,SAASA,GAAyD;AACrE,QAAIA,EAAO,WAAW,GAAG;AACrB,UAAIA,EAAO,CAAC,aAAa+Z;AACrB,oBAAK,QAAQ/Z,EAAO,CAAC,EAAE,KAAA,GAChB;AAGX,UAAI,OAAOA,EAAO,CAAC,KAAM;AACrB,oBAAK,WAAWA,EAAO,CAAC,CAAC,GAClB;AAAA,IAEf;AAGA,QAAIA,EAAO,SAAS,GAAG;AACnB,UAAIA,EAAO,KAAK,CAAAG,MAAKA,aAAawa,CAAK;AACnC,cAAM,IAAI,MAAM,qEAAqE;AAGzF,YAAMC,IAAkB5a,EAAO,IAAI,OAAK,IAAIiC,EAAS9B,CAAyB,CAAC;AAE/E,UAAIya,EAAI,KAAK,CAAAza,MAAKA,EAAE,MAAA,CAAO;AACvB,cAAM,IAAI,MAAM,uDAAuD;AAG3E,WAAK,QAAQya;AAAA,IACjB;AAEA,WAAO;AAAA,EACX;AAAA,EAEO,QAAe;AAClB,WAAO,IAAID,EAAM,GAAG,KAAK,MAAM;AAAA,EACnC;AAAA,EAEA,IAAI,MAAc;AACd,WAAO,UAAU,KAAK,MAAM,IAAI,CAAAxa,MAAKA,EAAE,GAAG,EAAE,KAAK,GAAG,CAAC;AAAA,EACzD;AAAA,EAEA,IAAI,UAAkB;AAClB,WAAO,IAAI,KAAK,MAAM,IAAI,CAAAA,MAAKA,EAAE,OAAO,EAAE,KAAK,GAAG,CAAC;AAAA,EACvD;AAAA,EAEA,WAAWiG,GAAgB;AACvB,QAAI,KAAK,cAAcA,EAAE;AACrB,YAAM,IAAI,MAAM,+CAA+C;AAMnE,UAAMyU,IAHK,KAAK,MACX,IAAI,CAAC1a,GAAGuB,MAAU0E,EAAE,MAAM1E,CAAK,EAAE,MAAA,EAAQ,SAASvB,CAAC,CAAC,EAGpD;AAAA,MACG,CAACkV,GAAKlV,MACFkV,EAAI,IAAIlV,EAAE,MAAA,EAAQ,IAAI,CAAC,CAAC;AAAA,MAAG,IAAI8B,EAAS,CAAC;AAAA,IAAA;AAGrD,WAAO,IAAIiY,EAAA,EAAO,KAAK,GAAGW,CAAS,EAAE,OAAA;AAAA,EACzC;AAAA,EAEA,SAASC,GAAWC,GAAiB;AACjC,QAAID,EAAG,cAAcC,EAAG;AACpB,YAAM,IAAI,MAAM,oCAAoC;AAGxD,gBAAK,QAAQ,CAAA,GACbD,EAAG,MAAM,QAAQ,CAAC3a,GAAGuB,MAAU;AAC3B,WAAK,MAAM,KAAKvB,EAAE,MAAA,EAAQ,IAAI4a,EAAG,MAAMrZ,CAAK,CAAC,EAAE,OAAO,CAAC,CAAC;AAAA,IAC5D,CAAC,GAEM;AAAA,EACX;AAGJ;ACrFO,MAAMsZ,UAAejB,EAAwC;AAAA,EAChE,eAAe/Z,GAAqD;AAChE,iBAAA,GAEIA,EAAO,SAAS,KAChB,KAAK,MAAM,GAAGA,CAAM,GAGjB;AAAA,EACX;AAAA;AAAA;AAAA,EAKO,SAASA,GAA2D;AACvE,QAAIA,EAAO,WAAW;AAClB,YAAM,IAAI,MAAM,eAAe;AAGnC,QAAIA,EAAO,WAAW,GAAG;AACrB,UAAIA,EAAO,CAAC,aAAa+Z;AACrB,oBAAK,QAAQ/Z,EAAO,CAAC,EAAE,KAAA,GAChB;AAGX,UAAI,OAAOA,EAAO,CAAC,KAAM;AACrB,eAAO,KAAK,WAAWA,EAAO,CAAC,CAAC;AAGpC,YAAM,IAAI,MAAM,eAAe;AAAA,IACnC;AAGA,QAAIA,EAAO,WAAW,GAAG;AACrB,YAAM,CAACwK,GAAGpE,CAAC,IAAIpG;AAGf,UAAIwK,aAAauP,KAAU3T,aAAa2T,GAAQ;AAC5C,YAAIvP,EAAE,cAAcpE,EAAE;AAClB,gBAAM,IAAI,MAAM,sCAAsC;AAG1D,oBAAK,QAAQA,EAAE,MAAM,IAAI,CAACjG,GAAGuB,MAAUvB,EAAE,MAAA,EAAQ,SAASqK,EAAE,MAAM9I,CAAK,CAAC,CAAC,GAClE;AAAA,MACX;AAAA,IACJ;AAGA,gBAAK,QAAQ1B,EAAO,IAAI,OAAK,IAAIiC,EAAS9B,CAAyB,CAAC,GAC7D;AAAA,EACX;AAAA,EAEO,QAAgB;AACnB,WAAO,IAAI6a,EAAO,GAAG,KAAK,MAAM;AAAA,EACpC;AAAA,EAEA,IAAI,MAAc;AACd,WAAO,oBAAoB,KAAK,MAAM,IAAI,CAAA7a,MAAKA,EAAE,GAAG,EAAE,KAAK,QAAQ,CAAC;AAAA,EACxE;AAAA,EAEA,IAAI,UAAkB;AAClB,WAAO,KAAK,KAAK,MAAM,IAAI,CAAAA,MAAKA,EAAE,OAAO,EAAE,KAAK,GAAG,CAAC;AAAA,EACxD;AAAA,EAEA,OAAO,aAAaH,GAA0B;AAC1C,WAAO,KAAKA,EAAO,KAAK,GAAG,CAAC;AAAA,EAChC;AAAA,EAEA,OAAO,SAASA,GAA0B;AACtC,WAAO,oBAAoBA,EAAO,KAAK,QAAQ,CAAC;AAAA,EACpD;AAAA,EAEA,MAAM,CAAC8E,OACH,KAAK,MAAM,QAAQ,CAAC3E,GAAGuB,MAAUvB,EAAE,IAAI2E,EAAE,MAAMpD,CAAK,CAAC,CAAC,GAC/C;AAAA,EAGX,QAAQ,CAACoD,GAAWmW,GAAiBC,MAA6B;AAE9D,QAAIC,IAAS,KAAK,IAAIrW,CAAC,EAAE;AACzB,WAAImW,MACAE,IAAS,KAAK,IAAIA,CAAM,KAGXD,IAAS,IAAI,MAAM,KAAK,MAEvB,KAAK,KAAKC,KAAU,KAAK,OAAOrW,EAAE,KAAK;AAAA,EAC7D;AAAA,EAEA,MAAMrF,GAAuB;AACzB,QAAI,KAAK,cAAc,KAAKA,EAAM,cAAc;AAC5C,YAAM,IAAI,MAAM,4CAA4C;AAGhE,WAAO,IAAIub;AAAA,MACP,KAAK,EAAE,MAAA,EAAQ,SAASvb,EAAM,CAAC,EAAE,SAAS,KAAK,EAAE,MAAA,EAAQ,SAASA,EAAM,CAAC,CAAC;AAAA,MAC1E,KAAK,EAAE,MAAA,EAAQ,SAASA,EAAM,CAAC,EAAE,SAAS,KAAK,EAAE,MAAA,EAAQ,SAASA,EAAM,CAAC,CAAC;AAAA,MAC1E,KAAK,EAAE,MAAA,EAAQ,SAASA,EAAM,CAAC,EAAE,SAAS,KAAK,EAAE,MAAA,EAAQ,SAASA,EAAM,CAAC,CAAC;AAAA,IAAA;AAAA,EAElF;AAAA;AAAA;AAAA,EAKA,iBAAiB,CAACoE,MACP,KAAK,iBAAiB,IAAI5B,EAAS4B,CAAC,EAAE,SAAS;AAAA,EAG1D,MAAM,CAACiB,MACI+U,GAAW,MAAM/U,CAAC;AAAA,EAGpB,WAAWrF,GAAqB;AACrC,WAAIA,EAAM,WAAW,IAAI,KAAKA,EAAM,SAAS,IAAI,IACtC,MAAM,WAAWA,EAAM,MAAM,GAAG,EAAE,CAAC,IAGvC,MAAM,WAAWA,CAAK;AAAA,EACjC;AAAA,EAEA,eAAe,CAACK,MACL8Z,GAAoB,MAAM9Z,CAAC;AAAA,EAGtC,UAAU,CAACA,MACA2Z,GAAiB,MAAM3Z,CAAC;AAAA,EAGnC,aAAa,CAACA,MACH,KAAK,IAAIA,CAAC,EAAE,OAAA;AAAA;AAAA,EAIvB,IAAI,SAAkB;AAClB,WAAO,KAAK,MAAM,MAAM,CAAAK,MAAKA,EAAE,QAAQ;AAAA,EAC3C;AAAA,EAEA,QAAiB;AACb,WAAO,KAAK,MAAM,MAAM,CAACA,GAAGuB,MAAUA,MAAU,IAAIvB,EAAE,MAAA,IAAUA,EAAE,QAAQ;AAAA,EAC9E;AAAA,EAEA,SAAkB;AACd,WAAO,KAAK,MAAM,MAAM,CAAAA,MAAKA,EAAE,QAAQ;AAAA,EAC3C;AAAA,EAEA,mBAAmB,CAAC0D,MAAkC;AAClD,UAAMsX,IAAS,IAAIlZ,EAAS4B,CAAC;AAC7B,gBAAK,MAAM,QAAQ,CAAA1D,MAAKA,EAAE,SAASgb,CAAM,CAAC,GACnC;AAAA,EACX;AAAA,EAEA,IAAI,OAAe;AACf,WAAO,KAAK,KAAK,KAAK,WAAW,KAAK;AAAA,EAC1C;AAAA,EAEA,IAAI,aAAuB;AAEvB,WAAO,KAAK,MAAM,OAAO,CAAC9F,GAAKlV,MAAMkV,EAAI,IAAIlV,EAAE,MAAA,EAAQ,IAAI,CAAC,CAAC,GAAG,IAAI8B,EAAS,CAAC,CAAC;AAAA,EACnF;AAAA,EAEA,SAAS,MAAY;AACjB,QAAI,KAAK,aAAa;AAClB,YAAM,IAAI,MAAM,4CAA4C;AAGhE,UAAM9B,IAAI,KAAK,EAAE,MAAA,EAAQ,SAAA,GACnBib,IAAI,KAAK,EAAE,MAAA;AAEjB,gBAAK,MAAM,CAAC,IAAIA,GAChB,KAAK,MAAM,CAAC,IAAIjb,GACT;AAAA,EACX;AAAA,EAEA,MAAM,OACF,KAAK,KAAA,GACL,KAAK,EAAE,IAAA,GACA;AAAA,EAGX,WAAW,OACP,KAAK,MAAM,QAAQ,CAAAA,MAAKA,EAAE,UAAU,GAC7B;AAAA,EAGX,WAAW,MAEA,KACF;AAAA,IACG4B,EAAQ,IAAI,GAAG,KAAK,MAAM,IAAI,CAAA5B,MAAKA,EAAE,WAAW,CAAC;AAAA,EAAA,EAEpD;AAAA,IACG4B,EAAQ,IAAI,GAAG,KAAK,MAAM,IAAI,CAAA5B,MAAKA,EAAE,SAAS,CAAC;AAAA,EAAA,EACjD;AAAA,IACE,KAAK,EAAE,WAAA,IAAe,KAAK;AAAA,EAAA;AAAA,EAIvC,WAAW,CAAC2E,MACD,KAAK,IAAIA,EAAE,MAAA,EAAQ,UAAU;AAAA,EAGxC,aAAa9E,GAA0B;AACnC,gBAAK,MAAM,QAAQ,CAACG,GAAGuB,MAAUvB,EAAE,IAAIH,EAAO0B,CAAK,CAAC,CAAC,GAC9C;AAAA,EACX;AAAA,EAEA,OAAO,MAAY;AACf,UAAM2Z,IAAO,KAAK;AAClB,WAAIA,MAAS,IACF,OAGJ,KAAK,eAAeA,CAAI;AAAA,EACnC;AAEJ;ACjHO,IAAKC,sBAAAA,OACRA,EAAA,OAAO,QACPA,EAAA,WAAW,YACXA,EAAA,gBAAgB,iBAChBA,EAAA,UAAU,WAJFA,IAAAA,KAAA,CAAA,CAAA,GAOAC,sBAAAA,OACRA,EAAA,OAAO,QACPA,EAAA,WAAW,YACXA,EAAA,gBAAgB,iBAChBA,EAAA,UAAU,WAJFA,IAAAA,KAAA,CAAA,CAAA;AC9GL,SAASC,GAAWC,IAAU,KAAc;AAC/C,SAAO,KAAK,WAAWA;AAC3B;AAOO,SAASC,EAAUlb,GAAWC,GAAYkb,GAA4B;AACzE,MAAIlb,MAAM;AACN,WAAID,KAAK,IACEkb,EAAU,GAAGlb,CAAC,IAEdkb,EAAUlb,GAAG,CAAC;AAK7B,MAAIA,MAAMC;AACN,WAAOD;AAIX,MAAImb,MAAY;AACZ,WAAO,KAAK,MAAM,KAAK,OAAA,KAAYlb,IAAID,IAAI,KAAKA,CAAC;AAIrD,MAAI,KAAK,IAAIC,IAAID,CAAC,KAAKmb,EAAQ;AAC3B,UAAM,IAAI,MAAM,4CAA4C;AAGhE,MAAI9R,IAAI6R,EAAUlb,GAAGC,CAAC;AACtB,SAAOkb,EAAQ,SAAS9R,CAAC;AACrB,IAAAA,IAAI6R,EAAUlb,GAAGC,CAAC;AAEtB,SAAOoJ;AACX;AAOO,SAAS+R,EAAaC,GAAahM,GAAwB;AAC9D,SAAIA,MAAS,KACF2L,GAAA,IAAeE,EAAU,GAAGG,CAAG,IAAI,CAACH,EAAU,GAAGG,CAAG,IAEpDH,EAAU,CAACG,GAAKA,CAAG;AAElC;AAEO,SAASC,GAAYD,GAAsB;AAC9C,MAAI9a,IAASgB,EAAQ,OAAA;AACrB,SAAI8Z,MAAQ,WACR9a,IAASA,EAAO,OAAO,CAAAZ,MAAKA,IAAI0b,CAAG,IAEhCE,GAAWhb,CAAM;AAC5B;AAEO,SAASib,GAAepc,GAAUqc,GAAsB;AAM3D,SALIA,MAAW,WACXA,IAAS,IAITrc,EAAI,UAAU,IACP,OAAO,OAAOA,CAAG,IAIrBsc,GAAatc,CAAG,EAAE,MAAM,GAAGqc,CAAM;AAC5C;AAEO,SAASF,GAAcnc,GAAa;AACvC,SAAIA,EAAI,WAAW,IAAY,OACxBA,EAAI8b,EAAU,GAAG9b,EAAI,SAAS,CAAC,CAAC;AAC3C;AAEO,SAASsc,GAAgBtc,GAAe;AAE3C,QAAMsc,IAAe,OAAO,OAAOtc,CAAG;AACtC,WAASW,IAAI2b,EAAa,SAAS,GAAG3b,IAAI,GAAGA,KAAK;AAC9C,UAAM6P,IAAI,KAAK,MAAM,KAAK,YAAY7P,IAAI,EAAE,GACtC4b,IAAOD,EAAa3b,CAAC;AAC3B2b,IAAAA,EAAa3b,CAAC,IAAI2b,EAAa9L,CAAC,GAChC8L,EAAa9L,CAAC,IAAI+L;AAAA,EACtB;AAEA,SAAOD;AACX;AChFO,MAAME,EAAoC;AAAA,EAC7C,OAAO,WAAWd,EAAc;AAAA,EAChC,OAAO,gBAAgBA,EAAc;AAAA,EACrCe;AAAA;AAAA;AAAA,EAIAC;AAAA,EACAC;AAAA,EACAC;AAAA;AAAA,EAGAC,KAA4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO5B,eAAezc,GAAmB;AAC9B,gBAAKsc,KAAK,IAAIra,EAAA,EAAW,KAAA,GACzB,KAAKsa,KAAK,IAAIta,EAAA,EAAW,KAAA,GACzB,KAAKua,KAAK,IAAIva,EAAA,EAAW,KAAA,GACzB,KAAKoa,KAAM,IAAIrB,EAAA,GAEXhb,EAAO,SAAS,KAChB,KAAK,MAAM,GAAGA,CAAM,GAGjB;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,QAAQ,IAAIA,MAA4B;AAEpC,QAAIA,EAAO,WAAW;AAClB,aAAO;AAIX,QAAIA,EAAO,WAAW,GAAG;AACrB,UAAIA,EAAO,CAAC,aAAaoc;AAErB,eAAO,KAAK,gBAAgBpc,EAAO,CAAC,EAAE,GAAGA,EAAO,CAAC,EAAE,GAAGA,EAAO,CAAC,EAAE,CAAC;AAGrE,UAAIA,EAAO,CAAC,aAAa8R;AAErB,eAAO,KAAK,aAAa9R,EAAO,CAAC,CAAC;AAGtC,UAAI,OAAOA,EAAO,CAAC,KAAM;AAErB,YAAI;AACA,gBAAMgK,IAAI,IAAI8H,EAAS9R,EAAO,CAAC,CAAC;AAChC,iBAAO,KAAK,MAAMgK,CAAC;AAAA,QACvB,SAASN,GAAG;AACR,yBAAQ,KAAKA,CAAC,GACP;AAAA,QACX;AAAA,IAER;AAEA,QAAI1J,EAAO,WAAW,GAAG;AACrB,UAAIA,EAAO,CAAC,aAAa2a,KAAS3a,EAAO,CAAC,aAAa2a;AACnD,eAAO,KAAK,WAAW3a,EAAO,CAAC,GAAGA,EAAO,CAAC,CAAC;AAG/C,UAAIA,EAAO,CAAC,aAAa2a,KAAS3a,EAAO,CAAC,aAAagb;AACnD,eAAO,KAAK,sBAAsBhb,EAAO,CAAC,GAAGA,EAAO,CAAC,CAAC;AAAA,IAE9D;AAEA,WAAIA,EAAO,WAAW,KAAKA,EAAO,MAAM,OAAKiC,EAAS,WAAW9B,CAAyB,CAAC,IAChF,KAAK;AAAA,MACRH,EAAO,CAAC;AAAA,MACRA,EAAO,CAAC;AAAA,MACRA,EAAO,CAAC;AAAA,IAAA,KAIhB,QAAQ,IAAI,kDAAkD,GAC9D,QAAQ,IAAIA,CAAM,GACX;AAAA,EACX;AAAA;AAAA;AAAA,EAKA,QAAQ,OACJ,KAAKsc,KAAK,KAAKA,GAAG,MAAA,GAClB,KAAKC,KAAK,KAAKA,GAAG,MAAA,GAClB,KAAKC,KAAK,KAAKA,GAAG,MAAA,GAElB,KAAKH,KAAM,KAAKA,GAAI,MAAA,GACb;AAAA,EAGX,IAAI,MAAc;AAOd,UAAMpW,IAAS,KAAKwW;AAGpB,YAFA,KAAKA,KAAc,GAEXxW,GAAA;AAAA,MACJ,KAAK;AACD,eAAO,KAAK,cAAc,QAAA,EAAU;AAAA,MACxC,KAAK;AACD,eAAO,KAAK,MAAM,WAAA,IACd,OAAO,KAAK,GAAG,EAAE,MACjB,OAAO,IAAIoH,EAAA,EAAU,MAAM,KAAK,KAAK,OAAO,KAAK,MAAM,EAAE;AAAA,MACjE,KAAK;AAAA,MACL,KAAK,GAAqB;AACtB,cAAMrF,IAAI,KAAK,EAAE,MAAA,EAAQ,SAAA;AAEzB,eAAI/B,MAAW,IACJ,GAAG+U,EAAO,MAAM,KAAK,GAAG,CAAC,MAAMA,EAAO,MAAM,KAAKqB,GAAI,EAAE,KAAK,KAAKA,GAAI,EAAE,GAAG,CAAC,cAAcrB,EAAO,MAAMhT,EAAE,EAAE,KAAKA,EAAE,EAAE,GAAG,CAAC,KAEvH;AAAA,mBACP,IAAIqF,EAAQ,KAAKgP,GAAI,CAAC,EACjB,IAAI,IAAI5R,EAAM,KAAK,EAAE,CAAC,EAAE,SAAS,IAAIA,EAAM,GAAG,CAAC,CAAC,EAChD,QAAQ,KAAK,EAAI,EACjB,GAAG;AAAA,mBACR,IAAI4C,EAAQ,KAAKgP,GAAI,CAAC,EACjB,IAAI,IAAI5R,EAAM,KAAK,EAAE,CAAC,EAAE,SAAS,IAAIA,EAAM,GAAG,CAAC,CAAC,EAChD,QAAQ,KAAK,EAAI,EACjB,GAAG;AAAA;AAAA,MAGhB;AAAA,MACA,SAAS;AACL,cAAMiS,IAAY,KAAK,YAAA;AACvB,eAAI,KAAKJ,GAAG,gBACRI,EAAU,SAAS,EAAE,GAElBA,EAAU;AAAA,MACrB;AAAA,IAAA;AAAA,EAGR;AAAA,EAEA,IAAI,UAAkB;AAIlB,UAAMzW,IAAS,KAAKwW;AAGpB,YAFA,KAAKA,KAAc,GAEXxW,GAAA;AAAA,MACJ,KAAK;AACD,eAAO,KAAK,cAAc,QAAA,EAAU;AAAA,MACxC,KAAK;AACD,eAAO,KAAK,MAAM,WAAA,IACd,OAAO,KAAK,GAAG,EAAE,UACjB,OAAO,IAAIoH,EAAA,EAAU,MAAM,KAAK,KAAK,OAAO,KAAK,MAAM,EAAE;AAAA,MACjE,KAAK,GAAyB;AAC1B,cAAMrF,IAAI,KAAK,EAAE,MAAA,EAAQ,SAAA;AACzB,eAAO,aAAa,KAAKqU,GAAI,EAAE,OAAO,IAAI,KAAKA,GAAI,EAAE,OAAO,SAASrU,EAAE,EAAE,OAAO,IAAIA,EAAE,EAAE,OAAO;AAAA,MACnG;AAAA,MACA,KAAK;AAED,eAAO;AAAA,MAEX,SAAS;AACL,cAAM0U,IAAY,KAAK,YAAA;AAEvB,eAAI,KAAKJ,GAAG,gBACRI,EAAU,SAAS,EAAE,GAElBA,EAAU;AAAA,MACrB;AAAA,IAAA;AAAA,EAGR;AAAA,EAEA,IAAI,KAAa;AACb,WAAO,KAAKL;AAAA,EAChB;AAAA,EAEA,IAAI,GAAG5c,GAAuB;AAC1B,SAAK,mBAAmBA,GAAO,KAAK,CAAC;AAAA,EACzC;AAAA,EAEA,IAAI,IAAc;AACd,WAAO,KAAK6c;AAAA,EAChB;AAAA,EAEA,IAAI,EAAE7c,GAAiB;AACnB,SAAK6c,KAAK7c;AAAA,EACd;AAAA,EAEA,cAAoB;AAChB,gBAAKgd,KAAc,GACZ;AAAA,EACX;AAAA,EAEA,cAAoB;AAChB,gBAAKA,KAAc,GACZ;AAAA,EACX;AAAA,EAEA,QAAc;AACV,gBAAKA,KAAc,GACZ;AAAA,EACX;AAAA,EAEA,eAAqB;AACjB,gBAAKA,KAAc,GACZ;AAAA,EACX;AAAA,EAEA,WAAiB;AACb,gBAAKA,KAAc,GACZ;AAAA,EACX;AAAA,EAEA,IAAI,IAAc;AACd,WAAO,KAAKF;AAAA,EAChB;AAAA,EAEA,IAAI,EAAE9c,GAAiB;AACnB,SAAK8c,KAAK9c;AAAA,EACd;AAAA,EAEA,IAAI,IAAc;AACd,WAAO,KAAK+c;AAAA,EAChB;AAAA,EAEA,IAAI,EAAE/c,GAAiB;AACnB,SAAK+c,KAAK/c;AAAA,EACd;AAAA;AAAA,EAGA,4BAA4B+B,IAAW,GAAW;AAC9C,QAAIkb,IAAY;AAEhB,WAAK,KAAKJ,GAAG,aACL,KAAKA,GAAG,UACRI,IAAY,MACL,KAAKJ,GAAG,MAAA,EAAQ,SAAA,EAAW,UAClCI,IAAY,OAEZA,IAAY,KAAKJ,GAAG,MAAM,QAAQ9a,CAAQ,IAAI,MAIjD,KAAK+a,GAAG,aACL,KAAKA,GAAG,iBACRG,KAAa,MAEjBA,KAAa,KAAKH,GAAG,MAAM,QAAQ/a,CAAQ,IAAI,MAG9C,KAAKgb,GAAG,aACL,KAAKA,GAAG,iBACRE,KAAa,MAEjBA,KAAa,KAAKF,GAAG,MAAM,QAAQhb,CAAQ,IAIxCkb,IAAY;AAAA,EACvB;AAAA,EAEA,IAAI,IAAY;AACZ,WAAO,IAAI1B,EAAO,KAAKuB,GAAG,MAAA,GAAS,KAAKD,GAAG,QAAQ,UAAU;AAAA,EACjE;AAAA,EAEA,IAAI,EAAE7c,GAAe;AACjB,SAAK,sBAAsB,KAAK,IAAIA,CAAK;AAAA,EAC7C;AAAA,EAEA,IAAI,WAAmB;AACnB,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,WAAWkd,GAAiB;AACxB,UAAM7O,IAAY6O,EAAG,EAAE,MAAA,EAAQ,SAAS,KAAKL,EAAE,EAC1C,IAAIK,EAAG,EAAE,MAAA,EAAQ,SAAS,KAAKJ,EAAE,CAAC,EAClC,IAAI,KAAKC,EAAE,EAAE,IAAA,GACZI,IAAK,KAAK,OAAO;AAGvB,WAAIA,EAAG,WACI,IAAI1C,EAAK,CAAC,IAGd,IAAIA,IAAO,KAAK,GAAG0C,EAAG,QAAA,GAAW9O,CAAS;AAAA,EAqBrD;AAAA,EAEA,kBAAkB,CAACtN,GAAyBC,GAAyBsH,MAAkC;AACnG,SAAKuU,KAAK,IAAIra,EAASzB,CAAC,GACxB,KAAK+b,KAAK,IAAIta,EAASxB,CAAC,GACxB,KAAK+b,KAAK,IAAIva,EAAS8F,CAAC;AAGxB,UAAMvE,IAAMzB,EAAQ,IAAI,KAAKua,GAAG,aAAa,KAAKC,GAAG,aAAa,KAAKC,GAAG,WAAW;AAOrF,QANIhZ,IAAM,MACN,KAAK8Y,GAAG,SAAS9Y,CAAG,EAAE,OAAA,GACtB,KAAK+Y,GAAG,SAAS/Y,CAAG,EAAE,OAAA,GACtB,KAAKgZ,GAAG,SAAShZ,CAAG,EAAE,OAAA,IAGtB,KAAK+Y,GAAG;AAER,kBAAKF,KAAM,IAAIrB,EAAO,KAAKwB,GAAG,QAAQ,OAAO,KAAKF,EAAE,EAAE,SAAA,GAAY,CAAC,GAC5D;AAIX,aAASnc,IAAI,GAAGA,IAAI,KAAKoc,GAAG,OAAOpc,KAAK;AACpC,YAAMib,IAAI,KAAKkB,GAAG,MAAA,EAAQ,OAAO,KAAKC,EAAE,EACnC,SAASpc,CAAC,EACV,SAAS,KAAKqc,GAAG,MAAA,EAAQ,OAAO,KAAKD,EAAE,CAAC,EACxC,OAAA;AAIL,UAFA,KAAKF,KAAM,IAAIrB,EAAO7a,GAAGib,CAAC,GAEtBA,EAAE;AACF,eAAO;AAAA,IAEf;AAGA,UAAMA,IAAI,KAAKoB,GAAG,MAAA,EAAQ,OAAO,KAAKD,EAAE,EAAE,SAAA,EAAW,OAAA;AACrD,gBAAKF,KAAM,IAAIrB,EAAO,GAAGI,CAAC,GAEnB;AAAA,EACX;AAAA,EAEA,eAAe,CAAC7V,MAAwB;AAEpC,IAAAA,EAAI,QAAQ,EAAI;AAGhB,UAAMwF,IAAU,IAAI,IAAIxF,EAAI,SAAS;AAGrC,QAAI,EAAEwF,EAAQ,IAAI,GAAG,KAAKA,EAAQ,IAAI,GAAG;AACrC,aAAO;AAIX,eAAW8R,KAAQ,CAAC,KAAK,GAAG;AACxB,MAAI9R,EAAQ,IAAI8R,CAAI,KAChB9R,EAAQ,OAAO8R,CAAI;AAI3B,WAAI9R,EAAQ,OAAO,IACR,OAIJ,KAAK;AAAA,MACRxF,EAAI,KAAK,cAAc,GAAG,EAAE;AAAA,MAC5BA,EAAI,KAAK,cAAc,GAAG,EAAE;AAAA,MAC5BA,EAAI,KAAK,cAAc,CAAC,EAAE;AAAA,IAAA;AAAA,EAElC;AAAA,EAEA,wBAAwB,CAAC8C,GAAmBL,MACjC,KAAK,mBAAmBK,GAAGL,EAAE,MAAA,EAAQ,QAAQ;AAAA,EAGxD,mBAAmB,CAACK,GAAWyC,GAASgS,IAA6BxB,EAAc,aAE3EwB,MAAgBxB,EAAc,gBACvB,KAAK,mBAAmBjT,GAAGyC,EAAE,QAAQ,IAGzC,KAAK,mBAAmBzC,GAAGyC,EAAE,MAAM;AAAA,EAG9C,qBAAqB,CAACzC,GAAmBpE,OACrC,KAAK;AAAA,IACDA,EAAE;AAAA,IACFA,EAAE;AAAA,IACFoE,EAAE,EAAE,MAAA,EAAQ,SAASpE,EAAE,CAAC,EACnB,IAAIoE,EAAE,EAAE,QAAQ,SAASpE,EAAE,CAAC,CAAC,EAAE,SAAA;AAAA,EAAS,GAGjD,KAAKoY,KAAM,IAAIrB,EAAO3S,EAAE,OAAO,GAExB;AAAA;AAAA;AAAA,EAMX,WAAWmC,GAAUpE,GAAU;AAC3B,WAAO,KAAK,mBAAmBoE,GAAG,IAAIwQ,EAAOxQ,GAAGpE,CAAC,EAAE,QAAQ;AAAA,EAC/D;AAAA;AAAA,EAGA,cAAwB;AAEpB,WADY,IAAI0L,EAAS,IAAIzE,EAAA,EAAU,MAAM,MAAM,KAAKiP,IAAI,KAAKC,IAAI,KAAKC,EAAE,GAAG,IAAInP,EAAQ,GAAG,CAAC,EACpF,SAAA;AAAA,EACf;AAAA,EAEA,cAAc,CAAC5N,MAAuC;AAClD,UAAM8F,IAAM,KAAK,cAAc,QAAQ,GAAG,GACtC1C,IAAI,IAAIZ,EAASxC,CAAK;AAE1B,WAAI8F,aAAeuM,IACRvM,EAAI,MAAM,SAAS,EAAC,GAAG1C,GAAE,IAE7B,IAAIZ,EAAA,EAAW,QAAA;AAAA,EAC1B;AAAA,EAEA,cAAc,CAACxC,MAAuC;AAClD,UAAM8F,IAAM,KAAK,cAAc,QAAQ,GAAG,GACtC1C,IAAI,IAAIZ,EAASxC,CAAK;AAE1B,WAAI8F,aAAeuM,IACRvM,EAAI,MAAM,SAAS,EAAC,GAAG1C,GAAE,IAG7B,IAAIZ,EAAA,EAAW,QAAA;AAAA,EAC1B;AAAA,EAEA,IAAI,SAAmB;AACnB,WAAO,KAAKua,GAAG,MAAA,EAAQ,WAAW,OAAO,KAAKD,EAAE;AAAA,EACpD;AAAA,EAEA,WAAW/R,GAAUpE,GAAmB;AACpC,UAAM2W,IAAM,KAAK;AAAA,MACb,IAAIX,EAAA,EAAO,WAAW5R,GAAGpE,CAAC;AAAA,IAAA;AAI9B,WAAI2W,EAAI,kBACGA,EAAI,MAAM,EAAE,SAAS,KAAK,IAAIvS,EAAE,EAAE,OAAOpE,EAAE,EAAE,KAAK,KAClD2W,EAAI,MAAM,EAAE,SAAS,KAAK,IAAIvS,EAAE,EAAE,OAAOpE,EAAE,EAAE,KAAK,KAClD2W,EAAI,MAAM,EAAE,SAAS,KAAK,IAAIvS,EAAE,EAAE,OAAOpE,EAAE,EAAE,KAAK,KAClD2W,EAAI,MAAM,EAAE,SAAS,KAAK,IAAIvS,EAAE,EAAE,OAAOpE,EAAE,EAAE,KAAK,IAEtD;AAAA,EACX;AAAA,EAEA,eAAe,CAAC4W,MAAiG;AAE7G,UAAMC,IAAK,IAAItC,EAAA;AACf,QAAIuC,IAAa,IAAOC,IAAS;AAkBjC,WAAI,KAAKZ,GAAG,OAAA,KAAYS,EAAK,EAAE,UAI3B,KAAK,aAAaA,CAAI,KACtBC,EAAG,IAAI,IAAIhb,EAAA,EAAW,QAAA,GACtBgb,EAAG,IAAI,IAAIhb,EAAA,EAAW,QAAA,GACtBib,IAAa,MACN,KAAK,SAASF,CAAI,KACzBC,EAAG,IAAI,IAAIhb,EAAA,EAAW,QAAA,GACtBgb,EAAG,IAAI,IAAIhb,EAAA,EAAW,QAAA,GACtBkb,IAAS,OAETF,EAAG,IAAI,KAAKV,GAAG,MAAA,EAAQ,SAASS,EAAK,CAAC,EAAE,SAAS,KAAKR,GAAG,MAAA,EAAQ,SAASQ,EAAK,CAAC,CAAC,EAC5E,OAAO,KAAKV,GAAG,MAAA,EAAQ,SAASU,EAAK,CAAC,EAAE,SAAS,KAAKT,GAAG,MAAA,EAAQ,SAASS,EAAK,CAAC,CAAC,CAAC,GACvFC,EAAG,IAAI,KAAKX,GAAG,MAAA,EAAQ,SAASU,EAAK,CAAC,EAAE,SAAS,KAAKR,GAAG,MAAA,EAAQ,SAASQ,EAAK,CAAC,CAAC,EAC5E,OAAO,KAAKT,GAAG,MAAA,EAAQ,SAASS,EAAK,CAAC,EAAE,SAAS,KAAKV,GAAG,MAAA,EAAQ,SAASU,EAAK,CAAC,CAAC,CAAC,IAGpF;AAAA,MACH,OAAOC;AAAA,MACP,iBAAiB,EAAEC,KAAcC;AAAA,MACjC,YAAAD;AAAA,MACA,QAAAC;AAAA,IAAA;AAAA,EAER;AAAA;AAAA,EAGA,SAASR,GAAoB;AACzB,WAAO,KAAKL,GAAG,MAAA,EACV,SAASK,EAAG,CAAC,EACb;AAAA,MACG,KAAKJ,GAAG,MAAA,EACH,SAASI,EAAG,CAAC;AAAA,IAAA,EAErB,IAAI,KAAKH,EAAE,EACX,OAAA;AAAA,EACT;AAAA,EAEA,eAAe,CAACQ,MAEL,KAAK,MAAM,QAAQA,EAAK,KAAK,KAAK,KAAK,OAAO,WAAWA,EAAK,MAAM;AAAA,EAG/E,oBAAoB,CAACA,MACV,KAAK,EAAE,WAAWA,EAAK,CAAC;AAAA,EAGnC,WAAW,CAACA,MACD,KAAK,MAAM,QAAQA,EAAK,KAAK,KAAK,KAAK,OAAO,QAAQA,EAAK,MAAM;AAAA,EAG5E,aAAa,MACF,KAAK,MAAM,WAAA;AAAA,EAGtB,IAAI,IAAY;AACZ,WAAO,KAAK,EAAE,OAAA;AAAA,EAClB;AAAA,EAEA,IAAI,SAAiB;AACjB,WAAO,IAAIhC,EAAO,KAAKsB,IAAI,KAAKC,EAAE;AAAA,EACtC;AAAA,EAEA,kBAAkB,CAAC1Y,MAAsB;AACrC,UAAM8Y,IAAK,KAAK,YAAY9Y,CAAC;AAE7B,QAAIuZ,IAAmB;AACvB,WAAO,KAAK,SAAST,CAAE,KAAKS,IAAmB;AAC3C,MAAAT,EAAG,EAAE,IAAIf,EAAa,GAAG,EAAK,CAAC,GAC/Be,EAAG,EAAE,IAAIf,EAAa,GAAG,EAAK,CAAC,GAC/BwB;AAIJ,WAAOT;AAAA,EACX;AAAA,EAEA,cAAc,CAAC9Y,MAAsB;AAEjC,UAAM8Y,IAAK,KAAK,EACX,QACA,iBAAiBf,EAAc/X,MAAM,UAAaA,KAAK,IAAK,IAAIA,GAAG,EAAK,CAAC,EACzE,IAAI,KAAKwY,EAAG;AAEjB,WAAO,IAAI1B,EAAMgC,CAAE;AAAA,EACvB;AAAA,EAEA,WAAW,MAAY;AACnB,UAAMnZ,IAAMzB,EAAQ,IAAI,KAAKua,GAAG,aAAa,KAAKC,GAAG,aAAa,KAAKC,GAAG,WAAW,GACjFvT,IAAMlH,EAAQ,IAAI,KAAKua,GAAG,WAAW,KAAKC,GAAG,WAAW,KAAKC,GAAG,SAAS;AAE7E,gBAAK;AAAA,MACD,KAAKF,GAAG,MAAA,EAAQ,SAAS9Y,CAAG,EAAE,OAAOyF,CAAG;AAAA,MACxC,KAAKsT,GAAG,MAAA,EAAQ,SAAS/Y,CAAG,EAAE,OAAOyF,CAAG;AAAA,MACxC,KAAKuT,GAAG,MAAA,EAAQ,SAAShZ,CAAG,EAAE,OAAOyF,CAAG;AAAA,IAAA,GAGrC;AAAA,EACX;AAAA,EAEA,IAAI,QAAkB;AAClB,WAAO,KAAKqT,GAAG,MAAA,EAAQ,WAAW,OAAO,KAAKC,EAAE;AAAA,EACpD;AACJ;AC/lBO,MAAMc,EAAS;AAAA;AAAA,EAElBC,KAAY,IAAI3C,EAAA;AAAA,EAChB4C,KAAY,IAAI5C,EAAA;AAAA,EAChB6C,KAAY,IAAI7C,EAAA;AAAA,EAChBjW,KAAW;AAAA;AAAA;AAAA,EAEX+Y,KAAuC;AAAA,IACnC,IAAM,IAAIrB,EAAA;AAAA,IACV,IAAM,IAAIA,EAAA;AAAA,IACV,IAAM,IAAIA,EAAA;AAAA,EAAK;AAAA,EAEnBsB,KAAW;AAAA,EACXC,KAA0C;AAAA,EAE1C,eAAe3d,GAAmB;AAG9B,WAAIA,EAAO,SAAS,KAChB,KAAK,MAAM,GAAGA,CAAM,GAGjB;AAAA,EACX;AAAA,EAEA,QAAQ,IAAIA,MAA4B;AAEpC,QAAIA,EAAO,WAAW,KACdA,EAAO,CAAC,aAAaqd;AACrB,aAAO,KAAK,KAAKrd,EAAO,CAAC,CAAC;AAIlC,QAAIA,EAAO,WAAW,GAAG;AAKrB,UAAIA,EAAO,MAAM,CAACG,MAAe,OAAOA,KAAM,QAAQ;AAElD,eAAO,KAAK;AAAA,UACR,GAAGH,EAAO,IAAI,CAACG,MACJ,IAAIic,EAAKjc,CAAC,CACpB;AAAA,QAAA;AAIT,UAAIH,EAAO,MAAM,CAACG,MAAeA,aAAaic,CAAI;AAE9C,eAAO,KAAK,UAAUpc,EAAO,CAAC,GAAGA,EAAO,CAAC,GAAGA,EAAO,CAAC,CAAC;AAGzD,UAAIA,EAAO,MAAM,CAACG,MAAgBA,aAAawa,CAAM;AACjD,eAAO,KAAK,WAAW3a,EAAO,CAAC,GAAGA,EAAO,CAAC,GAAGA,EAAO,CAAC,CAAC;AAAA,IAE9D;AAEA,QAAIA,EAAO,WAAW,GAAG;AACrB,YAAMF,IAAgBE,EAAO,IAAI,CAACG,MAAe,IAAI8B,EAAS9B,CAAW,CAAC;AAE1E,UAAIL,EAAE,KAAK,CAAAK,MAAKA,EAAE,MAAA,CAAO;AACrB,cAAM,IAAI,MAAM,yCAAyC;AAG7D,aAAO,KAAK,gBAAgBL,EAAE,CAAC,GAAGA,EAAE,CAAC,GAAGA,EAAE,CAAC,GAAGA,EAAE,CAAC,GAAGA,EAAE,CAAC,GAAGA,EAAE,CAAC,CAAC;AAAA,IAClE;AAEA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ,MACG,IAAIud;AAAA,IACP,KAAKC,GAAG,MAAA;AAAA,IACR,KAAKC,GAAG,MAAA;AAAA,IACR,KAAKC,GAAG,MAAA;AAAA,EAAM;AAAA;AAAA;AAAA;AAAA;AAAA,EAQtB,KAAK/d,GAAuB;AACxB,gBAAK6d,KAAK7d,EAAM,EAAE,MAAA,GAClB,KAAK8d,KAAK9d,EAAM,EAAE,MAAA,GAClB,KAAK+d,KAAK/d,EAAM,EAAE,MAAA,GAEX,KAAKme,GAAA;AAAA,EAChB;AAAA,EAEA,IAAI,IAAW;AACX,WAAO,KAAKN;AAAA,EAChB;AAAA,EAEA,IAAI,KAAa;AACb,WAAO,KAAKO,GAAY,KAAK,GAAG;AAAA,EACpC;AAAA,EAEA,IAAI,KAAa;AACb,WAAO,KAAKA,GAAY,KAAK,GAAG;AAAA,EACpC;AAAA,EAEA,IAAI,IAAW;AACX,WAAO,KAAKN;AAAA,EAChB;AAAA,EAEA,IAAI,KAAa;AACb,WAAO,KAAKM,GAAY,KAAK,GAAG;AAAA,EACpC;AAAA,EAEA,IAAI,KAAa;AACb,WAAO,KAAKA,GAAY,KAAK,GAAG;AAAA,EACpC;AAAA,EAEA,IAAI,IAAW;AACX,WAAO,KAAKL;AAAA,EAChB;AAAA,EAEA,IAAI,KAAa;AACb,WAAO,KAAKK,GAAY,KAAK,GAAG;AAAA,EACpC;AAAA,EAEA,IAAI,KAAa;AACb,WAAO,KAAKA,GAAY,KAAK,GAAG;AAAA,EACpC;AAAA,EAEA,IAAI,WAAmB;AACnB,WAAO,KAAK,SAAS,KAAK;AAAA,EAC9B;AAAA,EAEA,IAAI,WAAmB;AACnB,WAAO,KAAK,SAAS,KAAK;AAAA,EAC9B;AAAA,EAEA,IAAI,WAAmB;AACnB,WAAO,KAAK,SAAS,KAAK;AAAA,EAC9B;AAAA,EAEA,IAAI,WAAiB;AACjB,gBAAKH,KAAW,IACT;AAAA,EACX;AAAA,EAEA,IAAI,YAAkB;AAClB,gBAAKA,KAAW,IACT;AAAA,EACX;AAAA,EAEA,gBACInV,GAA0BuV,GAC1BtV,GAA0BuV,GAC1BC,GAA0BC,GAAgC;AAE1D,WAAO,KAAK;AAAA,MACR,IAAItD,EAAMpS,GAAIuV,CAAE;AAAA,MAChB,IAAInD,EAAMnS,GAAIuV,CAAE;AAAA,MAChB,IAAIpD,EAAMqD,GAAIC,CAAE;AAAA,IAAA;AAAA,EAExB;AAAA,EAEA,UAAUC,GAAsBC,GAAsBC,GAA4B;AAC9E,UAAMC,IAAW,IAAIjC,EAAK8B,CAAK,EAAE,MAAA,GAC3BI,IAAW,IAAIlC,EAAK+B,CAAK,EAAE,MAAA,GAC3BI,IAAW,IAAInC,EAAKgC,CAAK,EAAE,MAAA;AAGjC,QAAII,IAAYH,EAAG,aAAaC,CAAE;AAClC,QAAIE,EAAU;AACV,WAAKjB,KAAKiB,EAAU;AAAA;AAEpB,YAAM,IAAI,MAAM,0BAA0B;AAI9C,QADAA,IAAYF,EAAG,aAAaC,CAAE,GAC1BC,EAAU;AACV,WAAKhB,KAAKgB,EAAU;AAAA;AAEpB,YAAM,IAAI,MAAM,0BAA0B;AAI9C,QADAA,IAAYD,EAAG,aAAaF,CAAE,GAC1BG,EAAU;AACV,WAAKlB,KAAKkB,EAAU;AAAA;AAEpB,YAAM,IAAI,MAAM,0BAA0B;AAG9C,gBAAKZ,GAAA,GAGL,KAAKH,KAAS,EAAC,IAAAY,GAAI,IAAAE,GAAI,IAAAD,EAAA,GAEhB;AAAA,EAEX;AAAA,EAEA,WAAW9T,GAAUpE,GAAUzB,GAAgB;AAE3C,gBAAK2Y,KAAK9S,EAAE,MAAA,GACZ,KAAK+S,KAAKnX,EAAE,MAAA,GACZ,KAAKoX,KAAK7Y,EAAE,MAAA,GAEZ,KAAKiZ,GAAA,GACE;AAAA,EACX;AAAA,EAEA,SAASa,GAAqC;AAC1C,UAAMje,IAAI,KAAK,GAAG,MACZC,IAAI,KAAK,GAAG,MACZsH,IAAI,KAAK,GAAG;AAElB,WAAI0W,MAAS,QACF,KAAKC,GAAQle,GAAGC,GAAGsH,CAAC,IAG3B0W,MAAS,QACF,KAAKC,GAAQ3W,GAAGtH,GAAGD,CAAC,IAGxB,KAAKke,GAAQje,GAAGD,GAAGuH,CAAC;AAAA,EAC/B;AAAA,EAEA,IAAI,gBAAyB;AACzB,UAAM4W,IAAM,KAAK,GAAG,WAAW,OACzBC,IAAM,KAAK,GAAG,WAAW,OACzBC,IAAM,KAAK,GAAG,WAAW;AAE/B,WAAQF,MAAQC,KAASD,MAAQE;AAAA,EACrC;AAAA,EAEA,IAAI,YAAqB;AACrB,UAAMF,IAAM,KAAK,GAAG,WAAW,OACzBC,IAAM,KAAK,GAAG,WAAW,OACzBC,IAAM,KAAK,GAAG,WAAW;AAE/B,WAAOF,MAAQC,KACXD,MAAQE,KACRD,MAAQC;AAAA,EAChB;AAAA,EAEA,IAAI,cAAuB;AACvB,WAAO,KAAK,GAAG,WAAW,KAAK,EAAE,KAC7B,KAAK,GAAG,WAAW,KAAK,EAAE,KAC1B,KAAK,GAAG,WAAW,KAAK,EAAE;AAAA,EAClC;AAAA,EAEA,IAAI,UAAmB;AACnB,WAAO,KAAKna;AAAA,EAChB;AAAA,EAEA,IAAI,QAAQjF,GAAgB;AACxB,SAAKiF,KAAWjF;AAAA,EACpB;AAAA,EAEA,IAAI,QAAsC;AACtC,WAAO,KAAKge;AAAA,EAChB;AAAA,EAEA,IAAI,eAAwC;AACxC,WAAO,KAAKE;AAAA,EAChB;AAAA,EAEAmB,KAAsB,CAACnC,MAAmD;AAEtE,UAAMoC,IAAS,KAAK;AACpB,QAAIC,GAAIpC;AAaR,QAXID,MAAO,OACPqC,IAAKD,EAAO,IACZnC,IAAKmC,EAAO,MACLpC,MAAO,OACdqC,IAAKD,EAAO,IACZnC,IAAKmC,EAAO,MACLpC,MAAO,QACdqC,IAAKD,EAAO,IACZnC,IAAKmC,EAAO,KAGZC,MAAO,UAAapC,MAAO;AAC3B,YAAM,IAAI,MAAM,aAAaD,CAAE,iBAAiB;AAGpD,UAAMsC,IAAMD,EAAG,EAAE,SAAA,EAAW,MACtBE,IAAMtC,EAAG,EAAE,SAAA,EAAW,MACtBuC,IAAQH,EAAG,YAAA,EAAc,SAASE,CAAG,GACrCE,IAAQxC,EAAG,YAAA,EAAc,SAASqC,CAAG,GAErCI,IAAW,IAAIjD,EAAK+C,EAAM,MAAA,EAAQ,SAASC,CAAK,EAAE,UAAU,GAC5DlW,IAAW,IAAIkT,EAAKgD,EAAM,MAAA,EAAQ,SAASD,CAAK,EAAE,UAAU;AAGlE,WAAIxC,MAAO,MACA0C,EAAG,WAAW,KAAK,GAAG,KAAK,CAAC,IAAI,EAAC,UAAUA,GAAI,UAAUnW,MAAM,EAAC,UAAUA,GAAI,UAAUmW,EAAA,IAE/F1C,MAAO,MACA0C,EAAG,WAAW,KAAK,GAAG,KAAK,CAAC,IAAI,EAAC,UAAUA,GAAI,UAAUnW,MAAM,EAAC,UAAUA,GAAI,UAAUmW,EAAA,IAE/F1C,MAAO,MACA0C,EAAG,WAAW,KAAK,GAAG,KAAK,CAAC,IAAI,EAAC,UAAUA,GAAI,UAAUnW,MAAM,EAAC,UAAUA,GAAI,UAAUmW,EAAA,IAI5F,EAAC,UAAUA,GAAI,UAAUnW,EAAA;AAAA,EACpC;AAAA,EAEAoW,KAA6B,MAAwB;AACjD,UAAMC,IAAU;AAAA,MACZ,IAAM,IAAI5E,IAAQ,SAAS,KAAK2C,IAAI,KAAKC,EAAE;AAAA,MAC3C,IAAM,IAAI5C,IAAQ,SAAS,KAAK2C,IAAI,KAAKE,EAAE;AAAA,MAC3C,IAAM,IAAI7C,IAAQ,SAAS,KAAK4C,IAAI,KAAKC,EAAE;AAAA,IAAA,GAGzCgC,IAAU;AAAA,MACZ,GAAK,IAAIpD,IAAO,WAAW,KAAKkB,IAAIiC,EAAQ,EAAE;AAAA,MAC9C,GAAK,IAAInD,IAAO,WAAW,KAAKmB,IAAIgC,EAAQ,EAAE;AAAA,MAC9C,GAAK,IAAInD,IAAO,WAAW,KAAKoB,IAAI+B,EAAQ,EAAE;AAAA,MAC9C,cAAgB;AAAA,IAAA,GAGdE,IAAY;AAAA,MACd,IAAM,IAAIrD,EAAA,EAAO,mBAAmBmD,EAAQ,IAAI,IAAIvE,EAAO,KAAKsC,IAAI,KAAKC,EAAE,EAAE,QAAQ;AAAA,MACrF,IAAM,IAAInB,EAAA,EAAO,mBAAmBmD,EAAQ,IAAI,IAAIvE,EAAO,KAAKsC,IAAI,KAAKE,EAAE,EAAE,QAAQ;AAAA,MACrF,IAAM,IAAIpB,EAAA,EAAO,mBAAmBmD,EAAQ,IAAI,IAAIvE,EAAO,KAAKuC,IAAI,KAAKC,EAAE,EAAE,QAAQ;AAAA,MACrF,cAAgB;AAAA,IAAA,GAGdkC,IAAU;AAAA,MACZ,GAAK,IAAItD,EAAA,EAAO,mBAAmB,KAAKkB,IAAI,IAAItC,EAAO,KAAKuC,IAAI,KAAKC,EAAE,EAAE,QAAQ;AAAA,MACjF,GAAK,IAAIpB,EAAA,EAAO,mBAAmB,KAAKmB,IAAI,IAAIvC,EAAO,KAAKsC,IAAI,KAAKE,EAAE,EAAE,QAAQ;AAAA,MACjF,GAAK,IAAIpB,EAAA,EAAO,mBAAmB,KAAKoB,IAAI,IAAIxC,EAAO,KAAKsC,IAAI,KAAKC,EAAE,EAAE,QAAQ;AAAA,MACjF,cAAgB;AAAA,IAAA,GAGdoC,IAAK,KAAKb,GAAoB,GAAG,GACnCc,IAAK,KAAKd,GAAoB,GAAG,GACjCe,IAAK,KAAKf,GAAoB,GAAG,GAE/BgB,IAAY;AAAA,MACd,GAAKH,EAAG;AAAA,MACR,GAAKC,EAAG;AAAA,MACR,GAAKA,EAAG;AAAA,MACR,cAAgB;AAAA,IAAA,GAGdG,IAAoB;AAAA,MACtB,GAAKJ,EAAG;AAAA,MACR,GAAKC,EAAG;AAAA,MACR,GAAKC,EAAG;AAAA,MACR,cAAgB;AAAA,IAAA,GAGdG,IAAiC;AAAA,MACnC,SAAAR;AAAA,MACA,WAAAC;AAAA,MACA,SAAAC;AAAA,MACA,WAAAI;AAAA,MACA,mBAAAC;AAAA,IAAA;AAIJ,WAAAC,EAAa,QAAQ,eAAeA,EAAa,QAAQ,EAAE,aAAaA,EAAa,QAAQ,CAAC,EAAE,OAChGA,EAAa,UAAU,eAAeA,EAAa,UAAU,GAAG,aAAaA,EAAa,UAAU,EAAE,EAAE,OACxGA,EAAa,QAAQ,eAAeA,EAAa,QAAQ,EAAE,aAAaA,EAAa,QAAQ,CAAC,EAAE,OAChGA,EAAa,UAAU,eAAeA,EAAa,UAAU,EAAE,aAAaA,EAAa,UAAU,CAAC,EAAE,OAG/FA;AAAA,EACX;AAAA,EAEAtB,GAAQuB,GAAkBC,GAAmBC,GAA2B;AACpE,UAAMC,KAAUF,KAAa,IAAIC,KAAa,IAAKF,KAAY,MAAM,IAAIC,IAAYC;AAErF,WAAO,KAAKzC,KACN,KAAK,KAAK0C,CAAK,IACf,KAAK,KAAKA,CAAK,IAAI,MAAM,KAAK;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMAC,KAAkB,CAACC,MAA0B;AACzC,YAAQA,EAAO,eAAY;AAAA,MACvB,KAAK;AACD,eAAO,KAAKhD;AAAA,MAChB,KAAK;AACD,eAAO,KAAKC;AAAA,MAChB,KAAK;AACD,eAAO,KAAKC;AAAA,IAAA;AAIpB,WAAO,KAAKF;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOAO,KAAc,CAAC0C,GAAiBC,MACrB,IAAIxF;AAAA,IACP,KAAKqF,GAAgBE,CAAO;AAAA,IAC5B,KAAKF,GAAgBG,CAAO;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA,EAOpC5C,KAAwB;AAEpB,gBAAKH,KAAS;AAAA,MACV,IAAM,IAAIrB,EAAK,KAAKkB,IAAI,KAAKC,EAAE;AAAA,MAC/B,IAAM,IAAInB,EAAK,KAAKmB,IAAI,KAAKC,EAAE;AAAA,MAC/B,IAAM,IAAIpB,EAAK,KAAKkB,IAAI,KAAKE,EAAE;AAAA,IAAA,GAGnC,KAAKG,KAAgB,KAAK2B,GAAA,GAEnB;AAAA,EACX;AACJ;AC3aO,MAAMmB,EAAS;AAAA,EAClBC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC;AAAA,EACAC;AAAA,EACA5b;AAAA,EAEA,cAAc;AACV,SAAKA,KAAY,KACjB,KAAKwb,KAAS,IACd,KAAKE,KAAU,IAEf,KAAKH,KAAW,KAChB,KAAKK,KAAO,KAEZ,KAAKH,KAAY,IAAI3e,EAAA,EAAW,KAAA,GAChC,KAAK6e,KAAQ,IAAI5G,EAAA;AAAA,EACrB;AAAA,EAEA,IAAI,MAAc;AACd,QAAI,KAAK4G,GAAM,OAAA,EAAU,QAAO,KAAKF,GAAU;AAE/C,QAAI,KAAKA,GAAU,OAAA,EAAU,QAAO,KAAKE,GAAM;AAE/C,UAAM,CAAC7d,CAAC,IAAIhB,EAAS,mBAAmB,KAAK2e,IAAW,KAAKE,GAAM,MAAM,GAEnEnd,IAAI,KAAKmd,GAAM,MAAA,EAAQ,SAAS7d,EAAE,WAAW,EAAE,OAAA,GAC/CC,IAAM,GAAGD,EAAE,SAAS,IAAIU,EAAE,WAAW,GAAG;AAE9C,WAAIV,EAAE,gBAAgB,IAAUC,IAEzB,WAAWA,CAAG,OAAOD,EAAE,WAAW;AAAA,EAC7C;AAAA,EAEA,IAAI,IAAIxD,GAAe;AACnB,SAAKshB,KAAOthB;AAAA,EAChB;AAAA,EAEA,IAAI,UAAkB;AAClB,WAAO,KAAKihB;AAAA,EAChB;AAAA,EAEA,IAAI,QAAQjhB,GAAe;AACvB,SAAKihB,KAAWjhB;AAAA,EACpB;AAAA,EAEA,OAAO,aAAaA,GAAuC;AACvD,UAAMgT,IAAM,IAAIgO,EAAA;AAChB,IAAAhO,EAAI,SAAA;AAEJ,UAAM5P,IAAI,IAAIZ,EAASxC,CAAK;AAC5B,WAAAgT,EAAI,UAAU5P,EAAE,SAChB4P,EAAI,MAAM5P,EAAE,KAEZ4P,EAAI,WAAW5P,GACf4P,EAAI,OAAO,IAAIyH,EAAA,GAERzH;AAAA,EACX;AAAA,EAEA,OAAO,cAAcjI,GAAyBpE,GAAyBzB,GAAqC;AACxG,UAAM,CAACnE,GAAGC,GAAGsH,CAAC,IAAI,CAACyC,GAAGpE,GAAGzB,CAAC,EAAE,IAAI,CAAAxE,MAAK,IAAI8B,EAAS9B,CAAC,CAAC,GAG9CyI,IAASnI,EAAE,MAAA,EAAQ,IAAI,CAAC,EAAE,SAASD,EAAE,MAAA,EAAQ,SAASuH,CAAC,EAAE,SAAS,CAAC,CAAC;AAC1E,QAAIa,EAAO;AACP,aAAO,CAAA;AAGX,QAAIA,EAAO,YAAY;AACnB,YAAMN,IAAQM,EAAO,KAAA,GACfoY,IAAQvgB,EAAE,MAAA,EAAQ,WAAW,SAAS6H,CAAK,EAAE,OAAO9H,EAAE,MAAA,EAAQ,SAAS,CAAC,CAAC,GACzEygB,IAAQxgB,EAAE,MAAA,EAAQ,WAAW,IAAI6H,CAAK,EAAE,OAAO9H,EAAE,MAAA,EAAQ,SAAS,CAAC,CAAC;AAE1E,aAAO8H,EAAM,OAAA,IACP,CAACmY,EAAS,aAAaO,CAAK,CAAC,IAC7B,CAACP,EAAS,aAAaO,CAAK,GAAGP,EAAS,aAAaQ,CAAK,CAAC;AAAA,IACrE;AAEA,UAAMC,IAAO,IAAIT,EAAA;AACjB,IAAAS,EAAK,WAAWzgB,EAAE,QAAQ,WAAW,OAAOD,CAAC,EAAE,OAAO,CAAC,GACvD0gB,EAAK,OAAO,IAAIhH,EAAA,EAAO,KAAK,GAAGtR,GAAQpI,EAAE,MAAA,EAAQ,SAAS,CAAC,EAAE,QAAA,EAAU,UAAU,GACjF0gB,EAAK,SAAS,EAAK;AAEnB,UAAMC,IAAO,IAAIV,EAAA;AACjB,WAAAU,EAAK,WAAW1gB,EAAE,QAAQ,WAAW,OAAOD,CAAC,EAAE,OAAO,CAAC,GACvD2gB,EAAK,OAAO,IAAIjH,EAAA,EAAO,KAAK,GAAGtR,GAAQpI,EAAE,MAAA,EAAQ,SAAS,CAAC,EAAE,SAAS,GACtE2gB,EAAK,SAAS,EAAK,GAEZ,CAACD,GAAMC,CAAI;AAAA,EACtB;AAAA,EAEA,IAAI,QAAiB;AACjB,WAAO,KAAKR;AAAA,EAChB;AAAA,EAEA,IAAI,MAAMlhB,GAAgB;AACtB,SAAKkhB,KAASlhB;AAAA,EAClB;AAAA,EAEA,IAAI,WAAqB;AACrB,WAAO,KAAKmhB;AAAA,EAChB;AAAA,EAEA,IAAI,SAASnhB,GAAiB;AAC1B,SAAKmhB,KAAYnhB;AAAA,EACrB;AAAA,EAEA,QAAQA,IAAQ,IAAY;AACxB,gBAAKohB,KAAUphB,GACR;AAAA,EACX;AAAA,EAEA,IAAI,SAAkB;AAClB,WAAO,KAAKohB;AAAA,EAChB;AAAA,EAEA,IAAI,OAAOphB,GAAgB;AACvB,SAAKohB,KAAUphB;AAAA,EACnB;AAAA,EAEA,SAAe;AAEX,gBAAKqhB,GAAM,OAAA,GACX,KAAKF,GAAU,OAAA,GAER;AAAA,EACX;AAAA,EAEA,IAAI,OAAa;AACb,WAAO,KAAKE;AAAA,EAChB;AAAA,EAEA,IAAI,KAAKrhB,GAAa;AAClB,SAAKqhB,KAAQrhB;AAAA,EACjB;AAAA,EAEA,SAASA,IAAQ,IAAY;AACzB,gBAAKkhB,KAASlhB,GACP;AAAA,EACX;AAAA,EAEA,IAAI,QAAgB;AAChB,UAAM,IAAI,MAAM,mBAAmB;AAAA,EACvC;AAAA,EAEA,IAAI,WAAmB;AACnB,WAAO,KAAK0F;AAAA,EAChB;AAAA,EAEA,IAAI,SAAS1F,GAA2B;AACpC,IAAIA,MAAU,WAId,KAAK0F,KAAY1F;AAAA,EACrB;AACJ;ACrJO,MAAM2hB,EACwB;AAAA,EAEjCC,KAAwB;AAAA,EACxBC,KAA6B;AAAA,EAC7BC,KAAgC;AAAA,EAChCC,KAAiC;AAAA,EAQjC,eAAexhB,GAAmB;AAC9B,IAAIA,EAAO,SAAS,KAChB,KAAK,MAAM,GAAGA,CAAM;AAAA,EAE5B;AAAA,EAEA,SAASA,GAAyB;AAS9B,WAAI,OAAOA,EAAO,CAAC,KAAM,WACd,KAAK,WAAWA,EAAO,CAAC,CAAC,IAGhCA,EAAO,CAAC,aAAa8R,IACd,KAAK,aAAa9R,EAAO,CAAC,CAAC,IAGlCA,EAAO,CAAC,aAAaohB,IACd,KAAK,KAAKphB,EAAO,CAAC,CAAC,IAG1BA,EAAO,WAAW,KAClBA,EAAO,CAAC,aAAa2a,KAAS3a,EAAO,CAAC,aAAa2a,IAG5C,KAAK,gBAAgB3a,EAAO,CAAC,GAAGA,EAAO,CAAC,CAAC,IAGhDA,EAAO,UAAU,KAAKA,EAAO,CAAC,aACnB2a,MACV3a,EAAO,CAAC,aAAaiC,KAAY,OAAOjC,EAAO,CAAC,KAAM,YAGhD,KAAK;AAAA,MACRA,EAAO,CAAC;AAAA,MAAGA,EAAO,CAAC;AAAA,MAClB,OAAOA,EAAO,CAAC,KAAM,YAAaA,EAAO,CAAC,IAAI;AAAA,IAAA,IAIhD;AAAA,EACX;AAAA,EAEA,QAAgB;AACZ,WAAO,IAAIohB,IAAS;AAAA,MAChB,KAAK,OAAO,MAAA;AAAA,MACZ,KAAK,aAAa,MAAA;AAAA,MAClB;AAAA,IAAA;AAAA,EAER;AAAA,EAEA,KAAKK,GAAsB;AACvB,gBAAKJ,KAAUI,EAAO,OAAO,MAAA,GAC7B,KAAKD,KAAgBC,EAAO,aAAa,MAAA,GAEzC,KAAKC,GAAA,GAEE;AAAA,EACX;AAAA,EAEA,IAAI,MAAc;AACd,QAAI,KAAKH,OAAkB;AACvB,aAAO,KAAK,SAAS,SAAA,EAAW,SAAS;AAG7C,QAAII,GAAIC;AACR,WAAI,KAAK,OAAO,EAAE,OAAA,IACdD,IAAK,QAELA,IAAK,WAAW,KAAK,OAAO,EAAE,WAAA,IAAe,MAAM,GAAG,GAAG,KAAK,OAAO,EAAE,MAAA,EAAQ,IAAA,EAAM,GAAG,cAExF,KAAK,OAAO,EAAE,OAAA,IACdC,IAAK,QAELA,IAAK,WAAW,KAAK,OAAO,EAAE,WAAA,IAAe,MAAM,GAAG,GAAG,KAAK,OAAO,EAAE,MAAA,EAAQ,IAAA,EAAM,GAAG,cAErF,GAAGD,CAAE,IAAIC,CAAE,IAAI,KAAK,aAAa,GAAG;AAAA,EAC/C;AAAA,EAEA,IAAI,UAAkB;AAClB,QAAI,KAAKL,OAAkB;AACvB,aAAO,KAAK,SAAS,SAAA,EAAW,SAAS;AAG7C,QAAII,GAAIC;AACR,WAAI,KAAK,OAAO,EAAE,OAAA,IACdD,IAAK,QAELA,IAAK,KAAK,KAAK,OAAO,EAAE,WAAA,IAAe,MAAM,GAAG,GAAG,KAAK,OAAO,EAAE,MAAA,EAAQ,IAAA,EAAM,GAAG,OAElF,KAAK,OAAO,EAAE,OAAA,IACdC,IAAK,QAELA,IAAK,KAAK,KAAK,OAAO,EAAE,WAAA,IAAe,MAAM,GAAG,GAAG,KAAK,OAAO,EAAE,MAAA,EAAQ,IAAA,EAAM,GAAG,OAE/E,GAAGD,CAAE,IAAIC,CAAE,IAAI,KAAK,aAAa,OAAO;AAAA,EACnD;AAAA,EAEA,IAAI,cAAoB;AACpB,gBAAKL,KAAgB,GACd;AAAA,EACX;AAAA,EAEA,IAAI,iBAAuB;AACvB,gBAAKA,KAAgB,GACd;AAAA,EACX;AAAA,EAEA,IAAI,SAAgB;AAChB,WAAO,KAAKF,MAAW,IAAI1G,EAAA;AAAA,EAC/B;AAAA,EAEA,IAAI,WAAqB;AACrB,WAAO,KAAK2G,IAAW,MAAA,KAAW,IAAIxP,EAAS,KAAK;AAAA,EACxD;AAAA,EAEA,gBAAgB+P,GAAeC,GAA2B;AACtD,gBAAKT,KAAUQ,EAAO,MAAA,GACtB,KAAKL,KAAgB,IAAIxG,EAAO,KAAKqG,IAASS,CAAY,EAAE,YAE5D,KAAKJ,GAAA,GAEE;AAAA,EACX;AAAA,EAEA,iBAAiBG,GAAeE,GAA2BC,GAAwB;AAC/E,gBAAKX,KAAUQ,EAAO,MAAA,GAClBG,IACA,KAAKR,KAAiB,IAAIvf,EAAS8f,CAAM,IAEzC,KAAKP,KAAgB,IAAIvf,EAAS8f,CAAM,EAAE,IAAI,CAAC,GAGnD,KAAKL,GAAA,GAEE;AAAA,EACX;AAAA,EAEA,aAAanc,GAAqB;AAI9B,QAFAA,EAAI,SAAA,GAEAA,EAAI,OAAO,GAAG,EAAE,UAAU,KAAKA,EAAI,OAAO,GAAG,EAAE,UAAU,GAAG;AAE5D,YAAMiD,IAAKjD,EAAI,KAAK,cAAc,GAAG,GAAG,GAAGwY,IAAKxY,EAAI,KAAK,cAAc,GAAG,GAAG;AAC7E,UAAIgD,GAAWuV,GAAW/V;AAG1B,UAAIS,EAAG,YAAY,QAAQuV,EAAG,WAAW;AACrC,eAAAxY,EAAI,OAAOiD,EAAG,WAAW,GAEzBD,IAAKhD,EAAI,KAAK,cAAc,GAAG,GAAG,GAClCuY,IAAKvY,EAAI,KAAK,cAAc,GAAG,GAAG,GAElCwC,IAAIxC,EAAI,KAAK,cAAc,CAAC,GAE5B,KAAK8b,KAAU,IAAI1G,EAAMpS,EAAG,YAAY,MAAA,EAAQ,OAAO,CAAC,EAAE,YAAYuV,EAAG,YAAY,MAAA,EAAQ,OAAO,CAAC,EAAE,UAAU,GAEjH,KAAK0D,KAAgBzZ,EAAE,YAAY,MAAA,EAAQ,WACtC,IAAI,KAAKsZ,GAAQ,EAAE,QAAQ,IAAI,CAAC,CAAC,EACjC,IAAI,KAAKA,GAAQ,EAAE,MAAA,EAAQ,IAAI,CAAC,CAAC,GAEtC,KAAKK,GAAA,GAEE;AAGP,WAAKO,GAAA;AAAA,IAEb;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,WAAWzX,GAAUpE,GAAUzB,GAAgB;AAC3C,UAAM8E,IAAI,IAAI4T,EAAS7S,GAAGpE,GAAGzB,CAAC;AAC9B,QAAI,CAAC8E,EAAE,WAAW,CAACA,EAAE;AACjB,kBAAKwY,GAAA,GACE;AAGX,UAAMC,IAAMzY,EAAE,aAAa,UAAU,GAAG,MAAA,GAClC0Y,IAAM1Y,EAAE,aAAa,UAAU,GAAG,MAAA;AACxC,gBAAK,MAAMyY,EAAI,aAAaC,CAAG,EAAE,OAAO3X,CAAC,GAElC;AAAA,EACX;AAAA,EAEA,WAAWoC,GAAmB;AAC1B,WAAO,KAAK,aAAa,IAAIkF,EAASlF,CAAG,CAAC;AAAA,EAC9C;AAAA,EAEA,oBAA6B;AAGzB,UAAMvL,IAAWU,EAAQ,8BAA8B,KAAK,aAAa,OAAO,EAAI,GAE9EqgB,IAAkB,CAAA;AAExB,WAAA/gB,EAAS,QAAQ,CAAAghB,MAAW;AAKxB,iBAAWxe,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,GAAG,EAAE,CAAC;AAC/C,QAAAue,EAAO;AAAA,UAAK,IAAIzH;AAAA,YACR,KAAK,OAAO,EAAE,QAAQ,IAAI9W,EAAE,CAAC,IAAIwe,EAAQ,CAAC,CAAC;AAAA,YAC3C,KAAK,OAAO,EAAE,MAAA,EAAQ,IAAIxe,EAAE,CAAC,IAAIwe,EAAQ,CAAC,CAAC;AAAA,UAAA;AAAA,QAC/C;AAAA,IAGZ,CAAC,GACMD;AAAA,EACX;AAAA,EAEA,kBAAkB,CAAC/Z,MACR,KAAKiZ,IAAW,KAAK,EAAC,GAAGjZ,EAAE,GAAG,GAAGA,EAAE,EAAA,CAAE,KAAK;AAAA,EAGrD,iBAAiByC,GAAkB;AAC/B,QAAI,KAAKwW,OAAc;AACnB,aAAO,CAAA;AAGX,UAAMO,IAAS,KAAK,QACd7Z,IAAI8C,EAAE,GACNwX,IAAKxX,EAAE,IAGPN,IAAIxC,EAAE,YAEN5B,IAAIkc,EAAG,EAAE,MAAA,EAAQ,SAAST,EAAO,CAAC,EAAE,SAAS7Z,EAAE,CAAC,EACjD,IAAIsa,EAAG,EAAE,MAAA,EAAQ,SAAST,EAAO,CAAC,EAAE,SAAS7Z,EAAE,CAAC,CAAC,EACjD,SAAS,CAAC,GAETrD,IAAI2d,EAAG,EAAE,MAAA,EAAQ,SAAST,EAAO,CAAC,EAAE,IAAI,CAAC,EAC1C,IAAIS,EAAG,EAAE,MAAA,EAAQ,SAAST,EAAO,CAAC,EAAE,IAAI,CAAC,CAAC,EAC1C,SAAS,KAAK,YAAY,GAEzBpP,IAAMgO,EAAS,cAAcjW,GAAGpE,GAAGzB,CAAC;AAE1C,QAAI8N,EAAI,WAAW;AACf,aAAO,CAAA;AAIX,QAAIA,EAAI,WAAW,GAAG;AAClB,YAAM8P,IAAKD,EAAG,IAAIta,EAAE,QAAQ,iBAAiByK,EAAI,CAAC,EAAE,QAAQ,CAAC;AAC7D,aAAO;AAAA,QACH,IAAIkI,EAAM4H,EAAG,GAAGA,EAAG,CAAC;AAAA,MAAA;AAAA,IAE5B;AAGA,QAAI9P,EAAI,CAAC,EAAE,SAASA,EAAI,CAAC,EAAE,OAAO;AAE9B,YAAM+P,IAAMF,EAAG,IAAIta,EAAE,QAAQ,iBAAiByK,EAAI,CAAC,EAAE,QAAQ,CAAC,GACxDgQ,IAAMH,EAAG,IAAIta,EAAE,QAAQ,iBAAiByK,EAAI,CAAC,EAAE,QAAQ,CAAC;AAC9D,aAAO;AAAA,QACH,IAAIkI,EAAM6H,EAAI,GAAGA,EAAI,CAAC;AAAA,QACtB,IAAI7H,EAAM8H,EAAI,GAAGA,EAAI,CAAC;AAAA,MAAA;AAAA,IAE9B;AAEA,UAAMD,IAAMF,EAAG,IAAIta,EAAE,QAAQ,iBAAiByK,EAAI,CAAC,EAAE,KAAK,CAAC,GACrDgQ,IAAMH,EAAG,IAAIta,EAAE,QAAQ,iBAAiByK,EAAI,CAAC,EAAE,KAAK,CAAC;AAC3D,WAAO;AAAA,MACH,IAAIkI,EAAM6H,EAAI,GAAGA,EAAI,CAAC;AAAA,MACtB,IAAI7H,EAAM8H,EAAI,GAAGA,EAAI,CAAC;AAAA,IAAA;AAAA,EAE9B;AAAA,EAEA,IAAI,SAAe;AACf,WAAO,IAAIvI,EAAA,EAAO,KAAK,GAAG,KAAKsH,MAAiB,CAAC;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,iBAAiB1W,GAAiB;AACrC,QAAI,KAAKuW,OAAY,QAAQ,KAAKG,OAAkB;AAChD,aAAO;AAGX,UAAMkB,IAAW5X,EAAE,WAAW,KAAKuW,EAAO,EAAE,IAAI,CAAC,EAAE,OAC7CU,IAAS,KAAKP,GAAc;AAElC,WAAIkB,IAAWX,IAAS,QACb,IAGP,KAAK,IAAIW,IAAWX,CAAM,IAAI,QACvB,IAGJ;AAAA,EACX;AAAA,EAEA,UAAUA,GAA2BC,GAAwB;AACzD,WAAIA,IACA,KAAKR,KAAgB,IAAIvf,EAAS8f,CAAM,IAExC,KAAKP,KAAgB,IAAIvf,EAAS8f,CAAM,EAAE,IAAI,CAAC,GAGnD,KAAKL,GAAA,GACE;AAAA,EACX;AAAA,EAEA,IAAI,eAAyB;AACzB,WAAO,KAAKF,IAAe,MAAA,KAAW,IAAIvf,EAAS,EAAE;AAAA,EACzD;AAAA,EAEA,WAAW,CAACoG,MACJA,aAAapG,IACN,KAAK0gB,GAAmBta,CAAC,IAGhC,KAAK,gBAAgBA,CAAC,IACf,KAAKua,GAAoCva,CAAC,IAGjD,KAAKgZ,OAAY,QAAQ,KAAKA,GAAQ,WAAWhZ,CAAC,EAAE,QAAQ,KAAK,OAAO,QAEjE,KAAKwa,GAAyCxa,CAAC,KAG1D,QAAQ,IAAI,sCAAsC,GAC3C,CAAA;AAAA,EAGXqZ,KAA4B;AACxB,SAAKJ,KACD,IAAIxP;AAAA,MACA,IAAIzE,EAAQ,OAAO,KAAK,OAAO,EAAE,OAAO,YAAY,KAAK,OAAO,EAAE,OAAO,MAAM;AAAA,MAC/E,IAAIA,EAAQ,KAAK,aAAa,OAAO;AAAA,IAAA,EAC3C,SAAA;AAAA,EACN;AAAA,EAEA4U,KAAS;AACL,SAAKZ,KAAU,MACf,KAAKG,KAAgB,MACrB,KAAKF,KAAY;AAAA,EACrB;AAAA,EAEAsB,KAAsC,CAACva,MAAqB;AACxD,UAAMya,IAAK,IAAI9H,EAAO,KAAK,QAAQ3S,CAAC;AACpC,WAAO,CAAC,IAAI+T,EAAA,EAAO,mBAAmB/T,GAAGya,CAAE,CAAC;AAAA,EAChD;AAAA,EAEAD,KAA2C,CAACxa,MAAqB;AAO7D,UAAM0a,IAAQ,KAAK,OAAO,EAAE,MAAA,EAAQ,SAAS1a,EAAE,CAAC,GAAG2a,IAAQ,KAAK,OAAO,EAAE,MAAA,EAAQ,SAAS3a,EAAE,CAAC,GACzF4a,IAAW,IAAI5V,EAAQ,GAAG,GAAG6V,IAAY,IAAI7V,EAAQ,OAAO;AAEhE,WAAA4V,EAAS,SAASF,CAAK,EAAE,SAASC,CAAK,EAAE,IAAI,CAAC,GAC9CE,EAAU,SAAS,KAAK,YAAY,GAExB,IAAIpR,EAASmR,GAAUC,CAAS,EACtB,MAAA,EAEL,IAAI,CAAAzQ,MAAO;AAExB,UAAIxI;AACJ,YAAM1E,IAAM,IAAIuM,EAAS,KAAK,GAAG;AAEjC,aAAIW,EAAI,iBAAiBxQ,KACrBgI,IAAI5B,EAAE,EAAE,MAAA,EAAQ,SAAA,EAAW,SAASoK,EAAI,KAAK,EAAE,IAAIpK,EAAE,CAAC,GACtD9C,EAAI,MAAM,SAASkN,EAAI,KAAK,EAAE,IAAIxI,CAAC,MAEnCA,IAAI5B,EAAE,EAAE,MAAA,EAAQ,SAAA,EAAW,SAASoK,EAAI,KAAK,EAAE,IAAIpK,EAAE,CAAC,GACtD9C,EAAI,MAAM,SAASkN,EAAI,KAAK,EAAE,IAAIxI,CAAC,IAGhC,IAAImS,EAAK7W,CAAG;AAAA,IACvB,CAAC;AAAA,EAEL;AAAA,EAEAod,KAAqB,CAACQ,MAA4B;AAK9C,UAAM3iB,IAAI2iB,EAAM,WAAW1iB,IAAI,CAAC0iB,EAAM,aAAaC,IAAK,KAAK,OAAO,EAAE,SAASC,IAAK,KAAK,OAAO,EAAE,MAAA,GAE5FC,IAAK,KAAK,aAAa,MAAA,EAAQ,SAASH,EAAM,aAAa,IAAIA,EAAM,eAAe,CAAC,GACvF5a,IAAK6a,EAAG,QAAQ,SAAS5iB,CAAC,EAAE,SAAA,EAAW,SAAS6iB,EAAG,MAAA,EAAQ,SAAS5iB,CAAC,CAAC,EAAE,IAAI6iB,EAAG,MAAA,EAAQ,KAAA,CAAM,GAC7F9a,IAAK4a,EAAG,QAAQ,SAAS5iB,CAAC,EAAE,SAAA,EAAW,SAAS6iB,EAAG,MAAA,EAAQ,SAAS5iB,CAAC,CAAC,EAAE,SAAS6iB,EAAG,MAAA,EAAQ,KAAA,CAAM;AAEtG,WAAO,CAAC,IAAIlH,EAAK5b,GAAGC,GAAG8H,CAAE,GAAG,IAAI6T,EAAK5b,GAAGC,GAAG+H,CAAE,CAAC;AAAA,EAClD;AAEJ;ACtaO,MAAM+a,EAAM;AAAA,EACf,OAAO,WAAWhI,EAAe;AAAA;AAAA,EAEjC,OAAO,gBAAgBA,EAAe;AAAA;AAAA,EAEtCc,KAAa,IAAI1B,EAAA;AAAA,EACjB6I,KAAa,IAAIxI,EAAA;AAAA,EASjB,YAAYxQ,GAAUxC,GAAmB;AACrC,gBAAKqU,KAAM7R,EAAE,MAAA,GACb,KAAKgZ,KAAMxb,aAAa2S,IAAS,IAAIK,EAAOxQ,GAAGxC,CAAC,IAAIA,EAAE,MAAA,GAC/C;AAAA,EACX;AAAA,EAEA,QAAQ,OACJ,KAAKwb,KAAK,KAAKA,GAAG,MAAA,GAClB,KAAKnH,KAAM,KAAKA,GAAI,MAAA,GAEb;AAAA,EAGX,IAAI,MAAiE;AACjE,WAAO;AAAA,MACH,YAAY,GAAGrB,EAAO,MAAM,KAAK,KAAK,GAAG,CAAC,MAAMA,EAAO,MAAM,KAAKqB,GAAI,EAAE,KAAK,KAAKA,GAAI,EAAE,KAAK,KAAKA,GAAI,EAAE,GAAG,CAAC,cAAcrB,EAAO,MAAM,KAAKwI,GAAG,EAAE,KAAK,KAAKA,GAAG,EAAE,KAAK,KAAKA,GAAG,EAAE,GAAG,CAAC;AAAA,MACnL,QAAQ;AAAA,WACR,IAAInW,EAAQ,KAAKgP,GAAI,CAAC,EACb,IAAI,IAAI5R,EAAM,KAAK+Y,GAAG,CAAC,EAAE,SAAS,IAAI/Y,EAAM,GAAG,CAAC,CAAC,EACjD,QAAQ,KAAK,EAAI,EACjB,GAAG;AAAA,WACZ,IAAI4C,EAAQ,KAAKgP,GAAI,CAAC,EACb,IAAI,IAAI5R,EAAM,KAAK+Y,GAAG,CAAC,EAAE,SAAS,IAAI/Y,EAAM,GAAG,CAAC,CAAC,EACjD,QAAQ,KAAK,EAAI,EACjB,GAAG;AAAA,WACZ,IAAI4C,EAAQ,KAAKgP,GAAI,CAAC,EACb,IAAI,IAAI5R,EAAM,KAAK+Y,GAAG,CAAC,EAAE,SAAS,IAAI/Y,EAAM,GAAG,CAAC,CAAC,EACjD,QAAQ,KAAK,EAAI,EACjB,GAAG;AAAA;AAAA,MAEZ,WAAW,WAAW,IAAI4C,EAAQ,KAAK,GAAG,KAAKgP,GAAI,EAAE,MAAA,EAAQ,SAAA,CAAU,EAAE,GAAG,OAAO,KAAK,UAAU,EAAE,GAAG,gBAAgB,IAAIhP,EAAQ,KAAK,GAAG,KAAKgP,GAAI,EAAE,QAAQ,SAAA,CAAU,EAAE,GAAG,OAAO,KAAK,UAAU,EAAE,GAAG,gBAAgB,IAAIhP,EAAQ,KAAK,GAAG,KAAKgP,GAAI,EAAE,MAAA,EAAQ,SAAA,CAAU,EAAE,GAAG,OAAO,KAAK,UAAU,EAAE,GAAG;AAAA,IAAA;AAAA,EAEjT;AAAA,EAEA,IAAI,UAAqE;AACrE,UAAMoH,IAAM,KAAKpH,GAAI,EAAE,SACjBqH,IAAM,KAAKrH,GAAI,EAAE,SACjBsH,IAAM,KAAKtH,GAAI,EAAE,SACjBpY,IAAI,KAAK,UAAU,SAAA,GACnB2f,IAAK3f,EAAE,EAAE,SACT4f,IAAK5f,EAAE,EAAE,SACT6f,IAAK7f,EAAE,EAAE;AAEf,WAAO;AAAA,MACH,YAAY,GAAG+W,EAAO,UAAU,KAAK,KAAK,GAAG,CAAC,MAAMA,EAAO,UAAU,KAAKqB,GAAI,EAAE,SAAS,KAAKA,GAAI,EAAE,SAAS,KAAKA,GAAI,EAAE,OAAO,CAAC,cAAcrB,EAAO,UAAU,KAAKwI,GAAG,EAAE,SAAS,KAAKA,GAAG,EAAE,SAAS,KAAKA,GAAG,EAAE,OAAO,CAAC;AAAA,MACvN,QAAQ;AAAA,MACR,WAAW,MAAMC,CAAG,KAAKG,CAAE,SAASF,CAAG,KAAKG,CAAE,SAASF,CAAG,KAAKG,CAAE;AAAA,IAAA;AAAA,EAEzE;AAAA,EAEA,IAAI,KAAY;AACZ,WAAO,KAAKzH;AAAA,EAChB;AAAA,EAEA,IAAI,GAAG5c,GAAc;AACjB,SAAK4c,KAAM5c;AAAA,EACf;AAAA,EAEA,IAAI,IAAY;AACZ,WAAO,KAAK+jB;AAAA,EAChB;AAAA,EAEA,IAAI,EAAE/jB,GAAe;AACjB,SAAK+jB,KAAK/jB;AAAA,EACd;AAAA,EAEA,IAAI,YAAoB;AACpB,WAAO,KAAK+jB,GAAG,MAAA;AAAA,EACnB;AAAA,EAEA,WAAW7G,GAA+D;AAGtE,UAAMoH,IAAK,IAAI/I,EAAO,KAAKqB,IAAKM,CAAE,GAC9B3U,IAAI,KAAK,WACT4U,IAAK,KAAK,UAAU,YACpBoH,IAAOD,EAAG,MAAM/b,CAAC,EAAE,YACnBic,IAASD,EAAK,MAAA,EAAQ,OAAOpH,CAAE,GAC/BsH,IAAOD,EAAO,MAAA,EAAQ,KAAA;AAE1B,mBAAQ,IAAI,SAASF,EAAG,MAAM/b,CAAC,EAAE,OAAO,GACjC;AAAA,MACH,OAAO,KAAK,KAAKic,EAAO,KAAK;AAAA,MAC7B,UAAUA,EAAO,MAAA,EAAQ,KAAA;AAAA,MACzB,KAAKC,EAAK,QAAA,IAAYA,EAAK,MAAM,UAAUD,EAAO,GAAG;AAAA,IAAA;AAAA,EAE7D;AAAA;AAAA;AAAA,EAIA,WAAWzZ,GAAUpE,GAAmB;AACpC,UAAM2W,IAAM,KAAK;AAAA,MACb,IAAIwG,EAAM/Y,GAAGpE,CAAC;AAAA,IAAA;AAIlB,WAAI2W,EAAI,kBACGA,EAAI,MAAM,EAAE,SAAS,KAAK,IAAIvS,EAAE,EAAE,OAAOpE,EAAE,EAAE,KAAK,KAClD2W,EAAI,MAAM,EAAE,SAAS,KAAK,IAAIvS,EAAE,EAAE,OAAOpE,EAAE,EAAE,KAAK,KAClD2W,EAAI,MAAM,EAAE,SAAS,KAAK,IAAIvS,EAAE,EAAE,OAAOpE,EAAE,EAAE,KAAK,KAClD2W,EAAI,MAAM,EAAE,SAAS,KAAK,IAAIvS,EAAE,EAAE,OAAOpE,EAAE,EAAE,KAAK,KAClD2W,EAAI,MAAM,EAAE,SAAS,KAAK,IAAIvS,EAAE,EAAE,OAAOpE,EAAE,EAAE,KAAK,KAClD2W,EAAI,MAAM,EAAE,SAAS,KAAK,IAAIvS,EAAE,EAAE,OAAOpE,EAAE,EAAE,KAAK,IAEtD;AAAA,EACX;AAAA,EAEA,eAAe,CAAC4W,MAAmG;AAE/G,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC7C;AAAA;AAAA,EAGA,WAAW,CAACL,MACD;AAAA,EAGX,eAAe,CAACK,MAAyB;AAErC,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC7C;AAAA,EAEA,oBAAoB,CAACA,MAAyB;AAC1C,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC7C;AAAA,EAEA,WAAW,CAACA,MAAyB;AACjC,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC7C;AAAA,EAEA,aAAa,MAAe;AACxB,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC7C;AAAA,EAEA,IAAI,QAAe;AACf,WAAO,KAAKX,GAAI,MAAA;AAAA,EACpB;AAAA,EAEA,cAAc,CAACR,IAAM,MAAa;AAC9B,UAAMrR,IAAI,KAAK6R,GAAI,MAAA,GACfxY,IAAI,IAAI5B,EAAS2Z,EAAaC,GAAK,EAAK,CAAC;AAE7C,WAAO,IAAIlB;AAAA,MACPnQ,EAAE,EAAE,MAAA,EAAQ,IAAI,KAAKgZ,GAAG,EAAE,MAAA,EAAQ,SAAS3f,CAAC,CAAC;AAAA,MAC7C2G,EAAE,EAAE,MAAA,EAAQ,IAAI,KAAKgZ,GAAG,EAAE,MAAA,EAAQ,SAAS3f,CAAC,CAAC;AAAA,MAC7C2G,EAAE,EAAE,MAAA,EAAQ,IAAI,KAAKgZ,GAAG,EAAE,QAAQ,SAAS3f,CAAC,CAAC;AAAA,IAAA;AAAA,EAErD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuBA,WAAW,MAAY;AACnB,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAW7C;AACJ;AC1MO,MAAMsgB,GAAO;AAAA,EAChBC,KAAkB,IAAIpJ,EAAO,GAAG,GAAG,CAAC;AAAA,EACpCqJ,KAAgB,IAAI1J,EAAM,GAAG,GAAG,CAAC;AAAA,EAEjC,YAAY2J,GAAuB;AAC/B,WAAIA,KACA,KAAK,MAAMA,CAAM,GAGd;AAAA,EACX;AAAA,EAEA,MAAMA,GAAsB;AACxB,QAAIA,EAAO,SAASA,EAAO,QAAQ;AAC/B,WAAK,QAAQA,EAAO,OACpB,KAAK,SAASA,EAAO;AACrB;AAAA,IACJ;AAEA,QAAIA,EAAO,SAASA,EAAO,YAAY,WAAW,GAAG;AACjD,WAAK,QAAQA,EAAO;AACpB,YAAM,CAAC5K,GAAIC,CAAE,IAAI2K,EAAO;AACxB,WAAK,SAAS5K,EAAG,MAAMC,CAAE;AACzB;AAAA,IACJ;AAEA,QAAI2K,EAAO,UAAU;AACjB,YAAMC,IAAYD,EAAO,SAAS,SAAA,EAAW,SAAS,MAEhD9jB,IAAI+jB,EAAU,cAAc,GAAG,EAAE,aACjC9jB,IAAI8jB,EAAU,cAAc,GAAG,EAAE,aACjCxc,IAAIwc,EAAU,cAAc,GAAG,EAAE,aACjCvc,IAAIuc,EAAU,cAAc,CAAC,EAAE;AAGrC,WAAK,SAAS,IAAIvJ,EAAOxa,GAAGC,GAAGsH,CAAC,GAG5BvH,EAAE,cACF,KAAK,QAAQ,IAAIma,EAAM3S,EAAE,MAAA,EAAQ,OAAOxH,CAAC,EAAE,YAAY,GAAG,CAAC,IACpDC,EAAE,cACT,KAAK,QAAQ,IAAIka,EAAM,GAAG3S,EAAE,MAAA,EAAQ,OAAOvH,CAAC,EAAE,SAAA,GAAY,CAAC,IAE3D,KAAK,QAAQ,IAAIka,EAAM,GAAG,GAAG3S,EAAE,MAAA,EAAQ,OAAOD,CAAC,EAAE,SAAA,CAAU;AAG/D;AAAA,IACJ;AAEA,QAAIuc,EAAO,QAAQ,WAAW,KAAKA,EAAO,OAAO,MAAM,CAAA3hB,MAAKA,aAAaqY,CAAM,GAAG;AAC9E,YAAMxQ,IAAI8Z,EAAO,OAAO,CAAC,GACnBle,IAAIke,EAAO,OAAO,CAAC,GACnB3f,IAAI2f,EAAO,OAAO,CAAC,GAEnBjG,IAAK,IAAIrD,EAAOxQ,GAAGpE,CAAC,GACpBmY,IAAK,IAAIvD,EAAOxQ,GAAG7F,CAAC;AAC1B,WAAK,SAAS0Z,EAAG,MAAME,CAAE,GACzB,KAAK,QAAQ/T;AACb;AAAA,IACJ;AAEA,QAAI8Z,EAAO,cAAc,WAAW,GAAG;AACnC,YAAM,CAAC9jB,GAAGC,GAAGsH,GAAGC,CAAC,IAAIsc,EAAO;AAC5B,WAAK,SAAS,IAAItJ,EAAOxa,GAAGC,GAAGsH,CAAC,GAChC,KAAK,QAAQ,IAAI4S,EAAM,GAAG,GAAG,CAAC3S,CAAC;AAC/B;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,IAAI,MAAc;AAEd,WAAO,IAAI8J;AAAA,MACP,IAAIzE,EAAQ,OAAO,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAAA,MACjD,IAAIA,EAAQ,CAAC;AAAA,IAAA,EACf,SAAS;AAAA,EACf;AAAA,EAEA,IAAI,UAAkB;AAElB,WAAO,IAAIyE;AAAA,MACP,IAAIzE,EAAQ,OAAO,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAAA,MACjD,IAAIA,EAAQ,CAAC;AAAA,IAAA,EACf,SAAS;AAAA,EACf;AAAA,EAEA,IAAI,IAAc;AACd,WAAO,KAAK+W,GAAQ;AAAA,EACxB;AAAA,EAQA,MAAM3kB,GAAgCwb,GAAiBC,GAA0B;AAC7E,QAAIzb,aAAiB0kB;AACjB,aAAO,KAAK,OAAO,MAAM1kB,EAAM,QAAQwb,GAAOC,CAAM;AAGxD,QAAIsJ;AACJ,QAAI/kB,aAAiBub,GAAQ;AACzB,UAAIvb,EAAM,cAAc;AACpB,cAAM,IAAI,MAAM,kBAAkB;AAGtC,MAAA+kB,IAAY/kB;AAAA,IAChB;AACI,MAAA+kB,IAAY/kB,EAAM;AAItB,YADYyb,IAAS,KAAK,KAAK,IAAI,MACtB,KAAK,OAAO,MAAMsJ,GAAW,IAAMtJ,CAAM;AAAA,EAC1D;AAAA,EAEA,IAAI,IAAc;AACd,WAAO,KAAKkJ,GAAQ;AAAA,EACxB;AAAA,EAEA,IAAI,IAAc;AACd,WAAO,KAAKA,GAAQ;AAAA,EACxB;AAAA,EAEA,IAAI,IAAc;AACd,WAAO,KAAKA,GAAQ,IAAI,KAAKC,EAAM,EAAE,SAAA;AAAA,EACzC;AAAA,EAEA,WAAWI,GAAuB;AAC9B,WAAO,KAAK,OAAO,IAAIA,CAAK,EAAE,IAAI,KAAK,CAAC,EAAE,IAAA,EAAM,QAAQ,KAAK,OAAO;AAAA,EACxE;AAAA,EAEA,kBAAkBzH,GAAoB;AAClC,UAAM,EAAC,OAAAyH,GAAO,WAAAD,EAAA,IAAaxH,GACrBlT,IAAI,KAAK,OAAO,IAAI2a,CAAK,EAAE,IAAI,KAAK,CAAC,EAAE,OAAO,KAAK,OAAO,IAAID,CAAS,EAAE,UAAU;AACzF,WAAO,IAAI7J;AAAA,MACP,IAAIK,EAAOyJ,CAAK,EACX,IAAID,EAAU,MAAA,EAAQ,iBAAiB1a,CAAC,CAAC;AAAA,IAAA;AAAA,EAEtD;AAAA,EAEA,mBAAmB4a,GAAsB;AACnB,eAAK,OAAO,MAAMA,EAAM,MAAM,GAIrC,IAAI/J,EAAM,GAAG,GAAG,CAAC,GACtB,IAAI,MAAM,gDAAgD;AAAA,EAEpE;AAAA,EAEA,eAAegC,GAAoB;AAC/B,WAAO,KAAK,OAAO,IAAIA,CAAE,EAAE,IAAI,KAAK,CAAC,EAAE,OAAA;AAAA,EAC3C;AAAA,EAEA,IAAI,SAAiB;AACjB,WAAO,KAAKyH;AAAA,EAChB;AAAA,EAEA,IAAI,OAAO3kB,GAAuB;AAC9B,SAAK2kB,KAAU,IAAIpJ,EAAOvb,CAAK;AAAA,EACnC;AAAA,EAEA,IAAI,QAAe;AACf,WAAO,KAAK4kB;AAAA,EAChB;AAAA,EAEA,IAAI,MAAM5kB,GAAuB;AAC7B,SAAK4kB,KAAS,IAAI1J,EAAMlb,CAAK;AAAA,EACjC;AACJ;ACxKO,IAAKklB,uBAAAA,OACRA,EAAAA,EAAA,WAAA,CAAA,IAAA,YACAA,EAAAA,EAAA,WAAA,CAAA,IAAA,YACAA,EAAAA,EAAA,SAAA,CAAA,IAAA,UACAA,EAAAA,EAAA,iBAAA,CAAA,IAAA,kBACAA,EAAAA,EAAA,kBAAA,CAAA,IAAA,mBACAA,EAAAA,EAAA,aAAA,CAAA,IAAA,cACAA,EAAAA,EAAA,aAAA,CAAA,IAAA,cAPQA,IAAAA,MAAA,CAAA,CAAA;AAUL,MAAMC,GAAQ;AAAA,EACjBvD,KAA6B;AAAA,EAC7BG,KAAsC;AAAA,EACtCF,KAAkC;AAAA,EAClCuD,KAA0B;AAAA,EAE1B,YAAYhD,GAAgBE,GAA+B;AACvD,WAAIF,KAAUE,MACV,KAAKV,KAAUQ,GACf,KAAKL,KAAgB,IAAIvf,EAAS8f,CAAM,EAAE,MAAA,EAAQ,IAAI,CAAC,GACvD,KAAK+C,GAAA,IAEF;AAAA,EACX;AAAA,EAEA,aAAaC,GAAmC;AAC5C,UAAMxf,IAAM,IAAIuM,EAASiT,CAAQ,EAAE,SAAA,EAAW,OAAA,GAGxCha,IAAU,CAAC,KAAK,KAAK,GAAG;AAE9B,QAAIA,EAAQ,KAAK,CAACC,MAAWzF,EAAI,OAAOyF,CAAM,EAAE,UAAU,CAAC;AACvD,aAAO,KAAK,cAAA;AAGhB,UAAMnG,IAAcU,EAAI,KAAK,cAAc,GAAG,GAAG,EAAE;AACnD,WAAIwF,EAAQ,KAAK,CAACC,MAAWzF,EAAI,KAAK,cAAc,GAAGyF,CAAM,EAAE,YAAY,WAAWnG,CAAW,CAAC,IACvF,KAAK,cAAA,KAGhB,KAAKwc,KAAU,IAAI1G;AAAA,MACfpV,EAAI,KAAK,cAAc,GAAG,GAAG,EAAE,YAAY,QAAQ,WAAW,OAAO,CAAC;AAAA,MACtEA,EAAI,KAAK,cAAc,GAAG,GAAG,EAAE,YAAY,QAAQ,WAAW,OAAO,CAAC;AAAA,MACtEA,EAAI,KAAK,cAAc,GAAG,GAAG,EAAE,YAAY,MAAA,EAAQ,SAAA,EAAW,OAAO,CAAC;AAAA,IAAA,GAG1E,KAAKic,KAAgBjc,EAAI,KAAK,cAAc,CAAC,EACxC,YAAY,MAAA,EAAQ,SAAA,EACpB,IAAI,KAAK8b,GAAQ,EAAE,MAAA,EAAQ,IAAI,CAAC,CAAC,EACjC,IAAI,KAAKA,GAAQ,EAAE,MAAA,EAAQ,IAAI,CAAC,CAAC,EACjC,IAAI,KAAKA,GAAQ,EAAE,QAAQ,IAAI,CAAC,CAAC,GAEtC,KAAKyD,GAAA,GACE;AAAA,EACX;AAAA,EAEA,IAAI,SAAgB;AAChB,QAAI,KAAKzD,OAAY;AACjB,YAAM,IAAI,MAAM,sBAAsB;AAE1C,WAAO,KAAKA;AAAA,EAChB;AAAA,EAEA,IAAI,eAAyB;AACzB,QAAI,KAAKG,OAAkB;AACvB,YAAM,IAAI,MAAM,sBAAsB;AAE1C,WAAO,KAAKA;AAAA,EAChB;AAAA,EAEA,IAAI,SAA0D;AAC1D,QAAI,KAAKA,OAAkB;AACvB,YAAM,IAAI,MAAM,sBAAsB;AAG1C,WAAI,KAAKA,GAAc,aACZ;AAAA,MACH,KAAK,KAAKA,GAAc,MAAA,EAAQ,OAAO;AAAA,MACvC,SAAS,KAAKA,GAAc,MAAA,EAAQ,OAAO;AAAA,MAC3C,OAAO,KAAKA,GAAc,MAAA,EAAQ,OAAO;AAAA,IAAA,IAGtC;AAAA,MACH,KAAK,UAAU,KAAKA,GAAc,GAAG;AAAA,MACrC,SAAS,QAAQ,KAAKA,GAAc,OAAO;AAAA,MAC3C,OAAO,KAAKA,GAAc,MAAA,EAAQ,OAAO;AAAA,IAAA;AAAA,EAGrD;AAAA,EAEA,IAAI,WAAqB;AACrB,QAAI,KAAKF,OAAc;AACnB,YAAM,IAAI,MAAM,sBAAsB;AAE1C,WAAO,KAAKA;AAAA,EAChB;AAAA,EAEA,gBAAsB;AAClB,gBAAKD,KAAU,QACf,KAAKG,KAAgB,QACrB,KAAKF,KAAY,QACV;AAAA,EACX;AAAA,EAEA,IAAI,eAAqB;AACrB,gBAAKuD,KAAU,GACR;AAAA,EACX;AAAA,EAEA,IAAI,aAAmB;AACnB,gBAAKA,KAAU,GACR;AAAA,EACX;AAAA,EAGA,IAAI,MAAc;AACd,WAAO,KAAKG,GAAQ,EAAI;AAAA,EAC5B;AAAA,EAEA,IAAI,UAAkB;AAClB,WAAO,KAAKA,GAAQ,EAAK;AAAA,EAC7B;AAAA,EAEAA,KAAU,CAACC,MAA2B;AAClC,QAAI,KAAK3D,OAAc;AACnB,YAAM,IAAI,MAAM,sBAAsB;AAG1C,QAAI,KAAKuD,OAAY;AACjB,aAAOI,IAAQ,KAAK3D,GAAU,MAAM,KAAKA,GAAU;AAGvD,UAAMrb,IAAmB,CAAA;AAGzB,WAFqC,CAAC,KAAK,KAAK,GAAG,EAE3C,QAAQ,CAAC+E,MAA4B;AACzC,UAAI,KAAK,OAAOA,CAAM,EAAE;AACpB,QAAA/E,EAAO,KAAK,GAAG+E,CAAM,IAAI;AAAA,WACtB;AACH,cAAM3C,IAAI,IAAIgF,EAAQrC,CAAM,EAAE,SAAS,KAAK,OAAOA,CAAM,CAAC;AAC1D,QAAA/E,EAAO;AAAA,UACHgf,IACI,MAAM5c,EAAE,GAAG,UACX,IAAIA,EAAE,OAAO;AAAA,QAAA;AAAA,MAEzB;AAAA,IACJ,CAAC,GAEMpC,EAAO,KAAK,GAAG,IAAI,OAAOgf,IAAQ,KAAK,aAAa,MAAM,KAAK,aAAa;AAAA,EAEvF;AAAA,EAEAH,KAAyB;AACrB,SAAKxD,KAAY,IAAIxP;AAAA,MACjB,IAAIzE,EAAQ,GAAG,EAAE,SAAS,KAAK,OAAO,CAAC,EAAE,IAAI,CAAC,EACzC;AAAA,QACG,IAAIA,EAAQ,GAAG,EAAE,SAAS,KAAK,OAAO,CAAC,EAAE,IAAI,CAAC;AAAA,MAAA,EAEjD;AAAA,QACG,IAAIA,EAAQ,GAAG,EAAE,SAAS,KAAK,OAAO,CAAC,EAAE,IAAI,CAAC;AAAA,MAAA;AAAA,MAEtD,IAAIA,EAAQ,KAAK,YAAY;AAAA,IAAA,EAC/B,OAAA;AAAA,EACN;AAAA,EAEA,OAAO,oBAAoBsX;AAAA,EAC3B,mBAAmB,CAACliB,MAA0C;AAC1D,UAAMigB,IAAW,KAAK,OAAO,WAAWjgB,EAAE,MAAM,EAAE,OAC5CyiB,IAAK,KAAK,OAAO,OACjBC,IAAK1iB,EAAE,OAAO;AAEpB,WAAIigB,IAAWwC,IAAKC,IACT,IAGPzC,MAAawC,IAAKC,IACX,IAGRzC,MAAW,IACHwC,MAAKC,IAAK,IAAuC,IAGxDzC,MAAa,KAAK,IAAIwC,IAAKC,CAAE,IACtB,IAIPzC,IAAW,KAAK,IAAIwC,IAAKC,CAAE,IACpB,IAGJ;AAAA,EAEX;AAAA,EAEA,kBAAkB,CAAC9c,MACR,KAAKiZ,IAAW,KAAK;AAAA,IACxB,GAAGjZ,EAAE;AAAA,IACL,GAAGA,EAAE;AAAA,IACL,GAAGA,EAAE;AAAA,EAAA,CACR,KAAK;AAEd;ACjNO,SAAS+c,EAAYC,GAAgD;AACxE,QAAMf,IAAS,OAAO;AAAA,IAClB;AAAA,MACI,UAAU;AAAA,MACV,KAAK;AAAA,MACL,SAAS;AAAA,MACT,MAAM;AAAA,MACN,SAAS;AAAA,IAAA;AAAA,IACVe;AAAA,EAAA,GAGDrhB,IAAI,IAAI/B,EAAA;AAWd,MARIqiB,EAAO,WAEPtgB,EAAE,YAAY4X,EAAa0I,EAAO,KAAKA,EAAO,IAAI,IAGlDtgB,EAAE,YAAY0X,EAAU4I,EAAO,OAAO,IAAI,GAAGA,EAAO,GAAG,GAGvDA,EAAO;AACP,IAAAtgB,EAAE,cAAc;AAAA,OACb;AACH,QAAIshB,IAAgB;AACpB,WAAOthB,EAAE,gBAAgBshB,IAAgB;AACrC,MAAAthB,EAAE,cAAc0X,EAAU,GAAG4I,EAAO,GAAG,GACvCgB;AAAA,EAER;AAEA,SAAOhB,EAAO,UAAUtgB,EAAE,OAAA,IAAWA;AACzC;AChCO,SAASuhB,GAASF,GAAuC;AAC5D,QAAMf,IAAS,OAAO;AAAA,IAClB;AAAA,MACI,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,UAAU;AAAA,MACV,MAAM;AAAA,IAAA;AAAA,IACPe;AAAA,EAAA,GAGDriB,IAAI,IAAIyH,EAAA;AASd,MANAzH,EAAE,cAAcoiB,EAAY;AAAA,IACxB,MAAMd,EAAO;AAAA,IACb,SAAS;AAAA,IACT,SAAS,CAACA,EAAO;AAAA,EAAA,CACpB,GAEGA,EAAO,QAAQ,SAAS,GAAG;AAE3B,eAAWxZ,KAAKwZ,EAAO,QAAQ,MAAM,EAAE;AACnC,MAAAthB,EAAE,UAAU8H,GAAG,CAAC;AAEpB,aAAS,IAAI,GAAG,IAAIwZ,EAAO,QAAQ,KAAK;AACpC,YAAMxZ,IAAIiR,GAAWuI,EAAO,QAAQ,MAAM,EAAE,CAAC;AAC7C,MAAAthB,EAAE,UAAU8H,GAAG9H,EAAE,OAAO8H,CAAC,EAAE,MAAA,EAAQ,IAAI,CAAC,CAAC;AAAA,IAC7C;AAAA,EACJ;AACI,IAAA9H,EAAE,UAAUshB,EAAO,SAASA,EAAO,MAAM;AAG7C,SAAOthB;AACX;ACjCA,MAAMwiB,KAAmB;AAAA,EACrB,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,UAAU;AAAA,EACV,MAAM;AAAA,EACN,MAAM;AAAA,EACN,YAAY;AAAA,EACZ,gBAAgB;AAAA,EAChB,gBAAgB;AAAA,EAChB,UAAU;AACd;AAEO,SAASC,GAAWJ,GAA2C;AAClE,QAAMf,IAAS,OAAO;AAAA,IAClBkB;AAAA,IACAH;AAAA,EAAA,GAMEhd,IAAI,IAAIgF,EAAA,EAAU,MAAA;AAExB,MAAIrK;AAEJ,WAASzC,IAAI+jB,EAAO,QAAQ/jB,KAAK,GAAGA;AAEhC,IAAAyC,IAAIuiB,GAAS;AAAA,MACT,SAASjB,EAAO;AAAA,MAChB,QAAQ/jB;AAAA,MACR,UAAU+jB,EAAO;AAAA,MACjB,MAAO/jB,MAAM+jB,EAAO,SAAU,KAAQA,EAAO;AAAA,IAAA,CAChD,GAGGA,EAAO,QAAQA,EAAO,WAAW/jB,KACjCyC,EAAE,YAAY,IAAA,GAIlBqF,EAAE,IAAIrF,CAAC;AASX,MALIshB,EAAO,YAAYjc,EAAE,gBAAgB,YAAY,gBACjDA,EAAE,cAAA,EAAgB,YAAY,SAAA,GAI9Bic,EAAO,kBACJA,EAAO,iBAAiB,KACxBA,EAAO,iBAAiBjc,EAAE;AAC7B,WAAOA,EAAE,SAASic,EAAO,kBAAgB;AAErC,YAAM5iB,IAAQga,EAAU,GAAGrT,EAAE,SAAS,CAAC;AAEvC,MAAAA,EAAE,OAAO,OAAO3G,GAAO,CAAC;AAAA,IAC5B;AAGJ,SAAO2G,EAAE,OAAA;AACb;AC7DO,SAASqd,GAAYL,GAA6C;AACrE,QAAMf,IAAS,OAAO;AAAA,IAClB;AAAA,MACI,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,UAAU;AAAA,MACV,MAAM;AAAA,MACN,MAAM;AAAA,MACN,YAAY;AAAA,MACZ,gBAAgB;AAAA,MAChB,gBAAgB;AAAA,MAChB,UAAU;AAAA,MACV,UAAU;AAAA,QACN,WAAW;AAAA,QACX,UAAU;AAAA,QACV,SAAS;AAAA,QACT,YAAY;AAAA,MAAA;AAAA,IAChB;AAAA,IACDe;AAAA,EAAA,GAGDhd,IAAI,IAAIgF,EAAA,EAAU,IAAA;AAExB,WAAS,IAAI,GAAG,IAAIiX,EAAO,QAAQ,KAAK;AACpC,UAAMziB,IAAS4jB,GAAW;AAAA,MACtB,QAAQ;AAAA,MACR,MAAMnB,EAAO;AAAA,MACb,UAAUA,EAAO;AAAA,MACjB,SAASA,EAAO;AAAA,MAChB,MAAMA,EAAO;AAAA,IAAA,CAChB;AACD,IAAAjc,EAAE,SAASxG,CAAM;AAAA,EACrB;AAEA,SAAO,IAAIiQ,EAASzJ,GAAG,CAAC;AAC5B;AClCO,SAASsd,EAAUN,GAA+C;AACrE,QAAMf,IAKF,OAAO;AAAA,IACP;AAAA,MACI,MAAM;AAAA,MACN,UAAU;AAAA,MACV,KAAK;AAAA,MACL,UAAU;AAAA,IAAA;AAAA,IACXe;AAAA,EAAA,GAEDO,IAAQtB,EAAO,SAAS,KAC1BuB,IAAQvB,EAAO,SAAS,KAGtBnkB,IAAImkB,EAAO,WACbc,EAAY,EAAE,KAAKd,EAAO,KAAK,MAAMsB,EAAA,CAAO,IAC5C,IAAI3jB,EAAS2Z,EAAa0I,EAAO,KAAKsB,CAAK,CAAC,GAE1CxK,IAAIkJ,EAAO,WACbc,EAAY,EAAE,KAAKd,EAAO,KAAK,MAAMuB,EAAA,CAAO,IAC5C,IAAI5jB,EAAS2Z,EAAa0I,EAAO,KAAKuB,CAAK,CAAC;AAEhD,SAAI,OAAOvB,EAAO,QAAQ,MAAM,MAC5BnkB,EAAE,IAAA,GACFib,EAAE,IAAA,IAEF,OAAOkJ,EAAO,QAAQ,MAAM,MACxBnkB,EAAE,gBACFA,EAAE,SAAA,GAEFib,EAAE,gBACFA,EAAE,SAAA,IAGN,OAAOkJ,EAAO,QAAQ,MAAM,MACxBnkB,EAAE,gBACFA,EAAE,SAAA,GAEFib,EAAE,gBACFA,EAAE,SAAA,IAGN,OAAOkJ,EAAO,QAAQ,MAAM,MACxBnkB,EAAE,gBACFA,EAAE,SAAA,GAEFib,EAAE,gBACFA,EAAE,SAAA,IAIH,IAAIT,EAAMxa,GAAGib,CAAC;AACzB;ACzDO,SAAS0K,GAAUT,GAAiD;AACvE,QAAMf,IAAS,OAAO;AAAA,IAClB;AAAA,MACI,QAAQ;AAAA,QACJ,GAAG,EAAE,KAAK,KAAK,KAAK,GAAA;AAAA,QACpB,GAAG,EAAE,KAAK,KAAK,KAAK,GAAA;AAAA,MAAG;AAAA,MAE3B,gBAAgB;AAAA,IAAA;AAAA,IACjBe;AAAA,EAAA,GAEDxD,IAAS8D,EAAUrB,EAAO,MAAM;AAEtC,MAAIyB,GAAIlc;AACR,SAAIya,EAAO,mBAAmB,KAC1ByB,IAAKrK,EAAU,GAAG,CAAC,GACf7R,IAAIkc,KAAM,KAAKA,IAAK,MAAM,KAE9Blc,IAAI6R,EAAU,GAAG,EAAE,GAGhB,IAAI0F,EAAOS,GAAQhY,GAAG,EAAI;AACrC;ACrBO,SAASmc,GAAQX,GAA6C;AACjE,QAAMf,IAAS,OAAO;AAAA,IAClB;AAAA,MACI,GAAG;AAAA,QACC,GAAG1I,EAAa,EAAE;AAAA,QAClB,GAAGA,EAAa,EAAE;AAAA,MAAA;AAAA,IACtB;AAAA,IACDyJ;AAAA,EAAA,GAGDrd,IAAI,IAAIgT;AAAA,IACVY,EAAa,EAAE;AAAA,IACfA,EAAa,EAAE;AAAA,EAAA;AAGnB,SAAO5T,EAAE;AACL,IAAAA,EAAE,IAAI4T,EAAa,EAAE,GACrB5T,EAAE,IAAI4T,EAAa,EAAE;AAGzB,SAAI0I,EAAO,UAAU,IACbtc,EAAE,EAAE,KAAA,MAAWA,EAAE,EAAE,UACnBA,EAAE,EAAE,SAAA,IAEDsc,EAAO,UAAU,MACpBtc,EAAE,EAAE,KAAA,MAAWA,EAAE,EAAE,UACnBA,EAAE,EAAE,SAAA,GAIL,IAAIoU,EAAA,EAAO,sBAAsB,IAAIpB,EAAOsJ,EAAO,EAAE,GAAGA,EAAO,EAAE,CAAC,GAAGtc,CAAC;AACjF;AC9BO,SAASie,GAASZ,GAA+C;AACpE,QAAMf,IAAS,OAAO;AAAA,IAClB;AAAA,MACI,GAAG;AAAA,QACC,GAAG1I,EAAa,EAAE;AAAA,QAClB,GAAGA,EAAa,EAAE;AAAA,QAClB,GAAGA,EAAa,EAAE;AAAA,MAAA;AAAA,MAEtB,WAAW;AAAA,QACP,GAAGA,EAAa,EAAE;AAAA,QAClB,GAAGA,EAAa,EAAE;AAAA,QAClB,GAAGA,EAAa,EAAE;AAAA,MAAA;AAAA,IACtB;AAAA,IACDyJ;AAAA,EAAA,GAGD7a,IAAI,IAAImQ,EAAM2J,EAAO,EAAE,GAAGA,EAAO,EAAE,GAAGA,EAAO,EAAE,CAAC,GAChDtc,IAAI,IAAIgT,EAAOsJ,EAAO,UAAU,GAAGA,EAAO,UAAU,GAAGA,EAAO,UAAU,CAAC;AAE/E,SAAO,IAAIf,EAAM/Y,GAAGxC,CAAC;AACzB;ACFO,MAAMke,KAAS;AAAA,EAClB,UAAU,CAAC5B,MACAoB,GAAYpB,CAAM;AAAA,EAG7B,SAAS,CAACA,MACCmB,GAAWnB,CAAM;AAAA,EAG5B,OAAO,CAACA,MACGiB,GAASjB,CAAM;AAAA,EAG1B,UAAU,CAACA,MACAc,EAAYd,CAAM;AAAA,EAG7B,QAAQ,CAAC6B,GAAcC,GAAYzK,MACxBD,EAAUyK,GAAMC,GAAIzK,CAAO;AAAA,EAGtC,WAAW,CAACE,GAAawK,MACdzK,EAAaC,GAAKwK,CAAS;AAAA,EAGtC,OAAO,CAACxK,MACGC,GAAYD,CAAG;AAAA,EAG1B,MAAM,CAACJ,MACID,GAAWC,CAAO;AAAA,EAG7B,OAAO,CAAI7b,GAAUqc,MACVD,GAAYpc,GAAKqc,CAAM;AAAA,EAGlC,MAAM,CAAIrc,MACCmc,GAAWnc,CAAG;AAAA,EAGzB,SAAS,CAAIA,MACFsc,GAAatc,CAAG;AAAA,EAG3B,MAAM,CAAC0kB,MACI0B,GAAQ1B,CAAM;AAAA,EAGzB,OAAO,CAACA,MACG2B,GAAS3B,CAAM;AAAA,EAG1B,QAAQ,CAACA,MACEqB,EAAUrB,CAAM;AAAA,EAG3B,OAAO,CAACA,MACG,IAAI3J,EAAMgL,EAAUrB,CAAM,CAAC;AAAA,EAGtC,QAAQ,CAACA,MACEwB,GAAUxB,CAAM;AAE/B,GCxDMgC,KAAS;AAAA,EACX,SAAAvkB;AAAA,EACA,UAAAE;AAAA,EACA,MAAMqC;AAAA,EACN,OAAAmG;AAAA,EACA,SAAA4C;AAAA,EACA,UAAAyE;AAAA,EACA,QAAAoG;AAAA,EACA,cAAAxE;AAAA,EACA,QAAAR;AAAA,EACA,YAAA8C;AAAA,EACA,YAAAV;AAAA,EACA,QAAA4Q;AAAA,EACA,UAAU;AAAA,IACN,QAAAlL;AAAA,IACA,OAAAL;AAAA,IACA,MAAAyB;AAAA,IACA,UAAAiB;AAAA,IACA,QAAA+D;AAAA,IACA,OAAAmC;AAAA,IACA,QAAAY;AAAA,IACA,SAAAS;AAAA,EAAA;AAAA,EACJ,QACA2B;AACJ;","x_google_ignoreList":[4]}