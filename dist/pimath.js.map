{"version":3,"file":"pimath.js","sources":["../src/numeric.ts","../src/coefficients/fraction.ts","../src/coefficients/nthRoot.ts","../node_modules/piexpression/dist/piexpression.js","../src/algebra/monom.ts","../src/algebra/equationSolver.ts","../src/helpers.ts","../src/algebra/polynom.ts","../src/algebra/factor.ts","../src/algebra/polyFactor.ts","../src/algebra/equation.ts","../src/algebra/linearSystem.ts","../src/geometry/geomMath.ts","../src/geometry/vector.ts","../src/randomization/rndHelpers.ts","../src/geometry/point.ts","../src/geometry/line.ts","../src/geometry/circle.ts","../src/geometry/triangle.ts","../src/geometry/line3.ts","../src/geometry/plane3.ts","../src/geometry/matrix.ts","../src/randomization/coefficient/rndFraction.ts","../src/randomization/algebra/rndMonom.ts","../src/randomization/algebra/rndPolynom.ts","../src/randomization/algebra/rndEquation.ts","../src/randomization/geometry/rndVector.ts","../src/randomization/geometry/rndCircle.ts","../src/randomization/geometry/rndLine.ts","../src/randomization/geometry/rndLine3.ts","../src/randomization/random.ts","../src/algebra/logicalset.ts","../src/index.ts"],"sourcesContent":["\r\nfunction decompose(value: number): number[][] {\r\n    const divs: number[] = dividers(value)\r\n    const arr: number[][] = []\r\n    let u, v\r\n\r\n    while (divs.length > 0) {\r\n        u = divs.shift() ?? 1\r\n        v = (divs.length > 0 ? divs.pop() : +u) ?? 1\r\n\r\n        arr.push([u, v])\r\n    }\r\n\r\n    return arr\r\n}\r\n\r\nfunction divideNumbersByGCD(...values: number[]): number[] {\r\n    const g = greatestCommonDivisor(...values)\r\n\r\n    return values.map(x => x / g)\r\n}\r\n\r\n/**\r\n * Get the list of all dividers of a number.\r\n * @param value\r\n */\r\nfunction dividers(value: number): number[] {\r\n    const absV = Math.abs(value)\r\n    const maxV = Math.sqrt(absV)\r\n\r\n    // Initialize the list of dividers.\r\n    const D: number[] = []\r\n\r\n    for (let i = 1; i <= maxV; i++) {\r\n        if (value % i === 0) {\r\n            D.push(i)\r\n            D.push(absV / i)\r\n        }\r\n    }\r\n\r\n    // Order numbers.\r\n    D.sort(function (a, b) {\r\n        return a - b\r\n    })\r\n\r\n    // Make sure the array of value is unique.\r\n    return [...new Set(D)]\r\n}\r\n\r\n/**\r\n * Great Common Divisor\r\n * @param values : number values\r\n */\r\nfunction greatestCommonDivisor(...values: number[]): number {\r\n    // Define the gcd for two number\r\n    const gcd2 = function (a: number, b: number): number {\r\n        if (b === 0) {\r\n            return a\r\n        }\r\n        return gcd2(b, a % b)\r\n    }\r\n\r\n    let g = 1,\r\n        i = 2\r\n\r\n    // Nothing is given\r\n    if (values.length === 0) {\r\n        return 1\r\n    }\r\n    // Only one number is given\r\n    if (values.length === 1) {\r\n        // The first number is zero\r\n        if (values[0] === 0) {\r\n            return 1\r\n        }\r\n        // Return the number\r\n        return values[0]\r\n    }\r\n\r\n    // We have at least 2 numbers.\r\n    g = gcd2(values[0], values[1])\r\n\r\n    // The gcd of the two first value is one ? It's already finished.\r\n    if (g === 1) {\r\n        return 1\r\n    }\r\n\r\n    // The current gcd isn't one. Continue with all next values.\r\n    for (i = 2; i < values.length; i++) {\r\n        g = gcd2(g, values[i])\r\n        // Escape if gcd is already one.\r\n        if (g === 1) {\r\n            break\r\n        }\r\n    }\r\n\r\n    return Math.abs(g)\r\n}\r\n\r\n/**\r\n * Least Common Multiple\r\n * @param values: list of numbers\r\n */\r\nfunction leastCommonMultiple(...values: number[]): number {\r\n    return values.reduce(function (a, b) {\r\n        return Math.abs(a * b / greatestCommonDivisor(a, b))\r\n    })\r\n}\r\n\r\nfunction numberCorrection(value: number, number_of_digits = 3) {\r\n    return +value.toFixed(number_of_digits)\r\n}\r\n\r\nfunction periodic(value: number): number {\r\n    if (Number.isSafeInteger(value)) {\r\n        return 0\r\n    }\r\n\r\n    // Assume it's with decimal.\r\n    const decimal = (value.toString()).split('.')[0]\r\n\r\n    // The decimal part is limited\r\n    if (decimal.length < 10) {\r\n        return 0\r\n    }\r\n\r\n    // Find the periodic if it exists.\r\n    throw new Error('Periodic value: Not implemented yet')\r\n}\r\n\r\n/**\r\n * Get the list of the nth first prime numbers.\r\n * @param nb : number of primes to choose from\r\n */\r\nfunction primes(nb?: number): number[] {\r\n    const primesValues: number[] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]\r\n    if (nb === undefined) {\r\n        return primesValues\r\n    } else {\r\n        return primesValues.slice(0, Math.min(primesValues.length, nb))\r\n    }\r\n}\r\n\r\nfunction pythagoreanTripletsWithTarget(target: number, targetIsSquare?: boolean): number[][] {\r\n    // méthode inverse, à partir du triplet.\r\n    const triplets = [],\r\n        targetValue = targetIsSquare === true ? +target : target ** 2\r\n    for (let u = 0; u <= target; u++) {\r\n        for (let v = 0; v <= target; v++) {\r\n            if (u ** 2 + v ** 2 === targetValue) {\r\n                triplets.push([u, v, target])\r\n            }\r\n        }\r\n    }\r\n\r\n    return triplets\r\n}\r\n\r\nfunction round(value: number, decimals = 2): number {\r\n    const exp: number = Math.round(Number(`${value}e${decimals}`))\r\n\r\n    return Number(`${exp}e-${decimals}`)\r\n}\r\n\r\n\r\nexport const Numeric = {\r\n    decompose,\r\n    dividers,\r\n    divideNumbersByGCD,\r\n    gcd: greatestCommonDivisor,\r\n    lcm: leastCommonMultiple,\r\n    numberCorrection,\r\n    periodic,\r\n    primes,\r\n    pythagoreanTripletsWithTarget,\r\n    round\r\n}","import type {compareSign, IExpression, InputValue, IPiMathObject} from \"../pimath.interface\"\r\nimport {Numeric} from \"../numeric\"\r\n\r\nenum FRAC_TYPE {\r\n    frac = 'frac',\r\n    dfrac = 'dfrac',\r\n    tfrac = 'tfrac'\r\n}\r\n\r\n/**\r\n * The fraction class make possible to handle\r\n * \\\\(\\frac{a}{b}\\\\) or \\\\[\\frac{a}{b}\\\\]  values.\r\n */\r\nexport class Fraction implements IPiMathObject<Fraction>, IExpression<Fraction> {\r\n    #approximative = false\r\n    #denominator = 1\r\n    #numerator = 1\r\n    #type: FRAC_TYPE = FRAC_TYPE.frac\r\n\r\n    constructor()\r\n    constructor(value: InputValue<Fraction>)\r\n    constructor(numerator: number, denominator: number)\r\n    constructor(decimal: number, periodLength: number)\r\n    constructor(value?: InputValue<Fraction>, denominatorOrPeriodic?: number) {\r\n\r\n        if (value !== undefined) {\r\n            this.parse(value, denominatorOrPeriodic)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse the value to get the numerator and denominator\r\n     * @param value : number or string to parse to get the fraction\r\n     * @param denominatorOrPeriodic (optional|number) : length of the periodic part: 2.333333 => 1 or denominator value\r\n     */\r\n    public parse = (value: InputValue<Fraction>, denominatorOrPeriodic?: number): Fraction => {\r\n        let S: string[]\r\n\r\n        // A null value means a zero fraction.\r\n        if (value === \"\") {\r\n            this.#numerator = 0\r\n            this.#denominator = 1\r\n            return this\r\n        }\r\n\r\n        switch (typeof value) {\r\n            case \"string\":\r\n                // Split the string value in two parts: Numerator/Denominator\r\n                S = value.split('/')\r\n\r\n                // Security checks\r\n                if (S.length > 2) {\r\n                    throw new Error(`The given value is not a valid fraction (${value})`)\r\n                }\r\n                if (S.map(x => x === '' || isNaN(Number(x))).includes(true)) {\r\n                    throw new Error(`The given value is not a valid fraction (${value})`)\r\n                }\r\n\r\n                if (S.length === 1) {\r\n                    // No divide sign - it's a number\r\n                    return this.parse(+S[0])\r\n                } else if (S.length === 2) {\r\n                    // One divide signe\r\n                    // We check if the denominator is zero\r\n                    if (S[1] === '0') {\r\n                        this.#numerator = NaN\r\n                        this.#denominator = 1\r\n                    } else {\r\n                        this.#numerator = +S[0]\r\n                        this.#denominator = +S[1]\r\n                    }\r\n                } else {\r\n                    // More than one divide sign ?\r\n                    // This is impossible\r\n                    this.#numerator = NaN\r\n                    this.#denominator = 1\r\n                }\r\n                break\r\n            case \"number\":\r\n                if (Number.isSafeInteger(value)) {\r\n                    // The given value is an integer\r\n                    this.#numerator = +value\r\n\r\n                    if (denominatorOrPeriodic === undefined || !Number.isSafeInteger(denominatorOrPeriodic)) {\r\n                        this.#denominator = 1\r\n                    } else {\r\n                        this.#denominator = +denominatorOrPeriodic\r\n                    }\r\n                } else {\r\n                    // The given value is a float number\r\n                    // Get the number of decimals after the float sign\r\n                    const [, decimal] = (value.toString()).split('.')\r\n                    const p: number = decimal ? decimal.length : 0\r\n\r\n                    // Detect if the decimal part is periodic or not...\r\n\r\n                    // Transform the float number in two integer\r\n                    if (denominatorOrPeriodic === undefined) {\r\n                        this.#numerator = value * Math.pow(10, p)\r\n                        this.#denominator = Math.pow(10, p)\r\n                    } else if (Number.isSafeInteger(denominatorOrPeriodic)) {\r\n                        this.#numerator = value * Math.pow(10, p) - Math.floor(value * Math.pow(10, p - denominatorOrPeriodic))\r\n                        this.denominator = Math.pow(10, p) - Math.pow(10, p - denominatorOrPeriodic)\r\n                    }\r\n\r\n                    this.reduce()\r\n                }\r\n                break\r\n            case \"object\":\r\n                if (value instanceof Fraction) {\r\n                    this.#numerator = +value.numerator\r\n                    this.#denominator = +value.denominator\r\n                }\r\n                break\r\n        }\r\n        return this\r\n    }\r\n\r\n    public clone = (): Fraction => {\r\n        const F = new Fraction()\r\n        F.numerator = +this.#numerator\r\n        F.denominator = +this.#denominator\r\n        return F\r\n    }\r\n\r\n    public static average = (...fractions: (InputValue<Fraction>)[]): Fraction => {\r\n        const M = new Fraction().zero()\r\n\r\n        for (const f of fractions) {\r\n            M.add(f)\r\n        }\r\n\r\n        M.divide(fractions.length)\r\n\r\n        return M\r\n    }\r\n\r\n    public static max = (...fractions: InputValue<Fraction>[]): Fraction => {\r\n        let M = new Fraction(fractions[0])\r\n\r\n        for (const m of fractions) {\r\n            const compare = new Fraction(m)\r\n            if (compare.isGreater(M)) {\r\n                M = compare.clone()\r\n            }\r\n        }\r\n\r\n        return M\r\n    }\r\n\r\n    public static min = (...fractions: (InputValue<Fraction>)[]): Fraction => {\r\n        let M = new Fraction(fractions[0])\r\n\r\n        for (const m of fractions) {\r\n            const compare = new Fraction(m)\r\n            if (compare.isLesser(M)) {\r\n                M = compare.clone()\r\n            }\r\n        }\r\n\r\n        return M\r\n    }\r\n\r\n    public static sort = (fractions: (InputValue<Fraction>)[], reverse?: boolean): Fraction[] => {\r\n        const fractionsObject: Fraction[] = fractions.map(f => f instanceof Fraction ? f : new Fraction(f))\r\n\r\n        const sorted = fractionsObject.sort((a, b) => a.value - b.value)\r\n\r\n        if (reverse) {\r\n            sorted.reverse()\r\n        }\r\n\r\n        return sorted\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n\r\n    public static unique = (fractions: (InputValue<Fraction>)[]): Fraction[] => {\r\n        const unique: Record<string, boolean> = {},\r\n            distinct: Fraction[] = []\r\n\r\n        fractions.forEach(x => {\r\n            if (!(x instanceof Fraction)) {\r\n                x = new Fraction(x)\r\n            }\r\n\r\n            if (!unique[x.clone().reduce().tex]) {\r\n                distinct.push(x.clone())\r\n                unique[x.tex] = true\r\n            }\r\n        })\r\n\r\n        return distinct\r\n    }\r\n\r\n    public static xMultiply = (...values: (InputValue<Fraction>)[]): Fraction => {\r\n        const R = new Fraction()\r\n        // Parse the value.\r\n        // If it's a fraction, return a clone of it\r\n        // If it's an integer, return the fraction F/1\r\n        for (const value of values) {\r\n\r\n            const F = new Fraction(value)\r\n            R.numerator = R.numerator * F.numerator\r\n            R.denominator = R.denominator * F.denominator\r\n        }\r\n\r\n        return R\r\n    }\r\n\r\n    public abs = (): this => {\r\n        this.#numerator = Math.abs(this.#numerator)\r\n        this.#denominator = Math.abs(this.#denominator)\r\n        return this\r\n    }\r\n\r\n    public add = (F: InputValue<Fraction>): Fraction => {\r\n        if (F instanceof Fraction) {\r\n            const N: number = this.#numerator,\r\n                D: number = this.#denominator\r\n\r\n            this.#numerator = N * F.denominator + F.numerator * D\r\n            this.#denominator = D * F.denominator\r\n        } else {\r\n            return this.add(new Fraction(F))\r\n        }\r\n\r\n        return this.reduce()\r\n    }\r\n\r\n    public amplify = (k: number): this => {\r\n        if (Number.isSafeInteger(k)) {\r\n            this.#numerator *= k\r\n            this.#denominator *= k\r\n        }\r\n        return this\r\n    }\r\n\r\n    // TODO: The rest of the functions are not used or unnecessary ?\r\n    /**\r\n     * Simple function to determine if it's a fraction\r\n     */\r\n    public areEquals = (...F: Fraction[]): boolean => {\r\n        return F.every(f => f.isEqual(F[0]))\r\n    }\r\n\r\n    // ------------------------------------------\r\n    /**\r\n     * Compare the current coefficient with another coefficient\r\n     * @param F (Coefficient) The coefficient to _compare\r\n     * @param sign (string| default is =): authorized values: =, <, <=, >, >= with some variations.\r\n     */\r\n    public compare = (F: InputValue<Fraction>, sign?: compareSign): boolean => {\r\n        if (sign === undefined) {\r\n            sign = '='\r\n        }\r\n\r\n        let compareFraction: Fraction\r\n        if (F instanceof Fraction) {\r\n            compareFraction = F.clone()\r\n        } else {\r\n            compareFraction = new Fraction(F)\r\n        }\r\n\r\n        switch (sign) {\r\n            case '>':\r\n                return this.value > compareFraction.value\r\n            case \">=\":\r\n            case \"=>\":\r\n            case \"geq\":\r\n                return this.value >= compareFraction.value\r\n            case \"<\":\r\n                return this.value < compareFraction.value\r\n            case \"<=\":\r\n            case \"=<\":\r\n            case \"leq\":\r\n                return this.value <= compareFraction.value\r\n            case \"=\":\r\n                // let F2: Fraction = compareFraction.clone().reduce(),\r\n                //     F1: Fraction = this.clone().reduce();\r\n                // return (F1.numerator === F2.numerator && F1.denominator === F2.denominator);\r\n                return this.value === compareFraction.value\r\n            case \"<>\":\r\n                return this.value !== compareFraction.value\r\n            default:\r\n                return false\r\n        }\r\n    }\r\n\r\n    public get denominator(): number {\r\n        return this.#denominator\r\n    }\r\n\r\n    public set denominator(value: number) {\r\n        this.#denominator = value\r\n    }\r\n\r\n    public get dfrac(): this {\r\n        this.#type = FRAC_TYPE.dfrac\r\n        return this\r\n    }\r\n\r\n    public get display(): string {\r\n        if (this.isExact()) {\r\n            if (this.#denominator === 1) {\r\n                return `${this.#numerator}`\r\n            } else {\r\n                return `${this.#numerator}/${this.#denominator}`\r\n            }\r\n        } else {\r\n            return this.value.toFixed(3)\r\n        }\r\n    }\r\n\r\n    public divide = (F: Fraction | number): Fraction => {\r\n        const Q = new Fraction(F)\r\n\r\n        if (Q.numerator === 0) {\r\n            return new Fraction().infinite()\r\n        }\r\n\r\n        const N: number = +this.#numerator,\r\n            D: number = +this.#denominator\r\n\r\n        this.#numerator = N * Q.denominator\r\n        this.#denominator = D * Q.numerator\r\n        return this.reduce()\r\n    }\r\n\r\n    public get frac(): this {\r\n        this.#type = FRAC_TYPE.frac\r\n        return this\r\n    }\r\n\r\n    public infinite = (): this => {\r\n        this.#numerator = Infinity\r\n        this.#denominator = 1\r\n        return this\r\n    }\r\n\r\n    public invalid = (): this => {\r\n        this.#numerator = NaN\r\n        this.#denominator = 1\r\n        return this\r\n    }\r\n\r\n    public inverse = (): this => {\r\n        const n = +this.#numerator\r\n        this.#numerator = +this.#denominator\r\n        this.#denominator = n\r\n\r\n        return this\r\n    }\r\n\r\n    public isApproximative = (): boolean => {\r\n        return this.#approximative ||\r\n            this.#numerator.toString().length >= 15 && this.#denominator.toString().length >= 15\r\n    }\r\n\r\n    public isEqual = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '=')\r\n    }\r\n\r\n    public isEven = (): boolean => {\r\n        return this.isRelative() && this.value % 2 === 0\r\n    }\r\n\r\n    public isExact = (): boolean => {\r\n        return !this.isApproximative()\r\n    }\r\n\r\n    public isFinite = (): boolean => {\r\n        return !this.isInfinity() && !this.isNaN()\r\n    }\r\n\r\n    public isGeq = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '>=')\r\n    }\r\n\r\n    public isGreater = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '>')\r\n    }\r\n\r\n    public isInfinity = (): boolean => {\r\n        return Math.abs(this.#numerator) === Infinity\r\n    }\r\n\r\n    public isInverted = (p: Fraction): boolean => {\r\n        return this.isEqual(new Fraction().one().divide(p.clone()))\r\n    }\r\n\r\n    public isLeq = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '<=')\r\n    }\r\n\r\n    /* Compare shortcuts */\r\n    public isLesser = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '<')\r\n    }\r\n\r\n    public isNaN = (): boolean => {\r\n        return isNaN(this.#numerator)\r\n    }\r\n\r\n    public isNatural = (): boolean => {\r\n        return this.isRelative() && this.isPositive()\r\n    }\r\n\r\n    public isNegative = (): boolean => {\r\n        return this.sign() === -1\r\n    }\r\n\r\n    public isNegativeOne = (): boolean => {\r\n        return this.#numerator === -1 && this.#denominator === 1\r\n    }\r\n\r\n    public isNotEqual = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '<>')\r\n    }\r\n\r\n    // ------------------------------------------\r\n\r\n    public isNotZero = (): boolean => {\r\n        return this.#numerator !== 0\r\n    }\r\n\r\n    public isOdd = (): boolean => {\r\n        return this.isRelative() && this.value % 2 === 1\r\n    }\r\n\r\n    public isOne = (): boolean => {\r\n        return this.#numerator === 1 && this.#denominator === 1\r\n    }\r\n\r\n    public isOpposite = (p: Fraction): boolean => {\r\n        return this.isEqual(p.clone().opposite())\r\n    }\r\n\r\n    public isPositive = (): boolean => {\r\n        return this.sign() === 1\r\n    }\r\n\r\n    public isRational = (): boolean => {\r\n        return !this.isRelative()\r\n    }\r\n\r\n    public isReduced = (): boolean => {\r\n        return Math.abs(Numeric.gcd(this.#numerator, this.#denominator)) === 1\r\n    }\r\n\r\n    public isRelative = (): boolean => {\r\n        return this.clone().reduce().denominator === 1\r\n    }\r\n\r\n    public isSquare = (): boolean => {\r\n        return Math.sqrt(this.#numerator) % 1 === 0 && Math.sqrt(this.#denominator) % 1 === 0\r\n    }\r\n\r\n    public isStrictlyNegative = (): boolean => {\r\n        return this.value < 0\r\n    }\r\n\r\n    public isStrictlyPositive = (): boolean => {\r\n        return this.value > 0\r\n    }\r\n\r\n    // Mathematical operations specific to fractions\r\n    public isZero = (): boolean => {\r\n        return this.#numerator === 0\r\n    }\r\n\r\n    public multiply = (F: Fraction | number): this => {\r\n        // Parse the value.\r\n        // If it's a fraction, return a clone of it\r\n        // If it's an integer, return the fraction F/1\r\n        const Q = new Fraction(F)\r\n\r\n        this.#numerator = this.#numerator * Q.numerator\r\n        this.#denominator = this.#denominator * Q.denominator\r\n\r\n        return this.reduce()\r\n    }\r\n\r\n    // ------------------------------------------\r\n    public get numerator(): number {\r\n        return this.#numerator\r\n    }\r\n\r\n    public set numerator(value: number) {\r\n        this.#numerator = value\r\n    }\r\n\r\n    public one = (): this => {\r\n        this.#numerator = 1\r\n        this.#denominator = 1\r\n        return this\r\n    }\r\n\r\n    public opposite = (): this => {\r\n        this.#numerator = -this.#numerator\r\n        return this\r\n    }\r\n\r\n    public pow = (p: number | Fraction): Fraction => {\r\n        // TODO: Fraction.pow with a value different than a safe integer !\r\n        if (p instanceof Fraction) {\r\n            return this.pow(p.value)\r\n        }\r\n\r\n        this.reduce()\r\n        if (p < 0) {\r\n            this.inverse()\r\n        }\r\n\r\n        // Check if numerator and denominator are roots of...\r\n        // otherwise, convert to numeric.\r\n        const controlNumerator = Math.floor(Math.pow(this.#numerator, Math.abs(p))),\r\n            controlDenominator = Math.floor(Math.pow(this.#denominator, Math.abs(p)))\r\n\r\n        if (controlNumerator ** Math.abs(p) === this.#numerator\r\n            &&\r\n            controlDenominator ** Math.abs(p) === this.#denominator) {\r\n            this.#numerator = this.#numerator ** Math.abs(p)\r\n            this.#denominator = this.#denominator ** Math.abs(p)\r\n        } else {\r\n            this.#numerator = this.#numerator ** Math.abs(p)\r\n            this.#denominator = this.#denominator ** Math.abs(p)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    public reduce = (): this => {\r\n        const g = Numeric.gcd(this.#numerator, this.#denominator)\r\n        this.#numerator = this.#numerator / g\r\n        this.#denominator = this.#denominator / g\r\n\r\n        if (this.#denominator < 0) {\r\n            this.#denominator = -this.#denominator\r\n            this.#numerator = -this.#numerator\r\n        }\r\n        return this\r\n    }\r\n\r\n    public root = (p: number): this => {\r\n        // TODO: nth - root of a fraction => this will return another type of coefficient.\r\n\r\n        // Check if they are perfect roots..\r\n        if (p === 0) {\r\n            return this\r\n        }\r\n\r\n        // If negative, inverse the fraction\r\n        if (p < 0) {\r\n            this.inverse()\r\n        }\r\n\r\n        // if p is not a safe integer, throw error\r\n        if (!Number.isSafeInteger(p)) {\r\n            throw new Error(\"The root must be an integer.\")\r\n        }\r\n\r\n        // if the fraction is negative and the root is even, throw error\r\n        if (this.isNegative() && p % 2 === 0) {\r\n            throw new Error(\"The root of a negative number must be odd.\")\r\n        }\r\n\r\n        // get the sign of the fraction and make it positive\r\n        const sign = this.sign()\r\n        this.abs()\r\n\r\n        // Reduce the fraction\r\n        this.reduce()\r\n\r\n        // Check if numerator and denominator are roots of...\r\n        // otherwise, convert to numeric.\r\n        const controlNumerator = Math.floor(Math.pow(this.#numerator, Math.abs(1 / p))),\r\n            controlDenominator = Math.floor(Math.pow(this.#denominator, Math.abs(1 / p)))\r\n\r\n        this.#numerator = Math.pow(this.#numerator, Math.abs(1 / p))\r\n        this.#denominator = Math.pow(this.#denominator, Math.abs(1 / p))\r\n\r\n        if (controlNumerator !== this.#numerator\r\n            ||\r\n            controlDenominator !== this.#denominator) {\r\n            // The fraction is not a perfect root - make it approximative\r\n            this.#numerator = this.#numerator / this.#denominator\r\n            this.#denominator = 1\r\n            this.#approximative = true\r\n        }\r\n\r\n        // Restore the sign\r\n        this.multiply(sign)\r\n\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n\r\n    public sign = (): number => {\r\n        return (this.#numerator * this.#denominator >= 0) ? 1 : -1\r\n    }\r\n\r\n    public sqrt = (): this => {\r\n        return this.root(2)\r\n    }\r\n\r\n    public subtract = (F: Fraction | number): Fraction => {\r\n        if (F instanceof Fraction) {\r\n            return this.add(F.clone().opposite())\r\n        } else {\r\n            return this.add(-F)\r\n        }\r\n    }\r\n\r\n    // Display getter\r\n    public get tex(): string {\r\n        if (this.isInfinity()) {\r\n            return `${this.sign() === 1 ? '+' : '-'}\\\\infty`\r\n        }\r\n\r\n\r\n        if (this.isExact()) {\r\n            if (this.#denominator === 1) {\r\n                return `${this.#numerator}`\r\n            } else if (this.#numerator < 0) {\r\n                return `-\\\\${this.#type}{ ${-this.#numerator} }{ ${this.#denominator} }`\r\n            } else {\r\n                return `\\\\${this.#type}{ ${this.#numerator} }{ ${this.#denominator} }`\r\n            }\r\n        } else {\r\n            return this.value.toFixed(3)\r\n        }\r\n    }\r\n\r\n    public get texWithSign(): string {\r\n        return this.isPositive() ? `+${this.tex}` : this.tex\r\n    }\r\n\r\n    public get tfrac(): this {\r\n        this.#type = FRAC_TYPE.tfrac\r\n        return this\r\n    }\r\n\r\n    public get value(): number {\r\n        const result = this.#numerator / this.#denominator\r\n        return result === 0 ? 0 : result\r\n    }\r\n\r\n    public zero = (): this => {\r\n        this.#numerator = 0\r\n        this.#denominator = 1\r\n        return this\r\n    }\r\n}","// TODO: Remove NthRoot class\r\n/**\r\n * NthRoot is something like \"a+b\\sqrt{3}\r\n */\r\nexport class NthRoot {\r\n    #radical: number\r\n    #nth: number\r\n    #coefficient: number\r\n    #isValid: boolean\r\n\r\n    constructor(...values: number[]) {\r\n        this.#radical = 1\r\n        this.#coefficient = 1\r\n        this.#nth = 2\r\n        this.#isValid = true\r\n\r\n        if (values.length > 0) {\r\n            this.parse(values[0], values[1], values[2])\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get radical(): number {\r\n        return this.#radical\r\n    }\r\n\r\n    set radical(value: number) {\r\n        this.#radical = value\r\n    }\r\n\r\n    get nth(): number {\r\n        return this.#nth\r\n    }\r\n\r\n    set nth(value: number) {\r\n        if (Number.isSafeInteger(value) && value >= 2) {\r\n            this.#nth = value\r\n        } else {\r\n            // Error setting the nth root.\r\n            console.log('Error setting the nth root')\r\n            this.#nth = 2\r\n        }\r\n    }\r\n\r\n    get coefficient(): number {\r\n        return this.#coefficient\r\n    }\r\n\r\n    set coefficient(value: number) {\r\n        this.#coefficient = value\r\n    }\r\n\r\n    get tex(): string {\r\n        let C: string\r\n\r\n        if (this.#coefficient === 1) {\r\n            C = ''\r\n        } else if (this.#coefficient === -1) {\r\n            C = '-'\r\n        } else {\r\n            C = this.#coefficient.toString()\r\n        }\r\n\r\n        if (this.#radical === 1) {\r\n            return `${this.#coefficient}`\r\n        } else {\r\n            if (this.#nth === 2) {\r\n                return `${C}\\\\sqrt{${this.#radical}}`\r\n            } else {\r\n                return `${C}\\\\sqrt[${this.#nth}]{${this.#radical}}`\r\n            }\r\n        }\r\n    }\r\n\r\n    get display(): string {\r\n        let C: string\r\n\r\n        if (this.#coefficient === 1) {\r\n            C = ''\r\n        } else if (this.#coefficient === -1) {\r\n            C = '-'\r\n        } else {\r\n            C = this.#coefficient.toString()\r\n        }\r\n\r\n        if (this.#radical === 1) {\r\n            return `${this.#coefficient}`\r\n        } else {\r\n            if (this.#nth === 2) {\r\n                return `${C}sqrt{${this.#radical}}`\r\n            } else {\r\n                return `${C}root(${this.#nth}){${this.#radical}}`\r\n            }\r\n        }\r\n    }\r\n\r\n    get value(): number {\r\n        return this.#coefficient * Math.pow(this.#radical, 1 / this.#nth)\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (radical: number, nthroot?: number, coefficient?: number): this => {\r\n        this.#coefficient = coefficient ?? 1\r\n        this.#nth = nthroot ?? 2\r\n        this.#radical = radical\r\n\r\n        if (this.#nth % 2 === 0 && this.#radical < 0) {\r\n            this.#isValid = false\r\n        }\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    reduce = (): this => {\r\n        // Max value to test.\r\n        let V = Math.floor(Math.pow(this.#radical, 1 / this.#nth))\r\n        while (V > 1) {\r\n            if (this.#radical % Math.pow(V, this.#nth) === 0) {\r\n                // It's dividable by V^n\r\n                this.#coefficient *= V\r\n                this.#radical = this.#radical / Math.pow(V, this.#nth)\r\n\r\n                // Redifine the new testing value (this is optimization)\r\n                V = Math.floor(Math.pow(this.#radical, 1 / this.#nth))\r\n                continue\r\n            }\r\n            V--\r\n        }\r\n        return this\r\n    }\r\n\r\n    multiply = (N: NthRoot): this => {\r\n        this.#radical *= N.radical\r\n        return this.reduce()\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Help functions\r\n    // ------------------------------------------\r\n    hasRadical = (): boolean => {\r\n        return !(this.#radical === 1 || this.#radical === 0 || !this.#isValid)\r\n    }\r\n}","var _ = Object.defineProperty;\nvar C = (n) => {\n  throw TypeError(n);\n};\nvar b = (n, s, e) => s in n ? _(n, s, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[s] = e;\nvar A = (n, s, e) => b(n, typeof s != \"symbol\" ? s + \"\" : s, e), P = (n, s, e) => s.has(n) || C(\"Cannot \" + e);\nvar a = (n, s, e) => (P(n, s, \"read from private field\"), e ? e.call(n) : s.get(n)), k = (n, s, e) => s.has(n) ? C(\"Cannot add the same private member more than once\") : s instanceof WeakSet ? s.add(n) : s.set(n, e), N = (n, s, e, c) => (P(n, s, \"write to private field\"), c ? c.call(n, e) : s.set(n, e), e);\nconst v = {\n  pi: Math.PI,\n  e: Math.exp(1)\n};\nvar t = /* @__PURE__ */ ((n) => (n.VARIABLE = \"variable\", n.COEFFICIENT = \"coefficient\", n.OPERATION = \"operation\", n.CONSTANT = \"constant\", n.FUNCTION = \"function\", n.FUNCTION_ARGUMENT = \"function-argument\", n.MONOM = \"monom\", n.LEFT_PARENTHESIS = \"(\", n.RIGHT_PARENTHESIS = \")\", n))(t || {}), u = /* @__PURE__ */ ((n) => (n.EXPRESSION = \"expression\", n.POLYNOM = \"polynom\", n.SET = \"set\", n.NUMERIC = \"numeric\", n))(u || {});\nfunction F(n, s) {\n  if (n.length <= 1)\n    return n;\n  const e = Object.keys(s).filter((r) => s[r].type === t.FUNCTION).map((r) => r);\n  e.sort((r, O) => O.length - r.length);\n  const c = new RegExp(`^(${e.join(\"|\")})\\\\(`), i = Object.keys(v);\n  i.sort((r, O) => O.length - r.length);\n  const o = new RegExp(`^(${i.join(\"|\")})`), T = /^(\\d+(\\.\\d+)?)/;\n  let f = \"\", d, p, h;\n  for (; n.length > 0; ) {\n    if (d = p, h = void 0, e.length > 0 && c.exec(n)) {\n      const r = e.find((O) => n.startsWith(O));\n      r && (h = r + \"(\", n = n.slice(r.length + 1), p = t.FUNCTION);\n    } else if (i.length > 0 && o.exec(n)) {\n      const r = i.find((O) => n.startsWith(O));\n      r && (h = r, n = n.slice(r.length), p = t.CONSTANT);\n    } else if (T.exec(n)) {\n      const r = T.exec(n);\n      r && (h = r[0], n = n.slice(r[0].length), p = t.COEFFICIENT);\n    } else\n      switch (h = n[0], n = n.slice(1), h) {\n        case \"(\":\n          p = t.LEFT_PARENTHESIS;\n          break;\n        case \")\":\n          p = t.RIGHT_PARENTHESIS;\n          break;\n        case \",\":\n          p = t.FUNCTION_ARGUMENT;\n          break;\n        case \"+\":\n        case \"-\":\n        case \"*\":\n        case \"/\":\n        case \"^\":\n          p = t.OPERATION;\n          break;\n        default:\n          p = t.VARIABLE;\n      }\n    if (h === void 0 || p === void 0)\n      throw new Error(\"The token is undefined\");\n    f += w(d, p), f += h;\n  }\n  return f;\n}\nfunction w(n, s) {\n  return n === void 0 || n === t.OPERATION || s === t.OPERATION || n === t.LEFT_PARENTHESIS || n === t.FUNCTION || n === t.FUNCTION_ARGUMENT || s === t.RIGHT_PARENTHESIS || s === t.FUNCTION_ARGUMENT ? \"\" : \"*\";\n}\nconst U = {\n  \"^\": { precedence: 4, associative: \"right\", type: t.OPERATION },\n  \"*\": { precedence: 3, associative: \"left\", type: t.OPERATION },\n  \"/\": { precedence: 3, associative: \"left\", type: t.OPERATION },\n  \"+\": { precedence: 2, associative: \"left\", type: t.OPERATION },\n  \"-\": { precedence: 2, associative: \"left\", type: t.OPERATION }\n}, y = {\n  \"^\": { precedence: 4, associative: \"right\", type: t.OPERATION },\n  \"*\": { precedence: 3, associative: \"left\", type: t.OPERATION },\n  \"/\": { precedence: 3, associative: \"left\", type: t.OPERATION },\n  \"+\": { precedence: 2, associative: \"left\", type: t.OPERATION },\n  \"-\": { precedence: 2, associative: \"left\", type: t.OPERATION },\n  \"%\": { precedence: 3, associative: \"right\", type: t.OPERATION },\n  sin: { precedence: 4, associative: \"right\", type: t.FUNCTION },\n  cos: { precedence: 4, associative: \"right\", type: t.FUNCTION },\n  tan: { precedence: 4, associative: \"right\", type: t.FUNCTION },\n  sqrt: { precedence: 4, associative: \"right\", type: t.FUNCTION },\n  nthrt: { precedence: 4, associative: \"right\", type: t.FUNCTION },\n  \",\": { precedence: 2, associative: \"left\", type: t.FUNCTION_ARGUMENT }\n}, S = {\n  \"^\": { precedence: 4, associative: \"right\", type: t.OPERATION },\n  \"*\": { precedence: 3, associative: \"left\", type: t.OPERATION },\n  \"/\": { precedence: 3, associative: \"left\", type: t.OPERATION },\n  \"+\": { precedence: 2, associative: \"left\", type: t.OPERATION },\n  \"-\": { precedence: 2, associative: \"left\", type: t.OPERATION },\n  \"%\": { precedence: 3, associative: \"right\", type: t.OPERATION },\n  sin: { precedence: 4, associative: \"right\", type: t.FUNCTION },\n  cos: { precedence: 4, associative: \"right\", type: t.FUNCTION },\n  tan: { precedence: 4, associative: \"right\", type: t.FUNCTION },\n  sqrt: { precedence: 4, associative: \"right\", type: t.FUNCTION },\n  nthrt: { precedence: 4, associative: \"right\", type: t.FUNCTION },\n  ln: { precedence: 4, associative: \"right\", type: t.FUNCTION },\n  log: { precedence: 4, associative: \"right\", type: t.FUNCTION }\n}, M = {\n  \"&\": { precedence: 3, associative: \"left\", type: t.OPERATION },\n  \"|\": { precedence: 3, associative: \"left\", type: t.OPERATION },\n  \"!\": { precedence: 4, associative: \"right\", type: t.OPERATION },\n  \"-\": { precedence: 2, associative: \"left\", type: t.OPERATION }\n};\nvar I, R, l, g, E;\nclass L {\n  constructor(s) {\n    k(this, I);\n    k(this, R, []);\n    k(this, l, {});\n    k(this, g, []);\n    k(this, E);\n    N(this, I, typeof s > \"u\" ? u.POLYNOM : s), this.tokenConfigInitialization();\n  }\n  // Getter\n  get rpn() {\n    return a(this, R);\n  }\n  get rpnToken() {\n    return a(this, R).map((s) => s.token);\n  }\n  tokenConfigInitialization() {\n    return a(this, I) === u.SET ? (N(this, l, M), N(this, E, !1)) : a(this, I) === u.NUMERIC ? (N(this, l, S), N(this, E, !0)) : a(this, I) === u.EXPRESSION ? (N(this, l, y), N(this, E, !0)) : (N(this, l, U), N(this, E, !0)), N(this, g, Object.keys(a(this, l)).sort((s, e) => e.length - s.length)), a(this, l);\n  }\n  /**\n   * Get the next token to analyse.\n   * @param expr (string) Expression to analyse\n   * @param start (number) CUrrent position in the expr string.\n   */\n  NextToken(s, e) {\n    let c, i;\n    if (c = \"\", i = void 0, s[e] === \"(\")\n      c = \"(\", i = t.LEFT_PARENTHESIS;\n    else if (s[e] === \")\")\n      c = \")\", i = t.RIGHT_PARENTHESIS;\n    else if (s[e] === \",\")\n      c = \",\", i = t.FUNCTION_ARGUMENT;\n    else {\n      for (const o of a(this, g))\n        if (s.substring(e, e + o.length) === o) {\n          c += o, i = a(this, l)[o].type;\n          break;\n        }\n      for (const o in v)\n        if (s.substring(e, e + o.length) === o) {\n          c += o, i = t.CONSTANT;\n          break;\n        }\n      if (c === \"\")\n        if (/[0-9.]/.exec(s[e])) {\n          const o = /^([0-9.]+)/.exec(s.substring(e));\n          c = o ? o[0] : \"\", i = t.COEFFICIENT;\n        } else if (/[a-zA-Z]/.exec(s[e])) {\n          const o = /^([a-zA-Z])/.exec(s.substring(e));\n          c = o ? o[0] : \"\", i = t.VARIABLE;\n        } else\n          console.log(\"Unidentified token\", s[e], s, e), c = s[e], i = t.MONOM;\n    }\n    if (i === void 0)\n      throw new Error(`Token type is undefined for token ${c}`);\n    return [c, e + c.length, i];\n  }\n  /**\n   * Parse an expression using the shutting yard tree algorithms\n   * @param expr (string) Expression to analyse\n   * Returns a RPN list of items.\n   * @param uniformize\n   */\n  parse(s, e) {\n    const c = [], i = [];\n    let o = \"\", T = 0, f;\n    (e ?? a(this, E)) && (s = F(s, a(this, l)));\n    const d = 50;\n    let p = 50, h;\n    for (; T < s.length; ) {\n      if (p--, p === 0) {\n        console.log(\"SECURITY LEVEL 1 EXIT\");\n        break;\n      }\n      switch ([o, T, f] = this.NextToken(s, T), f) {\n        case t.MONOM:\n        case t.COEFFICIENT:\n        case t.VARIABLE:\n        case t.CONSTANT:\n          c.push({\n            token: o,\n            tokenType: f\n          });\n          break;\n        case t.OPERATION:\n          if (i.length > 0) {\n            let r = i[i.length - 1];\n            for (h = +d; r.token in a(this, l) && //either o1 is left-associative and its precedence is less than or equal to that of o2,\n            (a(this, l)[o].associative === \"left\" && a(this, l)[o].precedence <= a(this, l)[r.token].precedence || //or o1 is right associative, and has precedence less than that of o2,\n            a(this, l)[o].associative === \"right\" && a(this, l)[o].precedence < a(this, l)[r.token].precedence); ) {\n              if (h--, h === 0) {\n                console.log(\"SECURITY LEVEL 2 OPERATION EXIT\");\n                break;\n              }\n              if (c.push(i.pop() ?? { token: \"\", tokenType: t.OPERATION }), i.length === 0)\n                break;\n              r = i[i.length - 1];\n            }\n          }\n          i.push({ token: o, tokenType: f });\n          break;\n        case t.FUNCTION_ARGUMENT:\n          for (h = +d; i[i.length - 1].token !== \"(\" && i.length > 0; ) {\n            if (h--, h === 0) {\n              console.log(\"SECURITY LEVEL 2 FUNCTION ARGUMENT EXIT\");\n              break;\n            }\n            c.push(i.pop() ?? { token: o, tokenType: f });\n          }\n          break;\n        case t.LEFT_PARENTHESIS:\n          i.push({ token: o, tokenType: f }), s[T] === \"-\" && c.push({ token: \"0\", tokenType: t.COEFFICIENT });\n          break;\n        case t.RIGHT_PARENTHESIS:\n          for (h = +d; i[i.length - 1].token !== \"(\" && i.length > 1; ) {\n            if (h--, h === 0) {\n              console.log(\"SECURITY LEVEL 2 CLOSING PARENTHESIS EXIT\");\n              break;\n            }\n            c.push(i.pop() ?? { token: o, tokenType: f });\n          }\n          i.pop();\n          break;\n        case t.FUNCTION:\n          i.push({ token: o, tokenType: f });\n          break;\n        default:\n          throw new Error(`Token type ${o} is not handled`);\n      }\n    }\n    return N(this, R, c.concat(i.reverse())), this;\n  }\n}\nI = new WeakMap(), R = new WeakMap(), l = new WeakMap(), g = new WeakMap(), E = new WeakMap();\nclass m {\n  constructor(s, e) {\n    A(this, \"_rpn\");\n    A(this, \"_expression\");\n    A(this, \"_isValid\");\n    this._expression = s;\n    try {\n      this._rpn = new L(u.NUMERIC).parse(s, e).rpn;\n    } catch {\n      throw this._rpn = null, this._isValid = !1, new Error(`There was a problem parsing: ${s}`);\n    }\n  }\n  get rpn() {\n    return this._rpn ?? [];\n  }\n  get isValid() {\n    if (this._isValid === void 0)\n      try {\n        this.evaluate({ x: 2 });\n      } catch {\n        this._isValid = !1;\n      }\n    return this._isValid ?? !1;\n  }\n  set isValid(s) {\n    this._isValid = s;\n  }\n  get expression() {\n    return this._expression;\n  }\n  evaluate(s) {\n    const e = [];\n    if (this._rpn === null)\n      return this._isValid = !1, 0;\n    this._isValid = !0;\n    for (const c of this._rpn)\n      if (c.tokenType === t.COEFFICIENT)\n        if (!isNaN(+c.token))\n          e.push(+c.token);\n        else {\n          const i = c.token.split(\"/\");\n          if (i.length !== 2)\n            throw this._isValid = !1, new Error(\"This coefficient is not a fraction\");\n          e.push(+i[0] / +i[1]);\n        }\n      else if (c.tokenType === t.VARIABLE && s !== void 0)\n        Object.hasOwn(s, c.token) && e.push(+s[c.token]);\n      else if (c.tokenType === t.CONSTANT)\n        e.push(v[c.token]);\n      else if (c.tokenType === t.OPERATION) {\n        if (c.token === \"*\") {\n          const i = e.pop(), o = e.pop();\n          if (o === void 0 || i === void 0)\n            throw this._isValid = !1, new Error(`The multiplication factors ${o ?? \"a\"} or ${i ?? \"b\"} are not defined`);\n          e.push(o * i);\n        } else if (c.token === \"/\") {\n          const i = e.pop(), o = e.pop();\n          if (o === void 0 || i === void 0)\n            throw this._isValid = !1, new Error(`The division values ${o ?? \"a\"} or ${i ?? \"b\"} are not defined`);\n          e.push(o / i);\n        } else if (c.token === \"+\") {\n          const i = e.pop(), o = e.pop();\n          if (o === void 0 || i === void 0)\n            throw this._isValid = !1, new Error(`The addition values ${o ?? \"a\"} or ${i ?? \"b\"} are not defined`);\n          e.push(+o + +i);\n        } else if (c.token === \"-\") {\n          const i = e.pop(), o = e.pop() ?? 0;\n          if (i === void 0)\n            throw this._isValid = !1, new Error(\"The subtraction value b is  not defined\");\n          e.push(o - i);\n        } else if (c.token === \"^\") {\n          const i = e.pop(), o = e.pop();\n          if (o === void 0 || i === void 0)\n            throw this._isValid = !1, new Error(`The base value ${o ?? \"a\"} or exponent ${i ?? \"b\"} are not defined`);\n          e.push(Math.pow(o, i));\n        }\n      } else if (c.tokenType === t.FUNCTION) {\n        const i = e.pop();\n        if (i === void 0)\n          throw this._isValid = !1, new Error(`The parameters for ${c.token} is not defined`);\n        if (c.token === \"sin\")\n          e.push(Math.sin(i));\n        else if (c.token === \"cos\")\n          e.push(Math.cos(i));\n        else if (c.token === \"tan\")\n          e.push(Math.tan(i));\n        else if (c.token === \"sqrt\")\n          e.push(Math.sqrt(i));\n        else if (c.token === \"nthrt\") {\n          const o = e.pop();\n          if (o === void 0)\n            throw this._isValid = !1, new Error(\"The nthrt function requires two parameters\");\n          i % 2 === 0 && o < 0 ? e.push(NaN) : e.push((o < 0 ? -1 : 1) * Math.pow(Math.abs(o), 1 / i));\n        } else c.token === \"ln\" ? e.push(Math.log(i)) : c.token === \"log\" && e.push(Math.log10(i));\n      }\n    if (e.length === 1)\n      return this._numberCorrection(e[0]);\n    throw new Error(`There was a problem parsing: ${this._expression}`);\n  }\n  _numberCorrection(s, e = 8) {\n    return +s.toFixed(e);\n  }\n}\nexport {\n  m as NumExp,\n  L as ShutingYard,\n  u as ShutingyardMode,\n  t as ShutingyardType,\n  v as tokenConstant\n};\n","/***\r\n * Monom class\r\n */\r\nimport type {\r\n    IAlgebra,\r\n    IAnalyse,\r\n    IExpression,\r\n    InputAlgebra,\r\n    InputValue,\r\n    IPiMathObject,\r\n    literalType\r\n} from \"../pimath.interface\"\r\nimport { Fraction } from \"../coefficients/fraction\"\r\nimport { NthRoot } from \"../coefficients/nthRoot\"\r\nimport { Numeric } from \"../numeric\"\r\n\r\nimport { ShutingYard, ShutingyardType, type Token } from \"piexpression\"\r\n\r\nexport class Monom implements IPiMathObject<Monom>, IExpression<Monom>, IAnalyse<Monom>, IAlgebra<Monom> {\r\n    #coefficient: Fraction\r\n    #literal: literalType<Fraction>\r\n\r\n    constructor(value?: InputValue<Fraction>)\r\n    constructor(value?: Monom)\r\n    constructor(value?: InputAlgebra<Fraction>) {\r\n        this.#coefficient = new Fraction().zero()\r\n        this.#literal = {}\r\n\r\n        if (value !== undefined) {\r\n            // A string is given - try to parse the value.\r\n            this.parse(value)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    // -----------------------------------------\r\n    /**\r\n     * Parse a string to a monom. The string may include fraction.\r\n     * @param inputStr\r\n     */\r\n    public parse(inputStr: InputAlgebra<Monom>): this {\r\n        // Initialize the monom\r\n        this.#coefficient = new Fraction()\r\n        this.#literal = {}\r\n\r\n        if (typeof inputStr === 'string') {\r\n            this.#shutingYardToReducedMonom(inputStr)\r\n        } else if (typeof inputStr === 'number') {\r\n            this.#coefficient = new Fraction(inputStr)\r\n        } else if (inputStr instanceof Fraction) {\r\n            this.#coefficient = inputStr.clone()\r\n        } else if (inputStr instanceof Monom) {\r\n            this.#coefficient = inputStr.#coefficient.clone()\r\n\r\n            // Copy the literal parts\r\n            this.#cloneLiteral(inputStr)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Clone the current Monom.\r\n     */\r\n    public clone = (): Monom => {\r\n        const F: Monom = new Monom()\r\n\r\n        F.coefficient = this.#coefficient.clone()\r\n\r\n        // Copy the literal parts.\r\n        for (const k in this.#literal) {\r\n            F.setLetter(k, this.#literal[k].clone())\r\n        }\r\n        return F\r\n    }\r\n\r\n    public static gcd = (...monoms: Monom[]): Monom => {\r\n        // All the monoms must be with natural powers...\r\n        for (const m of monoms) {\r\n            if (m.containsRationalPower()) {\r\n                return new Monom().zero()\r\n            }\r\n        }\r\n\r\n        const M = new Monom(),\r\n            n: number = Numeric.gcd(...monoms.map(value => value.coefficient.numerator)),\r\n            d: number = Numeric.lcm(...monoms.map(value => value.coefficient.denominator))\r\n\r\n        // Get the coefficient.\r\n        M.coefficient = new Fraction(n, d).reduce()\r\n\r\n        // Set the literal parts - go through each monoms literal parts and get only the lowest degree of each letters.\r\n        for (const m of monoms) {\r\n            // Remove the inexistant letters from the resulting monom\r\n            for (const letter in M.literal) {\r\n                if (!(letter in m.literal)) {\r\n                    M.literal[letter].zero()\r\n                }\r\n            }\r\n            for (const letter in m.literal) {\r\n                if (!M.hasVariable(letter) && m.literal[letter].isStrictlyPositive()) {\r\n                    M.literal[letter] = m.literal[letter].clone()\r\n                } else {\r\n                    M.literal[letter] = new Fraction(Math.min(m.literal[letter].value, M.literal[letter].value))\r\n                }\r\n            }\r\n        }\r\n\r\n        return M\r\n    }\r\n\r\n    /**\r\n     * Multiply two monoms and return a NEW monom.\r\n     * @param monoms\r\n     */\r\n    public static xMultiply = (...monoms: Monom[]): Monom => {\r\n        const M = new Monom().one()\r\n\r\n        for (const m of monoms) {\r\n            M.multiply(m)\r\n        }\r\n\r\n        return M\r\n    }\r\n\r\n    /**\r\n     * Add all similar monoms. If they aren't similar, they are simply skipped.\r\n     * @param M (Monom[]) The monoms to add.\r\n     */\r\n    public add = (...M: InputAlgebra<Fraction>[]): this => {\r\n        for (const m of M) {\r\n            // If the value given is not a monom, create it.\r\n            const mAsMonom = (!(m instanceof Monom)) ? new Monom(m) : m\r\n\r\n            if (this.isSameAs(mAsMonom)) {\r\n                if (this.isZero()) {\r\n                    this.#cloneLiteral(mAsMonom)\r\n                }\r\n\r\n                this.#coefficient.add(mAsMonom.coefficient)\r\n            } else {\r\n                console.log('Add monom: ' + this.display + ' is not similar with ', mAsMonom.display)\r\n            }\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Get the coefficient \\\\(k\\\\) of the Monom \\\\(k\\\\cdot x^{n}\\\\)\r\n     * @returns {Fraction}\r\n     */\r\n    public get coefficient(): Fraction {\r\n        return this.#coefficient\r\n    }\r\n\r\n    /**\r\n     * Set the coefficient \\\\(k\\\\) value of the monom\r\n     * @param {Fraction | number | string} F\r\n     */\r\n    public set coefficient(F: InputValue<Fraction>) {\r\n        this.#coefficient = new Fraction(F)\r\n    }\r\n\r\n    public containsRationalPower = (): boolean => {\r\n        return Object.values(this.#literal).some((value) => value.isRational())\r\n    }\r\n\r\n    /**\r\n     * Get the degree of a monom. If no setLetter is given, the result will be the global degree.\r\n     * @param letter (string) Letter to get to degree (power)\r\n     */\r\n    public degree = (letter?: string): Fraction => {\r\n        if (this.variables.length === 0) {\r\n            return new Fraction().zero()\r\n        }\r\n        if (letter === undefined) {\r\n            // Not setLetter given -> we get the global monom degree (sum of all the letters).\r\n            return Object.values(this.#literal).reduce((t, n) => t.clone().add(n))\r\n        } else {\r\n            // A setLetter is given -> get the corresponding power.\r\n            return !this.hasVariable(letter) ? new Fraction().zero() : this.#literal[letter].clone()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Derivative the monom\r\n     * @param letter\r\n     */\r\n    public derivative = (letter?: string): Monom => {\r\n        // No setLetter given - assume it's the setLetter 'x'\r\n        if (letter === undefined) {\r\n            letter = 'x'\r\n        }\r\n\r\n        if (this.hasVariable(letter)) {\r\n            const d = this.#literal[letter].clone(),\r\n                dM = this.clone()\r\n\r\n            // Subtract one to the degree.\r\n            dM.#literal[letter].subtract(1)\r\n\r\n            // Multiply the coefficient by the previous degree\r\n            dM.#coefficient.multiply(new Fraction(d.clone()))\r\n            return dM\r\n        } else {\r\n            return new Monom().zero()\r\n        }\r\n    }\r\n\r\n    // Display getter\r\n    /**\r\n     * This display getter is to be used in the polynom display getter\r\n     */\r\n    public get display(): string {\r\n        let L = ''\r\n        const letters = Object.keys(this.#literal).sort()\r\n        for (const letter of letters) {\r\n            if (this.#literal[letter].isNotZero()) {\r\n                L += letter\r\n                if (this.#literal[letter].isNotEqual(1)) {\r\n                    L += `^(${this.#literal[letter].display})`\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this.#coefficient.value != 0) {\r\n                return this.#coefficient.display\r\n            } else {\r\n                return ''\r\n            }\r\n        } else {\r\n            if (this.#coefficient.value === 1) {\r\n                return L\r\n            } else if (this.#coefficient.value === -1) {\r\n                return `-${L}`\r\n            } else if (this.#coefficient.value === 0) {\r\n                return '0'\r\n            } else {\r\n                return `${this.#coefficient.display}${L}`\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Divide the current monoms by multiple monoms\r\n     * @param M (Monom[])\r\n     */\r\n    public divide = (...M: InputAlgebra<Fraction>[]): this => {\r\n        // Depending on the given value, choose the current item\r\n        for (const m of M) {\r\n            // If the value given is not a monom, create it.\r\n            const mAsMonom = (!(m instanceof Monom)) ? new Monom(m) : m\r\n\r\n            // Divide the coefficient\r\n            this.#coefficient.divide(mAsMonom.coefficient)\r\n\r\n            // Subtract the power values\r\n            for (const letter in mAsMonom.literal) {\r\n\r\n                this.#literal[letter] = this.hasVariable(letter) ?\r\n                    this.#literal[letter].subtract(mAsMonom.literal[letter]) :\r\n                    mAsMonom.literal[letter].clone().opposite()\r\n\r\n\r\n                // If the power of a particular setLetter is zero, delete it from the literal part..\r\n                if (this.#literal[letter].isZero()) {\r\n                    this.removeVariable(letter)\r\n                }\r\n            }\r\n        }\r\n        return this\r\n    }\r\n\r\n    public get dividers(): Monom[] {\r\n        // Decompose only if the coefficient is a natural number\r\n        if (!this.coefficient.isRelative()) {\r\n            return [this.clone()]\r\n        }\r\n\r\n        // Decompose only if the power values are natural numbers.\r\n        if (this.containsRationalPower()) {\r\n            return [this.clone()]\r\n        }\r\n\r\n        // Security : do not do this if greater than 10000\r\n        if (this.coefficient.numerator > 1000000) {\r\n            return [this.clone()]\r\n        }\r\n\r\n        const dividers = Numeric.dividers(Math.abs(this.coefficient.numerator))\r\n\r\n        // Decompose the literals parts.\r\n        let literals: literalType<Fraction>[] = []\r\n        for (const L in this.literal) {\r\n            // L is the letter.\r\n            literals = this._getLiteralDividers(literals, L)\r\n        }\r\n\r\n        const monomDividers: Monom[] = []\r\n        if (literals.length > 0 && dividers.length > 0) {\r\n            for (const N of dividers) {\r\n                for (const L of literals) {\r\n                    const M = new Monom()\r\n                    M.coefficient = new Fraction(N)\r\n                    M.literal = L\r\n                    monomDividers.push(M)\r\n                }\r\n            }\r\n        } else if (dividers.length === 0) {\r\n            for (const L of literals) {\r\n                const M = new Monom()\r\n                M.coefficient = new Fraction().one()\r\n                M.literal = L\r\n                monomDividers.push(M)\r\n            }\r\n        } else {\r\n            for (const N of dividers) {\r\n                const M = new Monom()\r\n                M.coefficient = new Fraction(N)\r\n                monomDividers.push(M)\r\n            }\r\n        }\r\n\r\n        return monomDividers.length === 0 ? [new Monom().one()] : monomDividers\r\n    }\r\n\r\n    /**\r\n     * Evaluate a monom. Each setLetter must be assigned to a Fraction.\r\n     * @param values    Dictionary of <setLetter: Fraction>\r\n     * @param asNumeric\r\n     */\r\n    public evaluate = (values: literalType<number | Fraction> | InputValue<Fraction>, asNumeric?: boolean): Fraction | number => {\r\n        // If as numeric return the numeric value\r\n        if (asNumeric === true) {\r\n            // Convert all values to numeric\r\n            // If the value is a Fraction, convert it to a number\r\n            if (values instanceof Fraction) {\r\n                return this.#evaluateAsNumeric(values.value)\r\n            }\r\n\r\n            // If the value is a NthRoot, return undefined\r\n            if (values instanceof NthRoot) {\r\n                return new Fraction().invalid()\r\n            }\r\n\r\n            // If the value is a number, return the numeric value\r\n            if (typeof values === 'number') {\r\n                return this.#evaluateAsNumeric(values)\r\n            }\r\n\r\n            // If the value is an object, return the numeric value\r\n            if (typeof values === 'object') {\r\n                // Convert {[key:string]:Fraction} to {[key:string]:number}\r\n                const tmpValues: literalType<number> = {}\r\n                for (const L in values) {\r\n                    tmpValues[L] = new Fraction(values[L]).value\r\n                }\r\n\r\n                return this.#evaluateAsNumeric(tmpValues)\r\n            }\r\n        }\r\n\r\n        // The answer must be a Fraction\r\n        const r = this.coefficient.clone()\r\n\r\n        if (typeof values === 'number' || values instanceof Fraction) {\r\n            const tmpValues: literalType<Fraction> = {}\r\n            tmpValues[this.variables[0]] = new Fraction(values)\r\n            return this.evaluate(tmpValues)\r\n        }\r\n\r\n        if (values instanceof NthRoot) {\r\n            return new Fraction().invalid()\r\n        }\r\n\r\n        if (typeof values === 'object') {\r\n            if (this.variables.length === 0) {\r\n                return this.coefficient\r\n            }\r\n\r\n            for (const L in this.#literal) {\r\n                const value = new Fraction(values[L])\r\n\r\n                r.multiply(value.pow(this.#literal[L]))\r\n            }\r\n        }\r\n\r\n        return r\r\n    }\r\n\r\n    // -------------------------------------\r\n    /**\r\n     * Determine if a monom contains a setLetter in it's literal part\r\n     * @param letter\r\n     */\r\n    public hasVariable = (letter?: string): boolean => {\r\n        // The letter was not found\r\n        return Object.hasOwn(this.#literal, letter ?? 'x')\r\n    }\r\n\r\n    public integrate(a: InputValue<Fraction>, b: InputValue<Fraction>, letter?: string  ): Fraction {\r\n        const primitive = this.primitive(letter)\r\n\r\n        return (primitive.evaluate(b) as Fraction)\r\n            .subtract(primitive.evaluate(a) as Fraction)\r\n    }\r\n\r\n    public inverse = (): this => {\r\n        this.#coefficient.opposite()\r\n        for (const letter in this.#literal) {\r\n            this.#literal[letter].opposite()\r\n        }\r\n        return this\r\n    }\r\n\r\n    public isDivisible = (div: Monom): boolean => {\r\n        // For all variables (letters), the current monom must have a degree higher than the divider\r\n        if (div.degree().isStrictlyPositive()) {\r\n            for (const letter of div.variables) {\r\n                if (!this.degree(letter).isGeq(div.degree(letter))) {\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n\r\n        // If the coefficient is rational, we suppose we don't need to check the division by the coefficient.\r\n        if (this.coefficient.isRational() || div.coefficient.isRational()) {\r\n            return true\r\n        }\r\n\r\n        return this.coefficient.clone().divide(div.coefficient).isRelative()\r\n    }\r\n\r\n    /**\r\n     * Determine if two monoms are equals\r\n     * @param M\r\n     */\r\n    public isEqual = (M: Monom): boolean => {\r\n        return this.isSameAs(M) && this.#coefficient.isEqual(M.coefficient)\r\n    }\r\n\r\n    public isLiteralSquare = (): boolean => {\r\n        for (const letter in this.literal) {\r\n            // A literal square must have a natural power\r\n            if (this.literal[letter].isRational()) {\r\n                return false\r\n            }\r\n\r\n            // The natural power must be be even\r\n            if (this.literal[letter].isEven()) {\r\n                return false\r\n            }\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is one\r\n     */\r\n    public isOne = (): boolean => {\r\n        return this.#coefficient.value === 1 && this.variables.length === 0\r\n    }\r\n\r\n    /**\r\n     * Determine if two monoms are similar\r\n     * @param M\r\n     */\r\n    public isSameAs = (M: Monom): boolean => {\r\n        // Get the list of all variables from both monoms.\r\n        const M1: string[] = this.variables\r\n        const M2: string[] = M.variables\r\n\r\n        // Get the list of all variables from both monoms.\r\n        const K: string[] = M1.concat(M2.filter((item) => !M1.includes(item)))\r\n\r\n        // If one of the monom is zero, it is the same than the other.\r\n        if (this.isZero() || M.isZero()) {\r\n            return true\r\n        }\r\n\r\n        // Both monoms has no literal part.\r\n        if (M1.length === 0 && M2.length === 0) {\r\n            return true\r\n        }\r\n\r\n        // Both monoms must have the same variables\r\n        if (M1.length !== M2.length) {\r\n            return false\r\n        }\r\n\r\n        // To _compare, both must be different from zero.\r\n        if (!this.isZero() && !M.isZero()) {\r\n            for (const key of K) {\r\n                // The variable is not available in one of the monom\r\n                if (!this.hasVariable(key) || !M.hasVariable(key)) {\r\n                    return false\r\n                }\r\n\r\n                // The variable does not have the same power in each monoms.\r\n                if (!this.#literal[key].isEqual(M.literal[key])) {\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n\r\n        // All are positive check - the monoms are the sames.\r\n        return true\r\n    }\r\n\r\n    public isSquare = (): boolean => {\r\n        if (!this.coefficient.isSquare()) {\r\n            return false\r\n        }\r\n        return this.isLiteralSquare()\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is null\r\n     */\r\n    public isZero = (): boolean => {\r\n        return this.#coefficient.value === 0\r\n    }\r\n\r\n    /**\r\n     * Get the literal part of \\\\(x^{n_1}y^{n_2}\\\\) as dictionary \\\\[\\\\begin{array}{ll}x&=n_1\\\\\\\\y&=n_2\\\\end{array}\\\\]\r\n     * @returns {literalType}\r\n     */\r\n    public get literal(): literalType<Fraction> {\r\n        return this.#literal\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom. Must be a dictionary {x: Fraction, y: Fraction, ...}\r\n     * @param {literalType<Fraction>} L\r\n     */\r\n    public set literal(L: literalType<Fraction>) {\r\n        this.#literal = L\r\n    }\r\n\r\n    /**\r\n     * Get the literal square roots of the Monom.\r\n     * TODO: remove this getter ? Is it used and is it correct ?\r\n     * @returns {literalType<Fraction>}\r\n     */\r\n    public get literalSqrt(): literalType<Fraction> {\r\n        // TODO: used in Polynom._factorize2ndDegree : remove it from here ?\r\n        if (this.isLiteralSquare()) {\r\n            const L: literalType<Fraction> = {}\r\n            for (const key in this.#literal) {\r\n                L[key] = this.#literal[key].clone().sqrt()\r\n            }\r\n            return L\r\n        } else {\r\n            return this.#literal\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom from a string\r\n     * @param inputStr  String like x^2y^3\r\n     */\r\n    public set literalStr(inputStr: string) {\r\n        // TODO : parse using ShutingYard tree !\r\n\r\n        // Match all x^n\r\n        for (const v of [...inputStr.matchAll(/([a-z])\\^([+-]?[0-9]+)/g)]) {\r\n            // Create the default letter entry if necessary.\r\n            if (!(v[1] in this.#literal)) {\r\n                this.#literal[v[1]] = new Fraction().zero()\r\n            }\r\n\r\n            // Add the new value.\r\n            // TODO: actually, it adds only numeric value\r\n            this.#literal[v[1]].add(+v[2])\r\n        }\r\n\r\n        // Match all x\r\n        for (const v of [...inputStr.matchAll(/([a-z](?!\\^))/g)]) {\r\n            // Match all single letters\r\n            if (!(v[1] in this.#literal)) {\r\n                this.#literal[v[1]] = new Fraction().zero()\r\n            }\r\n\r\n            // Add one to the value.\r\n            this.#literal[v[1]].add(1)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Multiple multiple monoms to the current monom\r\n     * @param M (Monom[]) The monoms to multiply to.\r\n     */\r\n    public multiply = (...M: InputAlgebra<Fraction>[]): this => {\r\n        for (const m of M) {\r\n            // If the value given is not a monom, create it.\r\n            const mAsMonom = (!(m instanceof Monom)) ? new Monom(m) : m\r\n\r\n            // Multiply the coefficient.\r\n            this.#coefficient.multiply(mAsMonom.coefficient)\r\n\r\n            // Multiply the literal parts.\r\n            for (const letter in mAsMonom.literal) {\r\n                if (!this.hasVariable(letter)) {\r\n                    this.#literal[letter] = mAsMonom.literal[letter].clone()\r\n                } else {\r\n                    this.#literal[letter].add(mAsMonom.literal[letter])\r\n                }\r\n            }\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Create a one value monom\r\n     */\r\n    public one = (): this => {\r\n        this.#coefficient = new Fraction().one()\r\n        this.#literal = {}\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Get the opposite\r\n     * Returns a monom.\r\n     */\r\n    public opposite = (): this => {\r\n        this.#coefficient.opposite()\r\n        return this\r\n    }\r\n\r\n    public get plotFunction(): string {\r\n        let L = ''\r\n        const letters = Object.keys(this.#literal).sort()\r\n\r\n        for (const letter of letters) {\r\n            if (this.#literal[letter].isNotZero()) {\r\n                L += (L === '' ? \"\" : \"*\") + letter\r\n                if (this.#literal[letter].isNotEqual(1)) {\r\n                    L += `^(${this.#literal[letter].display})`\r\n                }\r\n            }\r\n        }\r\n\r\n        // No literal part\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this.#coefficient.value != 0) {\r\n                return this.#coefficient.display\r\n            } else {\r\n                return ''\r\n            }\r\n        } else {\r\n            if (this.#coefficient.value === 1) {\r\n                return L\r\n            } else if (this.#coefficient.value === -1) {\r\n                return `-${L}`\r\n            } else if (this.#coefficient.value === 0) {\r\n                return '0'\r\n            } else {\r\n                return `${this.#coefficient.display}*${L}`\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the pow of a monom.\r\n     * @param nb (number) : Mathematical pow\r\n     */\r\n    public pow = (nb: number | Fraction): this => {\r\n        this.#coefficient.pow(nb)\r\n        for (const letter in this.#literal) {\r\n            this.#literal[letter].multiply(nb)\r\n        }\r\n        return this\r\n    }\r\n\r\n    public primitive = (letter?: string): Monom => {\r\n        // TODO: derivative including the ln value => implies creating different monom system ?\r\n        if (letter === undefined) {\r\n            letter = 'x'\r\n        }\r\n\r\n        // Zero monom\r\n        const M = this.clone()\r\n        let degree: Fraction\r\n\r\n        if (M.hasVariable(letter)) {\r\n            degree = M.degree(letter).clone().add(1)\r\n            M.coefficient = M.coefficient.clone().divide(degree)\r\n            M.setLetter(letter, degree)\r\n        } else {\r\n            // There is no letter.\r\n\r\n            // The coefficient might be zero (=> x) or a number a (=> ax)\r\n            if (M.coefficient.isZero()) {\r\n                M.coefficient = new Fraction().one()\r\n            }\r\n            M.setLetter(letter, 1)\r\n        }\r\n\r\n        return M\r\n    }\r\n\r\n    public reduce = (): this => {\r\n        // Reduce the coefficient\r\n        this.coefficient.reduce()\r\n\r\n        // Reduce the literal parts (removing null powers)\r\n        for (const letter in this.#literal) {\r\n            if (this.#literal[letter].isZero()) {\r\n                this.removeVariable(letter)\r\n            }\r\n        }\r\n        return this\r\n    }\r\n\r\n    public removeVariable(letter: string) {\r\n        /* eslint-disable */\r\n        delete this.#literal[letter]\r\n        /* eslint-enable */\r\n    }\r\n\r\n    /**\r\n     * Get the nth-root of the monom\r\n     */\r\n    public root = (): this => {\r\n        throw new Error('Method not implemented.')\r\n    }\r\n\r\n    /**\r\n     * Set the power of a particular setLetter\r\n     * @param letter (string) Letter to change\r\n     * @param pow (number) Power of the setLetter (must be positive integer.\r\n     */\r\n    public setLetter = (letter: string, pow: InputValue<Fraction>): this => {\r\n        if (!(pow instanceof Fraction)) {\r\n            return this.setLetter(letter, new Fraction(pow))\r\n        }\r\n\r\n        // Set the power of the letter to zero => remove it\r\n        if (this.hasVariable(letter) && pow.isZero()) {\r\n            this.removeVariable(letter)\r\n        }\r\n\r\n\r\n        this.#literal[letter] = pow.clone()\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Return the square root of a monom\r\n     */\r\n    public sqrt = (): this => {\r\n        if (this.isSquare()) {\r\n            this.#coefficient.sqrt()\r\n            for (const letter in this.#literal) {\r\n                this.#literal[letter].clone().divide(2)\r\n            }\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Subtract multiple monoms\r\n     * @param M (Monom[]) The monoms to subtract\r\n     */\r\n    public subtract = (...M: InputAlgebra<Fraction>[]): this => {\r\n        for (const m of M) {\r\n            // If the value given is not a monom, create it.\r\n            const mAsMonom = (!(m instanceof Monom)) ? new Monom(m) : m\r\n\r\n            if (this.isSameAs(mAsMonom)) {\r\n                if (this.isZero()) {\r\n                    this.#cloneLiteral(mAsMonom)\r\n                }\r\n\r\n                this.#coefficient.add(mAsMonom.clone().coefficient.opposite())\r\n            } else {\r\n                console.log('Subtract: Is not similar: ', mAsMonom.display)\r\n            }\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Get the tex output of the monom\r\n     */\r\n    public get tex(): string {\r\n        // TODO: display with square root !\r\n        // TODO: Refactor to make it more readable\r\n        let L = ''\r\n        const letters = Object.keys(this.#literal).sort()\r\n\r\n        for (const letter of letters) {\r\n            if (this.#literal[letter].isNotZero()) {\r\n                L += letter\r\n                if (this.#literal[letter].isNotEqual(1)) {\r\n                    L += `^{ ${this.#literal[letter].tfrac.tex } }`\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this.#coefficient.value != 0) {\r\n                return this.#coefficient.frac.tex\r\n            } else {\r\n                return '0'\r\n            }\r\n        } else {\r\n            if (this.#coefficient.value === 1) {\r\n                return L\r\n            } else if (this.#coefficient.value === -1) {\r\n                return `-${L}`\r\n            } else if (this.#coefficient.value === 0) {\r\n                return '0'\r\n            } else {\r\n                return `${this.#coefficient.frac.tex}${L}`\r\n            }\r\n        }\r\n    }\r\n\r\n    // Getter helpers.\r\n    /**\r\n     * Get the variables letters\r\n     */\r\n    public get variables(): string[] {\r\n        // const M = this.clone().clean()\r\n\r\n        const L: string[] = []\r\n        Object.entries(this.literal).forEach(\r\n            ([key, value]) => {\r\n                if (!value.isZero()) {\r\n                    L.push(key)\r\n                }\r\n            })\r\n        L.sort()\r\n        return L\r\n        // return Object.keys(M.literal)\r\n    }\r\n\r\n    /**\r\n     * Create a zero value monom\r\n     */\r\n    public zero = (): this => {\r\n        this.#coefficient = new Fraction().zero()\r\n        this.#literal = {}\r\n        return this\r\n    }\r\n\r\n    #cloneLiteral(inputStr: Monom) {\r\n        for (const k in inputStr.literal) {\r\n            this.#literal[k] = inputStr.literal[k].clone()\r\n        }\r\n    }\r\n\r\n    #evaluateAsNumeric = (values: literalType<number | Fraction> | InputValue<Fraction>): number => {\r\n        let r = this.coefficient.value\r\n\r\n        if (typeof values === \"number\") {\r\n            const tmpValues: literalType<number> = {}\r\n            const key = this.variables[0]\r\n            tmpValues[key] = values\r\n\r\n            return this.#evaluateAsNumeric(tmpValues)\r\n        }\r\n\r\n        if (values instanceof Fraction) {\r\n            const tmpValues: literalType<number> = {}\r\n            tmpValues[this.variables[0]] = new Fraction(values).value\r\n            return this.#evaluateAsNumeric(tmpValues)\r\n        }\r\n\r\n        if (values instanceof NthRoot) {\r\n            return NaN\r\n        }\r\n\r\n        if (typeof values === 'object') {\r\n            if (this.variables.length === 0) {\r\n                return this.coefficient.value\r\n            }\r\n\r\n            for (const L in this.#literal) {\r\n                const v = values[L]\r\n\r\n                if (v instanceof Fraction) {\r\n                    r *= v.value ** (this.#literal[L].value)\r\n                } else {\r\n                    r *= v ** (this.#literal[L].value)\r\n                }\r\n            }\r\n        }\r\n\r\n        return r\r\n    }\r\n\r\n    private _getLiteralDividers(arr: literalType<Fraction>[], letter: string): literalType<Fraction>[] {\r\n        const tmpList: Record<string, Fraction>[] = []\r\n\r\n        // Be default, this.literal[letter] should be a rational number.\r\n        for (let d = 0; d <= this.literal[letter].value; d++) {\r\n            if (arr.length === 0) {\r\n                const litt: literalType<Fraction> = {}\r\n                litt[letter] = new Fraction(d)\r\n                tmpList.push(litt)\r\n            } else {\r\n                for (const item of arr) {\r\n                    const litt: literalType<Fraction> = {}\r\n                    for (const currentLetter in item) {\r\n                        litt[currentLetter] = item[currentLetter]\r\n                    }\r\n                    litt[letter] = new Fraction(d)\r\n                    tmpList.push(litt)\r\n                }\r\n            }\r\n        }\r\n        return tmpList\r\n    }\r\n\r\n    #shutingYardToReducedMonom = (inputStr: string): this => {\r\n        // Get the RPN array of the current expression\r\n        const SY: ShutingYard = new ShutingYard().parse(inputStr)\r\n        const rpn: { token: string, tokenType: ShutingyardType }[] = SY.rpn\r\n\r\n        const stack: Monom[] = []\r\n\r\n        if (rpn.length === 0) {\r\n            this.zero()\r\n            return this\r\n        } else if (rpn.length === 1) {\r\n            const element = rpn[0]\r\n\r\n            this.one()\r\n            if (element.tokenType === ShutingyardType.COEFFICIENT) {\r\n                this.coefficient = new Fraction(element.token)\r\n            } else if (element.tokenType === ShutingyardType.VARIABLE) {\r\n                this.setLetter(element.token, 1)\r\n            }\r\n            return this\r\n        } else {\r\n            // Reset the monom\r\n            for (const element of rpn) {\r\n                this.#shutingYard_AddToken(stack, element)\r\n            }\r\n        }\r\n\r\n        this.one()\r\n        this.multiply(stack[0])\r\n        return this\r\n    }\r\n\r\n    #shutingYard_AddToken = (stack: Monom[], element: Token): void => {\r\n        let q1: Monom, q2: Monom, m: Monom, letter: string, pow: Fraction\r\n\r\n        if (element.tokenType === ShutingyardType.COEFFICIENT) {\r\n            stack.push(new Monom(new Fraction(element.token)))\r\n\r\n        } else if (element.tokenType === ShutingyardType.VARIABLE) {\r\n            const M = new Monom().one()\r\n            M.setLetter(element.token, 1)\r\n            stack.push(M.clone())\r\n\r\n        } else if (element.tokenType === ShutingyardType.OPERATION) {\r\n            switch (element.token) {\r\n                case '-':\r\n                    // this should only happen for negative powers or for negative coefficient.\r\n                    q2 = (stack.pop()) ?? new Monom().zero()\r\n                    q1 = (stack.pop()) ?? new Monom().zero()\r\n\r\n                    stack.push(q1.subtract(q2))\r\n\r\n                    break\r\n                case '*':\r\n                    // Get the last element in the stack\r\n                    q2 = (stack.pop()) ?? new Monom().one()\r\n                    q1 = (stack.pop()) ?? new Monom().one()\r\n\r\n                    stack.push(q1.multiply(q2))\r\n                    break\r\n                case '/':\r\n                    // Get the last element in the stack\r\n                    q2 = (stack.pop()) ?? new Monom().one()\r\n                    q1 = (stack.pop()) ?? new Monom().one()\r\n\r\n                    stack.push(q1.divide(q2))\r\n                    break\r\n                case '^': {\r\n                    // get the two last elements in the stack\r\n                    const poppedCoefficient = stack.pop()?.coefficient\r\n                    pow = poppedCoefficient ?? new Fraction().one()\r\n                    m = stack.pop() ?? new Monom().one()\r\n\r\n                    letter = m.variables[0]\r\n\r\n                    if (letter) {\r\n                        m.setLetter(letter, pow)\r\n                    }\r\n\r\n                    stack.push(m)\r\n                    // this.multiply(m.clone())\r\n                    break\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","// TODO: Convert EquationSolver class to a simple function ?\r\n\r\nimport type {InputValue, ISolution} from \"../pimath.interface\"\r\nimport type {Polynom} from \"./polynom\"\r\nimport {Fraction} from \"../coefficients/fraction\"\r\nimport {Numeric} from \"../numeric\"\r\nimport type {Equation} from \"./equation\"\r\n\r\nexport class EquationSolver {\r\n    readonly #equation: Polynom\r\n    readonly #variable: string\r\n\r\n    constructor(left: Polynom | Equation, right?: Polynom, variable = \"x\") {\r\n        this.#variable = variable\r\n\r\n        if (Object.hasOwn(left, 'moveLeft')) {\r\n            const equ = left as Equation\r\n            this.#equation = equ.left.clone().subtract(equ.right)\r\n        } else {\r\n            this.#equation = (left as Polynom).clone().subtract(right ?? 0)\r\n        }\r\n    }\r\n\r\n    public solve(): ISolution[] {\r\n        // TODO: Make sure the solutions are listed in growing order !\r\n        if (this.#equation.degree().isOne()) {\r\n            return this.#solveLinear()\r\n        }\r\n\r\n        if (this.#equation.degree().value === 2) {\r\n            return this.#solveQuadratic()\r\n        }\r\n\r\n        const result = this.#solveByFactorization()\r\n        if (result.length > 0) {\r\n            return result\r\n        }\r\n\r\n        // Use Cardan formula for cubic equations\r\n        if (this.#equation.degree().value === 3) {\r\n            return this.#solveCubic_CardanFormula()\r\n        }\r\n\r\n        throw new Error(\"The equation degree is too high.\")\r\n    }\r\n\r\n    public solveAsCardan(): ISolution[] {\r\n        if (this.#equation.degree().value !== 3) {\r\n            throw new Error(\"The equation is not cubic.\")\r\n        }\r\n        return this.#solveCubic_CardanFormula()\r\n    }\r\n\r\n    #makeApproximativeSolution(value: number, output?: { tex: string, display: string }): ISolution {\r\n        return {\r\n            variable: this.#variable,\r\n            exact: false,\r\n            value: +value.toFixed(10),\r\n            tex: output?.tex ?? '',\r\n            display: output?.display ?? ''\r\n        }\r\n    }\r\n\r\n    #makeSolution(value: InputValue<Fraction>): ISolution {\r\n        if (value instanceof Fraction && value.isApproximative()) {\r\n            return this.#makeApproximativeSolution(value.value)\r\n        }\r\n\r\n        const fraction = new Fraction(value)\r\n        return {\r\n            variable: this.#variable,\r\n            exact: fraction,\r\n            value: fraction.value,\r\n            tex: fraction.tex,\r\n            display: fraction.display\r\n        }\r\n    }\r\n\r\n    #solveByFactorization(): ISolution[] {\r\n        // Move everything to the left.\r\n\r\n        // Get the polynom on the left (on the right, it's zero)\r\n        let left = this.#equation.clone()\r\n\r\n        // The solutions of the equation\r\n        let solutions: ISolution[] = []\r\n\r\n        // multiply by the lcm of the denominators\r\n        // to get rid of the fractions\r\n        const lcm = left.lcmDenominator()\r\n        if (lcm !== 1) {\r\n            left.multiply(lcm)\r\n        }\r\n\r\n        // left is a polynom ax^n+...+b\r\n        const a = left.monomByDegree().coefficient // Greatest coefficient\r\n        let b = left.monomByDegree(0).coefficient // Constant term\r\n\r\n        // if the constant term is null, the polynom can be divided by x\r\n        while (b.isZero()) {\r\n            if (solutions.length === 0) {\r\n                solutions.push(this.#makeSolution(0))\r\n            }\r\n\r\n            left = (left.divide('x'))\r\n            b = left.monomByDegree(0).coefficient\r\n        }\r\n\r\n        // get all dividers of a and b\r\n        const dividersA = Numeric.dividers(a.value)\r\n        const dividersB = Numeric.dividers(b.value)\r\n\r\n        // test all possible solutions\r\n        for (const da of dividersA) {\r\n            for (const db of dividersB) {\r\n                const f = new Fraction(db, da)\r\n\r\n                // Test with the fraction\r\n                if ((left.evaluate(f) as Fraction).isZero() && !solutions.find(s => s.value === f.value)) {\r\n                    solutions.push(this.#makeSolution(f))\r\n                }\r\n\r\n                // Test with the opposite fraction\r\n                f.opposite()\r\n                if ((left.evaluate(f) as Fraction).isZero() && !solutions.find(s => s.value === f.value)) {\r\n                    solutions.push(this.#makeSolution(f))\r\n                }\r\n            }\r\n        }\r\n\r\n        // divide the left polynom by the solutions (as polynom)\r\n        // to get the reduced polynom\r\n        for (const s of solutions) {\r\n            // if the solution is exact and is zero, it's already divided: skip it !\r\n            if (s.exact !== false && (s.exact as Fraction).isZero()) {\r\n                continue\r\n            }\r\n\r\n            const p = this.#equation.clone().parse('x', (s.exact as Fraction).denominator, -(s.exact as Fraction).numerator)\r\n\r\n            while (left.isDividableBy(p)) {\r\n                left = left.divide(p)\r\n            }\r\n        }\r\n\r\n        // if the reduced polynom is of degree 0, we have found all the solutions\r\n        if (left.degree().isZero()) {\r\n            return solutions.sort((a, b) => a.value - b.value)\r\n        }\r\n\r\n        // if the reduced polynom is of degree greater than 3, we can't solve it\r\n        if (left.degree().value > 3) {\r\n            return []\r\n        }\r\n\r\n        // if the reduced polynom is of degree 1 or 2, we can solve it\r\n        const solver = new EquationSolver(left, left.clone().parse('0'), this.#variable)\r\n        solutions = solutions.concat(solver.solve())\r\n\r\n        return solutions.sort((a, b) => a.value - b.value)\r\n    }\r\n\r\n    #solveCubic_CardanFormula(): ISolution[] {\r\n        // get the coefficients of the equation\r\n        const left = this.#equation\r\n\r\n        // left is a polynom ax^3+bx^2+cx+d => the solution is x = (-b±√(b^2-4ac))/2a\r\n        const a = left.monomByDegree(3).coefficient\r\n        const b = left.monomByDegree(2).coefficient\r\n        const c = left.monomByDegree(1).coefficient\r\n        const d = left.monomByDegree(0).coefficient\r\n\r\n        // normalize the coefficient by dividing by a\r\n        const an = b.clone().divide(a)\r\n        const bn = c.clone().divide(a)\r\n        const cn = d.clone().divide(a)\r\n\r\n        // Depressed cubic equation\r\n        // x^3+px+q=0\r\n        const p = bn.clone().subtract(an.clone().pow(2).divide(3))\r\n        const q = cn.clone()\r\n            .subtract(an.clone().multiply(bn).divide(3))\r\n            .add(an.clone().pow(3).multiply(2).divide(27))\r\n\r\n\r\n        // Cardan method\r\n        // X^2 + qX - p^3/27 = 0\r\n        // X^2 -SX + P = 0\r\n        // S = u^3 + v^3 = -q\r\n        // P = u^3v^3 = -p^3/27\r\n        // u^3 and v^3 are the roots of the equation\r\n        const S = q.clone().opposite()\r\n        const P = p.clone().opposite().pow(3).divide(27)\r\n\r\n        // Discriminant : delta = -(S^2 - 4P)\r\n        // delta < 0 : 1 real solution\r\n        // delta = 0 : 2 real solutions\r\n        // delta > 0 : 3 real solutions\r\n        const delta = S.clone().pow(2).subtract(P.clone().multiply(4)).opposite()\r\n        // console.log('an=', an.display, 'bn=', bn.display, 'cn=', cn.display)\r\n        // console.log('p=', p.display, 'q=', q.display)\r\n        // console.log('S=', S.display, 'P=', P.display)\r\n        // console.log('delta=', delta.display)\r\n\r\n        // if delta is negative, there is one real solution\r\n        if (delta.isNegative()) {\r\n            const u = q.clone().opposite().add(delta.clone().opposite().sqrt()).divide(2).root(3)\r\n            const v = q.clone().opposite().subtract(delta.clone().opposite().sqrt()).divide(2).root(3)\r\n\r\n            const x = u.clone().add(v).subtract(an.clone().divide(3))\r\n\r\n            return [this.#makeSolution(x)]\r\n        }\r\n\r\n        // if delta is zero, there are two real solutions\r\n        if (delta.isZero()) {\r\n            const u = q.clone().opposite().divide(2).root(3)\r\n\r\n            const x1 = u.clone().opposite().subtract(an.clone().divide(3))\r\n            const x2 = u.clone().multiply(2).subtract(an.clone().divide(3))\r\n\r\n            // There is only one unique solution\r\n            if (x1.isEqual(x2)) {\r\n                return [this.#makeSolution(x1)]\r\n            }\r\n\r\n            return [\r\n                this.#makeSolution(x2),\r\n                this.#makeSolution(x1)\r\n            ].sort((a, b) => a.value - b.value)\r\n        }\r\n\r\n        // if delta is positive, there are three real solutions\r\n        if (delta.isPositive()) {\r\n            const x: number[] = []\r\n            const pv = p.value,\r\n                qv = q.value,\r\n                anv = an.value\r\n\r\n            for (let i = 0; i < 3; i++) {\r\n                x.push(2 * Math.sqrt(-pv / 3) * Math.cos(Math.acos(3 * qv / (2 * pv) * Math.sqrt(-3 / pv)) / 3 + 2 * Math.PI * i / 3) - anv / 3)\r\n            }\r\n\r\n            return x\r\n                .map(v => this.#makeApproximativeSolution(v))\r\n                .sort((a, b) => a.value - b.value)\r\n\r\n        }\r\n\r\n        return []\r\n    }\r\n\r\n    #solveLinear(): ISolution[] {\r\n        // The equation is linear.\r\n        // We can solve it by isolating the variable.\r\n\r\n        // left is a polynom ax+b => the solution is x = -b/a\r\n        const f = this.#equation.monomByDegree(0).coefficient.clone().opposite()\r\n            .divide(this.#equation.monomByDegree(1).coefficient)\r\n\r\n        return [\r\n            this.#makeSolution(f)\r\n        ]\r\n    }\r\n\r\n    #solveQuadratic(): ISolution[] {\r\n\r\n        // The equation is quadratic.\r\n        // We can solve it by isolating the variable.\r\n        const left = this.#equation\r\n\r\n        // left is a polynom ax^2+bx+c => the solution is x = (-b±√(b^2-4ac))/2a\r\n\r\n        const a = left.monomByDegree(2).coefficient\r\n        const b = left.monomByDegree(1).coefficient\r\n        const c = left.monomByDegree(0).coefficient\r\n\r\n        const delta2 = b.clone().pow(2).subtract(a.clone().multiply(c).multiply(4))\r\n\r\n        // if delta2 is negative, there is no solution\r\n        if (delta2.isNegative()) {\r\n            return []\r\n        }\r\n\r\n        // if delta2 is zero, there is one solution\r\n        // if delta2 is positive, there are two solutions\r\n        // if delta2 is a square, it will be an exact solution.\r\n\r\n        if (delta2.isSquare()) {\r\n            // delta is a fraction.\r\n            // the solutions are (-b±√(b^2-4ac))/2a\r\n            const delta = delta2.sqrt()\r\n            const f1 = b.clone().opposite().add(delta).divide(a.clone().multiply(2))\r\n            const f2 = b.clone().opposite().subtract(delta).divide(a.clone().multiply(2))\r\n\r\n            // Delta is zero, there is only one solution\r\n            if (delta.isZero()) {\r\n                return [this.#makeSolution(f1)]\r\n            }\r\n\r\n            // delta is positive, there are two solutions\r\n            return [\r\n                this.#makeSolution(f1),\r\n                this.#makeSolution(f2)\r\n            ].sort((a, b) => a.value - b.value)\r\n        }\r\n\r\n        // delta is not a square, there are one or two approximative solutions.\r\n        // We will use the approximate value of the square root.\r\n        // const delta = delta2.value ** 0.5\r\n        // const f1 = (-b.value + delta) / (2 * a.value)\r\n        // const f2 = (-b.value - delta) / (2 * a.value)\r\n\r\n        return this.#solveQuadratic_Output(a, b, delta2)\r\n    }\r\n\r\n    #solveQuadratic_Output(a: Fraction, b: Fraction, delta: Fraction): ISolution[] {\r\n        // -b +/- sqrt(delta) / 2a\r\n        // reduce the sqrt - extract pow.\r\n\r\n        // Get the greatest square factor\r\n        const deltaFactor: number = Numeric\r\n            .dividers(delta.value)\r\n            .filter(x => Math.sqrt(x) % 1 === 0)\r\n            .map(x => Math.sqrt(x)).pop() ?? 1\r\n\r\n        // Get the GCD of a, b, and the greatest delta factor.\r\n        const gcd = Numeric.gcd(2 * a.value, b.value, deltaFactor) * (a.isNegative() ? -1 : 1)\r\n\r\n        // Calculate the various values and transforming\r\n        const b2 = b.clone().divide(gcd).opposite()\r\n        const a2 = a.clone().divide(gcd).multiply(2)\r\n        const delta2 = delta.clone().divide(deltaFactor ** 2)\r\n        const deltaGcd = Math.abs(deltaFactor / gcd)\r\n        const deltaK1 = deltaFactor === 1 ? '-' : `-${deltaGcd} `\r\n        const deltaK2 = deltaFactor === 1 ? '+' : `+${deltaGcd} `\r\n\r\n        function texOutput(a: string, b: string, k: string, delta: string) {\r\n            return `\\\\frac{ ${b} ${k}\\\\sqrt{ ${delta} } }{ ${a} }`\r\n        }\r\n\r\n        function displayOutput(a: string, b: string, k: string, delta: string) {\r\n            return `(${b}${k}sqrt(${delta}))/${a}`\r\n        }\r\n\r\n        const d = delta.value ** 0.5\r\n        const f1 = (-b.value - d) / (2 * a.value)\r\n        const f2 = (-b.value + d) / (2 * a.value)\r\n\r\n        return [\r\n            this.#makeApproximativeSolution(f1,\r\n                {\r\n                    tex: texOutput(a2.tex, b2.tex, deltaK1.toString(), delta2.tex),\r\n                    display: displayOutput(a2.display, b2.display, deltaK1.toString(), delta2.display),\r\n                }\r\n            ),\r\n            this.#makeApproximativeSolution(f2,\r\n                {\r\n                    tex: texOutput(a2.tex, b2.tex, deltaK2.toString(), delta2.tex),\r\n                    display: displayOutput(a2.display, b2.display, deltaK2.toString(), delta2.display),\r\n                }\r\n            )\r\n        ].sort((a, b) => a.value - b.value)\r\n    }\r\n}\r\n","export function wrapParenthesis(str: string, tex = true): string {\r\n    return tex ? `\\\\left( ${str} \\\\right)` : `(${str})`\r\n}\r\n\r\nexport function wrapVert(str: string, tex = true): string {\r\n    return tex ? `\\\\left\\\\vert ${str} \\\\right\\\\vert` : `|${str}|`\r\n}\r\n\r\nexport function wrapNorm(str: string, tex = true): string {\r\n    return tex ? `\\\\left\\\\Vect ${str} \\\\right\\\\Vect` : `||${str}||`\r\n}\r\n\r\nexport function replace_in_array<T>(haystack: string[], search: string, target: string, start?: number, end?: number): T {\r\n    return haystack.map((x, index) => {\r\n        if (start !== undefined && index < start) {\r\n            return x\r\n        }\r\n        if (end !== undefined && index > end) {\r\n            return x\r\n        }\r\n        return x === search ? target : x\r\n    }) as T\r\n}\r\n","/**\r\n * Polynom module contains everything necessary to handle polynoms.*\r\n */\r\nimport {ShutingYard, ShutingyardType, type Token} from \"piexpression\"\r\nimport type {\r\n    IAlgebra,\r\n    IAnalyse,\r\n    IExpression,\r\n    InputAlgebra,\r\n    InputValue,\r\n    IPiMathObject,\r\n    ISolution,\r\n    literalType, TABLE_OF_SIGNS,\r\n    TABLE_OF_SIGNS_VALUES\r\n} from \"../pimath.interface\"\r\nimport {Fraction} from \"../coefficients/fraction\"\r\nimport {Numeric} from '../numeric'\r\nimport {EquationSolver} from './equationSolver'\r\nimport {Monom} from './monom'\r\nimport {replace_in_array} from \"../helpers\"\r\n\r\n\r\nexport type PolynomParsingType = InputValue<Polynom> | Monom\r\n\r\nexport interface IEuclidean {\r\n    quotient: Polynom,\r\n    reminder: Polynom\r\n}\r\n\r\n/**\r\n * Polynom class can handle polynoms, reorder, resolve, ...\r\n * ```\r\n * let P = new Polynom('3x-4')\r\n * ```\r\n */\r\nexport class Polynom implements IPiMathObject<Polynom>,\r\n    IExpression<Polynom>,\r\n    IAnalyse<Polynom>,\r\n    IAlgebra<Polynom> {\r\n\r\n    #factors: Polynom[]\r\n    #monoms: Monom[]\r\n    #roots: ISolution[]\r\n    #rootsCache = false\r\n\r\n    constructor(value: InputValue<Fraction>)\r\n    constructor(value: string)\r\n    constructor(value: Monom)\r\n    constructor(value: Polynom)\r\n    constructor(...values: InputValue<Fraction>[])\r\n    constructor(...values: InputAlgebra<Polynom>[])\r\n    constructor(polynomString?: InputAlgebra<Polynom>, ...values: InputAlgebra<Fraction>[]) {\r\n        this.#monoms = []\r\n        this.#factors = []\r\n        this.#roots = []\r\n\r\n        if (polynomString !== undefined) {\r\n            this.parse(polynomString, ...values)\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Parse a string to a polynom.\r\n     * @param inputStr\r\n     * @param values\r\n     */\r\n    public parse = (inputStr: PolynomParsingType, ...values: InputAlgebra<Monom>[]): this => {\r\n        // Reset the main variables.\r\n        this.#monoms = []\r\n        this.#factors = []\r\n\r\n        // TODO: allow to enter a liste of Fraction (a, b, c, ...) to make a polynom ax^n + bx^(n-1) + cx^(n-2) + ...\r\n        if (typeof inputStr === 'string') {\r\n            return this.#parseString(inputStr, ...values)\r\n        } else if (\r\n            (typeof inputStr === 'number' || inputStr instanceof Fraction || inputStr instanceof Monom)\r\n            && (values.length === 0)\r\n        ) {\r\n            this.#monoms.push(new Monom(inputStr as Monom))\r\n        } else if (inputStr instanceof Monom && values.length > 0) {\r\n            this.#monoms.push(new Monom(inputStr))\r\n            values.forEach(m => {\r\n                this.#monoms.push(new Monom(m as Monom))\r\n            })\r\n        } else if (inputStr instanceof Polynom) {\r\n            for (const m of inputStr.monoms) {\r\n                this.#monoms.push(m.clone())\r\n            }\r\n        }\r\n\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Clone the polynom\r\n     */\r\n    public clone = (): Polynom => {\r\n        const P = new Polynom()\r\n        const M: Monom[] = []\r\n\r\n        for (const m of this.#monoms) {\r\n            M.push(m.clone())\r\n        }\r\n\r\n\r\n        P.monoms = M\r\n\r\n        return P\r\n    }\r\n\r\n    public add = (...values: InputAlgebra<Polynom>[]): Polynom => {\r\n\r\n        for (const value of values) {\r\n            if (value instanceof Polynom) {\r\n                this.#monoms = this.#monoms.concat(value.monoms)\r\n            } else if (value instanceof Monom) {\r\n                this.#monoms.push(value.clone())\r\n            } else if (typeof value === \"number\" && Number.isSafeInteger(value)) {\r\n                this.#monoms.push(new Monom(value.toString()))\r\n            } else {\r\n                this.#monoms.push(new Monom(value))\r\n            }\r\n        }\r\n\r\n\r\n        return this.reduce()\r\n    }\r\n\r\n    public commonMonom = (): Monom => {\r\n        const M = new Monom().one()\r\n        const numerator: number = this.gcdNumerator()\r\n        const denominator: number = this.gcdDenominator()\r\n        const degree = this.degree()\r\n\r\n        M.coefficient = new Fraction(numerator, denominator)\r\n        for (const L of this.variables) {\r\n            // Initialize the setLetter with the max degree\r\n            M.setLetter(L, degree)\r\n            for (const m of this.#monoms) {\r\n                M.setLetter(L, Fraction.min(m.degree(L), M.degree(L)))\r\n                if (M.degree(L).isZero()) {\r\n                    break\r\n                }\r\n\r\n            }\r\n        }\r\n        return M\r\n    }\r\n\r\n    public degree = (letter?: string): Fraction => {\r\n        let d: Fraction = new Fraction().zero()\r\n        for (const m of this.#monoms) {\r\n            d = Fraction.max(m.degree(letter).value, d)\r\n        }\r\n\r\n        return d\r\n    }\r\n\r\n    public derivative = (letter?: string): Polynom => {\r\n        const dP = new Polynom()\r\n\r\n        for (const m of this.#monoms) {\r\n            dP.add(m.derivative(letter))\r\n        }\r\n\r\n        return dP\r\n    }\r\n\r\n    public get display(): string {\r\n        return this.#genDisplay()\r\n    }\r\n\r\n    public divide = (value: InputAlgebra<Polynom>): Polynom => {\r\n\r\n        if (value instanceof Fraction) {\r\n            return this.#divideByFraction(value)\r\n        } else if (typeof value === 'number' && Number.isSafeInteger(value)) {\r\n            return this.#divideByInteger(value)\r\n        } else if (value instanceof Monom) {\r\n            return this.divide(new Polynom(value))\r\n        } else if (value instanceof Polynom) {\r\n            if (value.monoms.length === 1 && value.variables.length === 0) {\r\n                return this.#divideByFraction(value.monoms[0].coefficient)\r\n            } else {\r\n                const {quotient, reminder} = this.euclidean(value)\r\n                if (reminder.isZero()) {\r\n                    this.#monoms = quotient.monoms\r\n                    return this\r\n                }\r\n            }\r\n        } else if (typeof value === 'string') {\r\n            return this.divide(new Polynom(value))\r\n        }\r\n\r\n        throw new Error(`Cannot divide by ${value as unknown as string}`)\r\n    }\r\n\r\n    public empty = (): this => {\r\n        this.#monoms = []\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Divide the current polynom by another polynom.\r\n     * @param P\r\n     * returns {quotient: Polynom, reminder: Polynom}\r\n     */\r\n    public euclidean = (P: Polynom): IEuclidean => {\r\n        const letter: string = P.variables[0]\r\n        const quotient: Polynom = new Polynom().zero()\r\n        const reminder: Polynom = this.clone().reorder(letter)\r\n\r\n        // There is no variable - means it's a number\r\n        if (P.variables.length === 0) {\r\n            const q = this.clone().divide(P)\r\n\r\n            return {\r\n                quotient: q.reduce(),\r\n                reminder: new Polynom().zero()\r\n            }\r\n        }\r\n\r\n        // Get at least a letter\r\n        const maxMP: Monom = P.monomByDegree(undefined, letter)\r\n        const degreeP: Fraction = P.degree(letter)\r\n\r\n        let newM: Monom\r\n\r\n        // Make the Euclidean division of the two polynoms.\r\n        let MaxIteration = this.degree(letter).value * 2\r\n        while (reminder.degree(letter).isGeq(degreeP) && MaxIteration > 0) {\r\n            MaxIteration--\r\n\r\n            // Get the greatest monom divided by the max monom of the divider\r\n            newM = reminder.monomByDegree(undefined, letter).clone().divide(maxMP)\r\n\r\n            if (newM.isZero()) {\r\n                continue\r\n            }\r\n\r\n            // Get the new quotient and reminder.\r\n            quotient.add(newM)\r\n            reminder.subtract(P.clone().multiply(newM)).reduce()\r\n\r\n            // Check if the reminder is zero.\r\n            if (newM.degree(letter).isZero()) {\r\n                break\r\n            }\r\n        }\r\n\r\n        quotient.reduce()\r\n        reminder.reduce()\r\n        return {quotient, reminder}\r\n    }\r\n\r\n    public evaluate = (values: literalType<Fraction | number> | InputValue<Fraction>, asNumeric?: boolean): Fraction | number => {\r\n        // Return the numeric value, without using Fraction\r\n        if (asNumeric) {\r\n            return this.#evaluateAsNumeric(values)\r\n        }\r\n\r\n        // Build the evaluated fraction\r\n        const r = new Fraction().zero()\r\n        this.#monoms.forEach(monom => {\r\n            //console.log('Evaluate polynom: ', monom.display, values, monom.evaluate(values).display);\r\n            r.add(monom.evaluate(values, asNumeric))\r\n        })\r\n\r\n        return r\r\n    }\r\n\r\n    // -------------------------------------\r\n    /**\r\n     * Factorize a polynom and store the best results in factors.\r\n     * @param letter\r\n     */\r\n    public factorize = (letter?: string): Polynom[] => {\r\n        let factors: Polynom[] = []\r\n        let P = this.clone().reorder()\r\n\r\n        // Extract the common monom\r\n        // 2x^3+6x^2 => 2x^2\r\n        const M = P.commonMonom()\r\n        // If the polynom starts with a negative monom, factorize it.\r\n        if (P.monomByDegree().coefficient.isStrictlyNegative() && M.coefficient.isStrictlyPositive() && !M.isOne()) {\r\n            M.opposite()\r\n        }\r\n\r\n\r\n        if (!M.isOne()) {\r\n            const tempPolynom: Polynom = new Polynom(M)\r\n            factors = [tempPolynom.clone()]\r\n            P = P.euclidean(tempPolynom).quotient\r\n        }\r\n\r\n        // Main loop\r\n        let securityLoop = P.degree().clone().multiply(2).value,\r\n            maxDegree = 1\r\n        while (securityLoop >= 0) {\r\n            securityLoop--\r\n            if (P.monoms.length < 2) {\r\n                // The polynom has only one monom => 7x^2\r\n                // No need to continue.\r\n                if (!P.isOne()) {\r\n                    factors.push(P.clone())\r\n                    P.one()\r\n                }\r\n                break\r\n            } else if (P.degree(letter).isOne()) {\r\n                // The polynom is a first degree polynom => 3x-5\r\n                // No need to continue\r\n                factors.push(P.clone())\r\n                P.one()\r\n                break\r\n            } else {\r\n                // Create the list of all \"potential\" polynom dividers.\r\n                let allDividers: Polynom[] = this.#getAllPotentialFactors(P, maxDegree, letter ?? 'x')\r\n                maxDegree = P.degree(letter).value\r\n\r\n                // Actually: 100ms\r\n                while (allDividers.length > 0) {\r\n                    const div = allDividers[0]\r\n\r\n                    if (!P.isDividableBy(div))\r\n                        // Not dividable. Remove it from the list\r\n                    {\r\n                        allDividers.shift()\r\n                    } else {\r\n                        // It's dividable - so make the division\r\n                        const result = P.euclidean(div)\r\n\r\n                        // Add the factor\r\n                        factors.push(div)\r\n\r\n                        // As it's dividable, get the quotient.\r\n                        P = result.quotient.clone()\r\n\r\n                        // filter all dividers that are no more suitable.\r\n                        allDividers = allDividers.filter(x => {\r\n                            const pX = P.monoms[0],\r\n                                pC = P.monoms[P.monoms.length - 1],\r\n                                dX = x.monoms[0],\r\n                                dC = x.monoms[x.monoms.length - 1]\r\n\r\n                            // Check last item (degree zero)\r\n                            if (!pC.isDivisible(dC)) {\r\n                                return false\r\n                            }\r\n\r\n                            // Check the first item (degree max)\r\n                            return pX.isDivisible(dX)\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Maybe there is still something in the Polynom (not everything was possible to factorize)\r\n        if (!P.isOne()) {\r\n            factors.push(P.clone())\r\n        }\r\n\r\n\r\n        // Save the factors\r\n        this.#factors = factors\r\n\r\n        return this.#factors\r\n    }\r\n\r\n    public gcdDenominator = (): number => {\r\n        return Numeric.gcd(...this.getDenominators())\r\n    }\r\n\r\n    public gcdNumerator = (): number => {\r\n        return Numeric.gcd(...this.getNumerators())\r\n    }\r\n\r\n    // Next functions are used for for commonMonom, which is used in the factorize method.\r\n    public getDenominators = (): number[] => {\r\n        const denominators: number[] = []\r\n        for (const m of this.#monoms) {\r\n            denominators.push(m.coefficient.denominator)\r\n        }\r\n\r\n        return denominators\r\n    }\r\n\r\n    public getNumerators = (): number[] => {\r\n        const numerators: number[] = []\r\n        for (const m of this.#monoms) {\r\n            numerators.push(m.coefficient.numerator)\r\n        }\r\n\r\n        return numerators\r\n    }\r\n\r\n    public getZeroes = (): ISolution[] => {\r\n        if (this.degree().isZero()) {\r\n            return []\r\n        }\r\n\r\n        this.roots = new EquationSolver(this.clone()).solve()\r\n        return this.roots\r\n    }\r\n\r\n    public hasVariable(letter: string): boolean {\r\n        return this.variables.includes(letter)\r\n    }\r\n\r\n    public integrate = (a: InputValue<Fraction>, b: InputValue<Fraction>, letter = 'x'): Fraction => {\r\n        const primitive = this.primitive(letter)\r\n\r\n        const valuesA: literalType<Fraction> = {},\r\n            valuesB: literalType<Fraction> = {}\r\n\r\n        valuesA[letter] = new Fraction(a)\r\n        valuesB[letter] = new Fraction(b)\r\n\r\n        return (primitive.evaluate(valuesB) as Fraction).subtract(primitive.evaluate(valuesA))\r\n    }\r\n\r\n    public inverse(): Polynom | undefined {\r\n        return undefined\r\n    }\r\n\r\n    public isDeveloped = (polynomString: string): boolean => {\r\n        let P: Polynom\r\n\r\n        // Start by removing the parenthesis after a \"power\"\r\n        const pString = polynomString.replaceAll(/\\^\\(([-0-9/]+)\\)/g, '$1')\r\n\r\n        // There is at least one parenthesis - it is not developed.\r\n        if (pString.includes('(') || pString.includes(')')) {\r\n            return false\r\n        }\r\n\r\n\r\n        // Try to build the polynom\r\n        try {\r\n            // Build the polynom\r\n            P = new Polynom(polynomString)\r\n        } catch (e) {\r\n            return false\r\n        }\r\n\r\n        // Both polynom aren't the same (once developed and reduced => they cannot be equivalent)\r\n        if (!this.isEqual(P)) {\r\n            return false\r\n        }\r\n\r\n\r\n        // Check that everything is completely developed. Actually, there are no parentheses... so it is fully developed\r\n        return true\r\n    }\r\n\r\n    public isDividableBy = (div: Polynom): boolean => {\r\n        // Quick evaluation.\r\n        if (div.degree().isOne()) {\r\n            const zero = div.getZeroes()[0]\r\n\r\n            if (zero.exact instanceof Fraction) {\r\n                return (this.evaluate(zero.exact) as Fraction).isZero()\r\n            } else {\r\n                return false\r\n            }\r\n\r\n        } else {\r\n            const {reminder} = this.euclidean(div)\r\n            return reminder.isZero()\r\n        }\r\n    }\r\n\r\n    public isEqual = (P: Polynom): boolean => {\r\n        return this.#compare(P, '=')\r\n    }\r\n\r\n    public get isMultiVariable(): boolean {\r\n        // Determine if a monom has more than one variable.\r\n        return this.#monoms.some(m => m.variables.length > 1)\r\n    }\r\n\r\n    public isOne(): boolean {\r\n        return this.#monoms.length === 1 && this.#monoms[0].coefficient.isOne() && this.degree().isZero()\r\n    }\r\n\r\n    public isOppositeAt = (P: Polynom): boolean => {\r\n        return this.#compare(P.clone().opposite(), '=')\r\n    }\r\n\r\n    public isReduced = (polynomString: string): boolean => {\r\n        // The polynom must be developed to be reduced.\r\n        if (!this.isDeveloped(polynomString)) {\r\n            return false\r\n        }\r\n\r\n\r\n        const P = new Polynom(polynomString)\r\n        if (P.monoms.length > this.monoms.length) {\r\n            return false\r\n        }\r\n\r\n\r\n        // TODO: Not ur the reduced system checking is working properly !\r\n        for (const m of P.monoms) {\r\n            if (!m.coefficient.isReduced()) {\r\n                return false\r\n            }\r\n        }\r\n\r\n\r\n        return false\r\n    }\r\n\r\n    public isSameAs = (P: Polynom): boolean => {\r\n        return this.#compare(P, 'same')\r\n    }\r\n\r\n    public isZero(): boolean {\r\n        return (this.#monoms.length === 1 && this.#monoms[0].coefficient.isZero()) || this.#monoms.length === 0\r\n    }\r\n\r\n    public lcmDenominator = (): number => {\r\n        return Numeric.lcm(...this.getDenominators())\r\n    }\r\n\r\n    public lcmNumerator = (): number => {\r\n        return Numeric.lcm(...this.getNumerators())\r\n    }\r\n\r\n    public get length() {\r\n        // TODO: Must reduce the monoms list to remove the zero coefficient.\r\n        return this.#monoms.length\r\n    }\r\n\r\n    public letters = (): string[] => {\r\n        let S = new Set<string>()\r\n\r\n        for (const m of this.#monoms) {\r\n            S = new Set([...S, ...m.variables])\r\n        }\r\n\r\n\r\n        return [...S]\r\n    }\r\n\r\n    public limitToInfinity = (letter?: string): Fraction => {\r\n        const M = this.monomByDegree(undefined, letter),\r\n            sign = M.coefficient.sign(),\r\n            degree = M.degree(letter)\r\n\r\n        if (degree.isStrictlyPositive()) {\r\n            return sign === 1 ? (new Fraction()).infinite() : (new Fraction()).infinite().opposite()\r\n        } else if (degree.isZero()) {\r\n            return M.coefficient\r\n        }\r\n\r\n\r\n        // Any other cases\r\n        return (new Fraction()).zero()\r\n    }\r\n\r\n    public limitToNegativeInfinity = (letter?: string): Fraction => {\r\n        const M = this.monomByDegree(undefined, letter),\r\n            sign = M.coefficient.sign(),\r\n            degree = M.degree(letter)\r\n\r\n        if (degree.isStrictlyPositive()) {\r\n            return sign === -1 ? (new Fraction()).infinite() : (new Fraction()).infinite().opposite()\r\n        } else if (degree.isZero()) {\r\n            return M.coefficient\r\n        }\r\n\r\n\r\n        // Any other cases\r\n        return (new Fraction()).zero()\r\n    }\r\n\r\n    public monomByDegree = (degree?: Fraction | number, letter?: string): Monom => {\r\n        if (degree === undefined)\r\n            // return the highest degree monom.\r\n        {\r\n            return this.monomByDegree(this.degree(letter), letter)\r\n        }\r\n\r\n\r\n        // Reduce the polynom.\r\n        const M = this.clone().reduce()\r\n        for (const m of M.#monoms) {\r\n            if (m.degree(letter).isEqual(degree)) {\r\n                return m.clone()\r\n            }\r\n        }\r\n\r\n\r\n        // Nothing was found - return the null monom.\r\n        return new Monom().zero()\r\n    }\r\n\r\n    // Used in LinearSystem.tex\r\n    public monomByLetter = (letter: string): Monom => {\r\n        const M = this.clone().reduce()\r\n        for (const m of M.#monoms) {\r\n            if (m.hasVariable(letter)) {\r\n                return m.clone()\r\n            }\r\n        }\r\n\r\n\r\n        return new Monom().zero()\r\n    }\r\n\r\n    // ------------------------------------------\r\n    public get monoms() {\r\n        return this.#monoms\r\n    }\r\n\r\n    public set monoms(M: Monom[]) {\r\n        this.#monoms = M\r\n    }\r\n\r\n    public monomsByDegree = (degree?: number | Fraction, letter?: string): Monom[] => {\r\n        if (degree === undefined)\r\n            // return the highest degree monom.\r\n        {\r\n            return this.monomsByDegree(this.degree(letter))\r\n        }\r\n\r\n        // Reduce the polynom.\r\n        const Ms: Monom[] = []\r\n\r\n        const M = this.clone().reduce()\r\n        for (const m of M.#monoms) {\r\n            if (m.degree(letter).isEqual(degree)) {\r\n                Ms.push(m.clone())\r\n            }\r\n        }\r\n\r\n\r\n        return Ms\r\n        // Nothing was found - return\r\n    }\r\n\r\n    public multiply = (value: unknown): Polynom => {\r\n\r\n        if (value instanceof Polynom) {\r\n            return this.#multiplyByPolynom(value)\r\n        } else if (value instanceof Fraction) {\r\n            return this.#multiplyByFraction(value)\r\n        } else if (value instanceof Monom) {\r\n            return this.#multiplyByMonom(value)\r\n        } else if (Number.isSafeInteger(value) && typeof value === 'number') {\r\n            return this.#multiplyByInteger(value)\r\n        }\r\n\r\n\r\n        // Something went wrong...\r\n        return this\r\n    }\r\n\r\n    public get numberOfVars(): number {\r\n        return this.variables.length\r\n    }\r\n\r\n    public one = (): this => {\r\n        this.#monoms = []\r\n        this.#monoms.push(new Monom().one())\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    public opposite = (): this => {\r\n        this.#monoms = this.#monoms.map(m => m.opposite())\r\n        return this\r\n    }\r\n\r\n    public get plotFunction(): string {\r\n        return this.#genDisplay('tex', false, false, true)\r\n    }\r\n\r\n    public pow = (nb: number): Polynom => {\r\n        if (!Number.isSafeInteger(nb)) {\r\n            return this.zero()\r\n        }\r\n\r\n        if (nb < 0) {\r\n            return this.zero()\r\n        }\r\n\r\n        if (nb === 0) {\r\n            return new Polynom()\r\n        }\r\n\r\n\r\n        const P = this.clone()\r\n        for (let i = 1; i < nb; i++) {\r\n            this.multiply(P)\r\n        }\r\n\r\n        return this.reduce()\r\n    }\r\n\r\n    public primitive = (letter?: string): Polynom => {\r\n        const dP = new Polynom()\r\n\r\n        for (const m of this.#monoms) {\r\n            dP.add(m.primitive(letter))\r\n        }\r\n\r\n        return dP\r\n    }\r\n\r\n    public reduce = (): Polynom => {\r\n        // Reduce the polynom\r\n\r\n        // Group the monoms by similarity\r\n        let i = 0\r\n        while (i < this.#monoms.length) {\r\n            for (let j = i + 1; j < this.#monoms.length; j++) {\r\n                if (this.#monoms[i].isSameAs(this.#monoms[j])) {\r\n                    this.#monoms[i].add(this.#monoms[j])\r\n                    this.#monoms.splice(j, 1)\r\n                    if (this.#monoms[i].isZero()) {\r\n                        this.#monoms[i] = new Monom().zero()\r\n                    }\r\n\r\n                    j--\r\n                }\r\n            }\r\n\r\n\r\n            i++\r\n        }\r\n\r\n        // Remove all null monoms\r\n        this.#monoms = this.#monoms.filter((m) => {\r\n            return !m.coefficient.isZero()\r\n        })\r\n\r\n        // Reduce all monoms coefficient.\r\n        for (const m of this.#monoms) {\r\n            m.coefficient.reduce()\r\n        }\r\n\r\n\r\n        if (this.length === 0) {\r\n            return new Polynom().zero()\r\n        }\r\n\r\n\r\n        return this.reorder()\r\n    }\r\n\r\n    public reorder = (letter = 'x', revert?: boolean): this => {\r\n        if (revert === undefined) {\r\n            revert = false\r\n        }\r\n\r\n        // TODO: Must handle multiple setLetter reorder system\r\n        const otherLetters = this.variables.filter(x => x !== letter)\r\n        this.#monoms.sort(function (a, b) {\r\n            const da = a.degree(letter).value,\r\n                db = b.degree(letter).value\r\n\r\n            // Values are different\r\n            if (da !== db) {\r\n                return revert ? da - db : db - da\r\n            }\r\n\r\n            // if values are equals, check other letters - it must be reverted in that case !\r\n            if (otherLetters.length > 0) {\r\n                for (const L of otherLetters) {\r\n                    const da = a.degree(L).value,\r\n                        db = b.degree(L).value\r\n\r\n                    // Values are different\r\n                    if (da !== db) {\r\n                        return revert ? da - db : db - da\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            return 0\r\n        })\r\n\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Replace a variable (letter) by a polynom.\r\n     * @param letter\r\n     * @param P\r\n     */\r\n    public replaceBy = (letter: string, P: Polynom): this => {\r\n        let pow: Fraction\r\n        const resultPolynom: Polynom = new Polynom().zero()\r\n\r\n        for (const m of this.monoms) {\r\n            if (!m.hasVariable(letter) || m.literal[letter].isZero()) {\r\n                resultPolynom.add(m.clone())\r\n            } else {\r\n                // We have found a variable to replace.\r\n\r\n                // Get the power.\r\n                pow = m.literal[letter].clone()\r\n\r\n                // Remove the variable from the monom\r\n                m.removeVariable(letter)\r\n\r\n                // Add the new monom to the result polynom\r\n                resultPolynom.add(P.clone().pow(Math.abs(pow.numerator)).multiply(m))\r\n            }\r\n        }\r\n\r\n\r\n        // Reduce the monoms\r\n        this.#monoms = resultPolynom.reduce().monoms\r\n        return this\r\n    }\r\n\r\n    public root(): Polynom {\r\n        throw new Error('Cannot take the root from a polynom')\r\n    }\r\n\r\n    get roots(): ISolution[] {\r\n        return this.#rootsCache ? this.#roots : this.getZeroes()\r\n    }\r\n\r\n    set roots(value: ISolution[]) {\r\n        this.#rootsCache = true\r\n        this.#roots = value\r\n    }\r\n\r\n    public sqrt(): Polynom {\r\n        throw new Error('Cannot take the square root from a polynom')\r\n    }\r\n\r\n    public subtract = (...values: InputAlgebra<Polynom>[]): Polynom => {\r\n        for (const value of values) {\r\n            if (value instanceof Polynom) {\r\n                this.add(value.clone().opposite())\r\n            } else if (value instanceof Monom) {\r\n                this.#monoms.push(value.clone().opposite())\r\n            } else {\r\n                this.#monoms.push(new Monom(value).opposite())\r\n            }\r\n        }\r\n\r\n\r\n        return this.reduce()\r\n    }\r\n\r\n    public tableOfSigns(rootsArray?: ISolution[]): TABLE_OF_SIGNS {\r\n        // returns ['+-', 'd|t|z', '+-']...\r\n\r\n        // global roots from eventually Polyfactor. Allows to add \"extra column\".\r\n        const roots: ISolution[] = rootsArray ?? this.getZeroes()\r\n\r\n        // Polynom roots (named zeroes)\r\n        const zeroes: ISolution[] = this.roots // if here, means, the roots has already been calculated !\r\n\r\n        // All zeroes from the function must be in the rootsArray.\r\n        if (rootsArray && zeroes.some(zero => roots.findIndex(x => x.value === zero.value) === -1)) {\r\n            throw new Error('Some roots cannot be found !')\r\n        }\r\n\r\n\r\n        // Build the table os sign length and default values\r\n        // The signs looks like: ['', 't', '', 't', '', 't', '']\r\n        let signs: TABLE_OF_SIGNS_VALUES[] = ['']\r\n        roots.forEach(() => signs.push('t', ''))\r\n\r\n        if (roots.length === 0) {\r\n            // The polynom is a constant: [+,t,+,t,+,t,+]\r\n            signs = replace_in_array(signs, '', this.monomsByDegree()[0].coefficient.isPositive() ? '+' : '-')\r\n        } else if (this.degree().isOne()) {\r\n            // First degree: ax+b\r\n            // [-,t,-,z,+,t,+,t,+]\r\n            const sign = this.monomsByDegree(1)[0].coefficient.sign()\r\n            // Get the index of the zero.\r\n            const idx = roots.findIndex(x => x.value === zeroes[0].value) * 2 + 1\r\n\r\n            signs[idx] = 'z'\r\n            signs = replace_in_array(signs, '', sign === 1 ? '-' : '+', 0, idx)\r\n            signs = replace_in_array(signs, '', sign === 1 ? '+' : '-', idx)\r\n\r\n        } else {\r\n            let start = 0, end: number, sign = '+'\r\n\r\n            zeroes.forEach((zero, index) => {\r\n                const zeroIndex = roots.findIndex(x => x.value === zeroes[index].value)\r\n\r\n                // Get the position of the (current) zero of the polynom\r\n                if (index === 0) {\r\n                    // Initialize.\r\n                    end = zeroIndex * 2 + 1\r\n                    signs[end] = 'z'\r\n                    signs = replace_in_array(\r\n                        signs, '',\r\n                        (this.evaluate(zero.value - 1, true) as number) < 0 ? '-' : '+',\r\n                        0, end)\r\n                }\r\n\r\n                start = zeroIndex * 2 + 1\r\n                end = index === zeroes.length - 1 ?\r\n                    signs.length :\r\n                    roots.findIndex(x => x.value === zeroes[index + 1].value) * 2 + 1\r\n\r\n                // evaluate the sign between current zero and the next one..\r\n                const x = index === zeroes.length - 1 ? zero.value + 1 :\r\n                    (zero.value + zeroes[index + 1].value) / 2\r\n\r\n                sign = (this.evaluate(x, true) as number) < 0 ? '-' : '+'\r\n\r\n                // Update the table of signs\r\n                signs[start] = 'z'\r\n                signs = replace_in_array(signs, '', sign, start, end)\r\n\r\n                // Prepare for the next line\r\n                start = +end\r\n                end = signs.length\r\n            })\r\n\r\n        }\r\n\r\n\r\n        return {roots, signs}\r\n    }\r\n\r\n    public get tex(): string {\r\n        return this.#genDisplay('tex')\r\n    }\r\n\r\n    public get variables(): string[] {\r\n        let V: string[] = []\r\n\r\n        for (const m of this.#monoms) {\r\n            V = V.concat(m.variables)\r\n        }\r\n\r\n\r\n        // Remove duplicates.\r\n        V = [...new Set(V)]\r\n        V.sort()\r\n        return V\r\n    }\r\n\r\n    /**\r\n     * Set the polynom to zero.\r\n     * @returns {this}\r\n     */\r\n    public zero = (): this => {\r\n        this.#monoms = []\r\n        this.#monoms.push(new Monom().zero())\r\n        return this\r\n    }\r\n\r\n    public get zeroes(): ISolution[] {\r\n        return this.getZeroes()\r\n    }\r\n\r\n    #compare = (P: Polynom, sign?: string): boolean => {\r\n        if (sign === undefined) {\r\n            sign = '='\r\n        }\r\n\r\n        // TODO: compare must also check the variables.\r\n\r\n        // Create clone version to reduce them without altering the original polynoms.\r\n        const cP1 = this.clone().reduce().reorder()\r\n        const cP2 = P.clone().reduce().reorder()\r\n\r\n        switch (sign) {\r\n            case '=':\r\n                // They must have the isSame length and the isSame degree\r\n                if (cP1.length !== cP2.length || !cP1.degree().isEqual(cP2.degree())) {\r\n                    return false\r\n                }\r\n\r\n                // Check if the coefficients are the isSame.\r\n                return cP1.monoms\r\n                    .every((m1, index) => m1.isEqual(cP2.monoms[index]))\r\n\r\n            case 'same':\r\n                // They must have the same length and the same degree\r\n                if (cP1.length !== cP2.length || !cP1.degree().isEqual(cP2.degree())) {\r\n                    return false\r\n                }\r\n\r\n                return cP1.monoms\r\n                    .every((m1, index) => m1.isSameAs(cP2.monoms[index]))\r\n\r\n            default:\r\n                return false\r\n        }\r\n    }\r\n\r\n\r\n    #divideByFraction = (F: Fraction): this => {\r\n        for (const m of this.#monoms) {\r\n            m.coefficient.divide(F)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    #divideByInteger = (nb: number): this => {\r\n        const nbF = new Fraction(nb)\r\n        for (const m of this.#monoms) {\r\n            m.coefficient.divide(nbF)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    #evaluateAsNumeric = (values: literalType<number | Fraction> | InputValue<Fraction>): number => {\r\n        let r = 0\r\n        this.#monoms.forEach(monom => {\r\n            r += monom.evaluate(values, true) as number\r\n        })\r\n\r\n        return r\r\n    }\r\n\r\n    #factorize2ndDegree = (letter: string): Polynom[] => {\r\n        let P1: Polynom, P2: Polynom,\r\n            a, b, c, delta, x1, x2, factor\r\n\r\n        // One variable only\r\n        if (this.numberOfVars === 1) {\r\n            a = this.monomByDegree(2, letter).coefficient\r\n            b = this.monomByDegree(1, letter).coefficient\r\n            c = this.monomByDegree(0, letter).coefficient\r\n            delta = b.clone().pow(2).subtract(a.clone().multiply(c).multiply(4))\r\n\r\n            if (delta.isZero()) {\r\n                x1 = b.clone().opposite().divide(a.clone().multiply(2))\r\n                P1 = new Polynom(letter).subtract(x1.display).multiply(x1.denominator)\r\n                P2 = new Polynom(letter).subtract(x1.display).multiply(x1.denominator)\r\n                factor = a.divide(x1.denominator).divide(x1.denominator)\r\n\r\n                if (!factor.isOne())\r\n                    // TODO: Update new Polynom to accept anything...\r\n                {\r\n                    return [new Polynom(factor.display), P1, P2]\r\n                } else {\r\n                    return [P1, P2]\r\n                }\r\n\r\n            } else if (delta.isPositive() && delta.isSquare()) {\r\n                x1 = b.clone().opposite()\r\n                    .add(delta.clone().sqrt())\r\n                    .divide(a.clone().multiply(2))\r\n                x2 = b.clone().opposite()\r\n                    .subtract(delta.clone().sqrt())\r\n                    .divide(a.clone().multiply(2))\r\n\r\n                // (2x+5)(3x-2)\r\n                // 6x^2+11x-10\r\n                // a = 6, b = 11, c = -10\r\n                // delta = 121-4*6*(-10) = 361= 19^2\r\n                // x1 = (-11 + 19)  / 12 = 8/12 = 2/3\r\n                // x2 = (-11 - 19)  / 12 = -30/12 = -5/2\r\n                factor = a.divide(x1.denominator).divide(x2.denominator)\r\n                if (factor.isOne()) {\r\n                    return [\r\n                        new Polynom(letter).subtract(x1.display).multiply(x1.denominator),\r\n                        new Polynom(letter).subtract(x2.display).multiply(x2.denominator),\r\n                    ]\r\n                } else {\r\n                    return [\r\n                        new Polynom(factor.display),\r\n                        new Polynom(letter).subtract(x1.display).multiply(x1.denominator),\r\n                        new Polynom(letter).subtract(x2.display).multiply(x2.denominator),\r\n                    ]\r\n                }\r\n\r\n\r\n            } else\r\n                // No solution possible - return the complete value.\r\n            {\r\n                return [this.clone()]\r\n            }\r\n\r\n        } else {\r\n            // If multiple variables, only handle perfect squares...\r\n            a = this.monomByDegree(2, letter)\r\n            b = this.monomByDegree(1, letter)\r\n            c = this.monomByDegree(0, letter)\r\n\r\n            if (a.isLiteralSquare() && c.isLiteralSquare())\r\n                // Check the middle item is same as...\r\n\r\n\r\n            {\r\n                if (b.clone().pow(2).isSameAs(a.clone().multiply(c))) {\r\n                    // Determine if the coefficient values matches.\r\n\r\n                    // Search 4 values (r, s, t, u) that matches:\r\n                    // (r X + s Y)(t X + u Y) = rt X^2 + (ru + st) XY + su Y^2\r\n\r\n                    const xPolynom = new Polynom('x', a.coefficient, b.coefficient, c.coefficient)\r\n                    const xFactors = xPolynom.#factorize2ndDegree('x')\r\n\r\n                    const factors = []\r\n                    let xyzPolynom: Polynom\r\n\r\n                    if (xFactors.length >= 2) {\r\n                        for (const p of xFactors) {\r\n                            if (p.degree().isZero()) {\r\n                                factors.push(p.clone())\r\n                            } else {\r\n                                xyzPolynom = p.clone()\r\n                                xyzPolynom.monoms[0].literal = a.literalSqrt\r\n                                xyzPolynom.monoms[1].literal = c.literalSqrt\r\n                                factors.push(xyzPolynom.clone())\r\n                            }\r\n                        }\r\n\r\n\r\n                        return factors\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            return [this.clone()]\r\n        }\r\n    }\r\n\r\n    #genDisplay = (output?: string, forceSign?: boolean, wrapParentheses?: boolean, withAllMultiplicationSign?: boolean): string => {\r\n        let P = ''\r\n\r\n        for (const k of this.#monoms) {\r\n            if (k.coefficient.value === 0) {\r\n                continue\r\n            }\r\n\r\n\r\n            // The monom to be displayed\r\n            let m\r\n            if (withAllMultiplicationSign) {\r\n                m = k.plotFunction\r\n            } else {\r\n                m = (output === 'tex') ? k.tex : k.display\r\n            }\r\n\r\n            P += `${(k.coefficient.sign() === 1 && (P !== '' || forceSign === true)) ? '+' : ''}${m}`\r\n        }\r\n\r\n        if (wrapParentheses === true && this.length > 1) {\r\n            if (output === 'tex') {\r\n                P = `\\\\left( ${P} \\\\right)`\r\n            } else {\r\n                P = `(${P})`\r\n            }\r\n        }\r\n\r\n\r\n        if (P === '') {\r\n            P = '0'\r\n        }\r\n\r\n        return P\r\n    }\r\n\r\n    #getAllPotentialFactors = (P: Polynom, maxDegree: number, letter: string): Polynom[] => {\r\n        const m1 = P.monoms[0].dividers,\r\n            m2 = P.monoms[P.monoms.length - 1].dividers\r\n\r\n        const allDividers: Polynom[] = []\r\n        m1.forEach(m1d => {\r\n            // Get only polynom that has a degree less than a specific value\r\n            if (m1d.degree(letter).isLeq(maxDegree)) {\r\n                m2.forEach(m2d => {\r\n                    if (m1d.degree(letter).isNotEqual(m2d.degree(letter))) {\r\n                        allDividers.push(new Polynom(m1d, m2d))\r\n                        allDividers.push(new Polynom(m1d, m2d.clone().opposite()))\r\n                    }\r\n                })\r\n            }\r\n\r\n\r\n        })\r\n\r\n        return allDividers\r\n    }\r\n\r\n    #multiplyByFraction = (F: Fraction): Polynom => {\r\n        for (const m of this.#monoms) {\r\n            m.coefficient.multiply(F)\r\n        }\r\n\r\n\r\n        return this.reduce()\r\n    }\r\n\r\n    #multiplyByInteger = (nb: number): Polynom => {\r\n        return this.#multiplyByFraction(new Fraction(nb))\r\n    }\r\n\r\n    #multiplyByMonom = (M: Monom): Polynom => {\r\n        for (const m of this.#monoms) {\r\n            m.multiply(M)\r\n        }\r\n\r\n        return this.reduce()\r\n    }\r\n\r\n    #multiplyByPolynom = (P: Polynom): Polynom => {\r\n        const M: Monom[] = []\r\n        for (const m1 of this.#monoms) {\r\n            for (const m2 of P.monoms) {\r\n                M.push(Monom.xMultiply(m1, m2))\r\n            }\r\n        }\r\n\r\n\r\n        this.#monoms = M\r\n        return this.reduce()\r\n    }\r\n\r\n    #parseString(inputStr: string, ...values: unknown[]): this {\r\n        if (values.length === 0) {\r\n            inputStr = '' + inputStr\r\n\r\n            // Parse the polynom using the shutting yard algorithm\r\n            if (inputStr !== '' && !isNaN(Number(inputStr))) {\r\n                this.empty()\r\n                // It's a simple number.\r\n                const m = new Monom(inputStr)\r\n                // m.coefficient = new Fraction(inputStr);\r\n                // m.literalStr = '';\r\n                this.add(m)\r\n                return this\r\n            }\r\n\r\n            // Parse the string.\r\n            return this.#shutingYardToReducedPolynom(inputStr)\r\n        } else if (/^[a-z]+/.test(inputStr)) {\r\n            // We assume the inputStr contains only letters.\r\n            this.empty()\r\n\r\n            const fractions = values.map(x => new Fraction(x as InputValue<Fraction>))\r\n\r\n            // Multiple setLetter version\r\n\r\n            if (inputStr.length > 1) {\r\n                // TODO: check that the number of values given correspond to the letters (+1 eventually)\r\n                const letters = inputStr.split('')\r\n                let i = 0\r\n\r\n                for (const F of fractions) {\r\n                    const m = new Monom()\r\n                    m.coefficient = F.clone()\r\n                    m.literalStr = letters[i] || ''\r\n                    this.add(m)\r\n                    i++\r\n                }\r\n            }\r\n            // Single setLetter version\r\n            else {\r\n                let n = fractions.length - 1\r\n                for (const F of fractions) {\r\n                    const m = new Monom()\r\n                    m.coefficient = F.clone()\r\n                    m.literalStr = `${inputStr}^${n}`\r\n                    this.add(m)\r\n                    n--\r\n                }\r\n            }\r\n            return this\r\n        } else {\r\n            return this.zero()\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Main parse using a shutting yard class\r\n     * @param inputStr\r\n     */\r\n    #shutingYardToReducedPolynom = (inputStr: string): this => {\r\n        // Get the RPN array of the current expression\r\n        const SY: ShutingYard = new ShutingYard().parse(inputStr)\r\n        const rpn: { token: string, tokenType: ShutingyardType }[] = SY.rpn\r\n\r\n        // New version for reducing shuting yard.\r\n        this.zero()\r\n\r\n        const stack: Polynom[] = []\r\n\r\n        // Loop through the each element of the RPN\r\n        for (const element of rpn) {\r\n            this.#shutingYard_addToken(stack, element)\r\n        }\r\n\r\n\r\n        if (stack.length === 1) {\r\n            this.add(stack[0])\r\n        }\r\n\r\n\r\n        return this.reorder()\r\n    }\r\n\r\n    #shutingYard_addToken = (stack: Polynom[], element: Token): void => {\r\n        switch (element.tokenType) {\r\n            case ShutingyardType.COEFFICIENT:\r\n                stack.push(new Polynom(element.token))\r\n                break\r\n\r\n            case ShutingyardType.VARIABLE:\r\n                stack.push(new Polynom().add(new Monom(element.token)))\r\n                break\r\n\r\n            case ShutingyardType.CONSTANT:\r\n                // TODO: add constant support to Polynom parsing.\r\n                console.log('Actually, not supported - will be added later !')\r\n                break\r\n\r\n            case ShutingyardType.OPERATION:\r\n                if (stack.length >= 2) {\r\n                    const b = stack.pop(),\r\n                        a = stack.pop()\r\n\r\n                    // Check if the polynoms are not undefined.\r\n                    if (a === undefined || b === undefined) {\r\n                        break\r\n                    }\r\n\r\n                    if (element.token === '+') {\r\n                        stack.push(a.add(b))\r\n                    } else if (element.token === '-') {\r\n                        stack.push(a.subtract(b))\r\n                    } else if (element.token === '*') {\r\n                        stack.push(a.multiply(b))\r\n                    } else if (element.token === '/') {\r\n                        if (b.degree().isStrictlyPositive()) {\r\n                            console.log('divide by a polynom -> should create a rational polynom !')\r\n                        } else {\r\n                            // a.divide(b.monoms[0].coefficient)\r\n                            stack.push(a.divide(b.monoms[0].coefficient))\r\n                        }\r\n                    } else if (element.token === '^') {\r\n                        if (b.degree().isStrictlyPositive()) {\r\n                            throw new Error('Cannot elevate a polynom with another polynom !')\r\n                        } else if (b.monoms[0].coefficient.isRelative())\r\n                            // Integer power\r\n                        {\r\n                            stack.push(a.pow(b.monoms[0].coefficient.value))\r\n                        } else {\r\n                            // Only allow power if the previous polynom is only a monom, without coefficient.\r\n                            if (a.monoms.length === 1 && a.monoms[0].coefficient.isOne()) {\r\n                                for (const letter in a.monoms[0].literal) {\r\n                                    a.monoms[0].literal[letter].multiply(b.monoms[0].coefficient)\r\n                                }\r\n\r\n                                stack.push(a)\r\n                            } else {\r\n                                console.error('Cannot have power with fraction')\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                } else if (element.token === '-') {\r\n                    const a = stack.pop()\r\n                    if (a) {\r\n                        stack.push(a.opposite())\r\n                    }\r\n                } else {\r\n                    throw new Error(\"Error parsing the polynom\")\r\n                }\r\n\r\n\r\n                break\r\n\r\n            case ShutingyardType.MONOM:\r\n                // Should never appear.\r\n                console.error('The monom token should not appear here')\r\n                break\r\n\r\n            case ShutingyardType.FUNCTION:\r\n                // Should never appear.\r\n                console.error('The function token should not appear here - might be introduced later.')\r\n                break\r\n        }\r\n\r\n\r\n    }\r\n\r\n}\r\n","import type {\r\n    IAlgebra,\r\n    IExpression,\r\n    InputAlgebra,\r\n    InputValue,\r\n    IPiMathObject,\r\n    ISolution,\r\n    literalType,\r\n    TABLE_OF_SIGNS\r\n} from \"../pimath.interface\"\r\nimport {Fraction} from \"../coefficients/fraction\"\r\nimport {Polynom} from \"./polynom\"\r\nimport {replace_in_array, wrapParenthesis} from \"../helpers\"\r\n\r\nexport class Factor implements IPiMathObject<Factor>,\r\n    IExpression<Factor>,\r\n    IAlgebra<Factor> {\r\n    #displayMode: FACTOR_DISPLAY\r\n    #polynom: Polynom\r\n    #power: Fraction\r\n    #singleMode = false\r\n\r\n    constructor(value: InputAlgebra<Polynom> | Factor, power?: InputValue<Fraction>) {\r\n        if (value instanceof Factor) {\r\n            this.#polynom = value.polynom.clone()\r\n            this.#power = value.power.clone()\r\n        } else if (typeof value === 'string' && power === undefined) {\r\n            // Must handle the case where the value is a string like (x-3)^2\r\n            const [base, p = '1'] = value.split('^')\r\n            this.#polynom = new Polynom(base)\r\n            this.#power = new Fraction(p.replace('(', '').replace(')', ''))\r\n        } else {\r\n            this.#polynom = new Polynom(value)\r\n            this.#power = new Fraction(power ?? 1)\r\n        }\r\n\r\n        this.#displayMode = FACTOR_DISPLAY.POWER\r\n\r\n        return this\r\n    }\r\n\r\n    public parse(/*value: InputValue<Factor>*/): Factor {\r\n        throw new Error(\"Method not implemented.\")\r\n    }\r\n\r\n    public clone(): Factor {\r\n        return new Factor(this)\r\n    }\r\n\r\n    public get tex(): string {\r\n        const num = this.power.numerator\r\n        const den = this.power.denominator\r\n\r\n        let base: string\r\n        let power: string\r\n\r\n        if (this.#displayMode === FACTOR_DISPLAY.ROOT && den > 1) {\r\n            base = `\\\\sqrt${den === 2 ? '' : `[ ${den} ]`}{ ${this.polynom.tex} }`\r\n            power = num === 1 ? '' : `^{ ${num} }`\r\n        } else {\r\n            base = this.#singleMode && this.power.isOne() ? this.polynom.tex : wrapParenthesis(this.polynom.tex)\r\n            power = (den === 1 && num === 1) ? '' : `^{ ${this.power.tex} }`\r\n        }\r\n\r\n        // Add the power if it's not 1 or -1\r\n        base = `${base}${power}`\r\n\r\n        // If the power is negative, make it as a fraction.\r\n        if (this.#displayMode === FACTOR_DISPLAY.ROOT && num < 0) {\r\n            base = `\\\\frac{ 1 }{ ${base} }`\r\n        }\r\n\r\n\r\n        return base\r\n    }\r\n\r\n    public get display(): string {\r\n        const num = this.power.numerator\r\n        const den = this.power.denominator\r\n\r\n        let base: string\r\n        let power: string\r\n\r\n        if (this.#displayMode === FACTOR_DISPLAY.ROOT && den > 1) {\r\n            base = `${den === 2 ? 'sqrt' : `root(${den})`}(${this.polynom.display})`\r\n            power = num === 1 ? '' : `^(${num})`\r\n        } else {\r\n            base = this.#singleMode && this.power.isOne() ? this.polynom.display : wrapParenthesis(this.polynom.display, false)\r\n            power = (den === 1 && num === 1) ? '' : `^(${this.power.display})`\r\n        }\r\n\r\n        // Add the power if it's not 1 or -1\r\n        base = `${base}${power}`\r\n\r\n        // If the power is negative, make it as a fraction.\r\n        if (this.#displayMode === FACTOR_DISPLAY.ROOT && num < 0) {\r\n            base = `1/(${base})`\r\n        }\r\n\r\n\r\n        return base\r\n    }\r\n\r\n    public add(): Factor {\r\n        throw new Error(\"Adding two factors is not possible\")\r\n    }\r\n\r\n    public get asSingle(): this {\r\n        this.#singleMode = true\r\n        return this\r\n    }\r\n\r\n    public degree(letter?: string): Fraction {\r\n        return this.polynom.degree(letter).multiply(this.power)\r\n    }\r\n\r\n    public derivative(): Factor[] {\r\n        // The power is zero, the derivative is zero\r\n        if (this.power.isZero()) {\r\n            return [new Factor('0', '1')]\r\n        }\r\n\r\n        // The power is one, the derivative is the derivative of the polynom\r\n        if (this.power.isOne()) {\r\n            return [new Factor(this.polynom.clone().derivative())]\r\n        }\r\n\r\n        // In any other case, the derivative consist of three Factors:\r\n        // the derivative of the polynom, the power and the polynom\r\n        return [\r\n            new Factor(this.power.clone()),\r\n            new Factor(this.polynom.clone().derivative()),\r\n            new Factor(this.polynom.clone(), this.power.clone().subtract(1))\r\n        ]\r\n    }\r\n\r\n    public develop(): Polynom {\r\n        if (this.power.isNatural()) {\r\n            return this.polynom.clone().pow(this.power.value)\r\n        }\r\n\r\n        throw new Error(\"The power must be a natural number\")\r\n    }\r\n\r\n    public divide(value: InputAlgebra<Factor | Polynom>): this {\r\n        if (value instanceof Factor) {\r\n            if (this.isSameAs(value)) {\r\n                this.power.subtract(value.power)\r\n                return this\r\n            }\r\n        }\r\n\r\n\r\n        const P = new Polynom(value as Polynom)\r\n        if (this.isSameAs(P)) {\r\n            this.power.subtract(1)\r\n            return this\r\n        }\r\n\r\n        throw new Error(\"The two factors must be the same\")\r\n    }\r\n\r\n    public evaluate(values: InputValue<Fraction> | literalType<number | Fraction>, asNumeric?: boolean): number | Fraction {\r\n        if (asNumeric) {\r\n            return (this.polynom.evaluate(values, true) as number) ** this.power.value\r\n        }\r\n\r\n\r\n        return (this.polynom.evaluate(values) as Fraction).pow(this.power)\r\n    }\r\n\r\n    public hasVariable(letter: string): boolean {\r\n        return this.polynom.hasVariable(letter)\r\n    }\r\n\r\n    public inverse(): this {\r\n        this.power.opposite()\r\n        return this\r\n    }\r\n\r\n    public isEqual(value: Factor): boolean {\r\n        // Must have the same polynom and the same reduce power\r\n\r\n        return this.isSameAs(value) &&\r\n            this.power.isEqual(value.power)\r\n    }\r\n\r\n    public isOne(): boolean {\r\n        return this.polynom.isOne() || this.power.isZero()\r\n    }\r\n\r\n    public isSameAs(value: InputAlgebra<Factor | Polynom>) {\r\n        let P: Polynom\r\n        if (value instanceof Factor) {\r\n            P = value.polynom\r\n        } else if (value instanceof Polynom) {\r\n            P = value\r\n        } else {\r\n            P = new Polynom(value)\r\n        }\r\n\r\n\r\n        return this.polynom.isEqual(P)\r\n    }\r\n\r\n    public isZero(): boolean {\r\n        return this.polynom.isZero()\r\n    }\r\n\r\n    public multiply(value: InputAlgebra<Factor | Polynom>): this {\r\n        if (value instanceof Factor) {\r\n            if (this.isSameAs(value)) {\r\n                this.power.add(value.power)\r\n                return this\r\n            }\r\n        }\r\n\r\n\r\n        const P = new Polynom(value as Polynom)\r\n        if (this.isSameAs(P)) {\r\n            this.power.add(1)\r\n            return this\r\n        }\r\n\r\n        throw new Error(\"The two factors must be the same\")\r\n    }\r\n\r\n    public one(): this {\r\n        this.#polynom.one()\r\n        this.#power.one()\r\n        return this\r\n    }\r\n\r\n    public opposite(): Factor {\r\n        throw new Error(\"Method not implemented.\")\r\n    }\r\n\r\n    public get polynom(): Polynom {\r\n        return this.#polynom\r\n    }\r\n\r\n    public set polynom(value: Polynom) {\r\n        this.#polynom = value\r\n    }\r\n\r\n    public pow(value: number | Fraction): this {\r\n        this.power.multiply(value)\r\n        return this\r\n    }\r\n\r\n    public get power(): Fraction {\r\n        return this.#power\r\n    }\r\n\r\n    public set power(value: InputValue<Fraction>) {\r\n        this.#power = new Fraction(value)\r\n    }\r\n\r\n    public primitive(): Factor {\r\n        throw new Error(\"Method not implemented.\")\r\n    }\r\n\r\n    public reduce(): Factor {\r\n        throw new Error(\"Method not implemented.\")\r\n    }\r\n\r\n    public root(value: number): this {\r\n        this.power.divide(value)\r\n        return this\r\n    }\r\n\r\n    public sqrt(): this {\r\n        return this.root(2)\r\n    }\r\n\r\n    public subtract(): Factor {\r\n        throw new Error(\"Subtracting two factors is not possible\")\r\n    }\r\n\r\n    public tableOfSigns(roots?: ISolution[]): TABLE_OF_SIGNS {\r\n        const pow = this.power.clone().reduce()\r\n        const tos = this.polynom.tableOfSigns(roots)\r\n\r\n        // The zero roots becomes defence (d) if the power is negative\r\n        if (pow.isStrictlyNegative()) {\r\n            tos.signs = replace_in_array(tos.signs, 'z', 'd')\r\n        }\r\n\r\n        // The - sign becomes\r\n        // + (plus) if the power num is even and the power den is odd\r\n        // i (invalid) if the power denominator is even\r\n        if (pow.denominator % 2 === 0) {\r\n            // it's an even roots : no negative values!\r\n            tos.signs = replace_in_array(tos.signs, '-', 'h')\r\n        } else if (pow.numerator % 2 === 0) {\r\n            // it's an even power :  negative values becomes positive !\r\n            tos.signs = replace_in_array(tos.signs, '-', '+')\r\n        }\r\n\r\n\r\n        return {roots: tos.roots, signs: tos.signs}\r\n    }\r\n\r\n    public get variables(): string[] {\r\n        return this.polynom.variables\r\n    }\r\n\r\n    public get withPower(): this {\r\n        this.#displayMode = FACTOR_DISPLAY.POWER\r\n        return this\r\n    }\r\n\r\n    public get withRoot(): this {\r\n        this.#displayMode = FACTOR_DISPLAY.ROOT\r\n        return this\r\n    }\r\n\r\n    public zero(): this {\r\n        this.#polynom.zero()\r\n        this.#power.one()\r\n        return this\r\n    }\r\n\r\n}\r\n\r\nexport enum FACTOR_DISPLAY {\r\n    ROOT,\r\n    POWER\r\n}\r\n\r\n","import type {\r\n    FACTOR_TABLE_OF_SIGNS,\r\n    IAlgebra,\r\n    IExpression,\r\n    InputAlgebra,\r\n    InputValue,\r\n    IPiMathObject,\r\n    ISolution,\r\n    literalType,\r\n    POLYFACTOR_TABLE_OF_SIGNS,\r\n    TABLE_OF_SIGNS_VALUES\r\n} from \"../pimath.interface\"\r\nimport {Fraction} from \"../coefficients/fraction\"\r\nimport {Factor, FACTOR_DISPLAY} from \"./factor\"\r\nimport {Polynom} from \"./polynom\"\r\n\r\n\r\n// PolyFactor is a class that represents a polynomial in factored form.\r\nexport class PolyFactor implements IPiMathObject<PolyFactor>,\r\n    IExpression<PolyFactor>,\r\n    IAlgebra<PolyFactor> {\r\n\r\n    #displayMode: FACTOR_DISPLAY = FACTOR_DISPLAY.POWER\r\n    #factors: Factor[] = []\r\n\r\n    constructor(...values: (Factor | InputAlgebra<Polynom> | PolyFactor)[]) {\r\n        this.parse(...values)\r\n        return this\r\n    }\r\n\r\n    public parse(...values: (Factor | InputAlgebra<Polynom> | PolyFactor)[]): this {\r\n        if (values.length === 0) {\r\n            return this\r\n        }\r\n\r\n        this.#factors = []\r\n\r\n        values.forEach(value => {\r\n            if (typeof value === 'string') {\r\n                const factors = value.split(')(').join(')*(').split('*')\r\n                this.#factors.push(...factors.map(f => new Factor(f)))\r\n            } else if (value instanceof PolyFactor) {\r\n                this.#factors.push(...value.factors.map(f => f.clone()))\r\n            } else {\r\n                this.#factors.push(new Factor(value))\r\n            }\r\n        })\r\n\r\n        return this\r\n    }\r\n\r\n    public clone(): PolyFactor {\r\n        return new PolyFactor(...this.#factors.map(f => f.clone()))\r\n    }\r\n\r\n    public get tex(): string {\r\n        const {num, den} = this.#extractNumeratorAndDenominator()\r\n\r\n        if (den.length === 0) {\r\n            if (num.length === 1) {\r\n                return num[0].asSingle.tex\r\n            }\r\n\r\n            return num.map(f => f.tex).join(\"\")\r\n        }\r\n\r\n        // There is a numerator and a denominator\r\n        const numTeX = num.length === 1 ? num[0].asSingle.tex : num.map(f => f.tex).join(\"\")\r\n        const denTeX = den.length === 1 ? den[0].asSingle.tex : den.map(f => f.tex).join(\"\")\r\n\r\n        return `\\\\frac{ ${numTeX} }{ ${denTeX} }`\r\n\r\n    }\r\n\r\n    public get display(): string {\r\n        const {num, den} = this.#extractNumeratorAndDenominator()\r\n\r\n        if (den.length === 0) {\r\n            if (num.length === 1) {\r\n                return num[0].asSingle.display\r\n            }\r\n\r\n            return num.map(f => f.display).join(\"\")\r\n        }\r\n\r\n        // There is a numerator and a denominator\r\n        const numTeX = num.length === 1 ? num[0].asSingle.display : num.map(f => f.display).join(\"\")\r\n        const denTeX = den.length === 1 ? den[0].asSingle.display : den.map(f => f.display).join(\"\")\r\n\r\n        return `(${numTeX})/(${denTeX})`\r\n\r\n    }\r\n\r\n    static #gcdWith(PF1: PolyFactor, PF2: PolyFactor): PolyFactor {\r\n        // Get all factors of the two polynomials\r\n        // Find the common factors\r\n        const factors1 = keyFactors(PF1)\r\n\r\n        const factors2 = keyFactors(PF2)\r\n\r\n        const common = Object.keys(factors1).filter(k => Object.hasOwn(factors2, k))\r\n\r\n        // Find the minimum power of the common factors\r\n        const factors = common.map(k => {\r\n            const power = factors1[k].reduce((acc, f) => acc.add(f.power), new Fraction('0'))\r\n            const power2 = factors2[k].reduce((acc, f) => acc.add(f.power), new Fraction('0'))\r\n            return new Factor(k, Fraction.min(power, power2))\r\n        })\r\n\r\n        return new PolyFactor(...factors)\r\n    }\r\n\r\n    public static gcd(...values: PolyFactor[]): PolyFactor {\r\n        if (values.length === 0) {\r\n            return new PolyFactor().one()\r\n        }\r\n        if (values.length === 1) {\r\n            return values[0]\r\n        }\r\n        if (values.length === 2) {\r\n            return PolyFactor.#gcdWith(values[0], values[1])\r\n        }\r\n\r\n        // values is not undefined,\r\n        let PF = values[0]\r\n        values.shift()\r\n        values.forEach(value => PF = PolyFactor.#gcdWith(PF, value))\r\n\r\n        return PF\r\n    }\r\n\r\n    public add(...values: PolyFactor[]): this {\r\n        // List of the polyFactors\r\n        let PF: PolyFactor[] = [this, ...values]\r\n\r\n        // Get the gcd of the PolyFactors\r\n        const gcd = PolyFactor.gcd(...PF)\r\n\r\n        // Divide the PF by the gcd\r\n        PF = PF.map(pf => pf.divide(gcd).reduce())\r\n\r\n        // Add the dPF values: develop the polynoms and add them\r\n        const P = new Polynom('0')\r\n        PF.forEach(pf => P.add(pf.develop()))\r\n\r\n        // Make the new factor\r\n        this.#factors = [\r\n            ...gcd.factors,\r\n            new Factor(P)\r\n        ]\r\n\r\n        return this\r\n    }\r\n\r\n    get asPower(): this {\r\n        this.#displayMode = FACTOR_DISPLAY.POWER\r\n        return this\r\n    }\r\n\r\n    get asRoot(): this {\r\n        this.#displayMode = FACTOR_DISPLAY.ROOT\r\n        return this\r\n    }\r\n\r\n    public degree(letter?: string): Fraction {\r\n        return this.#factors.reduce((acc, f) => acc.add(f.degree(letter)), new Fraction('0'))\r\n    }\r\n\r\n    get denominator(): Factor[] {\r\n        return this.#factors.filter(f => f.power.isNegative())\r\n    }\r\n\r\n    public derivative(): this {\r\n        const dPF: PolyFactor[] = []\r\n\r\n        const length = this.#factors.length\r\n\r\n        for (let i = 0; i < length; i++) {\r\n            const factors = this.#factors.slice()\r\n            const factor = factors.splice(i, 1)[0]\r\n            dPF.push(new PolyFactor(...factors).multiply(new PolyFactor(...factor.derivative())))\r\n        }\r\n\r\n        // Reduce the polyFactors\r\n        dPF.forEach(pf => pf.reduce())\r\n\r\n        const first = dPF.shift()\r\n        if (first !== undefined) {\r\n            this.#factors = first.factors\r\n        }\r\n\r\n        return this.add(...dPF)\r\n    }\r\n\r\n    public develop(): Polynom {\r\n        // Develop each factor and multiply them\r\n        const P = new Polynom('1')\r\n\r\n        this.#factors.forEach(f => {\r\n            P.multiply(f.develop())\r\n        })\r\n\r\n        return P\r\n    }\r\n\r\n    public divide(value: PolyFactor): this {\r\n        this.#factors = this.#factors.concat(value.clone().factors.map(f => f.inverse()))\r\n        return this\r\n    }\r\n\r\n    public evaluate(values: InputValue<Fraction> | literalType<number | Fraction>, asNumeric?: boolean): number | Fraction {\r\n        if (asNumeric) {\r\n            return this.#factors\r\n                .reduce((acc, f) => acc * (f.evaluate(values, asNumeric) as number), 1)\r\n        }\r\n\r\n        return this.#factors\r\n            .reduce((acc, f) => acc.multiply(f.evaluate(values)), new Fraction('1'))\r\n    }\r\n\r\n    public get factors(): Factor[] {\r\n        return this.#factors\r\n    }\r\n\r\n    public set factors(value: Factor[]) {\r\n        this.#factors = value\r\n    }\r\n\r\n    public fromPolynom(polynom: InputAlgebra<Polynom>, letter?: string): this {\r\n        // Find all factors from a polynom\r\n        this.#factors = new Polynom(polynom).factorize(letter).map(value => new Factor(value))\r\n        return this\r\n    }\r\n\r\n    public getFactors() {\r\n        return this.#factors\r\n    }\r\n\r\n    public getZeroes(): ISolution[] {\r\n        // Calculate the list of roots (ordered, unique)\r\n        const roots: ISolution[] = ([] as ISolution[])\r\n            .concat(...this.#factors.map(x => x.polynom.getZeroes()))\r\n        // .concat(...tos.map(x => x.roots))\r\n\r\n        // Sort the values.\r\n        roots.sort((a, b) => a.value - b.value)\r\n        // Remove duplicates.\r\n        return roots\r\n            .filter((value, index, self) =>\r\n                    index === self.findIndex((t) =>\r\n                        t.value === value.value\r\n                    )\r\n            )\r\n    }\r\n\r\n    public hasVariable(letter: string): boolean {\r\n        return this.#factors.some(f => f.hasVariable(letter))\r\n    }\r\n\r\n    public inverse(): this {\r\n        this.#factors = this.#factors.map(f => f.inverse())\r\n        return this\r\n    }\r\n\r\n    public isEqual(value: PolyFactor): boolean {\r\n        const gcd = PolyFactor.gcd(this, value)\r\n\r\n        const PF1 = this.clone().divide(gcd).reduce()\r\n        const PF2 = value.clone().divide(gcd).reduce()\r\n\r\n        return PF1.isOne() && PF2.isOne()\r\n    }\r\n\r\n    public isOne(): boolean {\r\n        return this.#factors.every(f => f.isOne())\r\n    }\r\n\r\n    public isZero(): boolean {\r\n        return this.#factors.every(f => f.isZero())\r\n    }\r\n\r\n    public multiply(...values: PolyFactor[]): this {\r\n        values.forEach(value => {\r\n            this.#factors = this.#factors.concat(value.clone().factors)\r\n        })\r\n\r\n        return this\r\n    }\r\n\r\n    get numerator(): Factor[] {\r\n        return this.#factors.filter(f => f.power.isPositive())\r\n    }\r\n\r\n    public one(): this {\r\n        this.#factors = [new Factor('1', '1')]\r\n        return this\r\n    }\r\n\r\n    public opposite(): this {\r\n        // Add the -1 factor or remove if it exists\r\n        const index = this.#factors.findIndex(f => f.display === '(-1)')\r\n\r\n        if (index >= 0) {\r\n            this.#factors.splice(index, 1)\r\n        } else {\r\n            this.#factors.push(new Factor('-1', '1'))\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    public pow(value: number | Fraction): this {\r\n        this.#factors = this.#factors.map(f => f.pow(value))\r\n        return this\r\n    }\r\n\r\n    public primitive(): PolyFactor {\r\n        throw new Error(\"Method not implemented.\")\r\n    }\r\n\r\n    public reduce(): this {\r\n        // Regroup the factors by their base\r\n        const factors = keyFactors(this)\r\n\r\n        // Multiply the factors of the same base\r\n        this.#factors = Object.values(factors)\r\n            .map(f => {\r\n                const base = f[0].polynom\r\n                const power = f.reduce((acc, f) => acc.add(f.power), new Fraction('0'))\r\n                return new Factor(base, power.reduce())\r\n            })\r\n            .filter(f => !f.power.isZero())\r\n\r\n        return this\r\n    }\r\n\r\n    public root(value: number): this {\r\n        this.#factors = this.#factors.map(f => f.root(value))\r\n        return this\r\n    }\r\n\r\n    public sort(): this {\r\n        this.#factors = this.#factors\r\n            .sort((a, b) => a.degree().isLeq(b.degree()) ? -1 : 1)\r\n        return this\r\n    }\r\n\r\n    public sqrt(): this {\r\n        this.#factors = this.#factors.map(f => f.sqrt())\r\n        return this\r\n    }\r\n\r\n    public subtract(...values: PolyFactor[]): this {\r\n        return this.add(...values.map(f => f.opposite()))\r\n    }\r\n\r\n    public tableOfSigns(): POLYFACTOR_TABLE_OF_SIGNS {\r\n        // Calculate the table of signs for each factor\r\n        const roots = this.getZeroes()\r\n\r\n        // Modify each lines of tos[<index>].signs to display extra zeroes\r\n        const factors: FACTOR_TABLE_OF_SIGNS[] = this.factors\r\n            .map(factor => {\r\n                return {factor: new Factor(factor), ...factor.tableOfSigns(roots)}\r\n            })\r\n\r\n        // Build the table of signs with extra roots\r\n        const signs: TABLE_OF_SIGNS_VALUES[] = factors\r\n            .map(item => item.signs)\r\n            .reduce<TABLE_OF_SIGNS_VALUES[]>((a, b) => {\r\n                if (a.length === 0) {\r\n                    a = b\r\n                } else {\r\n                    // assume a and b are array from same length.\r\n                    b.forEach((value, index) => {\r\n                        // Case of a zero, invalid or tab value\r\n                        // tab < zero < defence\r\n                        switch (value) {\r\n                            case \"d\":\r\n                                a[index] = \"d\"\r\n                                break\r\n                            case \"z\":\r\n                                a[index] = a[index] === \"d\" ? \"d\" : \"z\"\r\n                                break\r\n                            case \"h\":\r\n                                a[index] = \"h\"\r\n                                break\r\n                            case \"-\":\r\n                                a[index] = a[index] === \"h\" ? \"h\" : a[index] === \"-\" ? \"+\" : \"-\"\r\n                                break\r\n                        }\r\n                    })\r\n                }\r\n\r\n                return a\r\n            }, [])\r\n\r\n        return {signs, roots, factors}\r\n        //\r\n        // // the signs of the PolyFactor\r\n        // const signs: TABLE_OF_SIGNS_VALUES[] = []\r\n        // const currentColumn: TABLE_OF_SIGNS_VALUES[] = []\r\n        // tos.forEach(item => {\r\n        //     currentColumn.push(item.signs[0])\r\n        // })\r\n        // // add the global signs:\r\n        // // if there is an invalid value, it's invalid\r\n        // // if there is an even number of negative signs, it's positive\r\n        // signs.push(\r\n        //     currentColumn.filter(x => x === 'h').length > 0 ? 'h' :\r\n        //         currentColumn.filter(x => x === '-').length % 2 === 0 ? '+' :\r\n        //             '-'\r\n        // )\r\n        //\r\n        // // Go through each roots\r\n        // roots.forEach(root => {\r\n        //     let currentColumn: TABLE_OF_SIGNS_VALUES[] = []\r\n        //\r\n        //     // Remove the sign and zero of the factor's table of signs it root is the zero of the factor.\r\n        //     tos.forEach(item=>{\r\n        //         if(item.signs.length>2){\r\n        //             if(item.roots[0].value === root.value){\r\n        //                 currentColumn.push(item.signs[1])\r\n        //                 item.signs = item.signs.slice(2)\r\n        //                 item.roots.pop() // remove the root from the list\r\n        //             }\r\n        //         }\r\n        //     })\r\n        //     signs.push(\r\n        //         currentColumn.filter(x => x === 'd').length > 0 ? 'd' :\r\n        //             currentColumn.filter(x => x === 'z').length > 0 ? 'z' :\r\n        //                 't'\r\n        //     )\r\n        //\r\n        //\r\n        //     currentColumn = []\r\n        //     tos.forEach(item => {\r\n        //         currentColumn.push(item.signs[0])\r\n        //     })\r\n        //     signs.push(\r\n        //         currentColumn.filter(x => x === 'h').length > 0 ? 'h' :\r\n        //             currentColumn.filter(x => x === '-').length % 2 === 0 ? '+' :\r\n        //                 '-'\r\n        //     )\r\n        // })\r\n        //\r\n        //\r\n        //\r\n        // return {roots, signs}\r\n    }\r\n\r\n    public get variables(): string[] {\r\n        return this.#factors\r\n            .reduce((acc: string[], f: Factor) => acc.concat(f.variables), [])\r\n    }\r\n\r\n    public zero(): this {\r\n        this.#factors = [new Factor('0', '1')]\r\n        return this\r\n    }\r\n\r\n    #extractNumeratorAndDenominator() {\r\n        let num: Factor[],\r\n            den: Factor[] = []\r\n\r\n        if (this.#displayMode === FACTOR_DISPLAY.ROOT) {\r\n            // the power are positive integers\r\n            num = this.numerator\r\n            den = this.denominator.map(f => f.clone().inverse())\r\n        } else {\r\n            num = this.#factors\r\n        }\r\n\r\n        // There is no factor\r\n        if (num.length === 0) {\r\n            num = [new Factor('1')]\r\n        }\r\n        return {num, den}\r\n    }\r\n\r\n}\r\n\r\nfunction keyFactors(value: PolyFactor): Record<string, Factor[]> {\r\n    const coefficient = new Fraction().one()\r\n\r\n    const kF = value.factors.reduce((acc: Record<string, Factor[]>, f) => {\r\n        // It's only a value\r\n        if (f.polynom.degree().isZero()) {\r\n            if (f.polynom.monoms.length > 0) {\r\n                coefficient.multiply(f.polynom.monoms[0].coefficient)\r\n            }\r\n\r\n            return acc\r\n        }\r\n\r\n        // It's a polynom\r\n        const base = f.polynom.display\r\n        if (Object.hasOwn(acc, base)) {\r\n            acc[base].push(f)\r\n        } else {\r\n            acc[base] = [f]\r\n        }\r\n\r\n        return acc\r\n    }, {})\r\n\r\n    if (coefficient.isOne()) {\r\n        return kF\r\n    }\r\n\r\n    // Add the coefficient\r\n    kF[coefficient.display] = [new Factor(coefficient.display, 1)]\r\n\r\n    return kF\r\n}\r\n","import type {\r\n    IAlgebra,\r\n    IEquation,\r\n    InputAlgebra,\r\n    InputValue,\r\n    IPiMathObject,\r\n    ISolution,\r\n    literalType\r\n} from \"../pimath.interface\"\r\nimport { Fraction } from \"../coefficients/fraction\"\r\nimport { Numeric } from \"../numeric\"\r\nimport { EquationSolver } from \"./equationSolver\"\r\nimport { Monom } from \"./monom\"\r\nimport { Polynom } from \"./polynom\"\r\n\r\nexport type EQUATION_SIGN = \"=\" | \"<=\" | \">=\" | \"<\" | \">\"\r\n\r\nexport class Equation implements\r\n    IPiMathObject<Equation>,\r\n    IEquation<Equation>,\r\n    IAlgebra<Equation> {\r\n\r\n    // Left part of the equation\r\n    #left: Polynom\r\n    // Right part of the equation\r\n    #right: Polynom\r\n    // Signe of the equation\r\n    #sign: EQUATION_SIGN\r\n\r\n\r\n    constructor(equation: InputAlgebra<Polynom> | Equation)\r\n    constructor(left: InputAlgebra<Polynom>, right: InputAlgebra<Polynom>, sign?: EQUATION_SIGN)\r\n    constructor(left?: InputAlgebra<Polynom> | Equation, right?: InputAlgebra<Polynom>, sign?: EQUATION_SIGN) {\r\n        // Default equation\r\n        this.#left = new Polynom().zero()\r\n        this.#right = new Polynom().zero()\r\n        this.#sign = '='\r\n\r\n        // Only one value, it's an equation\r\n        if (left !== undefined && right === undefined) {\r\n            if (left instanceof Equation) {\r\n                return left.clone()\r\n            } else if (typeof left === 'string') {\r\n                // Parse the equation as a string.\r\n                this.parse(left)\r\n            }\r\n\r\n        } else if (left !== undefined && right !== undefined) {\r\n            // Two values, it's an equation with left and right polynoms.\r\n            this.left = new Polynom(left as InputAlgebra<Polynom>)\r\n            this.right = new Polynom(right)\r\n        }\r\n\r\n        if (sign !== undefined) {\r\n            this.sign = sign\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    public parse = (equationString: string): this => {\r\n        // Find the string separator\r\n        const strSign: string | false = this.#findSign(equationString)\r\n\r\n        if (strSign === false) {\r\n            throw new Error('The equation is not valid (no sign found)')\r\n        }\r\n\r\n        // The StrSign is found\r\n        const pStr: string[] = equationString.split(strSign)\r\n\r\n        return this.create(new Polynom(pStr[0]), new Polynom(pStr[1]), this.#formatSign(strSign))\r\n    }\r\n\r\n    public create = (left: Polynom, right: Polynom, sign?: string): this => {\r\n        this.#left = left\r\n        this.#right = right\r\n        this.#sign = this.#formatSign(sign ?? \"=\")\r\n        return this\r\n    }\r\n\r\n    public clone = (): Equation => {\r\n        return new Equation(this.#left.clone(), this.#right.clone(), this.#sign)\r\n    }\r\n\r\n    /**\r\n     * Add a value to the equation\r\n     * if value is an equation, add the left part to the left part of the equation\r\n     * and the right part to the right part of the equation\r\n     * if value is a string, try to create an equation\r\n     * if it fails, create a polynom and add it to the left and right part of the equation\r\n     * @param value | Polynom | Monom | Fraction | string | monom\r\n     */\r\n    public add(value: InputValue<Equation | Polynom>): this {\r\n        if (value instanceof Equation) {\r\n            // add the left part of the equation\r\n            this.#left.add(value.left)\r\n            // add the right part of the equation\r\n            this.#right.add(value.right)\r\n\r\n            return this\r\n        }\r\n\r\n        if (typeof value === 'string' &&\r\n            !Equation.isEquationString(value)) {\r\n\r\n            return this.add(new Equation(value))\r\n        }\r\n\r\n        const p = new Polynom(value)\r\n        this.#left.add(p)\r\n        this.#right.add(p)\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Get the degree of the equation\r\n     * @param letter\r\n     */\r\n    public degree = (letter?: string): Fraction => {\r\n        return Fraction.max(this.#left.degree(letter), this.#right.degree(letter))\r\n    }\r\n\r\n    /**\r\n     * divide an equation by a given value (transformed as a fraction)\r\n     *\r\n     * ```\r\n     * 8x+10=6x \\vert 2\r\n     * 4x+5=3x\r\n     * ```\r\n     *\r\n     * |>Alternatively with $3x-4$ maybe it's working ?\r\n     * $$\\frac{3x}{5}$$\r\n     *\r\n     * @param value\r\n     * @returns {Equation}\r\n     */\r\n    public divide = (value: InputValue<Fraction>): this => {\r\n        // Make sure we have a fraction.\r\n        const F: Fraction = new Fraction(value)\r\n\r\n        if (F.isZero()) {\r\n            return this\r\n        } else {\r\n            return this.multiply(F.inverse())\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create an Equation using two polynoms.\r\n     * Markdown *support* is cool\r\n     * @param values\r\n     * @param asNumeric\r\n     */\r\n    public evaluate(values: InputValue<Fraction> | literalType<number | Fraction>, asNumeric?: boolean  ): boolean {\r\n        // Evaluate the left and right part of the equation.\r\n        // compare the results.\r\n\r\n        // Evaluate the left and right part of the equation.\r\n        const left = this.#left.evaluate(values, asNumeric),\r\n            right = this.#right.evaluate(values, asNumeric)\r\n\r\n        // compare the results.\r\n        if (asNumeric) {\r\n            return left === right\r\n        }\r\n\r\n        return (left as Fraction).isEqual(right as Fraction)\r\n    }\r\n\r\n    /**\r\n     * Determine if the equation contains a variable.\r\n     * @param letter\r\n     */\r\n    public hasVariable = (letter: string): boolean => {\r\n        return this.variables.includes(letter)\r\n    }\r\n\r\n\r\n    public isEqual(value: InputValue<Equation>): boolean {\r\n        const equ = new Equation(value)\r\n        return equ.left.isEqual(this.#left) && equ.right.isEqual(this.#right)\r\n    }\r\n\r\n    public isLinearTo = (equ: Equation): boolean => {\r\n        // Move all left.\r\n        const p1 = equ.clone().moveLeft().simplify().left,\r\n            p2 = this.clone().moveLeft().simplify().left\r\n\r\n        // They are the same.\r\n        return p1.isEqual(p2) || p1.isOppositeAt(p2)\r\n    }\r\n\r\n    /**\r\n     * Determine if the equation contains more than one letter/variable.\r\n     */\r\n    public isMultiVariable = (): boolean => {\r\n        return this.#left.isMultiVariable || this.#right.isMultiVariable\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations helpers\r\n    public isEqualTo = (equ: Equation): boolean => {\r\n        const p1 = equ.clone().moveLeft().left,\r\n            p2 = this.clone().moveLeft().left\r\n\r\n        // They are the same.\r\n        return p1.isEqual(p2) || p1.isOppositeAt(p2)\r\n    }\r\n\r\n    /**\r\n     * Reorder the polynom to have only one letter on the left, the rest on the right.\r\n     * @param letter\r\n     */\r\n    public isolate = (letter?: string): this | false => {\r\n        // Determine if we can isolate the variables.\r\n\r\n        // Both part of the equations must be of the first degree.\r\n        //TODO: handle equations of degree two or more ?\r\n        if (!this.degree(letter).isOne()) {\r\n            return false\r\n        }\r\n\r\n        // Modify the equation to isolate the asked variable.\r\n        // TODO: must handle equations like 3xy+5y=4 => y = 4/(3x-5)\r\n        if (this.isMultiVariable()) {\r\n            return false\r\n        }\r\n\r\n        // Isolate the letter.\r\n        let mMove: Monom\r\n        // Start by moving everything to the left.\r\n        this.#left.subtract(this.#right)\r\n        this.#right.zero()\r\n        const values = [...this.#left.monoms]\r\n        for (const m of values) {\r\n            if (!m.hasVariable(letter)) {\r\n                mMove = m.clone()\r\n                this.#left.subtract(mMove)\r\n                this.#right.subtract(mMove)\r\n            }\r\n        }\r\n\r\n        // In theory, we should have only one item on the left.\r\n        if (this.#left.length !== 1) {\r\n            return false\r\n        }\r\n\r\n        const cMove: Fraction = this.#left.monoms[0].coefficient.clone()\r\n        this.#left.divide(cMove)\r\n        this.#right.divide(cMove)\r\n        return this\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations operations\r\n\r\n    // -----------------------------------------------\r\n    public letters = (): string[] => {\r\n        return [...new Set([...this.#left.letters(), ...this.#right.letters()])]\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    /**\r\n     * Reorder will move all monoms containing a letter on the left, all the other on the right.\r\n     */\r\n    public moveLeft = (): this => {\r\n        this.#left.subtract(this.#right)\r\n        this.#right.zero()\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Multiple an equation by a fraction value.\r\n     * @param value\r\n     */\r\n    public multiply = (value: InputValue<Fraction>): this => {\r\n        // Make sure we have a fraction.\r\n        const F: Fraction = new Fraction(value)\r\n\r\n        // Multiply each part of the equation by the fraction\r\n        this.#left.multiply(F)\r\n        this.#right.multiply(F)\r\n\r\n        // The sign of the inequality must be changed.\r\n        if (this.#sign !== '=' && F.sign() === -1) {\r\n            this.#reverseSign()\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    public pow(value: number): this {\r\n        this.#left.pow(value)\r\n        this.#right.pow(value)\r\n        return this\r\n    }\r\n    public opposite = (): this => {\r\n        this.#left = this.#left.opposite()\r\n        this.#right = this.#right.opposite()\r\n        return this\r\n    }\r\n\r\n    public reduce(): this {\r\n        // reduce means moving everything to the left\r\n        // remove the fractions\r\n        // simplify the equation\r\n        // reorder the equation\r\n        // start with a positive left part\r\n\r\n        // Move all left. The right part is now zero.\r\n        this.moveLeft()\r\n\r\n        // Reduce the equation: simplify and reorder.\r\n        this.#left.reduce()\r\n\r\n        // Simplify the equation.\r\n        this.simplify()\r\n\r\n        // Make sure the first part is positive.\r\n        if (this.#left.monoms[0].coefficient.isNegative()) {\r\n            this.multiply(-1)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    public reorder = (allLeft?: boolean): this => {\r\n        // Move all monoms of degree greater than 0 to the left.\r\n        // and all zero degree monoms to the right.\r\n        this.#left.subtract(this.#right)\r\n        this.#right.zero()\r\n        this.#left.reorder()\r\n\r\n        // we have all left (so equal zero) : it's done !\r\n        if (allLeft) {\r\n            return this\r\n        }\r\n\r\n        // Fetch all zero degree monoms.\r\n        this.#left.monoms\r\n            .filter(m => m.degree().isZero())\r\n            .forEach(m => {\r\n                const move = m.clone()\r\n                this.#left.subtract(move)\r\n                this.#right.subtract(move)\r\n            })\r\n\r\n        // Reorder the left and right polynoms\r\n        this.#left.reorder()\r\n        this.#right.reorder()\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    public replaceBy = (letter: string, P: Polynom): this => {\r\n        this.#left.replaceBy(letter, P)\r\n        this.#right.replaceBy(letter, P)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Multiply by the lcm denominator and divide by the gcm numerators.\r\n     */\r\n    public simplify = (): this => {\r\n        this.multiply(Numeric.lcm(...this.#left.getDenominators(), ...this.#right.getDenominators()))\r\n        this.divide(Numeric.gcd(...this.#left.getNumerators(), ...this.#right.getNumerators()))\r\n        return this\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    public solve = (): ISolution[] => {\r\n        const solver = new EquationSolver(this.clone())\r\n        return solver.solve()\r\n    }\r\n\r\n    public split(): [Polynom, Polynom] {\r\n        return [this.#left.clone(), this.#right.clone()]\r\n    }\r\n\r\n    public subtract(value: InputValue<Equation | Polynom>): this {\r\n        if (value instanceof Equation) {\r\n            this.#left.subtract(value.left)\r\n            this.#right.subtract(value.right)\r\n\r\n            return this\r\n        }\r\n\r\n        if (typeof value === 'string' &&\r\n            !Equation.isEquationString(value)) {\r\n            return this.subtract(new Equation(value))\r\n        }\r\n\r\n        const p = new Polynom(value)\r\n        this.#left.subtract(p)\r\n        this.#right.subtract(p)\r\n\r\n        return this\r\n    }\r\n\r\n    public test = (values: literalType<Fraction>): boolean => {\r\n        return (this.left.evaluate(values) as Fraction).isEqual(this.right.evaluate(values))\r\n    }\r\n\r\n    public static isEquationString(equationString: string): boolean {\r\n        // The equation sign can be one of the following:\r\n        // =, <, >, <=, >=\r\n\r\n        return equationString.includes('=') ||\r\n            equationString.includes('<') ||\r\n            equationString.includes('>') ||\r\n            equationString.includes('<=') ||\r\n            equationString.includes('>=')\r\n    }\r\n\r\n    public static makeSolutionsUnique(solutions: ISolution[], sorted?: boolean): ISolution[] {\r\n        const solutionAsTex: string[] = [],\r\n            uniqueSolutions = solutions.filter(sol => {\r\n                if (!solutionAsTex.includes(sol.tex)) {\r\n                    solutionAsTex.push(sol.tex)\r\n                    return true\r\n                } else {\r\n                    return false\r\n                }\r\n            })\r\n\r\n        if (sorted === true) {\r\n            uniqueSolutions.sort((a, b) => a.value - b.value)\r\n        }\r\n\r\n        return uniqueSolutions\r\n    }\r\n\r\n    public get display(): string {\r\n        return `${this.#left.display}${this.signAsTex}${this.#right.display}`\r\n    }\r\n\r\n    // Getter and setter\r\n    public get left(): Polynom {\r\n        return this.#left\r\n    }\r\n\r\n    public set left(value: Polynom) {\r\n        this.#left = value\r\n    }\r\n\r\n    public get numberOfVars(): number {\r\n        return this.variables.length\r\n    }\r\n\r\n    public get right(): Polynom {\r\n        return this.#right\r\n    }\r\n\r\n    public set right(value: Polynom) {\r\n        this.#right = value\r\n    }\r\n\r\n    // ------------------------------------------\r\n    public get sign(): string {\r\n        return this.#sign\r\n    }\r\n\r\n    public set sign(value: string) {\r\n        // Set the sign value as formatted.\r\n        this.#sign = this.#formatSign(value)\r\n    }\r\n\r\n    public get signAsTex(): string {\r\n        if (this.#sign === '>=') {\r\n            return '\\\\geq'\r\n        }\r\n\r\n        if (this.#sign === '<=') {\r\n            return '\\\\leq'\r\n        }\r\n\r\n        return this.#sign\r\n    }\r\n\r\n    public get tex(): string {\r\n        return `${this.#left.tex}${this.signAsTex}${this.#right.tex}`\r\n    }\r\n\r\n    public get variables(): string[] {\r\n        return [...new Set(this.#right.variables.concat(this.#left.variables))]\r\n    }\r\n\r\n    #findSign = (equationString: string): string | false => {\r\n        if (equationString.includes('geq')) {\r\n            return (equationString.includes('\\\\geq')) ? '\\\\geq' : 'geq'\r\n        } else if (equationString.includes('leq')) {\r\n            return (equationString.includes('\\\\leq')) ? '\\\\leq' : 'leq'\r\n        } else if (equationString.includes('>=')) {\r\n            return '>='\r\n        } else if (equationString.includes('=>')) {\r\n            return '=>'\r\n        } else if (equationString.includes('>')) {\r\n            return '>'\r\n        } else if (equationString.includes('<=')) {\r\n            return '<='\r\n        } else if (equationString.includes('=<')) {\r\n            return '=<'\r\n        } else if (equationString.includes('<')) {\r\n            return '<'\r\n        } else if (equationString.includes('=')) {\r\n            return '='\r\n        }\r\n\r\n        throw new Error('The equation is not valid (no sign found)')\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations solving algorithms\r\n    #formatSign = (signStr?: string): EQUATION_SIGN => {\r\n        if (signStr === undefined) {\r\n            return '='\r\n        }\r\n\r\n        if (signStr.includes('geq')) {\r\n            return '>='\r\n        } else if (signStr.includes('>=')) {\r\n            return '>='\r\n        } else if (signStr.includes('=>')) {\r\n            return '>='\r\n        } else if (signStr.includes('>')) {\r\n            return '>'\r\n        } else if (signStr.includes('leq')) {\r\n            return '<='\r\n        } else if (signStr.includes('<=')) {\r\n            return '<='\r\n        } else if (signStr.includes('=<')) {\r\n            return '<='\r\n        } else if (signStr.includes('<')) {\r\n            return '<'\r\n        } else {\r\n            return '='\r\n        }\r\n    }\r\n\r\n    #reverseSign = (): this => {\r\n        if (this.#sign === '=') {\r\n            return this\r\n        }\r\n\r\n        if (this.#sign.includes('<')) {\r\n            this.#sign.replace('<', '>')\r\n            return this\r\n        }\r\n        if (this.#sign.includes('>')) {\r\n            this.#sign.replace('>', '<')\r\n            return this\r\n        }\r\n\r\n        return this\r\n    }\r\n}\r\n","import type {IAlgebra, IEquation, InputValue, IPiMathObject, ISolution, literalType} from \"../pimath.interface\"\r\nimport {Fraction} from \"../coefficients/fraction\"\r\nimport {Equation} from \"./equation\"\r\nimport {Monom} from \"./monom\"\r\nimport {Polynom} from \"./polynom\"\r\n\r\nexport class LinearSystem implements IPiMathObject<LinearSystem>,\r\n    IEquation<LinearSystem>,\r\n    IAlgebra<LinearSystem> {\r\n\r\n    #equations: Equation[]\r\n\r\n    // Determine the letters in the linear system, usually ['x', 'y']\r\n    #variables: string[]\r\n\r\n    constructor(...values: (string | Equation)[]) {\r\n        this.#equations = []\r\n        this.#variables = []\r\n\r\n        if (values.length > 0) {\r\n            this.parse(...values)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    public parse = (...equations: (string | Equation)[]): this => {\r\n        // make the original equations\r\n        this.#equations = equations.map(value => new Equation(value))\r\n\r\n        // get the letters.\r\n        this.#findLetters()\r\n        return this\r\n    }\r\n\r\n    public clone = (): LinearSystem => {\r\n        return new LinearSystem()\r\n            .parse(...this.#equations.map(equ => equ.clone()))\r\n    }\r\n\r\n    public static fromMatrix(\r\n        matrix: InputValue<Fraction>[][],\r\n        letters = 'xyz'): LinearSystem {\r\n        // Check that each row has the same number of columns\r\n        const cols = matrix[0].length\r\n        if (matrix.some(row => row.length !== cols)) {\r\n            throw new Error(\"All rows must have the same number of columns\")\r\n        }\r\n\r\n        // Determine the default letters. The number of letters are cols-1\r\n        const vars = letters.split('')\r\n            .splice(0, cols - 1)\r\n\r\n        // Create a new LinearSystem\r\n        return new LinearSystem(\r\n            ...matrix.map(row => {\r\n                const P = new Polynom(vars.join(''), ...row)\r\n                return new Equation(P, 0)\r\n            })\r\n        )\r\n\r\n    }\r\n\r\n    public add(value: InputValue<LinearSystem | Equation | Polynom>, index?: number): this {\r\n        if (value instanceof LinearSystem) {\r\n            const length = value.equations.length\r\n            if (length !== this.#equations.length) {\r\n                throw new Error(\"The number of equations must be the same\")\r\n            }\r\n\r\n            for (let i = 0; i < length; i++) {\r\n                this.#equations[i].add(value.equations[i])\r\n            }\r\n        } else {\r\n            if (index === undefined || index < 0 || index >= this.#equations.length) {\r\n                throw new Error(\"Index out of range\")\r\n            }\r\n            const equ = new Equation(value)\r\n            this.#equations[index].add(equ)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    public buildTex = (equations: Equation[], operators?: (string[])[]): string => {\r\n        let equStr: string[]\r\n        let m: Monom\r\n        let letters: string[] = []\r\n        const equArray: string[] = []\r\n\r\n        // Get the letters from the linear system\r\n        for (const equ of equations) {\r\n            letters = letters.concat(equ.letters())\r\n        }\r\n\r\n        letters = [...new Set(letters)]\r\n        letters.sort()\r\n\r\n        for (let i = 0; i < equations.length; i++) {\r\n            const equ = equations[i]\r\n\r\n            equStr = []\r\n            for (const L of letters) {\r\n                m = equ.left.monomByLetter(L)\r\n\r\n                if (equStr.length === 0) {\r\n                    equStr.push(m.isZero() ? '' : m.tex)\r\n                } else {\r\n                    equStr.push(m.isZero() ? '' : ((m.coefficient.sign() === 1) ? '+' : '') + m.tex)\r\n                }\r\n            }\r\n\r\n            // Add the equal sign\r\n            equStr.push('=')\r\n\r\n            // Add the right hand part of the equation (should be only a number, because it has been reordered)\r\n            equStr.push(equ.right.tex)\r\n\r\n            // Add the operations if existing\r\n            if (operators?.[i] !== undefined) {\r\n                // add extra space at the end of the equation\r\n                equStr[equStr.length - 1] = equStr[equStr.length - 1] + ' \\\\phantom{\\\\quad}'\r\n                for (const o of operators[i]) {\r\n                    equStr.push(`\\\\ \\\\cdot\\\\ ${o.startsWith('-') ? \"\\\\left(\" + o + \"\\\\right)\" : o}`)\r\n                }\r\n            }\r\n\r\n            // Add to the list.\r\n            equArray.push(equStr.join('&'))\r\n        }\r\n\r\n        let operatorsColumns = 0\r\n        if (operators !== undefined && operators.length > 0) {\r\n            operatorsColumns = operators[0].length\r\n        }\r\n\r\n        return `\\\\left\\\\{\\\\begin{array}{${\"r\".repeat(letters.length)}cl ${\"|l\".repeat(operatorsColumns)}}${equArray.join('\\\\\\\\ ')}\\\\end{array}\\\\right.`\r\n    }\r\n\r\n    public degree(letter?: string | undefined): Fraction {\r\n        return Fraction.max(...this.#equations.map(equ => equ.degree(letter)))\r\n    }\r\n\r\n    get display() {\r\n        // TODO : LinearSystem - display: implement the display of the linear system\r\n        return this.tex + 'as display'\r\n    }\r\n\r\n    // ------------------------------------------\r\n    public get equations(): Equation[] {\r\n        return this.#equations\r\n    }\r\n\r\n    public set equations(value) {\r\n        this.#equations = value\r\n    }\r\n\r\n    public evaluate(values: InputValue<Fraction> | literalType<number | Fraction>, asNumeric?: boolean | undefined): number | Fraction {\r\n        throw new Error(\"Method not implemented.\")\r\n    }\r\n\r\n    public hasVariable(letter: string): boolean {\r\n        return this.#variables.includes(letter)\r\n    }\r\n\r\n    public isEqual(value: LinearSystem): boolean {\r\n        return this.equations.every((equ, index) => equ.isEqual(value.equations[index]))\r\n    }\r\n\r\n    public get isSolvable(): boolean {\r\n        const V = this.variables\r\n\r\n        // TODO: in some case, it is possible to resolve systems if there isn't the isSame number of vars and equations\r\n        if (V.length !== this.#equations.length) {\r\n            return false\r\n        }\r\n\r\n        //TODO: Must check if two equations isn't a linear combination of the others ?\r\n\r\n        return true\r\n    }\r\n\r\n    public get matrix(): [Fraction[][], Fraction[]] {\r\n        //TODO: use Matrix class\r\n        return this.#makeMatrix()\r\n    }\r\n\r\n    public mergeEquations = (eq1: Equation, eq2: Equation, factor1: Fraction, factor2: Fraction): Equation => {\r\n        // Set and clone the equations.\r\n\r\n        const eq1multiplied = eq1.clone().multiply(new Fraction(factor1)),\r\n            eq2multiplied = eq2.clone().multiply(new Fraction(factor2))\r\n\r\n        // Add both equations together.\r\n        eq1multiplied.left.add(eq2multiplied.left)\r\n        eq1multiplied.right.add(eq2multiplied.right)\r\n\r\n        return eq1multiplied\r\n    }\r\n\r\n    public multiply(value: InputValue<Fraction> | InputValue<Fraction>[], index?: number): this {\r\n        // Multiply the system by a number\r\n        // the value can be an array of numbers\r\n        // the value can be a number and the index of the equation to multiply\r\n        if (Array.isArray(value)) {\r\n            if (value.length !== this.#equations.length) {\r\n                throw new Error(\"The number of values must be the same as the number of equations\")\r\n            }\r\n\r\n            for (let i = 0; i < value.length; i++) {\r\n                this.#equations[i].multiply(value[i])\r\n            }\r\n            return this\r\n        }\r\n\r\n        if (index === undefined || index < 0 || index >= this.#equations.length) {\r\n            throw new Error(\"Index out of range\")\r\n        }\r\n\r\n        this.#equations[index].multiply(value)\r\n\r\n        return this\r\n    }\r\n\r\n    public reduce(): LinearSystem {\r\n        throw new Error(\"Method not implemented.\")\r\n    }\r\n\r\n    // ------------------------------------------\r\n    public reorder = (): this => {\r\n        for (const E of this.#equations) {\r\n            E.reorder()\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    solve(): ISolution[] {\r\n        return []\r\n    }\r\n\r\n    public solveMatrix = (): Fraction[] => {\r\n        const [matrix, vector] = this.matrix\r\n        // Solve the matrix\r\n\r\n        // Make the augmented matrix (matrix + vector)\r\n        const augmentedMatrix: Fraction[][] = matrix.map((row, index) => [...row, vector[index]])\r\n\r\n        // Reduce the matrix\r\n        for (let i = 0; i < matrix.length; i++) {\r\n            // Find the pivot (the first non-zero element in the row)\r\n            const pivot = augmentedMatrix[i][i].clone()\r\n\r\n            // Normalize the row: divide all elements by the pivot\r\n            // the pivot is now 1\r\n            augmentedMatrix[i] = augmentedMatrix[i].map(x => x.divide(pivot))\r\n\r\n            // reduce the other rows using the pivot.\r\n            for (let j = 0; j < matrix.length; j++) {\r\n                if (j === i) {\r\n                    continue\r\n                }\r\n\r\n                const factor = augmentedMatrix[j][i].clone().opposite()\r\n                for (let k = 0; k < augmentedMatrix[j].length; k++) {\r\n                    augmentedMatrix[j][k].add(augmentedMatrix[i][k].clone().multiply(factor))\r\n                }\r\n\r\n                // Check if the system is undetermined (no solution or infinite solutions)\r\n                // the j line must not be all zeros\r\n                // the last element must be zero => the system is undetermined\r\n                // the last element must not be zero => the system is impossible\r\n                if (augmentedMatrix[j].slice(0, augmentedMatrix[j].length - 1).every(x => x.isZero())) {\r\n                    if (augmentedMatrix[j][augmentedMatrix[j].length - 1].isZero()) {\r\n                        return [new Fraction().infinite()]\r\n                    } else {\r\n                        return []\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return augmentedMatrix.map(x => x[x.length - 1])\r\n    }\r\n\r\n    public subtract(value: InputValue<LinearSystem | Equation | Polynom>, index?: number): this {\r\n        if (value instanceof LinearSystem) {\r\n            const length = value.equations.length\r\n            if (length !== this.#equations.length) {\r\n                throw new Error(\"The number of equations must be the same\")\r\n            }\r\n\r\n            for (let i = 0; i < length; i++) {\r\n                this.#equations[i].subtract(value.equations[i])\r\n            }\r\n        } else {\r\n            if (index === undefined || index < 0 || index >= this.#equations.length) {\r\n                throw new Error(\"Index out of range\")\r\n            }\r\n            const equ = new Equation(value)\r\n            this.#equations[index].subtract(equ)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    public get tex(): string {\r\n        // Build the array of values.\r\n        // Reorder\r\n        // This clone the system :!!!\r\n        //TODO: Avoid cloning this linear system\r\n        const LS = this.clone().reorder()\r\n\r\n        return this.buildTex(LS.equations)\r\n    }\r\n\r\n    public get variables(): string[] {\r\n        return this.#variables\r\n    }\r\n\r\n    public set variables(value: string | string[]) {\r\n        const vars = (typeof value === \"string\") ? value.split('') : [...value]\r\n        vars.sort()\r\n        this.#variables = vars\r\n    }\r\n\r\n    #findLetters = (): this => {\r\n        this.#variables = this.#equations.reduce((acc: string[], equ) => {\r\n            return [...new Set([...acc, ...equ.variables])]\r\n        }, [])\r\n        //\r\n        // // Find all letters used.\r\n        // let variables = new Set<string>()\r\n        //\r\n        // for (const equ of this.#equations) {\r\n        //     variables = new Set([...variables, ...equ.variables])\r\n        // }\r\n        //\r\n        // this.#variables = [...variables]\r\n        this.#variables.sort()\r\n        return this\r\n    }\r\n\r\n    #makeMatrix = (): [Fraction[][], Fraction[]] => {\r\n        // Make the matrix\r\n        const matrix: Fraction[][] = []\r\n        const vector: Fraction[] = []\r\n\r\n        for (const E of this.#equations) {\r\n            const row: Fraction[] = []\r\n\r\n            const equ = E.clone().reorder()\r\n            for (const L of this.variables) {\r\n                const m = equ.left.monomByLetter(L)\r\n                row.push(m.coefficient)\r\n            }\r\n\r\n            // Add the \"no letter part\"\r\n            vector.push(equ.right.monoms[0].coefficient)\r\n\r\n            // Add to the matrix\r\n            matrix.push(row)\r\n        }\r\n\r\n        return [matrix, vector]\r\n    }\r\n\r\n}\r\n","import { Fraction } from \"../coefficients/fraction\"\r\nimport type { Vector } from \"./vector\"\r\n\r\ntype V = Vector\r\nexport function areVectorsEquals(v1: V, v2: V): boolean {\r\n    return v1.dimension === v2.dimension &&\r\n        v1.array.every(\r\n            (value, index) => {\r\n                return v2.array[index].isEqual(value)\r\n            })\r\n}\r\n\r\nexport function areVectorsColinears(v1: V, v2: V): boolean {\r\n    if (v1.dimension !== v2.dimension) { return false }\r\n\r\n    // Constant of proportionality\r\n    const k = v2.array[0].value / v1.array[0].value\r\n    return v1.array.every(\r\n        (value, index) => {\r\n            return v2.array[index].value === value.value * k\r\n        })\r\n}\r\n\r\n\r\nexport function dotProduct(v1: V, v2: V): Fraction {\r\n    if (v1.dimension !== v2.dimension) { return new Fraction().invalid() }\r\n\r\n    // Calculate the dot product\r\n    // Why does the reduce not add the last element?\r\n\r\n    return v1.array.reduce(\r\n        (acc, value, index) => {\r\n            return acc.add(value.clone().multiply(v2.array[index]))\r\n        }, new Fraction(0))\r\n}\r\n\r\nexport function determinant(...values: V[]): Fraction {\r\n    // TODO: Make it work for vectors of dimension n\r\n    // Check if the vectors are in the same dimension\r\n    if (values.some((value) => value.dimension !== values[0].dimension)) {\r\n        return new Fraction().invalid()\r\n    }\r\n\r\n    // Check if the vectors are in dimension 2 or 3 and that the number of values is correct\r\n    if (values[0].dimension === 2 && values.length !== 2) {\r\n        return new Fraction().invalid()\r\n    }\r\n\r\n    if (values[0].dimension === 3 && values.length !== 3) {\r\n        return new Fraction().invalid()\r\n    }\r\n\r\n    // Calculate the determinant 2x2\r\n    if (values[0].dimension === 2) {\r\n        return values[0].array[0].clone().multiply(values[1].array[1])\r\n            .subtract(values[0].array[1].clone().multiply(values[1].array[0]))\r\n    }\r\n\r\n    // Calculate the determinant 3x3\r\n    return values[0].array[0].clone()\r\n        .multiply(\r\n            values[1].array[1].clone().multiply(values[2].array[2])\r\n                .subtract(values[1].array[2].clone().multiply(values[2].array[1]))\r\n        )\r\n        .subtract(values[0].array[1].clone()\r\n            .multiply(\r\n                values[1].array[0].clone().multiply(values[2].array[2])\r\n                    .subtract(values[1].array[2].clone().multiply(values[2].array[0]))\r\n            )\r\n        )\r\n        .add(values[0].array[2].clone()\r\n            .multiply(values[1].array[0].clone().multiply(values[2].array[1])\r\n                .subtract(values[1].array[1].clone().multiply(values[2].array[0]))))\r\n}\r\n","/**\r\n * Vector2D module contains everything necessary to handle 2d vectors.\r\n * @module Vector\r\n */\r\nimport type { InputValue, IPiMathObject } from \"../pimath.interface\"\r\nimport { Fraction } from \"../coefficients/fraction\"\r\nimport { Numeric } from \"../numeric\"\r\nimport { areVectorsColinears, areVectorsEquals, dotProduct } from \"./geomMath\"\r\n\r\nexport class Vector implements\r\n    IPiMathObject<Vector> {\r\n    #array: Fraction[] = []\r\n    #asPoint = false\r\n\r\n    constructor(...values: Vector[] | InputValue<Fraction>[]) {\r\n        if (values.length > 0) {\r\n            this.parse(...values)\r\n        }\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get array(): Fraction[] {\r\n        return this.#array\r\n    }\r\n\r\n    set array(value: Fraction[]) {\r\n        this.#array = value\r\n    }\r\n\r\n    get x(): Fraction {\r\n        return this.#array[0]\r\n    }\r\n\r\n    set x(value: Fraction | number | string) {\r\n        this.#array[0] = new Fraction(value)\r\n    }\r\n\r\n    get y(): Fraction {\r\n        return this.#array[1]\r\n    }\r\n\r\n    set y(value: Fraction | number | string) {\r\n        this.#array[1] = new Fraction(value)\r\n    }\r\n\r\n    get z(): Fraction {\r\n        if (this.dimension < 3) { throw new Error('Vector is not 3D') }\r\n        return this.#array[2]\r\n    }\r\n\r\n    set z(value: Fraction | number | string) {\r\n        if (this.dimension < 3) { throw new Error('Vector is not 3D') }\r\n        this.#array[2] = new Fraction(value)\r\n    }\r\n\r\n    get asPoint(): boolean {\r\n        return this.#asPoint\r\n    }\r\n\r\n    set asPoint(value: boolean) {\r\n        this.#asPoint = value\r\n    }\r\n\r\n\r\n    get normSquare(): Fraction {\r\n        // Get the norm square of the vector\r\n        return this.array.reduce((acc, x) => acc.add(x.clone().pow(2)), new Fraction(0))\r\n    }\r\n\r\n    get norm(): number {\r\n        return Math.sqrt(this.normSquare.value)\r\n    }\r\n\r\n    get tex(): string {\r\n        if (this.#asPoint) {\r\n            return `\\\\left(${this.array.map(x => x.tex).join(';')}\\\\right)`\r\n        }\r\n\r\n        return `\\\\begin{pmatrix} ${this.array.map(x => x.tex).join(' \\\\\\\\ ')} \\\\end{pmatrix}`\r\n    }\r\n\r\n    get display(): string {\r\n        if (this.#asPoint) {\r\n            return `(${this.array.map(x => x.display).join(';')})`\r\n        }\r\n\r\n        return `((${this.array.map(x => x.display).join(',')}))`\r\n    }\r\n\r\n    setDimension(value = 2): this{\r\n        if (value < 2) {\r\n            throw new Error('Dimension must be at least 2')\r\n        }\r\n\r\n        if (value < this.dimension) {\r\n            this.#array = this.#array.slice(0, value)\r\n        } else if(value > this.dimension) {\r\n            for(let i = this.dimension; i < value; i++) {\r\n                this.#array.push(new Fraction(0))\r\n            }\r\n        }\r\n\r\n        return this\r\n    }\r\n    get dimension(): number {\r\n        return this.array.length\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    get isNull(): boolean {\r\n        return this.array.every(x => x.isZero())\r\n    }\r\n\r\n    static asTex(...values: string[]): string {\r\n        return `\\\\begin{pmatrix} ${values.join(' \\\\\\\\ ')} \\\\end{pmatrix}`\r\n    }\r\n    static asDisplay(...values: string[]): string {\r\n        return `((${values.join(',')}))`\r\n    }\r\n\r\n    public defineAsPoint(value?: boolean): this {\r\n        this.#asPoint = value !== false\r\n        return this\r\n    }\r\n    public parse(...values: Vector[] | InputValue<Fraction>[]): this {\r\n        if (values.length === 0) {\r\n            throw new Error(`Invalid value`)\r\n        }\r\n\r\n        if (values.length === 1) {\r\n            if (values[0] instanceof Vector) {\r\n                return values[0].clone() as this\r\n            } else if (typeof values[0] === 'string') {\r\n                return this.fromString(values[0])\r\n            } else {\r\n                throw new Error(`Invalid value`)\r\n            }\r\n        }\r\n\r\n        // Two values are given\r\n        if (values.length === 2) {\r\n            const [A, B] = values\r\n\r\n            // The two values are vectors\r\n            if (A instanceof Vector && B instanceof Vector) {\r\n                if (A.dimension !== B.dimension) { throw new Error('Vectors must have the same dimension') }\r\n\r\n                this.#array = B.array.map((x, index) => x.clone().subtract(A.array[index]))\r\n                return this\r\n            }\r\n        }\r\n\r\n        // Two ore more values as number, string, fraction...\r\n        this.#array = values.map(x => new Fraction(x as InputValue<Fraction>))\r\n\r\n        return this\r\n    }\r\n\r\n    public clone(): Vector {\r\n        const V = new Vector()\r\n        V.array = this.copy()\r\n        V.asPoint = this.asPoint\r\n        return V\r\n    }\r\n\r\n    public copy(): Fraction[] {\r\n        return this.#array.map(x => x.clone())\r\n    }\r\n\r\n    zero = (): this => {\r\n        this.#array.forEach(x => x.zero())\r\n        return this\r\n    }\r\n\r\n    one = (): this => {\r\n        this.zero()\r\n        this.x.one()\r\n        return this\r\n    }\r\n\r\n    opposite = (): this => {\r\n        this.#array.forEach(x => x.opposite())\r\n        return this\r\n    }\r\n\r\n    add = (V: Vector): this => {\r\n        this.#array.forEach((x, index) => x.add(V.array[index]))\r\n        return this\r\n    }\r\n\r\n    subtract = (V: Vector): this => {\r\n        return this.add(V.clone().opposite())\r\n    }\r\n\r\n    unit = (): this => {\r\n        const norm = this.norm\r\n        if (norm === 0) {\r\n            return this\r\n        }\r\n\r\n        return this.divideByScalar(norm)\r\n    }\r\n\r\n    middleOf(V1: Vector, V2: Vector): this {\r\n        if (V1.dimension !== V2.dimension) { throw new Error('Vectors must be the same dimension') }\r\n\r\n        this.array = []\r\n        V1.array.forEach((x, index) => {\r\n            this.array.push(x.clone().add(V2.array[index]).divide(2))\r\n        })\r\n\r\n        return this\r\n    }\r\n\r\n    translate(...values: Fraction[]): this {\r\n        this.array.forEach((x, index) => x.add(values[index]))\r\n        return this\r\n    }\r\n\r\n\r\n    dot = (V: Vector): Fraction => {\r\n        return dotProduct(this, V)\r\n    }\r\n\r\n    cross(value: Vector): Vector {\r\n        if (this.dimension !== 3 || value.dimension !== 3) {\r\n            throw new Error('Cross product can only be determined in 3D')\r\n        }\r\n\r\n        return new Vector(\r\n            this.y.clone().multiply(value.z).subtract(this.z.clone().multiply(value.y)),\r\n            this.z.clone().multiply(value.x).subtract(this.x.clone().multiply(value.z)),\r\n            this.x.clone().multiply(value.y).subtract(this.y.clone().multiply(value.x))\r\n        )\r\n    }\r\n\r\n    normal = (): this => {\r\n        if (this.dimension >= 3) { throw new Error('Normal vector can only be determined in 2D') }\r\n\r\n        const x = this.x.clone().opposite(),\r\n            y = this.y.clone()\r\n        this.#array[0] = y\r\n        this.#array[1] = x\r\n        return this\r\n    }\r\n\r\n    isZero(): boolean {\r\n        return this.array.every(x => x.isZero())\r\n    }\r\n    isOne(): boolean {\r\n        return this.array.every((x, index) => index === 0 ? x.isOne() : x.isZero())\r\n    }\r\n\r\n    isEqual = (v: Vector): boolean => {\r\n        return areVectorsEquals(this, v)\r\n    }\r\n\r\n    isColinearTo = (v: Vector): boolean => {\r\n        return areVectorsColinears(this, v)\r\n    }\r\n\r\n    isNormalTo = (v: Vector): boolean => {\r\n        return this.dot(v).isZero()\r\n    }\r\n\r\n    multiplyByScalar = (k: InputValue<Fraction>): this => {\r\n        const scalar = new Fraction(k)\r\n        this.array.forEach(x => x.multiply(scalar))\r\n        return this\r\n    }\r\n\r\n    divideByScalar = (k: InputValue<Fraction>): this => {\r\n        return this.multiplyByScalar(new Fraction(k).inverse())\r\n    }\r\n\r\n    simplify = (): this => {\r\n        // Multiply by the lcm of denominators.\r\n        return this\r\n            .multiplyByScalar(\r\n                Numeric.lcm(...this.array.map(x => x.denominator))\r\n            )\r\n            .divideByScalar(\r\n                Numeric.gcd(...this.array.map(x => x.numerator))\r\n            ).\r\n            multiplyByScalar(\r\n                this.x.isNegative() ? -1 : 1\r\n            )\r\n    }\r\n\r\n    angle = (V: Vector, sharp?: boolean, radian?: boolean): number => {\r\n\r\n        let scalar = this.dot(V).value\r\n        if (sharp) {\r\n            scalar = Math.abs(scalar)\r\n        }\r\n\r\n        const toDegree = radian ? 1 : 180 / Math.PI\r\n\r\n        return toDegree * Math.acos(scalar / (this.norm * V.norm))\r\n    }\r\n\r\n\r\n    fromString = (value: string): this => {\r\n        // Remove the first letter if it's a parenthesis.\r\n        if (value.startsWith('(')) {\r\n            value = value.substring(1)\r\n        }\r\n\r\n        // Remove the last letter if it's a parenthesis.\r\n        if (value.endsWith(')')) {\r\n            value = value.substring(0, value.length - 1)\r\n        }\r\n\r\n        // Split comma, semi colon or single space.\r\n        const components = value.split(/[,;\\s]/g)\r\n            .filter((v) => v.trim() !== '')\r\n\r\n        // there must be at least two components.\r\n        if (components.length < 2) {\r\n            return this\r\n        }\r\n\r\n        // Validate the fraction values.\r\n        this.#array = components.map(x => new Fraction(x))\r\n        return this\r\n    }\r\n\r\n    distanceTo(item: Vector): { value: number, fraction: Fraction, tex: string } {\r\n        const V = new Vector(this, item)\r\n\r\n        return {\r\n            value: V.norm,\r\n            fraction: V.normSquare,\r\n            tex: V.tex\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Random helpers\r\n */\r\nimport { Numeric } from \"../numeric\"\r\n\r\n\r\n/**\r\n * Random boolean with a percent ratio\r\n * @param percent\r\n */\r\nexport function randomBool(percent = 0.5): boolean {\r\n    return Math.random() < percent\r\n}\r\n\r\n/**\r\n * Random integer between two values.\r\n * @param a (number) : From this value to the second value. If the second is ommited, this value is the max value.\r\n * @param b (number) : To this value. If this is ommited.\r\n */\r\nexport function randomInt(a: number, b?: number, exclude?: number[]): number {\r\n    if (b === undefined) {\r\n        if (a >= 0) {\r\n            return randomInt(0, a)\r\n        } else {\r\n            return randomInt(a, 0)\r\n        }\r\n    }\r\n\r\n    // Same start and end values\r\n    if (a === b) {\r\n        return a\r\n    }\r\n\r\n    // No exclusion\r\n    if (exclude === undefined) {\r\n        return Math.floor(Math.random() * (b - a + 1) + a)\r\n    }\r\n\r\n    // With exclusion\r\n    if (Math.abs(b - a) <= exclude.length) {\r\n        throw new Error('The number of excluded values is too high.')\r\n    }\r\n\r\n    let r = randomInt(a, b)\r\n    while (exclude.includes(r)) {\r\n        r = randomInt(a, b)\r\n    }\r\n    return r\r\n}\r\n\r\n/**\r\n * Random integer between -max and max value.\r\n * @param max (number) : determine the limits.\r\n * @param zero (bool) : determine if zero is allowed or not.\r\n */\r\nexport function randomIntSym(max: number, zero?: boolean): number {\r\n    if (zero === false) {\r\n        return randomBool() ? randomInt(1, max) : -randomInt(1, max)\r\n    } else {\r\n        return randomInt(-max, max)\r\n    }\r\n}\r\n\r\nexport function randomPrime(max?: number): number {\r\n    let primes = Numeric.primes()\r\n    if (max !== undefined) {\r\n        primes = primes.filter(x => x < max)\r\n    }\r\n    return randomItem(primes)\r\n}\r\n\r\nexport function randomArray<T>(arr: T[], number?: number): T[] {\r\n    if (number === undefined) {\r\n        number = 1\r\n    }\r\n\r\n    // Return a clone array\r\n    if (arr.length <= 0) {\r\n        return Object.values(arr)\r\n    }\r\n\r\n    // Randomize the array and return the n first elements.\r\n    return shuffleArray(arr).slice(0, number)\r\n}\r\n\r\nexport function randomItem<T>(arr: T[]): T {\r\n    if (arr.length === 0) { return null as T }\r\n    return arr[randomInt(0, arr.length - 1)]\r\n}\r\n\r\nexport function shuffleArray<T>(arr: T[]): T[] {\r\n    // The Fisher-Yates algorithm\r\n    const shuffleArray = Object.values(arr)\r\n    for (let i = shuffleArray.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1))\r\n        const temp = shuffleArray[i]\r\n        shuffleArray[i] = shuffleArray[j]\r\n        shuffleArray[j] = temp\r\n    }\r\n\r\n    return shuffleArray\r\n}\r\n","/**\r\n * Vector2D module contains everything necessary to handle 2d vectors.\r\n * @module Point\r\n */\r\n\r\nimport { Fraction } from \"../coefficients/fraction\"\r\nimport type { InputValue } from \"../pimath.interface\"\r\nimport { Vector } from \"./vector\"\r\n\r\nexport class Point extends Vector {\r\n\r\n    constructor()\r\n    constructor(value: Vector)\r\n    constructor(start: Vector, end: Vector)\r\n    constructor(...values: InputValue<Fraction>[])\r\n    constructor(...values: Vector[] | InputValue<Fraction>[]) {\r\n        super()\r\n\r\n        // Initialize the vector\r\n        if (values.length > 0) {\r\n            this.parse(...values)\r\n        }\r\n    };\r\n\r\n    public override parse(...values: Vector[] | InputValue<Fraction>[]): this {\r\n        this.asPoint = true\r\n\r\n        if (values.length === 1) {\r\n            if (values[0] instanceof Vector) {\r\n                this.array = values[0].copy()\r\n                return this\r\n            }\r\n\r\n            if (typeof values[0] === 'string') {\r\n                this.fromString(values[0])\r\n                return this\r\n            }\r\n        }\r\n\r\n\r\n        if (values.length > 1) {\r\n            if (values.some(x => x instanceof Vector)) {\r\n                throw new Error('Creating a point with  multiple argument requires an input fraction')\r\n            }\r\n\r\n            const nbs: Fraction[] = values.map(x => new Fraction(x as InputValue<Fraction>))\r\n\r\n            if (nbs.some(x => x.isNaN())) {\r\n                throw new Error('The value is not a valid point sting (a,b): ' + values.join(','))\r\n            }\r\n\r\n            this.array = nbs\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n\r\n    public override clone(): Point {\r\n        const V = new Point()\r\n        V.array = this.copy()\r\n        V.asPoint = true\r\n        return V\r\n    }\r\n\r\n}\r\n","/**\r\n * This class works for 2d line in a plane.\r\n */\r\n\r\nimport { Numeric } from \"../numeric\"\r\nimport { Fraction } from \"../coefficients/fraction\"\r\nimport { Equation } from \"../algebra/equation\"\r\nimport { Polynom } from \"../algebra/polynom\"\r\nimport { Monom } from \"../algebra/monom\"\r\nimport { Vector } from \"./vector\"\r\nimport type { InputValue, IPiMathObject } from \"../pimath.interface\"\r\nimport { randomIntSym } from \"../randomization/rndHelpers\"\r\nimport { Point } from \"./point\"\r\n\r\nexport enum LinePropriety {\r\n    None = 'none',\r\n    Parallel = 'parallel',\r\n    Perpendicular = 'perpendicular',\r\n    Tangent = 'tangent'\r\n}\r\n\r\nexport interface LineConfig {\r\n    points?: Point[],\r\n    point?: Point,\r\n    direction?: Vector,\r\n    normal?: Vector\r\n}\r\n\r\nexport class Line implements IPiMathObject<Line> {\r\n    // A line is defined as the canonical form\r\n    static PERPENDICULAR = LinePropriety.Perpendicular\r\n    static PARALLEL = LinePropriety.Parallel\r\n    #reduceBeforeDisplay: boolean\r\n    // ax + by + c = 0\r\n    #a: Fraction\r\n    #b: Fraction\r\n    #c: Fraction\r\n    #OA: Vector\r\n    #d: Vector\r\n    #n: Vector\r\n\r\n    #outputMode: 'canonical' | 'equation' | 'mxh' | 'parametric' | 'system' = \"canonical\"\r\n\r\n    /**\r\n     * Value can be a mix of:\r\n     *\r\n     * @param values\r\n     */\r\n    constructor(...values: unknown[]) {\r\n        this.#a = new Fraction().zero()\r\n        this.#b = new Fraction().zero()\r\n        this.#c = new Fraction().zero()\r\n        this.#OA = new Vector()\r\n        this.#d = new Vector()\r\n        this.#n = new Vector()\r\n\r\n        this.#reduceBeforeDisplay = true\r\n\r\n        if (values.length > 0) {\r\n            this.parse(...values)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    get a(): Fraction {\r\n        return this.#a\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n\r\n    set a(value: Fraction) {\r\n        this.#a = value\r\n    }\r\n\r\n    get b(): Fraction {\r\n        return this.#b\r\n    }\r\n\r\n    set b(value: Fraction) {\r\n        this.#b = value\r\n    }\r\n\r\n    get c(): Fraction {\r\n        return this.#c\r\n    }\r\n\r\n    set c(value: Fraction) {\r\n        this.#c = value\r\n    }\r\n\r\n    get OA(): Vector {\r\n        return this.#OA\r\n    }\r\n\r\n    set OA(value: Vector) {\r\n        this.#OA = value\r\n    }\r\n\r\n    get d(): Vector {\r\n        return this.#d\r\n    }\r\n\r\n    set d(value: Vector) {\r\n        this.#d = value\r\n    }\r\n\r\n    get n(): Vector {\r\n        return this.#n\r\n    }\r\n\r\n    // ------------------------------------------\r\n    getEquation(): Equation {\r\n        const equ = new Equation(new Polynom().parse('xy', this.#a, this.#b, this.#c), new Polynom('0'))\r\n        if (this.#reduceBeforeDisplay) {\r\n            return equ.simplify()\r\n        } else {\r\n            return equ\r\n        }\r\n    }\r\n\r\n    // get system(): { x: Equation, y: Equation } {\r\n    //     const e1 = new Equation(\r\n    //         new Polynom('x'),\r\n    //         new Polynom(this.#OA.x)\r\n    //             .add(new Monom('k').multiply(this.#d.x))\r\n    //     ),\r\n    //         e2 = new Equation(\r\n    //             new Polynom('y'),\r\n    //             new Polynom(this.#OA.y)\r\n    //                 .add(new Monom('k').multiply(this.#d.y))\r\n    //         )\r\n\r\n    //     return { x: e1, y: e2 }\r\n    // }\r\n\r\n    get canonical(): this {\r\n        this.#outputMode = 'canonical'\r\n        return this\r\n    }\r\n    get equation(): this {\r\n        this.#outputMode = 'equation'\r\n        return this\r\n    }\r\n    get mxh(): this {\r\n        this.#outputMode = 'mxh'\r\n        return this\r\n    }\r\n    get parametric(): this {\r\n        this.#outputMode = 'parametric'\r\n        return this\r\n    }\r\n    get system(): this {\r\n        this.#outputMode = 'system'\r\n        return this\r\n    }\r\n\r\n    get tex(): string {\r\n        // canonical    =>  ax + by + c = 0\r\n        // mxh          =>  y = -a/b x - c/b\r\n        // parametric   =>  (xy) = OA + k*d\r\n        // equation     => ax + by = -c\r\n        const output = this.#outputMode\r\n        this.#outputMode = 'canonical'\r\n        switch (output) {\r\n            case 'equation':\r\n                return this.getEquation().reorder().tex\r\n            case 'mxh':\r\n                return this.slope.isInfinity() ?\r\n                    'x=' + this.OA.x.tex :\r\n                    'y=' + new Polynom().parse('x', this.slope, this.height).tex\r\n            case 'parametric':\r\n            case 'system': {\r\n                const d = this.#d.clone()\r\n                if (this.#reduceBeforeDisplay) {\r\n                    d.simplify()\r\n                }\r\n\r\n                if (output === 'parametric') {\r\n                    return `${Vector.asTex('x', 'y')} = ${Vector.asTex(this.#OA.x.tex, this.#OA.y.tex)} + k\\\\cdot ${Vector.asTex(d.x.tex, d.y.tex)}`\r\n                } else {\r\n                    return `\\\\left\\\\{\\\\begin{aligned}\r\n            x &= ${(new Polynom(this.#OA.x)\r\n                            .add(new Monom(this.#d.x).multiply(new Monom('k'))))\r\n                            .reorder('k', true)\r\n                            .tex}\\\\\\\\ \r\n            y &= ${(new Polynom(this.#OA.y)\r\n                            .add(new Monom(this.#d.y).multiply(new Monom('k'))))\r\n                            .reorder('k', true)\r\n                            .tex}\r\n            \\\\end{aligned}\\\\right.`\r\n                }\r\n            }\r\n            default:\r\n                {\r\n                    const canonical = this.getEquation()\r\n                    if (this.#a.isNegative()) {\r\n                        canonical.multiply(-1)\r\n                    }\r\n                    return canonical.tex\r\n                }\r\n        }\r\n\r\n    }\r\n\r\n    get reduceBeforeDisplay(): boolean {\r\n        return this.#reduceBeforeDisplay\r\n    }\r\n\r\n    set reduceBeforeDisplay(value: boolean) {\r\n        this.#reduceBeforeDisplay = value\r\n    }\r\n\r\n    get display(): string {\r\n        // canonical    =>  ax + by + c = 0\r\n        // mxh          =>  y = -a/b x - c/b\r\n        // parametric   =>  (xy) = OA + k*d // not relevant in display mode.\r\n        const output = this.#outputMode\r\n        this.#outputMode = 'canonical'\r\n\r\n        switch (output) {\r\n            case 'equation':\r\n                return this.getEquation().reorder().display\r\n            case 'mxh':\r\n                return this.slope.isInfinity() ?\r\n                    'x=' + this.OA.x.display :\r\n                    'y=' + new Polynom().parse('x', this.slope, this.height).display\r\n            case 'parametric': {\r\n                const d = this.#d.clone()\r\n                if (this.#reduceBeforeDisplay) {\r\n                    d.simplify()\r\n                }\r\n\r\n                return `((x,y))=((${this.#OA.x.display},${this.#OA.y.display}))+k((${d.x.display},${d.y.display}))`\r\n            }\r\n            default: {\r\n                const canonical = this.getEquation()\r\n                // Make sur the first item is positive.\r\n                if (this.#a.isNegative()) {\r\n                    canonical.multiply(-1)\r\n                }\r\n                return canonical.display\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    get normal(): Vector {\r\n        return new Vector(this.#a, this.#b)\r\n    }\r\n\r\n    get director(): Vector {\r\n        return this.#d.clone()\r\n    }\r\n\r\n    get slope(): Fraction {\r\n        return this.#a.clone().opposite().divide(this.#b)\r\n    }\r\n\r\n    get height(): Fraction {\r\n        return this.#c.clone().opposite().divide(this.#b)\r\n    }\r\n\r\n    randomPoint = (k?: number): Point => {\r\n        // Return a random point on the line.\r\n        const pt = this.#d\r\n            .clone()\r\n            .multiplyByScalar(randomIntSym((k === undefined || k <= 1) ? 3 : k, false))\r\n            .add(this.#OA)\r\n\r\n        pt.asPoint = true\r\n\r\n        return pt\r\n    }\r\n\r\n    randomNearPoint = (k?: number): Point => {\r\n        const pt = this.randomPoint(k)\r\n\r\n        let maxIterationTest = 10\r\n        while (this.isOnLine(pt) && maxIterationTest > 0) {\r\n            pt.x.add(randomIntSym(1, false))\r\n            pt.y.add(randomIntSym(1, false))\r\n            maxIterationTest--\r\n\r\n        }\r\n\r\n        return pt\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse data to a line\r\n     * @param {any} values\r\n     * @returns {Line}\r\n     */\r\n    parse = (...values: unknown[]): this => {\r\n        // Nothing is given...\r\n        if (values.length === 0) {\r\n            return this\r\n        }\r\n\r\n        // One value only: already a line (clone it), an Equation, a string (as Equation)\r\n        if (values.length === 1) {\r\n            if (values[0] instanceof Line) {\r\n                // Already a Line\r\n                return this.fromCoefficient(values[0].a, values[0].b, values[0].c)\r\n            } else if (values[0] instanceof Equation) {\r\n                // It's an Equation\r\n                return this.fromEquation(values[0])\r\n            } else if (typeof values[0] === \"string\") {\r\n                // It's a string - create an Equation from it.\r\n                try {\r\n                    const E = new Equation(values[0])\r\n                    return this.parse(E)\r\n                } catch (e) {\r\n                    return this\r\n                }\r\n            }\r\n        }\r\n\r\n        // Two values are given: two vectors\r\n        if (values.length === 2 && values.every(x=>x instanceof Vector)) {\r\n            const formattedValues: Vector[] = values as Vector[]\r\n\r\n            if (formattedValues[0].asPoint && formattedValues[1].asPoint) {\r\n                // Two points\r\n                return this.fromPointAndDirection(formattedValues[0], new Vector(formattedValues[0], formattedValues[1]))\r\n            }\r\n\r\n            if (formattedValues[0].asPoint && !formattedValues[1].asPoint) {\r\n                // One point and one vector director\r\n                return this.fromPointAndDirection(formattedValues[0], formattedValues[1])\r\n            }\r\n\r\n        }\r\n\r\n        if (values.length === 3) {\r\n            if (values[0] instanceof Vector && values[1] instanceof Vector) {\r\n                if (values[2] === LinePropriety.Perpendicular) {\r\n                    return this.fromPointAndNormal(values[0], values[1])\r\n                } else if (values[2] === LinePropriety.Parallel) {\r\n                    return this.fromPointAndDirection(values[0], values[1])\r\n                }\r\n            }\r\n\r\n            if (values[0] instanceof Vector && values[1] instanceof Line) {\r\n                if (values[2] === LinePropriety.Parallel || values[2] === null) {\r\n                    return this.fromPointAndLine(values[0], values[1], LinePropriety.Parallel)\r\n                } else {\r\n                    return this.fromPointAndLine(values[0], values[1], LinePropriety.Perpendicular)\r\n                }\r\n            }\r\n\r\n            return this.fromCoefficient(\r\n                values[0] as InputValue<Fraction>,\r\n                values[1] as InputValue<Fraction>,\r\n                values[2] as InputValue<Fraction>\r\n            )\r\n        }\r\n\r\n        console.log('Something wrong happened while creating the line')\r\n        console.log(values)\r\n        return this\r\n    }\r\n\r\n    fromPoints(pt1: Point, pt2: Point){\r\n        return this.fromPointAndDirection(pt1, new Vector(pt1, pt2))\r\n    }\r\n    fromEquation = (equ: Equation): this => {\r\n        // Reorder the eequation\r\n        equ.reorder(true)\r\n\r\n        // It must contain either x, y or both.\r\n        const letters = new Set(equ.letters())\r\n\r\n        // No 'x', no 'y' in the equations\r\n        if (!(letters.has('x') || letters.has('y'))) {\r\n            return this\r\n        }\r\n\r\n        // Another letter in the equation ?\r\n        for (const elem of ['x', 'y']) {\r\n            if (letters.has(elem)) {\r\n                letters.delete(elem)\r\n            }\r\n        }\r\n\r\n        if (letters.size > 0) {\r\n            return this\r\n        }\r\n\r\n        // Everything should be ok now...\r\n        return this.fromCoefficient(\r\n            equ.left.monomByLetter('x').coefficient,\r\n            equ.left.monomByLetter('y').coefficient,\r\n            equ.left.monomByDegree(0).coefficient\r\n        )\r\n    }\r\n    fromCoefficient = (a: InputValue<Fraction>, b: InputValue<Fraction>, c: InputValue<Fraction>): this => {\r\n        this.#a = new Fraction(a)\r\n        this.#b = new Fraction(b)\r\n        this.#c = new Fraction(c)\r\n\r\n        this.#d = new Vector(this.#b.clone(), this.#a.clone().opposite())\r\n        this.#OA = new Vector(new Fraction().zero(), this.#c.clone())\r\n        this.#n = this.#d.clone().normal()\r\n\r\n        return this\r\n    }\r\n\r\n    fromPointAndDirection = (P: Point, d: Vector): this => {\r\n        // OX = OP + k*d\r\n        // x = px + kdx     * dy\r\n        // y = py + kdy     * dx\r\n        // ------------------\r\n        // dy * x = px * dy + kdxdy\r\n        // dx * y = py * dx + kdxdy\r\n        // ------------------\r\n        // dy * x - dx * y = px * dy - py * dx\r\n        // dy * x - dx * y - (px * dy - py * dx) = 0\r\n        this.fromCoefficient(\r\n            d.y,\r\n            d.x.clone().opposite(),\r\n            P.x.clone().multiply(d.y).subtract(P.y.clone().multiply(d.x)).opposite()\r\n        )\r\n\r\n        // Choose the current values as point and direction vector instead of the automatic version.\r\n        this.#OA = P.clone()\r\n        this.#d = d.clone()\r\n        this.#n = this.#d.clone().normal()\r\n\r\n        return this\r\n    }\r\n\r\n    fromPointAndNormal = (P: Point, n: Vector): this => {\r\n        return this.fromCoefficient(\r\n            n.x,\r\n            n.y,\r\n            P.x.clone().multiply(n.x)\r\n                .add(P.y.clone().multiply(n.y)).opposite()\r\n        )\r\n    }\r\n\r\n    fromPointAndLine = (P: Vector, L: Line, orientation?: LinePropriety): this => {\r\n\r\n        if (orientation === undefined) {\r\n            orientation = LinePropriety.Parallel\r\n        }\r\n\r\n        if (orientation === LinePropriety.Parallel) {\r\n            return this.fromPointAndNormal(P, L.normal)\r\n        } else if (orientation === LinePropriety.Perpendicular) {\r\n            return this.fromPointAndNormal(P, L.director)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    clone = (): this => {\r\n        this.#a = this.#a.clone()\r\n        this.#b = this.#b.clone()\r\n        this.#c = this.#c.clone()\r\n\r\n        this.#d = this.#d.clone()\r\n        this.#OA = this.#OA.clone()\r\n        this.#n = this.#n.clone()\r\n\r\n        return this\r\n    }\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    isOnLine = (pt: Vector): boolean => {\r\n        return this.#a.clone()\r\n            .multiply(pt.x)\r\n            .add(\r\n                this.#b.clone()\r\n                    .multiply(pt.y)\r\n            )\r\n            .add(this.#c)\r\n            .isZero()\r\n    }\r\n\r\n    isParallelTo = (line: Line): boolean => {\r\n        // Do they have the isSame direction ?\r\n        return this.slope.isEqual(line.slope) && this.height.isNotEqual(line.height)\r\n    }\r\n    isSameAs = (line: Line): boolean => {\r\n        return this.slope.isEqual(line.slope) && this.height.isEqual(line.height)\r\n    }\r\n    isPerpendicularTo = (line: Line): boolean => {\r\n        return this.d.isNormalTo(line.d)\r\n    }\r\n    isVertical = (): boolean => {\r\n        return this.slope.isInfinity()\r\n    }\r\n    simplify = (): this => {\r\n        const lcm = Numeric.lcm(this.#a.denominator, this.#b.denominator, this.#c.denominator),\r\n            gcd = Numeric.gcd(this.#a.numerator, this.#b.numerator, this.#c.numerator)\r\n\r\n        this.fromCoefficient(\r\n            this.#a.clone().multiply(lcm).divide(gcd),\r\n            this.#b.clone().multiply(lcm).divide(gcd),\r\n            this.#c.clone().multiply(lcm).divide(gcd),\r\n        )\r\n\r\n        return this\r\n    }\r\n\r\n    simplifyDirection = (): this => {\r\n        this.#d.simplify()\r\n        return this\r\n    }\r\n    intersection = (line: Line): { point: Point, hasIntersection: boolean, isParallel: boolean, isSame: boolean } => {\r\n        const Pt = new Point()\r\n        let isParallel = false, isSame = false\r\n\r\n        // this         => ax+by+c = 0\r\n        // line         => dx+ey+f = 0\r\n        //\r\n        //  aex + bey + ce = 0\r\n        //  dbx + bey + bf = 0\r\n        // (ae-db)x + ce-bf = 0\r\n        //\r\n        //  adx + bdy + cd = 0\r\n        //  adx + aey + af = 0\r\n        // (bd-ae)y + (cd-af)\r\n        //\r\n        // x = (bf-ce)/(ae-db)\r\n        // y = (af-cd)/(bd-ae)\r\n\r\n\r\n        // Theres is no 'y'\r\n        if (this.#b.isZero() || line.b.isZero()) {\r\n            // TODO : handle no y in the line canonical form\r\n        }\r\n\r\n        if (this.isParallelTo(line)) {\r\n            Pt.x = new Fraction().invalid()\r\n            Pt.y = new Fraction().invalid()\r\n            isParallel = true\r\n        } else if (this.isSameAs(line)) {\r\n            Pt.x = new Fraction().invalid()\r\n            Pt.y = new Fraction().invalid()\r\n            isSame = true\r\n        } else {\r\n            Pt.x = this.#b.clone().multiply(line.c).subtract(this.#c.clone().multiply(line.b))\r\n                .divide(this.#a.clone().multiply(line.b).subtract(this.#b.clone().multiply(line.a)))\r\n            Pt.y = this.#a.clone().multiply(line.c).subtract(this.#c.clone().multiply(line.a))\r\n                .divide(this.#b.clone().multiply(line.a).subtract(this.#a.clone().multiply(line.b)))\r\n        }\r\n\r\n        return {\r\n            point: Pt,\r\n            hasIntersection: !(isParallel || isSame),\r\n            isParallel,\r\n            isSame\r\n        }\r\n    }\r\n\r\n    distanceTo(pt: Point): { value: number, fraction: Fraction, tex: string } {\r\n        const numerator = pt.x.clone().multiply(this.#a)\r\n            .add(pt.y.clone().multiply(this.#b))\r\n            .add(this.#c).abs(),\r\n            d2 = this.normal.normSquare\r\n\r\n        // The denominator is null - shouldn't be possible\r\n        if (d2.isZero()) {\r\n            return {\r\n                value: NaN,\r\n                tex: 'Not a line',\r\n                fraction: new Fraction().infinite()\r\n            }\r\n        }\r\n        // The denominator is a perfect square - simplify the tex result\r\n        const value = numerator.value / Math.sqrt(d2.value),\r\n            F = numerator.clone().divide(d2.clone().sqrt())\r\n\r\n        // The denominator is a perfect square.\r\n        if (d2.isSquare()) {\r\n            return {\r\n                value,\r\n                tex: F.tex,\r\n                fraction: F\r\n            }\r\n        }\r\n        // Complete answer...\r\n        return {\r\n            value,\r\n            tex: `\\\\frac{${numerator.tex}}{\\\\sqrt{${d2.tex}}}`,\r\n            fraction: F\r\n        }\r\n    }\r\n\r\n    hitSegment(A: Point, B: Point): boolean {\r\n        const iPt = this.intersection(\r\n            new Line().fromPoints(A, B)\r\n        )\r\n\r\n        // There is an intersection point\r\n        if (iPt.hasIntersection) {\r\n            return iPt.point.x.value >= Math.min(A.x.value, B.x.value)\r\n                && iPt.point.x.value <= Math.max(A.x.value, B.x.value)\r\n                && iPt.point.y.value >= Math.min(A.y.value, B.y.value)\r\n                && iPt.point.y.value <= Math.max(A.y.value, B.y.value)\r\n        }\r\n        return false\r\n    }\r\n\r\n    getValueAtX = (value: Fraction | number): Fraction => {\r\n        const equ = this.getEquation().isolate('y'),\r\n            F = new Fraction(value)\r\n\r\n        if (equ instanceof Equation) {\r\n            return equ.right.evaluate({ x: F }) as Fraction\r\n        }\r\n        return new Fraction().invalid()\r\n    }\r\n\r\n    getValueAtY = (value: Fraction | number): Fraction => {\r\n        const equ = this.getEquation().isolate('x'),\r\n            F = new Fraction(value)\r\n\r\n        if (equ instanceof Equation) {\r\n            return equ.right.evaluate({ y: F }) as Fraction\r\n        }\r\n\r\n        return new Fraction().invalid()\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Special functions\r\n    // ------------------------------------------\r\n    canonicalAsFloatCoefficient(decimals?: number): string {\r\n        if (decimals === undefined) {\r\n            decimals = 2\r\n        }\r\n\r\n        let canonical = ''\r\n\r\n        if (!this.#a.isZero()) {\r\n            if (this.#a.isOne()) {\r\n                canonical = 'x'\r\n            } else if (this.#a.clone().opposite().isOne()) {\r\n                canonical = '-x'\r\n            } else {\r\n                canonical = this.#a.value.toFixed(decimals) + 'x'\r\n            }\r\n        }\r\n\r\n        if (!this.#b.isZero()) {\r\n            if (this.#b.isPositive()) {\r\n                canonical += '+'\r\n            }\r\n            canonical += this.#b.value.toFixed(decimals) + 'y'\r\n        }\r\n\r\n        if (!this.#c.isZero()) {\r\n            if (this.#c.isPositive()) {\r\n                canonical += '+'\r\n            }\r\n            canonical += this.#c.value.toFixed(decimals)\r\n        }\r\n\r\n\r\n        return canonical + '=0'\r\n    }\r\n}","import { Line, LinePropriety } from \"./line\"\r\nimport { Vector } from \"./vector\"\r\nimport { Numeric } from \"../numeric\"\r\nimport { Fraction } from \"../coefficients/fraction\"\r\nimport { Equation } from \"../algebra/equation\"\r\nimport { Polynom } from \"../algebra/polynom\"\r\nimport { Monom } from \"../algebra/monom\"\r\nimport type { IPiMathObject } from \"../pimath.interface\"\r\nimport { Point } from \"./point\"\r\n\r\nexport class Circle\r\n    implements\r\n    IPiMathObject<Circle> {\r\n    #center: Point | undefined = undefined\r\n    #squareRadius: Fraction | undefined = undefined\r\n    #cartesian: Equation | undefined = undefined\r\n\r\n    constructor()\r\n    constructor(equation: string | Equation)\r\n    constructor(circle: Circle)\r\n    constructor(center: Point, radius: Fraction | number, square?: boolean)\r\n    constructor(center: Point, pointThrough: Point)\r\n    constructor(A: Point, B: Point, C: Point)\r\n    constructor(...values: unknown[]) {\r\n        if (values.length > 0) {\r\n            this.parse(...values)\r\n        }\r\n    }\r\n\r\n    get center(): Point {\r\n        return this.#center ?? new Point()\r\n    }\r\n\r\n    get squareRadius(): Fraction {\r\n        return this.#squareRadius ?? new Fraction(0)\r\n    }\r\n\r\n    get cartesian(): Equation {\r\n        if (this.#cartesian === undefined) { throw new Error('Cartesian equation not defined') }\r\n\r\n        return this.#cartesian\r\n    }\r\n\r\n    get radius(): { tex: string, display: string, value: number } {\r\n        if (this.#squareRadius === undefined) { return { tex: '', display: '', value: 0 } }\r\n        if (this.#squareRadius.isSquare()) {\r\n            return {\r\n                tex: this.#squareRadius.clone().sqrt().tex,\r\n                display: this.#squareRadius.clone().sqrt().display,\r\n                value: this.#squareRadius.clone().sqrt().value\r\n            }\r\n        } else {\r\n            return {\r\n                tex: `\\\\sqrt{${this.#squareRadius.tex}}`,\r\n                display: `sqrt(${this.#squareRadius.display})`,\r\n                value: this.#squareRadius.clone().sqrt().value\r\n            }\r\n        }\r\n    }\r\n\r\n    get tex(): string {\r\n\r\n        let cx, cy\r\n        if (this.center.x.isZero()) {\r\n            cx = 'x^2'\r\n        } else {\r\n            cx = `\\\\left(x${this.center.x.isNegative() ? '+' : '-'}${this.center.x.clone().abs().tex}\\\\right)^2`\r\n        }\r\n        if (this.center.y.isZero()) {\r\n            cy = 'y^2'\r\n        } else {\r\n            cy = `\\\\left(y${this.center.y.isNegative() ? '+' : '-'}${this.center.y.clone().abs().tex}\\\\right)^2`\r\n        }\r\n        return `${cx}+${cy}=${this.squareRadius.tex}`\r\n    }\r\n\r\n    get developed(): string {\r\n        return this.cartesian.tex\r\n    }\r\n\r\n    get display(): string {\r\n        let cx, cy\r\n        if (this.center.x.isZero()) {\r\n            cx = 'x^2'\r\n        } else {\r\n            cx = `(x${this.center.x.isNegative() ? '+' : '-'}${this.center.x.clone().abs().tex})^2`\r\n        }\r\n        if (this.center.y.isZero()) {\r\n            cy = 'y^2'\r\n        } else {\r\n            cy = `(y${this.center.y.isNegative() ? '+' : '-'}${this.center.y.clone().abs().tex})^2`\r\n        }\r\n        return `${cx}+${cy}=${this.squareRadius.display}`\r\n    }\r\n\r\n    /**\r\n     * Get the relative position between circle and line. It corresponds to the number of intersection.\r\n     * @param {Line} L\r\n     * @returns {number}\r\n     */\r\n    relativePosition = (L: Line): number => {\r\n        if (this.#center === undefined || this.#squareRadius === undefined) { throw new Error('Circle not defined') }\r\n\r\n        const distance = L.distanceTo(this.#center), radius = Math.sqrt(this.#squareRadius.value)\r\n\r\n        if (distance.value - radius > 0.0000000001) {\r\n            return 0 // external\r\n        } else if (Math.abs(distance.value - radius) < 0.0000000001) {\r\n            return 1 // tangent\r\n        } else {\r\n            return 2 // external\r\n        }\r\n    }\r\n\r\n    lineIntersection = (L: Line): Point[] => {\r\n        const intersectionPoints: Point[] = []\r\n        // let solX: Fraction\r\n\r\n        if (this.#cartesian === undefined) { return [] }\r\n        const equX = this.#cartesian.clone(), lineX = L.getEquation().clone().isolate('x'),\r\n            lineY = L.getEquation().clone().isolate('y')\r\n\r\n        if (lineX instanceof Equation && lineY instanceof Equation) {\r\n            equX.replaceBy('y', lineY.right).simplify()\r\n            equX.solve()\r\n\r\n            // TODO: rework the solutions of an equation.\r\n            // for (const x of equX.solutions) {\r\n            //     if (x.exact === false && isNaN(x.value)) {\r\n            //         continue\r\n            //     }\r\n\r\n            //     solX = new Fraction(x.exact === false ? x.value : x.exact)\r\n            //     intersectionPoints.push(new Point(solX.clone(), lineY.right.evaluate(solX)))\r\n            // }\r\n        }\r\n\r\n        return intersectionPoints\r\n    }\r\n\r\n    tangents = (P: Point | Fraction): Line[] => {\r\n        if (P instanceof Fraction) {\r\n            return this.#tangentsWithSlope(P)\r\n        } else if (this.isPointOnCircle(P)) {\r\n            return this.#tangentsThroughOnePointOnTheCircle(P)\r\n        } else if (this.#center !== undefined && this.#center.distanceTo(P).value > this.radius.value) {\r\n            //TODO:  Must check it's outside the circle\r\n            return this.#tangentsThroughOnePointOutsideTheCircle(P)\r\n        } else {\r\n            console.log('No tangents as the point is inside !')\r\n        }\r\n        return []\r\n    }\r\n\r\n    isPointOnCircle = (P: Point): boolean => {\r\n        return this.#cartesian?.test({ x: P.x, y: P.y }) ?? false\r\n    }\r\n\r\n    getPointsOnCircle = (numberIsInteger?: boolean): Point[] => {\r\n        if (numberIsInteger === undefined) {\r\n            numberIsInteger = false\r\n        }\r\n\r\n        // It means searching for pythagorician triples that make a perfect square.\r\n        // (x-4)^2 + (y+3)^2 = 15\r\n\r\n        const triplets = Numeric.pythagoreanTripletsWithTarget(this.squareRadius.value, true)\r\n\r\n        const points: Point[] = []\r\n\r\n        triplets.forEach(triplet => {\r\n            // Allow positive / negative values\r\n            // x-a = t  => x = a + t\r\n            // x-a = -t => x = a - t\r\n\r\n            for (const k of [[1, 1], [-1, 1], [-1, -1], [1, -1]]) {\r\n                points.push(new Point(\r\n                    this.center.x.clone().add(k[0] * triplet[0]),\r\n                    this.center.y.clone().add(k[1] * triplet[1])\r\n                )\r\n                )\r\n                // Check if the point is not already in points.\r\n                // TODO: isInListOfPoints not implemented\r\n                // if (!pt.isInListOfPoints(points)) {\r\n                //     points.push(pt)\r\n                // }\r\n            }\r\n        })\r\n        return points\r\n    }\r\n\r\n    clone(): Circle {\r\n        return new Circle(\r\n            this.center.clone(),\r\n            this.squareRadius.clone(),\r\n            true\r\n        )\r\n        // this.#center = this.center.clone()\r\n        // this.#squareRadius = this.squareRadius.clone()\r\n        // this._calculateCartesian()\r\n        // return this\r\n    }\r\n\r\n    setRadius(radius: Fraction | number, square?: boolean): this {\r\n        if (square) {\r\n            this.#squareRadius = new Fraction(radius)\r\n        } else {\r\n            this.#squareRadius = new Fraction(radius).pow(2)\r\n        }\r\n        this.#calculateCartesian()\r\n        return this\r\n    }\r\n\r\n    #tangentsThroughOnePointOnTheCircle = (P: Point): Line[] => {\r\n        const CT = new Vector(this.center, P)\r\n        return [new Line(P, CT, LinePropriety.Perpendicular)]\r\n    }\r\n\r\n    #tangentsThroughOnePointOutsideTheCircle = (P: Point): Line[] => {\r\n        // y = mx + h\r\n        // px, py => h = -m px + py => mx - y -m.px + py = 0 =>\r\n        // Centre: cx, cy, radius: r\r\n        // (m.cx - cy -m.px + py)^2 = r^2  * (m^2  + 1)\r\n        // (m(cx-py) - (cy - py))^2 = r^2  * (m^2  + 1)\r\n\r\n        const cx_px = this.center.x.clone().subtract(P.x), cy_py = this.center.y.clone().subtract(P.y),\r\n            polyLeft = new Polynom('x'), polyRight = new Polynom('x^2+1')\r\n\r\n        polyLeft.multiply(cx_px).subtract(cy_py).pow(2)\r\n        polyRight.multiply(this.squareRadius)\r\n\r\n        const equ = new Equation(polyLeft, polyRight)\r\n        const solutions = equ.solve()\r\n\r\n        return solutions.map(sol => {\r\n            //  h = -m px + py\r\n            let h: Fraction\r\n            const equ = new Equation('y', 'x')\r\n\r\n            if (sol.exact instanceof Fraction) {\r\n                h = P.x.clone().opposite().multiply(sol.exact).add(P.y)\r\n                equ.right.multiply(sol.exact).add(h)\r\n            } else {\r\n                h = P.x.clone().opposite().multiply(sol.value).add(P.y)\r\n                equ.right.multiply(sol.value).add(h)\r\n            }\r\n\r\n            return new Line(equ)\r\n        })\r\n\r\n    }\r\n\r\n    #tangentsWithSlope = (slope: Fraction): Line[] => {\r\n        // d(C;t)=r => ac1+bc2 + x = +- sqrt(a^2 + b^2)*r\r\n        // x = -ac1-bc2  +-  sqrt(a^2 + b^2)*r\r\n        // y = a/bx + h => ax-by + H = 0\r\n\r\n        const a = slope.numerator, b = -slope.denominator, c1 = this.center.x.clone(), c2 = this.center.y.clone()\r\n\r\n        const sq = this.squareRadius.clone().multiply(slope.numerator ** 2 + slope.denominator ** 2),\r\n            x1 = c1.clone().multiply(a).opposite().subtract(c2.clone().multiply(b)).add(sq.clone().sqrt()),\r\n            x2 = c1.clone().multiply(a).opposite().subtract(c2.clone().multiply(b)).subtract(sq.clone().sqrt())\r\n\r\n        return [new Line(a, b, x1), new Line(a, b, x2)]\r\n    }\r\n\r\n    #reset(): this {\r\n        this.#center = undefined\r\n        this.#squareRadius = undefined\r\n        this.#cartesian = undefined\r\n\r\n        return this\r\n    }\r\n\r\n    parse(...values: unknown[]): this {\r\n        // Data can be given in these formats:\r\n        // one value, a string -> make it an Equation\r\n        // one value, an Equation\r\n        // one value, a circle -> clone it\r\n        // two values: two points (center and pointThrough)\r\n        // two values: point and Fraction (center and radius)\r\n        // three values: Vector2D, Fraction, Boolean (center, square radius, true)\r\n\r\n        this.#reset()\r\n\r\n        if (typeof values[0] === 'string') {\r\n            this.#parseEquation(new Equation(values[0]))\r\n        } else if (values[0] instanceof Equation) {\r\n            this.#parseEquation(values[0])\r\n        } else if (values[0] instanceof Circle) {\r\n            this.#parseCopyCircle(values[0])\r\n        } else if (values[0] instanceof Point && values.length > 1) {\r\n            if (values[1] instanceof Point) {\r\n                if (values[2] instanceof Point) {\r\n                    // TODO: Add the method to parse through three points\r\n                    // this._parseThroughtThreePoints(values[0], values[1], values[2])\r\n                } else {\r\n                    this.#parseCenterAndPointThrough(values[0], values[1])\r\n                }\r\n            } else if (values[1] instanceof Fraction || typeof values[1] === 'number') {\r\n                this.#parseCenterAndRadius(values[0], values[1], (typeof values[2] === \"boolean\") ? values[2] : false)\r\n            }\r\n        }\r\n\r\n        // Calculate once the different values.\r\n        this.#calculateCartesian()\r\n\r\n\r\n        return this\r\n    }\r\n\r\n    #calculateCartesian() {\r\n        this.#cartesian = (\r\n            new Equation(\r\n                new Polynom(`(x-(${this.center.x.display}))^2+(y-(${this.center.y.display}))^2`),\r\n                new Polynom(this.squareRadius.display))\r\n        ).moveLeft()\r\n    }\r\n\r\n    #parseCopyCircle(circle: Circle): this {\r\n        this.#center = circle.center.clone()\r\n        this.#squareRadius = circle.squareRadius.clone()\r\n        this.#calculateCartesian()\r\n        return this\r\n    }\r\n\r\n    #parseCenterAndRadius(center: Point, radius: Fraction | number, square?: boolean): this {\r\n        this.#center = center.clone()\r\n        if (square) {\r\n            this.#squareRadius = (new Fraction(radius))\r\n        } else {\r\n            this.#squareRadius = new Fraction(radius).pow(2)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    #parseCenterAndPointThrough(center: Point, pointThrough: Point): this {\r\n        this.#center = center.clone()\r\n        this.#squareRadius = new Vector(this.#center, pointThrough).normSquare\r\n        return this\r\n    }\r\n\r\n    #parseEquation(equ: Equation): this {\r\n\r\n        // Move everything to the left.\r\n        equ.moveLeft()\r\n\r\n        if (equ.degree('x').value === 2 && equ.degree('y').value === 2) {\r\n            // Both must be of degree 2.\r\n            const x2 = equ.left.monomByDegree(2, 'x'), y2 = equ.left.monomByDegree(2, 'y')\r\n            let x1: Monom, y1: Monom, c: Monom\r\n\r\n            // Both square monoms must have the same coefficient.\r\n            if (x2.coefficient.isEqual(y2.coefficient)) {\r\n                equ.divide(x2.coefficient)\r\n\r\n                x1 = equ.left.monomByDegree(1, 'x')\r\n                y1 = equ.left.monomByDegree(1, 'y')\r\n\r\n                c = equ.left.monomByDegree(0)\r\n\r\n                this.#center = new Point(x1.coefficient.clone().divide(2).opposite(), y1.coefficient.clone().divide(2).opposite())\r\n\r\n                this.#squareRadius = c.coefficient.clone().opposite()\r\n                    .add(this.#center.x.clone().pow(2))\r\n                    .add(this.#center.y.clone().pow(2))\r\n\r\n            } else {\r\n                // The circle is not a valid circle\r\n                this.#center = undefined\r\n                this.#squareRadius = undefined\r\n            }\r\n        }\r\n        return this\r\n    }\r\n\r\n    // private _parseThroughtThreePoints(A: Point, B: Point, C: Point): this {\r\n    //     const T = new Triangle(A, B, C), mAB = T.remarquables.mediators.AB.clone(),\r\n    //         mAC = T.remarquables.mediators.AC.clone()\r\n    //     this.parse(mAB.intersection(mAC).point, A)\r\n\r\n    //     return this\r\n    // }\r\n\r\n}","import { Fraction } from \"../coefficients/fraction\"\r\nimport { Line } from \"./line\"\r\nimport { Vector } from \"./vector\"\r\nimport { Point } from \"./point\"\r\n\r\nexport interface remarquableLines {\r\n    'medians': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Vector | null\r\n    },\r\n    'mediators': {\r\n        'AB': Line,\r\n        'AC': Line,\r\n        'BC': Line,\r\n        'intersection': Vector | null\r\n    },\r\n    'heights': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Vector | null\r\n    },\r\n    'bisectors': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Vector | null\r\n    },\r\n    externalBisectors: {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Vector | null\r\n    }\r\n}\r\n\r\nexport class Triangle {\r\n    #A: Point = new Point()\r\n    #B: Point = new Point()\r\n    #C: Point = new Point()\r\n    #lines: { 'AB': Line, 'AC': Line, 'BC': Line } = {\r\n        'AB': new Line(),\r\n        'AC': new Line(),\r\n        'BC': new Line()\r\n    }\r\n    #middles: { 'AB': Point, 'AC': Point, 'BC': Point } = {\r\n        'AB': new Point(),\r\n        'AC': new Point(),\r\n        'BC': new Point()\r\n    }\r\n    #remarquables: remarquableLines | null = null\r\n\r\n    constructor(...values: unknown[]) {\r\n\r\n        if (values.length > 0) {\r\n            this.parse(...values)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setters\r\n    // ------------------------------------------\r\n\r\n    get A(): Point {\r\n        return this.#A\r\n    }\r\n\r\n    get B(): Point {\r\n        return this.#B\r\n    }\r\n\r\n    get C(): Point {\r\n        return this.#C\r\n    }\r\n\r\n    get AB(): Vector {\r\n        return this.#getSegment('A', 'B')\r\n    }\r\n\r\n    get BA(): Vector {\r\n        return this.#getSegment('B', 'A')\r\n    }\r\n\r\n    get BC(): Vector {\r\n        return this.#getSegment('B', 'C')\r\n    }\r\n\r\n    get CB(): Vector {\r\n        return this.#getSegment('C', 'B')\r\n    }\r\n\r\n    get AC(): Vector {\r\n        return this.#getSegment('A', 'C')\r\n    }\r\n\r\n    get CA(): Vector {\r\n        return this.#getSegment('C', 'A')\r\n    }\r\n\r\n    get isRectangle(): boolean {\r\n        if (this.AB.isNormalTo(this.BC)) {\r\n            return true\r\n        }\r\n        if (this.AB.isNormalTo(this.AC)) {\r\n            return true\r\n        }\r\n        if (this.BC.isNormalTo(this.AC)) {\r\n            return true\r\n        }\r\n\r\n        return false\r\n    }\r\n\r\n    get isEquilateral(): boolean {\r\n        return this.AB.normSquare.isEqual(this.BC.normSquare) &&\r\n            this.AB.normSquare.isEqual(this.AC.normSquare)\r\n    }\r\n\r\n    get isIsocele(): boolean {\r\n        return this.AB.normSquare.isEqual(this.BC.normSquare) ||\r\n            this.AB.normSquare.isEqual(this.AC.normSquare) ||\r\n            this.BC.normSquare.isEqual(this.AC.normSquare)\r\n    }\r\n\r\n    get lines(): { 'AB': Line, 'BC': Line, 'AC': Line } {\r\n        return this.#lines\r\n    }\r\n\r\n    get remarquables(): remarquableLines | null {\r\n        return this.#remarquables\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Parse values to a triangle. Supported formats:\r\n     * Vector2D, Vector2D, Vector2D\r\n     * x1, y1, x2, y2, x3, y3\r\n     * TODO: Something else ?\r\n     * @param values\r\n     */\r\n    parse = (...values: unknown[]): Triangle => {\r\n        if (values.length === 6) {\r\n            // Check if all values are number or fractions.\r\n            const v: Fraction[] = values.map((x: unknown) => new Fraction(x as string))\r\n\r\n            if (v.some(x => x.isNaN())) {\r\n                throw new Error('One of the values is not a valid number')\r\n            }\r\n\r\n            return this.parse(\r\n                new Vector(v[0], v[1]),\r\n                new Vector(v[2], v[3]),\r\n                new Vector(v[4], v[5]),\r\n            )\r\n        } else if (values.length === 3) {\r\n            // Possibilities:\r\n            // - Three points (or part of points, only dict for example, or array (TODO: Add the array syntax for point)\r\n            // - Three lines\r\n            // - Three lines as text.\r\n            if (values.every((x: unknown) => typeof x === 'string')) {\r\n                // Three lines as text.\r\n                return this.parse(\r\n                    ...values.map((x) => {\r\n                        return new Line(x)\r\n                    })\r\n                )\r\n            } else if (values.every((x: unknown) => x instanceof Line)) {\r\n                // We have three lines\r\n                const AB: Line = (values[0]).clone()\r\n                const BC: Line = (values[1]).clone()\r\n                const AC: Line = (values[2]).clone()\r\n                this.#lines = { AB, BC, AC }\r\n\r\n                // Get the intersection points -> build the triangle using these intersection points.\r\n                let intersect = AB.intersection(BC)\r\n                if (intersect.hasIntersection) {\r\n                    this.#B = intersect.point.clone()\r\n                } else {\r\n                    throw new Error('Lines do not intersect !')\r\n                }\r\n\r\n                intersect = BC.intersection(AC)\r\n                if (intersect.hasIntersection) {\r\n                    this.#C = intersect.point.clone()\r\n                } else {\r\n                    throw new Error('Lines do not intersect !')\r\n                }\r\n\r\n                intersect = AC.intersection(AB)\r\n                if (intersect.hasIntersection) {\r\n                    this.#A = intersect.point.clone()\r\n                } else {\r\n                    throw new Error('Lines do not intersect !')\r\n                }\r\n\r\n            } else if (values.every((x: unknown) => (x instanceof Point))) {\r\n                // We have three points.\r\n                this.#A = (values[0]).clone()\r\n                this.#B = (values[1]).clone()\r\n                this.#C = (values[2]).clone()\r\n                this.#lines = {\r\n                    'AB': new Line(this.#A, this.#B),\r\n                    'BC': new Line(this.#B, this.#C),\r\n                    'AC': new Line(this.#A, this.#C)\r\n                }\r\n            }\r\n        } else if (values.length === 1) {\r\n            if (values[0] instanceof Triangle) {\r\n                return values[0].clone()\r\n            }\r\n        }\r\n\r\n        this.#updateTriangle()\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Clone the Triangle class\r\n     */\r\n    clone = (): Triangle => {\r\n        return new Triangle(\r\n            this.#A.clone(),\r\n            this.#B.clone(),\r\n            this.#C.clone()\r\n        )\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Triangle operations and properties\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Generate the Line object for the three segments of the triangle\r\n     */\r\n    #updateTriangle = () => {\r\n        this.#A.asPoint = true\r\n        this.#B.asPoint = true\r\n        this.#C.asPoint = true\r\n\r\n        this.#middles = {\r\n            'AB': new Point().middleOf(this.#A, this.#B),\r\n            'AC': new Point().middleOf(this.#A, this.#C),\r\n            'BC': new Point().middleOf(this.#B, this.#C)\r\n        }\r\n\r\n        this.#remarquables = this.#calculateRemarquableLines()\r\n    }\r\n\r\n\r\n    /**\r\n     * Get the Vector2D class for the given name\r\n     * @param ptName\r\n     */\r\n    #getPointByName = (ptName: string): Point => {\r\n        switch (ptName.toUpperCase()) {\r\n            case 'A':\r\n                return this.#A\r\n            case 'B':\r\n                return this.#B\r\n            case 'C':\r\n                return this.#C\r\n        }\r\n\r\n        // Something went wrong ! Return the first point\r\n        return this.#A\r\n    }\r\n    /**\r\n     * Get the vector for the segment given by name.\r\n     * @param ptName1\r\n     * @param ptName2\r\n     */\r\n    #getSegment = (ptName1: string, ptName2: string): Vector => {\r\n        return new Vector(\r\n            this.#getPointByName(ptName1),\r\n            this.#getPointByName(ptName2)\r\n        )\r\n    }\r\n\r\n    #calculateRemarquableLines = (): remarquableLines => {\r\n\r\n        const medians = {\r\n            'A': new Line().fromPoints(this.#A, this.#middles.BC),\r\n            'B': new Line().fromPoints(this.#B, this.#middles.AC),\r\n            'C': new Line().fromPoints(this.#C, this.#middles.AB),\r\n            'intersection': null\r\n        }\r\n\r\n        const mediators = {\r\n            'AB': new Line().fromPointAndNormal(this.#middles.AB, new Vector(this.#A, this.#B).normal()),\r\n            'AC': new Line().fromPointAndNormal(this.#middles.AC, new Vector(this.#A, this.#C).normal()),\r\n            'BC': new Line().fromPointAndNormal(this.#middles.BC, new Vector(this.#B, this.#C).normal()),\r\n            'intersection': null\r\n        }\r\n\r\n        const heights = {\r\n            'A': new Line().fromPointAndNormal(this.#A, new Vector(this.#B, this.#C).normal()),\r\n            'B': new Line().fromPointAndNormal(this.#B, new Vector(this.#A, this.#C).normal()),\r\n            'C': new Line().fromPointAndNormal(this.#C, new Vector(this.#A, this.#B).normal()),\r\n            'intersection': null\r\n        }\r\n\r\n        const bA = this.#calculateBisectors('A'),\r\n            bB = this.#calculateBisectors('B'),\r\n            bC = this.#calculateBisectors('C')\r\n\r\n        const bisectors = {\r\n            'A': bA.internal,\r\n            'B': bB.internal,\r\n            'C': bB.internal,\r\n            'intersection': null\r\n        }\r\n\r\n        const externalBisectors = {\r\n            'A': bA.external,\r\n            'B': bB.external,\r\n            'C': bC.external,\r\n            'intersection': null\r\n        }\r\n\r\n        const remarquables: remarquableLines = {\r\n            medians,\r\n            mediators,\r\n            heights,\r\n            bisectors,\r\n            externalBisectors\r\n        }\r\n\r\n        // As it's a triangle, we assume the lines are intersecting and aren't parallel or superposed.\r\n        remarquables.medians.intersection = remarquables.medians.A.intersection(remarquables.medians.B).point\r\n        remarquables.mediators.intersection = remarquables.mediators.AB.intersection(remarquables.mediators.BC).point\r\n        remarquables.heights.intersection = remarquables.heights.A.intersection(remarquables.heights.B).point\r\n        remarquables.bisectors.intersection = remarquables.bisectors.A.intersection(remarquables.bisectors.B).point\r\n\r\n        // Everything was calculated for the remarquable lines.\r\n        return remarquables\r\n    }\r\n\r\n    #calculateBisectors = (pt: string): { internal: Line, external: Line } => {\r\n        const tlines = this.lines\r\n        let d1, d2\r\n\r\n        if (pt === 'A') {\r\n            d1 = tlines.AB\r\n            d2 = tlines.AC\r\n        } else if (pt === 'B') {\r\n            d1 = tlines.AB\r\n            d2 = tlines.BC\r\n        } else if (pt === 'C') {\r\n            d1 = tlines.BC\r\n            d2 = tlines.AC\r\n        }\r\n\r\n        if (d1 === undefined || d2 === undefined) {\r\n            throw new Error(`The point ${pt} does not exist`)\r\n        }\r\n\r\n        const d1n = d1.n.simplify().norm\r\n        const d2n = d2.n.simplify().norm\r\n        const d1Equ = d1.getEquation().multiply(d2n)\r\n        const d2Equ = d2.getEquation().multiply(d1n)\r\n\r\n        const b1: Line = new Line(d1Equ.clone().subtract(d2Equ).simplify())\r\n        const b2: Line = new Line(d2Equ.clone().subtract(d1Equ).simplify())\r\n\r\n        // Must determine which bisectors is in the triangle\r\n        if (pt === 'A') {\r\n            return b1.hitSegment(this.B, this.C) ? { internal: b1, external: b2 } : { internal: b2, external: b1 }\r\n        }\r\n        if (pt === 'B') {\r\n            return b1.hitSegment(this.A, this.C) ? { internal: b1, external: b2 } : { internal: b2, external: b1 }\r\n        }\r\n        if (pt === 'C') {\r\n            return b1.hitSegment(this.B, this.A) ? { internal: b1, external: b2 } : { internal: b2, external: b1 }\r\n        }\r\n\r\n        // Default returns the first bisector\r\n        return { internal: b1, external: b2 }\r\n    }\r\n}","/**\r\n * This class works for 2d line in a plane.\r\n */\r\n\r\nimport { Fraction } from \"../coefficients/fraction\"\r\nimport { Polynom } from \"../algebra/polynom\"\r\nimport { Monom } from \"../algebra/monom\"\r\nimport { randomIntSym } from \"../randomization/rndHelpers\"\r\nimport { Vector } from \"./vector\"\r\nimport { Point } from \"./point\"\r\n\r\nexport enum LinePropriety {\r\n    None = 'none',\r\n    Parallel = 'parallel',\r\n    Perpendicular = 'perpendicular',\r\n    Tangent = 'tangent'\r\n}\r\n\r\nexport class Line3 {\r\n    // A line is defined as the canonical form\r\n    static PERPENDICULAR = LinePropriety.Perpendicular\r\n    static PARALLEL = LinePropriety.Parallel\r\n    // ax + by + c = 0\r\n    #OA: Point = new Point()\r\n    #d: Vector = new Vector()\r\n\r\n    /**\r\n     * Value can be a mix of:\r\n     *\r\n     * @param values\r\n     */\r\n    constructor(A: Point, B: Point)\r\n    constructor(A: Point, d: Vector)\r\n    constructor(A: Point, d: Vector | Point) {\r\n        this.#OA = A.clone()\r\n        this.#d = d.asPoint ? new Vector(A, d) : d.clone()\r\n        return this\r\n    }\r\n\r\n    get OA(): Point {\r\n        return this.#OA\r\n    }\r\n\r\n    set OA(value: Point) {\r\n        this.#OA = value\r\n    }\r\n    get point(): Point {\r\n        return this.#OA.clone()\r\n    }\r\n\r\n    get d(): Vector {\r\n        return this.#d\r\n    }\r\n\r\n    set d(value: Vector) {\r\n        this.#d = value\r\n    }\r\n\r\n    get tex(): { parametric: string, system: string, cartesian: string } {\r\n        return {\r\n            parametric: `${Vector.asTex('x', 'y', 'z')} = ${Vector.asTex(this.#OA.x.tex, this.#OA.y.tex, this.#OA.z.tex)} + k\\\\cdot ${Vector.asTex(this.#d.x.tex, this.#d.y.tex, this.#d.z.tex)}`,\r\n            system: `\\\\left\\\\{\\\\begin{aligned}\r\n    x &= ${(new Polynom(this.#OA.x)\r\n                    .add(new Monom(this.#d.x).multiply(new Monom('k'))))\r\n                    .reorder('k', true)\r\n                    .tex}\\\\\\\\ \r\n    y &= ${(new Polynom(this.#OA.y)\r\n                    .add(new Monom(this.#d.y).multiply(new Monom('k'))))\r\n                    .reorder('k', true)\r\n                    .tex}\\\\\\\\\r\n    z &= ${(new Polynom(this.#OA.z)\r\n                    .add(new Monom(this.#d.z).multiply(new Monom('k'))))\r\n                    .reorder('k', true)\r\n                    .tex}\r\n\\\\end{aligned}\\\\right.`,\r\n            cartesian: `\\\\frac{ ${new Polynom('x', 1, this.#OA.x.clone().opposite()).tex} }{ ${this.direction.x.tex} } = \\\\frac{ ${new Polynom('y', 1, this.#OA.y.clone().opposite()).tex} }{ ${this.direction.y.tex} } = \\\\frac{ ${new Polynom('z', 1, this.#OA.z.clone().opposite()).tex} }{ ${this.direction.z.tex} }`\r\n        }\r\n    }\r\n\r\n    get display(): { parametric: string, system: string, cartesian: string } {\r\n        const OAx = this.#OA.x.display\r\n        const OAy = this.#OA.y.display\r\n        const OAz = this.#OA.z.display\r\n        const n = this.direction.simplify()\r\n        const nx = n.x.display\r\n        const ny = n.y.display\r\n        const nz = n.z.display\r\n\r\n        return {\r\n            parametric: `${Vector.asDisplay('x', 'y', 'z')} = ${Vector.asDisplay(this.#OA.x.display, this.#OA.y.display, this.#OA.z.display)} + k\\\\cdot ${Vector.asDisplay(this.#d.x.display, this.#d.y.display, this.#d.z.display)}`,\r\n            system: '',\r\n            cartesian: `(x-${OAx})/${nx} = (y-${OAy})/${ny} = (z-${OAz})/${nz}`\r\n        }\r\n    }\r\n\r\n    get direction(): Vector {\r\n        return this.#d.clone()\r\n    }\r\n\r\n    clone = (): this => {\r\n        this.#d = this.#d.clone()\r\n        this.#OA = this.#OA.clone()\r\n\r\n        return this\r\n    }\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    isOnLine = (pt: Point): boolean => {\r\n        return false\r\n    }\r\n\r\n    isParallelTo = (line: Line3): boolean => {\r\n        // Do they have the isSame direction ?\r\n        throw new Error('Method not implemented.')\r\n    }\r\n    isSameAs = (line: Line3): boolean => {\r\n        throw new Error('Method not implemented.')\r\n    }\r\n    isPerpendicularTo = (line: Line3): boolean => {\r\n        throw new Error('Method not implemented.')\r\n    }\r\n    isVertical = (): boolean => {\r\n        throw new Error('Method not implemented.')\r\n    }\r\n    simplify = (): this => {\r\n        throw new Error('Method not implemented.')\r\n        // const lcm = Numeric.lcm(this.#a.denominator, this.#b.denominator, this.#c.denominator),\r\n        //     gcd = Numeric.gcd(this.#a.numerator, this.#b.numerator, this.#c.numerator)\r\n\r\n        // this.fromCoefficient(\r\n        //     this.#a.clone().multiply(lcm).divide(gcd),\r\n        //     this.#b.clone().multiply(lcm).divide(gcd),\r\n        //     this.#c.clone().multiply(lcm).divide(gcd),\r\n        // )\r\n\r\n        // return this\r\n    }\r\n\r\n    intersection = (line: Line3): { point: Vector, hasIntersection: boolean, isParallel: boolean, isSame: boolean } => {\r\n        // const Pt = new Vector()\r\n        // let isParallel = false, isSame = false\r\n\r\n\r\n        // // Theres is no 'y'\r\n        // if (this.#b.isZero() || line.b.isZero()) {\r\n        //     // TODO : handle no y in the line canonical form\r\n        // }\r\n\r\n        // if (this.isParallelTo(line)) {\r\n        //     Pt.x = new Fraction().invalid()\r\n        //     Pt.y = new Fraction().invalid()\r\n        //     isParallel = true\r\n        // } else if (this.isSameAs(line)) {\r\n        //     Pt.x = new Fraction().invalid()\r\n        //     Pt.y = new Fraction().invalid()\r\n        //     isSame = true\r\n        // } else {\r\n        //     Pt.x = this.#b.clone().multiply(line.c).subtract(this.#c.clone().multiply(line.b))\r\n        //         .divide(this.#a.clone().multiply(line.b).subtract(this.#b.clone().multiply(line.a)))\r\n        //     Pt.y = this.#a.clone().multiply(line.c).subtract(this.#c.clone().multiply(line.a))\r\n        //         .divide(this.#b.clone().multiply(line.a).subtract(this.#a.clone().multiply(line.b)))\r\n        // }\r\n\r\n        // return {\r\n        //     point: Pt,\r\n        //     hasIntersection: !(isParallel || isSame),\r\n        //     isParallel,\r\n        //     isSame\r\n        // }\r\n        throw new Error('Method not implemented.')\r\n    }\r\n\r\n    distanceTo(pt: Point): { value: number, fraction: Fraction, tex: string } {\r\n        // Distance is:\r\n        // |(x - x0) x d| / |d|\r\n        const AP = new Vector(this.#OA, pt),\r\n            d = this.direction,\r\n            d2 = this.direction.normSquare,\r\n            num2 = AP.cross(d).normSquare,\r\n            num2d2 = num2.clone().divide(d2),\r\n            dnum = num2d2.clone().sqrt()\r\n\r\n        console.log('CROSS', AP.cross(d).display)\r\n        return {\r\n            value: Math.sqrt(num2d2.value),\r\n            fraction: num2d2.clone().sqrt(),\r\n            tex: dnum.isExact() ? dnum.tex : `\\\\sqrt{${num2d2.tex}}`\r\n        }\r\n    }\r\n\r\n    hitSegment(A: Point, B: Point): boolean {\r\n        const iPt = this.intersection(\r\n            new Line3(A, B)\r\n        )\r\n\r\n        // There is an intersection point\r\n        if (iPt.hasIntersection) {\r\n            return iPt.point.x.value >= Math.min(A.x.value, B.x.value)\r\n                && iPt.point.x.value <= Math.max(A.x.value, B.x.value)\r\n                && iPt.point.y.value >= Math.min(A.y.value, B.y.value)\r\n                && iPt.point.y.value <= Math.max(A.y.value, B.y.value)\r\n                && iPt.point.z.value >= Math.min(A.z.value, B.z.value)\r\n                && iPt.point.z.value <= Math.max(A.z.value, B.z.value)\r\n        }\r\n        return false\r\n    }\r\n\r\n    // getValueAtX = (value: Fraction | number): Fraction => {\r\n    //     const equ = this.equation.clone().isolate('y'),\r\n    //         F = new Fraction(value)\r\n\r\n    //     if (equ instanceof Equation) {\r\n    //         return equ.right.evaluate({ x: F }) as Fraction\r\n    //     }\r\n    //     return new Fraction().invalid()\r\n    // }\r\n\r\n    // getValueAtY = (value: Fraction | number): Fraction => {\r\n    //     const equ = this.equation.clone().isolate('x'),\r\n    //         F = new Fraction(value)\r\n\r\n    //     if (equ instanceof Equation) {\r\n    //         return equ.right.evaluate({ y: F }) as Fraction\r\n    //     }\r\n\r\n    //     return new Fraction().invalid()\r\n    // }\r\n\r\n    randomPoint = (max = 5): Point => {\r\n        const A = this.#OA.clone(),\r\n            k = new Fraction(randomIntSym(max, false))\r\n\r\n        return new Point(\r\n            A.x.clone().add(this.#d.x.clone().multiply(k)),\r\n            A.y.clone().add(this.#d.y.clone().multiply(k)),\r\n            A.z.clone().add(this.#d.z.clone().multiply(k))\r\n        )\r\n    }\r\n}","import { Equation } from \"../algebra/equation\"\r\nimport { Polynom } from \"../algebra/polynom\"\r\nimport { Fraction } from \"../coefficients/fraction\"\r\nimport { Line3 } from \"./line3\"\r\nimport { Point } from \"./point\"\r\nimport { Vector } from \"./vector\"\r\n\r\n\r\ninterface Plane3Config {\r\n    point?: Point,\r\n    normal?: Vector,\r\n    directions?: Vector[],\r\n    equation?: Equation,\r\n    points?: Point[],\r\n    coefficients?: number[]\r\n}\r\nexport class Plane3 {\r\n    #normal: Vector = new Vector(0, 0, 1)\r\n    #point: Point = new Point(0, 0, 0)\r\n\r\n    constructor(config?: Plane3Config) {\r\n        if (config) {\r\n            this.parse(config)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    get normal(): Vector {\r\n        return this.#normal\r\n    }\r\n    set normal(value: Vector) {\r\n        this.#normal = value\r\n        this.#normal.asPoint = false\r\n    }\r\n    get point(): Point {\r\n        return this.#point\r\n    }\r\n    set point(value: Point) {\r\n        this.#point = value\r\n        this.#point.asPoint = true\r\n    }\r\n\r\n    get a(): Fraction {\r\n        return this.#normal.x\r\n    }\r\n    get b(): Fraction {\r\n        return this.#normal.y\r\n    }\r\n    get c(): Fraction {\r\n        return this.#normal.z\r\n    }\r\n    get d(): Fraction {\r\n        return this.#normal.dot(this.#point).opposite()\r\n    }\r\n\r\n    get tex(): string {\r\n        // return the cartesian equation of the plane\r\n        return new Equation(\r\n            new Polynom('xyz', this.a, this.b, this.c, this.d),\r\n            new Polynom(0)\r\n        ).reduce().tex\r\n    }\r\n\r\n    parse(config: Plane3Config) {\r\n        if (config.point && config.normal) {\r\n            this.point = config.point\r\n            this.normal = config.normal\r\n            return\r\n        }\r\n\r\n        if (config.point && config.directions?.length === 2) {\r\n            this.point = config.point\r\n            const [v1, v2] = config.directions\r\n            this.normal = v1.cross(v2)\r\n            return\r\n        }\r\n\r\n        if (config.equation) {\r\n            const cartesian = config.equation.moveLeft().reduce().left\r\n\r\n            const a = cartesian.monomByLetter('x').coefficient\r\n            const b = cartesian.monomByLetter('y').coefficient\r\n            const c = cartesian.monomByLetter('z').coefficient\r\n            const d = cartesian.monomByDegree(0).coefficient\r\n\r\n            // Get the normal vector\r\n            this.normal = new Vector(a, b, c)\r\n\r\n            // Get a point on the plane\r\n            if (a.isNotZero()) {\r\n                this.point = new Point(d.clone().divide(a).opposite(), 0, 0)\r\n            } else if (b.isNotZero()) {\r\n                this.point = new Point(0, d.clone().divide(b).opposite(), 0)\r\n            } else {\r\n                this.point = new Point(0, 0, d.clone().divide(c).opposite())\r\n            }\r\n            // Make sure it's considered as point\r\n            return\r\n        }\r\n\r\n        if (config.points?.length === 3 && config.points.every(p => p instanceof Vector)) {\r\n            const A = config.points[0]\r\n            const B = config.points[1]\r\n            const C = config.points[2]\r\n\r\n            const AB = new Vector(A, B)\r\n            const AC = new Vector(A, C)\r\n            this.normal = AB.cross(AC)\r\n            this.point = A\r\n            return\r\n        }\r\n\r\n        if (config.coefficients?.length === 4) {\r\n            const [a, b, c, d] = config.coefficients\r\n            this.normal = new Vector(a, b, c)\r\n            this.point = new Point(0, 0, -d)\r\n            return\r\n        }\r\n    }\r\n\r\n    angle(vector: Vector, sharp?: boolean, radian?: boolean): number\r\n    angle(line: Line3, sharp?: boolean, radian?: boolean): number\r\n    angle(plane: Plane3, sharp?: boolean, radian?: boolean): number\r\n    angle(value: Plane3 | Line3 | Vector, sharp?: boolean, radian?: boolean): number {\r\n        if (value instanceof Plane3) {\r\n            return this.normal.angle(value.normal, sharp, radian)\r\n        }\r\n\r\n        let direction: Vector\r\n        if (value instanceof Vector) {\r\n            if (value.dimension !== 3) {\r\n                throw new Error('Vector is not 3D')\r\n            }\r\n\r\n            direction = value\r\n        } else {\r\n            direction = value.direction\r\n        }\r\n\r\n        const a90 = radian ? Math.PI / 2 : 90\r\n        return a90 - this.normal.angle(direction, true, radian)\r\n    }\r\n\r\n    distanceTo(point: Vector): number {\r\n        return this.normal.dot(point).add(this.d).abs().value / this.normal.norm\r\n    }\r\n\r\n    intersectWithLine(line: Line3): Point {\r\n        const { point, direction } = line\r\n        const t = this.normal.dot(point).add(this.d).divide(this.normal.dot(direction).opposite())\r\n        return point.clone().add(direction.clone().multiplyByScalar(t))\r\n    }\r\n\r\n    intersectWithPlane(plane: Plane3): Line3 {\r\n        const direction = this.normal.cross(plane.normal)\r\n\r\n        // Solve the system:\r\n        // p1 // p2 // z=0\r\n        const pt = new Point(0, 0, 0)\r\n        throw new Error('Intersection with plane  not yet implemented !')\r\n        return new Line3(pt, direction)\r\n    }\r\n\r\n    isPointOnPlane(pt: Point): boolean {\r\n        return this.normal.dot(pt).add(this.d).isZero()\r\n    }\r\n}","import { Fraction } from \"../coefficients/fraction\"\r\nimport { determinant } from \"./geomMath\"\r\nimport type { Vector } from \"./vector\"\r\n\r\n\r\nexport class Matrix {\r\n    #values: Vector[] = []\r\n    constructor(...values: Vector[]) {\r\n        this.#values = values\r\n\r\n        return this\r\n    }\r\n\r\n    get values(): Vector[] {\r\n        return this.#values\r\n    }\r\n\r\n    get array(): Fraction[][] {\r\n        return this.#values.map(v => v.array)\r\n    }\r\n\r\n    get dimension(): number[] {\r\n        return [this.#values.length, this.#values[0].dimension]\r\n    }\r\n\r\n    isSquare(): boolean {\r\n        return this.#values.length === this.#values[0].dimension\r\n    }\r\n\r\n    determinant(): Fraction {\r\n        if (!this.isSquare()) {\r\n            throw new Error('Matrix is not square')\r\n        }\r\n\r\n        return determinant(...this.values)\r\n    }\r\n}","import type { randomCoefficientConfig } from \"../rndTypes\"\r\nimport { Fraction } from \"../../coefficients/fraction\"\r\nimport { randomInt, randomIntSym } from \"../rndHelpers\"\r\n\r\nexport function rndFraction(userConfig?: randomCoefficientConfig): Fraction {\r\n    const config = Object.assign(\r\n        {\r\n            negative: true,\r\n            max: 10,\r\n            reduced: true,\r\n            zero: true,\r\n            natural: false\r\n        }, userConfig)\r\n\r\n    // Create a null fraction\r\n    const Q = new Fraction()\r\n\r\n\r\n    if (config.negative) {\r\n        // Allow negative numbers\r\n        Q.numerator = randomIntSym(config.max, config.zero)\r\n    } else {\r\n        // Only positive numbers\r\n        Q.numerator = randomInt(config.zero ? 0 : 1, config.max)\r\n    }\r\n\r\n    if (config.natural) {\r\n        Q.denominator = 1\r\n    } else {\r\n        let securityCount = 0\r\n        while (Q.isRelative() && securityCount < 10) {\r\n            Q.denominator = randomInt(1, config.max)\r\n            securityCount++\r\n        }\r\n    }\r\n\r\n    return config.reduced ? Q.reduce() : Q\r\n}\r\n","import type { randomMonomConfig } from \"../rndTypes\"\r\nimport { Monom } from \"../../algebra/monom\"\r\nimport { rndFraction } from \"../coefficient/rndFraction\"\r\nimport { randomItem } from \"../rndHelpers\"\r\n\r\nexport function rndMonom(userConfig?: randomMonomConfig): Monom {\r\n    const config = Object.assign(\r\n        {\r\n            letters: 'x',\r\n            degree: 2,\r\n            fraction: true,\r\n            zero: false\r\n        }, userConfig)\r\n\r\n    // Create a monom instance\r\n    const M = new Monom()\r\n\r\n    // Generate the coefficient\r\n    M.coefficient = rndFraction({\r\n        zero: config.zero,\r\n        reduced: true,\r\n        natural: !config.fraction\r\n    })\r\n\r\n    if (config.letters.length > 1) {\r\n        // Initialise each items...\r\n        for (const L of config.letters.split('')) {\r\n            M.setLetter(L, 0)\r\n        }\r\n        for (let i = 0; i < config.degree; i++) {\r\n            const L = randomItem(config.letters.split(\"\"))\r\n            M.setLetter(L, M.degree(L).clone().add(1))\r\n        }\r\n    } else {\r\n        M.setLetter(config.letters, config.degree)\r\n    }\r\n\r\n    return M\r\n}","import type { randomPolynomConfig } from \"../rndTypes\"\r\nimport { rndMonom } from \"./rndMonom\"\r\nimport { Polynom } from \"../../algebra/polynom\"\r\nimport { Monom } from \"../../algebra/monom\"\r\nimport { randomInt } from \"../rndHelpers\"\r\n\r\nconst factorableConfig = {\r\n    letters: 'x',\r\n    degree: 2,\r\n    fraction: false,\r\n    zero: false,\r\n    unit: false,\r\n    factorable: false,\r\n    allowNullMonom: true,\r\n    numberOfMonoms: 0,\r\n    positive: true\r\n}\r\n\r\nexport function rndPolynom(userConfig?: randomPolynomConfig): Polynom {\r\n    const config = Object.assign(\r\n        factorableConfig,\r\n        userConfig\r\n    )\r\n\r\n    // Create the polynom\r\n    const P = new Polynom().empty()\r\n\r\n    let M: Monom\r\n\r\n    for (let i = config.degree; i >= 0; i--) {\r\n        // Create monom of corresponding degree.\r\n        M = rndMonom({\r\n            letters: config.letters,\r\n            degree: i,\r\n            fraction: config.fraction,\r\n            zero: (i === config.degree) ? false : config.allowNullMonom\r\n        })\r\n\r\n        // If degree is the greatest and unit is true, set the monom value to one.\r\n        if (config.unit && config.degree === i) {\r\n            M.coefficient.one()\r\n        }\r\n\r\n        // Add to the polynom\r\n        P.add(M)\r\n    }\r\n\r\n    // Make sure the first monom is positive.\r\n    if (config.positive && P.monomByDegree().coefficient.isNegative()) {\r\n        P.monomByDegree().coefficient.opposite()\r\n    }\r\n\r\n    // If the number of monoms is greater than the allowed value, remove some of them... except the first one !\r\n    if (config.numberOfMonoms\r\n        && config.numberOfMonoms > 0\r\n        && config.numberOfMonoms < P.length) {\r\n        while (P.length > config.numberOfMonoms) {\r\n            // Remove a random monom, except the first one\r\n            const index = randomInt(1, P.length - 1)\r\n\r\n            P.monoms.splice(index, 1)\r\n        }\r\n    }\r\n\r\n    return P.reduce()\r\n}\r\n\r\nexport function rndFactorablePolynom(userConfig?: randomPolynomConfig): Polynom {\r\n    const config = Object.assign(\r\n        factorableConfig,\r\n        userConfig\r\n    )\r\n\r\n    const P = new Polynom().one()\r\n\r\n    const _factorableConfig = { ...config }\r\n    _factorableConfig.degree = 1\r\n    _factorableConfig.factorable = false\r\n\r\n    for (let i = 0; i < config.degree; i++) {\r\n        P.multiply(rndPolynom(_factorableConfig))\r\n    }\r\n\r\n    return P.reduce()\r\n}","import type { randomEquationConfig } from \"../rndTypes\"\r\nimport { Polynom } from \"../../algebra/polynom\"\r\nimport { Equation } from \"../../algebra/equation\"\r\nimport { rndPolynom } from \"./rndPolynom\"\r\n\r\nexport function rndEquation(userConfig?: randomEquationConfig): Equation {\r\n    const config = Object.assign(\r\n        {\r\n            letters: 'x',\r\n            degree: 1,\r\n            fraction: false,\r\n            zero: false,\r\n            unit: false,\r\n            factorable: false,\r\n            allowNullMonom: true,\r\n            numberOfMonoms: 0,\r\n            positive: true,\r\n            solution: {\r\n                allowZero: true,\r\n                fraction: false,\r\n                nothing: false,\r\n                everything: false\r\n            }\r\n        }, userConfig)\r\n\r\n    // Create a polynom\r\n    const P = new Polynom().one()\r\n\r\n    for (let i = 0; i < config.degree; i++) {\r\n        const factor = rndPolynom({\r\n            degree: 1,\r\n            unit: config.unit,\r\n            fraction: config.fraction,\r\n            letters: config.letters,\r\n            zero: config.zero\r\n        })\r\n        P.multiply(factor)\r\n    }\r\n\r\n    return new Equation(P, 0)\r\n}\r\n","import { Fraction } from \"../../coefficients/fraction\"\r\nimport type { randomGeometryPointConfig } from \"../rndTypes\"\r\nimport { rndFraction } from \"../coefficient/rndFraction\"\r\nimport { randomIntSym } from \"../rndHelpers\"\r\nimport { Point } from \"../../geometry/point\"\r\n\r\nexport function rndVector(userConfig?: randomGeometryPointConfig): Point {\r\n    const config: {\r\n        axis: 'x' | 'y' | 'z' | null,\r\n        fraction: boolean,\r\n        max: number,\r\n        quadrant: number | null\r\n    } = Object.assign(\r\n        {\r\n            axis: true,\r\n            fraction: false,\r\n            max: 10,\r\n            quadrant: null\r\n        }, userConfig)\r\n\r\n    const zeroX = config.axis === 'x',\r\n        zeroY = config.axis === 'y'\r\n\r\n\r\n    const x = config.fraction ?\r\n        rndFraction({ max: config.max, zero: zeroX }) :\r\n        new Fraction(randomIntSym(config.max, zeroX))\r\n\r\n    const y = config.fraction ?\r\n        rndFraction({ max: config.max, zero: zeroY }) :\r\n        new Fraction(randomIntSym(config.max, zeroY))\r\n\r\n    if (Number(config.quadrant) === 1) {\r\n        x.abs()\r\n        y.abs()\r\n    }\r\n    if (Number(config.quadrant) === 2) {\r\n        if (x.isPositive()) {\r\n            x.opposite()\r\n        }\r\n        if (y.isNegative()) {\r\n            y.opposite()\r\n        }\r\n    }\r\n    if (Number(config.quadrant) === 3) {\r\n        if (x.isPositive()) {\r\n            x.opposite()\r\n        }\r\n        if (y.isPositive()) {\r\n            y.opposite()\r\n        }\r\n    }\r\n    if (Number(config.quadrant) === 4) {\r\n        if (x.isNegative()) {\r\n            x.opposite()\r\n        }\r\n        if (y.isPositive()) {\r\n            y.opposite()\r\n        }\r\n    }\r\n\r\n    return new Point(x, y)\r\n}\r\n","import { Circle } from \"../../geometry/circle\"\r\nimport { randomInt } from \"../rndHelpers\"\r\nimport type { randomGeometryCircleConfig } from \"../rndTypes\"\r\nimport { rndVector } from \"./rndVector\"\r\n\r\nexport function rndCircle(userConfig?: randomGeometryCircleConfig): Circle {\r\n    const config = Object.assign(\r\n        {\r\n            center: {\r\n                x: { min: -10, max: 10 },\r\n                y: { min: -10, max: 10 }\r\n            },\r\n            pointsOnCircle: 8\r\n        }, userConfig)\r\n\r\n    const center = rndVector(config.center)\r\n\r\n    let rv, r\r\n    if (config.pointsOnCircle === 8) {\r\n        rv = randomInt(1, 3),\r\n            r = rv ** 2 + (rv + 1) ** 2\r\n    } else {\r\n        r = randomInt(1, 20)\r\n    }\r\n\r\n    return new Circle(center, r, true)\r\n}","import { Line } from \"../../geometry/line\"\r\nimport { Vector } from \"../../geometry/vector\"\r\nimport { randomIntSym } from \"../rndHelpers\"\r\nimport type { randomGeometryLineConfig } from \"../rndTypes\"\r\n\r\nexport function rndLine(userConfig?: randomGeometryLineConfig): Line {\r\n    const config = Object.assign(\r\n        {\r\n            A: {\r\n                x: randomIntSym(10),\r\n                y: randomIntSym(10)\r\n            },\r\n        }, userConfig)\r\n\r\n    // The A point exists.\r\n    const d = new Vector(\r\n        randomIntSym(10),\r\n        randomIntSym(10)\r\n    )\r\n\r\n    while (d.isNull) {\r\n        d.x = randomIntSym(10)\r\n        d.y = randomIntSym(10)\r\n    }\r\n\r\n    if (config.slope === 1) {\r\n        if (d.x.sign() !== d.y.sign()) {\r\n            d.y.opposite()\r\n        }\r\n    } else if (config.slope === -1) {\r\n        if (d.x.sign() !== d.y.sign()) {\r\n            d.y.opposite()\r\n        }\r\n    }\r\n\r\n    return new Line(new Vector(config.A.x, config.A.y), d)\r\n}","import { Line3 } from \"../../geometry/line3\"\r\nimport { Point } from \"../../geometry/point\"\r\nimport { Vector } from \"../../geometry/vector\"\r\nimport { randomIntSym } from \"../rndHelpers\"\r\nimport type { randomGeometryLine3Config } from \"../rndTypes\"\r\n\r\nexport function rndLine3(userConfig?: randomGeometryLine3Config): Line3 {\r\n    const config = Object.assign(\r\n        {\r\n            A: {\r\n                x: randomIntSym(10),\r\n                y: randomIntSym(10),\r\n                z: randomIntSym(10)\r\n            },\r\n            direction: {\r\n                x: randomIntSym(10),\r\n                y: randomIntSym(10),\r\n                z: randomIntSym(10)\r\n            }\r\n        }, userConfig)\r\n\r\n    // The direction vector exists.\r\n    const A = new Point(config.A.x, config.A.y, config.A.z)\r\n    const d = new Vector(config.direction.x, config.direction.y, config.direction.z)\r\n\r\n    return new Line3(A, d)\r\n}","import type {\r\n    randomCoefficientConfig,\r\n    randomEquationConfig,\r\n    randomGeometryCircleConfig,\r\n    randomGeometryLine3Config,\r\n    randomGeometryLineConfig,\r\n    randomGeometryPointConfig,\r\n    randomMonomConfig,\r\n    randomPolynomConfig\r\n} from \"./rndTypes\"\r\nimport { randomArray, randomBool, randomInt, randomIntSym, randomItem, randomPrime, shuffleArray } from \"./rndHelpers\"\r\nimport { rndFraction } from \"./coefficient/rndFraction\"\r\nimport { rndMonom } from \"./algebra/rndMonom\"\r\nimport { rndPolynom } from \"./algebra/rndPolynom\"\r\nimport { rndEquation } from \"./algebra/rndEquation\"\r\nimport { rndCircle } from \"./geometry/rndCircle\"\r\nimport { rndLine } from \"./geometry/rndLine\"\r\nimport { rndLine3 } from \"./geometry/rndLine3\"\r\nimport { rndVector } from \"./geometry/rndVector\"\r\n\r\nexport type * from \"./rndTypes\"\r\n\r\nexport const Random = {\r\n    equation: (config?: randomEquationConfig) => {\r\n        return rndEquation(config)\r\n    },\r\n\r\n    polynom: (config?: randomPolynomConfig) => {\r\n        return rndPolynom(config)\r\n    },\r\n\r\n    monom: (config?: randomMonomConfig) => {\r\n        return rndMonom(config)\r\n    },\r\n\r\n    fraction: (config?: randomCoefficientConfig) => {\r\n        return rndFraction(config)\r\n    },\r\n\r\n    number: (from: number, to: number, exclude?: number[]): number => {\r\n        return randomInt(from, to, exclude)\r\n    },\r\n\r\n    numberSym: (max: number, allowZero?: boolean): number => {\r\n        return randomIntSym(max, allowZero)\r\n    },\r\n\r\n    prime: (max: number): number => {\r\n        return randomPrime(max)\r\n    },\r\n\r\n    bool: (percent?: number): boolean => {\r\n        return randomBool(percent)\r\n    },\r\n\r\n    array: <T>(arr: T[], number?: number): T[] => {\r\n        return randomArray(arr, number)\r\n    },\r\n\r\n    item: <T>(arr: T[]): T => {\r\n        return randomItem(arr)\r\n    },\r\n\r\n    shuffle: <T>(arr: T[]): T[] => {\r\n        return shuffleArray(arr)\r\n    },\r\n\r\n    line: (config?: randomGeometryLineConfig) => {\r\n        return rndLine(config)\r\n    },\r\n\r\n    line3: (config?: randomGeometryLine3Config) => {\r\n        return rndLine3(config)\r\n    },\r\n\r\n    vector: (config?: randomGeometryPointConfig) => {\r\n        return rndVector(config)\r\n    },\r\n\r\n    point: (config?: randomGeometryPointConfig) => {\r\n        const vector = rndVector(config)\r\n        vector.asPoint = true\r\n\r\n        return vector\r\n    },\r\n\r\n    circle: (config?: randomGeometryCircleConfig) => {\r\n        return rndCircle(config)\r\n    }\r\n}","/**\r\n * Polynom module contains everything necessary to handle polynoms.\r\n * @module Logicalset\r\n */\r\nimport {ShutingYard, ShutingyardMode} from \"piexpression\"\r\n\r\n/**\r\n * Polynom class can handle polynoms, reorder, resolve, ...\r\n */\r\nexport class LogicalSet {\r\n    #rpn: { token: string, tokenType: string }[]\r\n\r\n    /**\r\n     *\r\n     * @param {string} value (optional) Default polynom to parse on class creation\r\n     */\r\n    constructor(value?: string) {\r\n        this.#rpn = []\r\n\r\n        if (value !== undefined) {\r\n            this.parse(value)\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    parse = (value: string): this => {\r\n        // Parse the updated value to the shutingyard algorithm\r\n        this.#rpn = new ShutingYard(ShutingyardMode.SET)\r\n            .parse(value)\r\n            .rpn\r\n\r\n        return this\r\n    }\r\n\r\n    evaluate(values: Record<string, boolean>): boolean {\r\n        // Add missing key(s) and set them as false by default.\r\n        this.variables.forEach(key => {\r\n            if (!Object.hasOwn(values, key)) {\r\n                values[key] = false\r\n            }\r\n        })\r\n\r\n        const stack: boolean[] = []\r\n        for (const token of this.#rpn) {\r\n            console.log(token)\r\n            if (token.tokenType === 'variable') {\r\n                stack.push(values[token.token])\r\n            } else if (token.tokenType === 'operation') {\r\n                if (token.token === '!') {\r\n                    // need only one item from stack\r\n                    if (stack.length >= 1) {\r\n                        const a = stack.pop()\r\n                        stack.push(!a)\r\n                    } else {\r\n                        return false\r\n                    }\r\n                } else {\r\n                    // All other operations needs two items from stack\r\n                    const a = stack.pop()\r\n                    const b = stack.pop()\r\n                    if (a !== undefined && b !== undefined) {\r\n                        switch (token.token) {\r\n                            case \"&\":\r\n                                stack.push(a && b)\r\n                                break\r\n                            case \"|\":\r\n                                stack.push(a || b)\r\n                                break\r\n                            case \"-\":\r\n                                return false\r\n                        }\r\n\r\n                    } else {\r\n                        return false\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return stack.length === 1 && stack[0]\r\n    }\r\n\r\n    get rpn(): { token: string, tokenType: string }[] {\r\n        return this.#rpn\r\n    }\r\n\r\n    get tex(): string {\r\n        const varStack: { token: string, tokenType: string }[] = []\r\n\r\n        for (const token of this.#rpn) {\r\n            if (token.tokenType === 'variable') {\r\n                varStack.push(token)\r\n            } else {\r\n                switch (token.token) {\r\n                    case '&':\r\n                        if (varStack.length >= 2) {\r\n                            const second = varStack.pop(),\r\n                                first = varStack.pop()\r\n\r\n                            if (second && first) {\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\cap ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                        }\r\n                        break\r\n                    case '|':\r\n                        if (varStack.length >= 2) {\r\n                            const second = varStack.pop(),\r\n                                first = varStack.pop()\r\n\r\n                            if (second && first) {\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\cup ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                        }\r\n                        break\r\n                    case '-':\r\n                        if (varStack.length >= 2) {\r\n                            const second = varStack.pop(),\r\n                                first = varStack.pop()\r\n\r\n                            if (second && first) {\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\setminus ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                        }\r\n                        break\r\n                    case '!':\r\n                        if (varStack.length >= 1) {\r\n                            const first = varStack.pop()\r\n\r\n                            if (first) {\r\n                                varStack.push({token: `\\\\overline{ ${first.token} }`, tokenType: 'variable'})\r\n                            }\r\n                        }\r\n                        break\r\n                }\r\n            }\r\n        }\r\n\r\n        return varStack[0].token\r\n    }\r\n\r\n    get variables(): string[] {\r\n        return this.#rpn\r\n            .filter(value => value.tokenType === 'variable')\r\n            .map(value => value.token)\r\n    }\r\n\r\n    vennAB(): string[] {\r\n        return this.#evaluateAsVenn({\r\n                A: ['A', 'AB'],\r\n                B: ['B', 'AB']\r\n            },\r\n            ['A', 'B', 'AB', 'E']\r\n        )\r\n    }\r\n\r\n    vennABC(): string[] {\r\n        return this.#evaluateAsVenn({\r\n                A: ['A', 'AB', 'AC', 'ABC'],\r\n                B: ['B', 'AB', 'BC', 'ABC'],\r\n                C: ['C', 'AC', 'BC', 'ABC']\r\n            },\r\n            ['A', 'B', 'C', 'AB', 'AC', 'BC', 'ABC', 'E']\r\n        )\r\n    }\r\n\r\n    #evaluateAsVenn(tokenSets: Record<string, string[] | undefined>, reference?: string[]): string[] {\r\n        const varStack: (Set<string>)[] = []\r\n\r\n        let referenceSet: Set<string>\r\n        if (reference === undefined) {\r\n            referenceSet = new Set()\r\n            for (const key in tokenSets) {\r\n                referenceSet = new Set([\r\n                    ...referenceSet,\r\n                    ...(tokenSets[key] ?? [])\r\n                ])\r\n            }\r\n        } else {\r\n            referenceSet = new Set(reference)\r\n        }\r\n\r\n        for (const token of this.#rpn) {\r\n            if (token.tokenType === 'variable') {\r\n                // The variable has no token - assume it's empty.\r\n                if (tokenSets[token.token] === undefined) {\r\n                    varStack.push(new Set())\r\n                } else {\r\n                    varStack.push(new Set(tokenSets[token.token]))\r\n                }\r\n\r\n            } else {\r\n                switch (token.token) {\r\n                    case '&':\r\n                        if (varStack.length >= 2) {\r\n                            const second = varStack.pop(),\r\n                                first = varStack.pop()\r\n\r\n                            if (first && second) {\r\n                                varStack.push(new Set([...first].filter(x => second.has(x))))\r\n                            }\r\n                        }\r\n                        break\r\n                    case '|':\r\n                        if (varStack.length >= 2) {\r\n                            const second = varStack.pop(),\r\n                                first = varStack.pop()\r\n                            if (first && second) {\r\n                                varStack.push(new Set([...first, ...second]))\r\n                            }\r\n                        }\r\n                        break\r\n                    case '-':\r\n                        if (varStack.length >= 2) {\r\n                            const second = varStack.pop(),\r\n                                first = varStack.pop()\r\n\r\n                            if (first && second) {\r\n                                varStack.push(new Set([...first].filter(x => !second.has(x))))\r\n                            }\r\n                        }\r\n                        break\r\n                    case '!':\r\n                        if (varStack.length >= 1) {\r\n                            const first = varStack.pop()\r\n\r\n                            if (first) {\r\n                                varStack.push(new Set([...referenceSet].filter(x => !first.has(x))))\r\n                            }\r\n                        }\r\n                        break\r\n                }\r\n            }\r\n        }\r\n\r\n        return [...varStack[0]].sort()\r\n    }\r\n}","// Expose as global\r\nimport {Fraction} from \"./coefficients/fraction\"\r\nimport {NthRoot} from \"./coefficients/nthRoot\"\r\nimport {Monom} from \"./algebra/monom\"\r\nimport {Polynom} from \"./algebra/polynom\"\r\nimport {Factor} from \"./algebra/factor\"\r\nimport {PolyFactor} from \"./algebra/polyFactor\"\r\nimport {Equation} from \"./algebra/equation\"\r\nimport {LinearSystem} from \"./algebra/linearSystem\"\r\nimport {Circle} from \"./geometry/circle\"\r\nimport {Line} from \"./geometry/line\"\r\nimport {Point} from \"./geometry/point\"\r\nimport {Triangle} from \"./geometry/triangle\"\r\nimport {Vector} from \"./geometry/vector\"\r\nimport {Line3} from \"./geometry/line3\"\r\nimport {Plane3} from \"./geometry/plane3\"\r\nimport {Matrix} from \"./geometry/matrix\"\r\n\r\nimport {Numeric} from \"./numeric\"\r\nimport {Random} from \"./randomization/random\"\r\n\r\nimport {NumExp} from \"piexpression\"\r\nimport {LogicalSet} from \"./algebra/logicalset\"\r\n\r\nexport type * from \"./pimath.interface\"\r\n\r\nconst Geometry = {\r\n    Vector: Vector,\r\n    Point: Point,\r\n    Line: Line,\r\n    Triangle: Triangle,\r\n    Circle: Circle,\r\n    Line3: Line3,\r\n    Plane3: Plane3,\r\n}\r\n\r\n// Make a global object\r\nconst PiMath = {\r\n    Numeric,\r\n    Fraction,\r\n    Root: NthRoot,\r\n    Monom,\r\n    Polynom,\r\n    Equation,\r\n    Matrix,\r\n    LinearSystem,\r\n    Factor,\r\n    PolyFactor,\r\n    LogicalSet,\r\n    Random,\r\n    Geometry,\r\n    NumExp\r\n}\r\n\r\n// Export default value\r\nexport default PiMath\r\n"],"names":["decompose","value","divs","dividers","arr","u","v","divideNumbersByGCD","values","g","greatestCommonDivisor","x","absV","maxV","D","i","a","b","gcd2","leastCommonMultiple","numberCorrection","number_of_digits","periodic","primes","nb","primesValues","pythagoreanTripletsWithTarget","target","targetIsSquare","triplets","targetValue","round","decimals","Numeric","_approximative","_denominator","_numerator","_type","_Fraction","denominatorOrPeriodic","__privateAdd","__publicField","S","__privateSet","decimal","p","F","__privateGet","N","k","f","sign","compareFraction","Q","n","than","controlNumerator","controlDenominator","result","fractions","M","m","compare","reverse","sorted","unique","distinct","R","Fraction","_radical","_nth","_coefficient","_isValid","NthRoot","radical","nthroot","coefficient","V","C","_","s","e","A","P","c","t","r","O","o","T","h","w","U","y","I","l","E","L","_literal","_Monom_instances","cloneLiteral_fn","_evaluateAsNumeric","_shutingYardToReducedMonom","_shutingYard_AddToken","_Monom","mAsMonom","__privateMethod","letter","d","dM","asNumeric","tmpValues","div","M1","M2","K","item","key","degree","pow","inputStr","rpn","ShutingYard","stack","element","ShutingyardType","_a","q1","q2","letters","literals","monomDividers","primitive","tmpList","litt","currentLetter","monoms","Monom","_equation","_variable","_EquationSolver_instances","makeApproximativeSolution_fn","makeSolution_fn","solveByFactorization_fn","solveCubic_CardanFormula_fn","solveLinear_fn","solveQuadratic_fn","solveQuadratic_Output_fn","_EquationSolver","left","right","variable","equ","output","fraction","solutions","lcm","dividersA","dividersB","da","db","solver","an","bn","cn","q","delta","x1","x2","pv","qv","anv","delta2","f1","f2","deltaFactor","gcd","b2","a2","deltaGcd","deltaK1","deltaK2","texOutput","displayOutput","EquationSolver","wrapParenthesis","str","tex","replace_in_array","haystack","search","start","end","index","_factors","_monoms","_roots","_rootsCache","_compare","_divideByFraction","_divideByInteger","_factorize2ndDegree","_genDisplay","_getAllPotentialFactors","_multiplyByFraction","_multiplyByInteger","_multiplyByMonom","_multiplyByPolynom","_Polynom_instances","parseString_fn","_shutingYardToReducedPolynom","_shutingYard_addToken","_Polynom","polynomString","numerator","denominator","dP","quotient","reminder","maxMP","degreeP","newM","MaxIteration","monom","factors","tempPolynom","securityLoop","maxDegree","allDividers","pX","pC","dX","dC","denominators","numerators","valuesA","valuesB","pString","zero","Ms","j","revert","otherLetters","resultPolynom","cP1","cP2","m1","nbF","P1","P2","factor","xPolynom","xFactors","xyzPolynom","forceSign","wrapParentheses","withAllMultiplicationSign","m2","m1d","m2d","rootsArray","roots","zeroes","signs","idx","zeroIndex","Polynom","_displayMode","_polynom","_power","_singleMode","_Factor","power","base","num","den","tos","Factor","FACTOR_DISPLAY","FACTOR_DISPLAY2","_PolyFactor_static","gcdWith_fn","_PolyFactor_instances","extractNumeratorAndDenominator_fn","_PolyFactor","numTeX","denTeX","PF","pf","acc","dPF","length","first","polynom","self","PF1","PF2","keyFactors","factors1","factors2","power2","PolyFactor","kF","_left","_right","_sign","_findSign","_formatSign","_reverseSign","_Equation","equationString","strSign","pStr","p1","p2","mMove","cMove","allLeft","move","signStr","solutionAsTex","uniqueSolutions","sol","Equation","_equations","_variables","_findLetters","_makeMatrix","_LinearSystem","equations","operators","equStr","equArray","operatorsColumns","eq1","eq2","factor1","factor2","eq1multiplied","eq2multiplied","matrix","vector","augmentedMatrix","row","pivot","cols","vars","LS","LinearSystem","areVectorsEquals","v1","v2","areVectorsColinears","dotProduct","determinant","_array","_asPoint","_Vector","norm","scalar","sharp","radian","components","B","V1","V2","Vector","randomBool","percent","randomInt","exclude","randomIntSym","max","randomPrime","randomItem","randomArray","number","shuffleArray","temp","Point","nbs","LinePropriety","_reduceBeforeDisplay","_b","_c","_OA","_d","_n","_outputMode","_Line","pt","maxIterationTest","formattedValues","elem","orientation","line","Pt","isParallel","isSame","canonical","pt1","pt2","d2","iPt","Line","_center","_squareRadius","_cartesian","_tangentsThroughOnePointOnTheCircle","_tangentsThroughOnePointOutsideTheCircle","_tangentsWithSlope","_Circle_instances","reset_fn","calculateCartesian_fn","parseCopyCircle_fn","parseCenterAndRadius_fn","parseCenterAndPointThrough_fn","parseEquation_fn","_Circle","distance","radius","intersectionPoints","equX","lineX","lineY","numberIsInteger","points","triplet","CT","cx_px","cy_py","polyLeft","polyRight","slope","c1","c2","sq","cx","cy","square","circle","center","pointThrough","y2","y1","Circle","_A","_B","_C","_lines","_middles","_remarquables","_updateTriangle","_getPointByName","_getSegment","_calculateRemarquableLines","_calculateBisectors","_Triangle","AB","BC","AC","intersect","ptName","ptName1","ptName2","medians","mediators","heights","bA","bB","bC","bisectors","externalBisectors","remarquables","tlines","d1","d1n","d2n","d1Equ","d2Equ","b1","Triangle","_Line3","OAx","OAy","OAz","nx","ny","nz","AP","num2","num2d2","dnum","Line3","_normal","_point","_Plane3","config","cartesian","direction","point","plane","Plane3","_values","Matrix","rndFraction","userConfig","securityCount","rndMonom","factorableConfig","rndPolynom","rndEquation","rndVector","zeroX","zeroY","rndCircle","rv","rndLine","rndLine3","Random","from","to","allowZero","_rpn","_LogicalSet_instances","evaluateAsVenn_fn","LogicalSet","ShutingyardMode","token","varStack","second","tokenSets","reference","referenceSet","Geometry","PiMath","NumExp"],"mappings":"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,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM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","x_google_ignoreList":[3]}