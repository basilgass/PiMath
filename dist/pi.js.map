{"version":3,"file":"pi.js","mappings":"mBAAO,MAAMA,EACTC,aAAaC,EAAcC,EAAgB,GACvC,OAAOC,OAAOC,KAAKC,MAAMF,OAAOF,EAAM,IAAIC,IAAW,KAAKA,GAO9DF,aAAaM,GACT,IAAIC,EAAkB,CAAC,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,K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","sources":["webpack://pimath/./src/maths/numeric.ts","webpack://pimath/./src/maths/shutingyard.ts","webpack://pimath/./src/maths/random/randomCore.ts","webpack://pimath/./src/maths/coefficients/fraction.ts","webpack://pimath/./src/maths/algebra/monom.ts","webpack://pimath/./src/maths/random/rndMonom.ts","webpack://pimath/./src/maths/algebra/polynom.ts","webpack://pimath/./src/maths/random/rndPolynom.ts","webpack://pimath/./src/maths/random/rndHelpers.ts","webpack://pimath/./src/maths/random/index.ts","webpack://pimath/./src/maths/algebra/index.ts","webpack://pimath/./src/maths/geometry/index.ts","webpack://pimath/./src/maths/coefficients/nthroot.ts","webpack://pimath/./src/maths/algebra/equation.ts","webpack://pimath/./src/maths/algebra/linearSystem.ts","webpack://pimath/./src/maths/algebra/logicalset.ts","webpack://pimath/./src/maths/algebra/rational.ts","webpack://pimath/./src/maths/geometry/vector.ts","webpack://pimath/./src/maths/geometry/point.ts","webpack://pimath/./src/maths/geometry/line.ts","webpack://pimath/./src/maths/geometry/triangle.ts","webpack://pimath/./src/maths/geometry/circle.ts","webpack://pimath/./src/main.ts"],"sourcesContent":["export class Numeric{\r\n    static round(value:number, decimals:number=2):number {\r\n        return Number(Math.round(Number(value+'e'+decimals))+'e-'+decimals);\r\n    }\r\n\r\n    /**\r\n     * Get the list of the nth first prime numbers.\r\n     * @param nb : number of primes to choose from\r\n     */\r\n    static prime(nb?:number):number[]{\r\n        let primes:number[] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973];\r\n        if(nb === undefined){\r\n            return primes;\r\n        }else{\r\n            return primes.slice(0,Math.max(primes.length,nb));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the list of all dividers of a number.\r\n     * @param value\r\n     */\r\n    static dividers(value:number):number[]{\r\n        let D: number[];\r\n        const maxV = Math.sqrt(Math.abs(value));\r\n\r\n        // Initialize the list of dividers.\r\n        D = [];\r\n\r\n        for(let i=1; i<=maxV; i++){\r\n            if(value%i===0){\r\n                D.push(i);\r\n                D.push(value/i);\r\n            }\r\n        }\r\n\r\n        // Order numbers.\r\n        D.sort(function(a, b){return a-b;});\r\n\r\n        // Make sure the array of value is unique.\r\n        return [...new Set(D)];\r\n    }\r\n    /**\r\n     * Great Common Divisor\r\n     * @param values : number values\r\n     */\r\n    static gcd(...values:number[]):number{\r\n        // Define the gcd for two number\r\n        let gcd2 = function(a:number,b:number):number{\r\n            if(b===0){return a;}\r\n            return gcd2(b, a%b);\r\n        };\r\n\r\n        let g:number = 1,\r\n            i:number = 2;\r\n\r\n        // Nothing is given\r\n        if(values.length===0){return 1;}\r\n        // Only one number is given\r\n        if(values.length===1){\r\n            // The first number is zero\r\n            if(values[0]===0){return 1;}\r\n            // Return the number\r\n            return values[0];\r\n        }\r\n\r\n        // We have at least 2 numbers.\r\n        g = gcd2(values[0],values[1]);\r\n\r\n        // The gcd of the two first value is one ? It's already finished.\r\n        if(g===1){return 1;}\r\n\r\n        // The current gcd isn't one. Continue with all next values.\r\n        for(i=2; i<values.length; i++){\r\n            g = gcd2(g, values[i]);\r\n            // Escape if gcd is already one.\r\n            if(g===1){break;}\r\n        }\r\n\r\n        return Math.abs(g);\r\n    }\r\n\r\n    /**\r\n     * Least Common Multiple\r\n     * @param values: list of numbers\r\n     */\r\n    static lcm(...values:number[]):number{\r\n        return values.reduce(function(a,b){\r\n            return Math.abs(a * b / Numeric.gcd(a, b));\r\n        });\r\n    }\r\n}","type tokenType = {\r\n    [key: string]: {\r\n        precedence: number,\r\n        associative: string\r\n    }\r\n}\r\n\r\nexport class Shutingyard {\r\n    private _rpn: { token: string, tokenType: string }[] = [];\r\n    readonly _mode: 'polynom' | 'set';\r\n    private _tokenConfig: tokenType;\r\n    private _uniformize: boolean;\r\n\r\n    constructor(mode?: 'polynom' | 'set') {\r\n        this._mode = typeof mode === 'undefined' ? 'polynom' : mode;\r\n        this.tokenConfigInitialization()\r\n    }\r\n\r\n    /**\r\n     * Determin if the token is a defined operation\r\n     * Defined operations: + - * / ^ sin cos tan\r\n     * @param token\r\n     */\r\n    isOperation(token: string): boolean {\r\n        if (token[0].match(/[+\\-*/^]/g)) {\r\n            return true;\r\n        }\r\n        //\r\n        // if (token.match(/^sin|cos|tan/g)) {\r\n        //     return true;\r\n        // }\r\n\r\n        return false;\r\n    }\r\n\r\n    tokenConfigInitialization(): tokenType {\r\n        if (this._mode === 'set') {\r\n            this._tokenConfig = {\r\n                '&': {precedence: 3, associative: 'left'},\r\n                '|': {precedence: 3, associative: 'left'},\r\n                '!': {precedence: 4, associative: 'right'},\r\n                '-': {precedence: 2, associative: 'left'}\r\n            }\r\n            this._uniformize = false;\r\n        } else {\r\n            this._tokenConfig = {\r\n                '^': {precedence: 4, associative: 'right'},\r\n                '*': {precedence: 3, associative: 'left'},\r\n                '/': {precedence: 3, associative: 'left'},\r\n                '+': {precedence: 2, associative: 'left'},\r\n                '-': {precedence: 2, associative: 'left'},\r\n                '%': {precedence: 3, associative: 'right'},\r\n                'sin': {precedence: 4, associative: 'right'},\r\n                'cos': {precedence: 4, associative: 'right'},\r\n                'tab': {precedence: 4, associative: 'right'},\r\n            }\r\n            this._uniformize = true\r\n        }\r\n        return this._tokenConfig\r\n    }\r\n\r\n    /**\r\n     * Get the next token to analyse.\r\n     * @param expr (string) Expression to analyse\r\n     * @param start (number) CUrrent position in the expr string.\r\n     */\r\n    NextToken2(expr: string, start: number): [string, number, string] {\r\n        let token: string, tokenType: string;\r\n        token = '';\r\n        tokenType = '';\r\n        // Case of parenthesis or comma (generic items)\r\n        if (expr[start] === '(') {\r\n            token = '(';\r\n            tokenType = '(';\r\n        }\r\n        // It's a closing parenthese\r\n        else if (expr[start] === ')') {\r\n            token = ')';\r\n            tokenType = ')';\r\n        }\r\n        // It's an argument separator for a function\r\n        else if (expr[start] === ',') {\r\n            token = ',';\r\n            tokenType = 'function-argument';\r\n        } else{\r\n            // Order token keys by token characters length (descending)\r\n            const keys = Object.keys(this._tokenConfig).sort((a,b)=>b.length-a.length)\r\n\r\n            for(let key of keys){\r\n                if(expr.substr(start, key.length) === key){\r\n                    token += key;\r\n                    tokenType = 'operation'\r\n                    break\r\n                }\r\n            }\r\n\r\n            if(token===''){\r\n                // No function found ! Might be a coefficient !\r\n                if( expr[start].match(/[0-9]/) ) {\r\n                    token = expr.substr(start).match(/^([0-9.,/]+)/)[0]\r\n                    tokenType = 'coefficient'\r\n                }else if (expr[start].match(/[a-zA-Z]/)) {\r\n                    token = expr.substr(start).match(/^([a-zA-Z])/)[0]\r\n                    tokenType = 'variable'\r\n                }else{\r\n                    console.log('Unidentified token', expr[start], expr, start)\r\n                    token = expr[start]\r\n                    tokenType = 'monom'\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n\r\n        // console.log(token, tokenType)\r\n        return [token, start + token.length, tokenType];\r\n    }\r\n\r\n    NextToken(expr: string, start: number): [string, number, string] {\r\n        let tokenMatch: string[], token: string, tokenType: string;\r\n\r\n        this.NextToken2(expr, start)\r\n        // Detect a fraction monoms or return empty array\r\n        tokenMatch = (expr.substr(start).match(/^[0-9/a-zA-Z^]+/g)) || [];\r\n\r\n        if (expr.substr(start, start + 3).match(/^(sin|cos|tan)/g)) {\r\n            token = expr.substr(start, 3)\r\n            tokenType = 'function'\r\n        } else if (tokenMatch.length > 0) {\r\n            token = tokenMatch[0];\r\n            tokenType = 'monom';\r\n        }\r\n        // It's an operation !\r\n        else if (expr[start].match(/[+\\-*/^]/g)) {\r\n            token = expr[start];\r\n            tokenType = 'operation';\r\n        } else if (expr[start].match(/[&|!]/g)) {\r\n            token = expr[start];\r\n            tokenType = 'operation';\r\n        }\r\n        // It's an opening parenthese\r\n        else if (expr[start] === '(') {\r\n            token = '(';\r\n            tokenType = '(';\r\n        }\r\n        // It's a closing parenthese\r\n        else if (expr[start] === ')') {\r\n            token = ')';\r\n            tokenType = ')';\r\n        }\r\n        // It's an argument separator for a function\r\n        else if (expr[start] === ',') {\r\n            token = ',';\r\n            tokenType = 'function-argument';\r\n        }\r\n        // It's a monom.\r\n        else {\r\n            // TODO: Actually, negative exposant aren't supported.\r\n            // token = (expr.substr(start).match(/^[\\da-z\\^]+/g)[0])||'';\r\n            token = tokenMatch[0];\r\n            tokenType = 'monom';\r\n\r\n            if (token === '') {\r\n                token = expr[start];\r\n                tokenType = 'monom';\r\n                console.log('SHUTING YARD - NEXT TOKEN: error at ', start);\r\n            }\r\n        }\r\n\r\n        // console.log(token, start + token.length, tokenType);\r\n        return [token, start + token.length, tokenType];\r\n    }\r\n\r\n    /**\r\n     * Sanitize an expression by adding missing common operation (multiplication between parentheseses)\r\n     * @param expr\r\n     * @constructor\r\n     */\r\n    Uniformizer(expr: string): string {\r\n        // Determiner if need to be uniformized\r\n        if(!this._uniformize){return expr}\r\n\r\n        let expr2;\r\n        // Replace missing multiplication between two parenthese\r\n        expr2 = expr.replace(/\\)\\(/g, ')*(');\r\n\r\n        // Replace missing multiplication between number or setLetter and parenthese.\r\n\r\n        // 3x(x-4) => 3x*(x-4)\r\n        expr2 = expr2.replace(/([\\da-zA-Z])(\\()/g, \"$1*$2\");\r\n\r\n        // (x-4)3x => (x-4)*3x\r\n        expr2 = expr2.replace(/(\\))([\\da-zA-Z])/g, \"$1*$2\");\r\n\r\n        // Add multiplication between number and letters.\r\n        // 3x => 3*x\r\n        expr2 = expr2.replace(/([0-9])([a-zA-Z])/g, \"$1*$2\");\r\n        expr2 = expr2.replace(/([a-zA-Z])([0-9])/g, \"$1*$2\");\r\n\r\n        // Add multiplication between letters ?\r\n        // TODO: More robust solution to handle all letters ?\r\n        expr2 = expr2.replace(/([abcxyz])([abcxyz])/g, \"$1*$2\");\r\n\r\n        // Restore operation auto formating (prevent adding the mutliplcation star)\r\n        // TODO: Accept list of functions\r\n        let fnToken = ['sin', 'cos', 'tan']\r\n        for (let token of fnToken) {\r\n            expr2 = expr2.replace(new RegExp(token + '\\\\*', 'g'), token);\r\n        }\r\n\r\n        return expr2;\r\n    }\r\n\r\n    /**\r\n     * Parse an expression using the shutting yard tree algorithms\r\n     * @param expr (string) Expression to analyse\r\n     * Returns a RPN list of items.\r\n     * @param operators\r\n     */\r\n    parse(expr: string, operators?: string[]): Shutingyard {\r\n        let outQueue: {token:string, tokenType: string}[] = [],    // Output queue\r\n            opStack: {token:string, tokenType: string}[] = [],     // Operation queue\r\n            token: string = '',\r\n            tokenPos: number = 0,\r\n            tokenType: string = '',\r\n            previousOpStatckLength = 0\r\n\r\n        expr = this.Uniformizer(expr);\r\n\r\n        let securityLoopLvl1 = 50,\r\n            securityLoopLvl2_default = 50,\r\n            securityLoopLvl2;\r\n\r\n        while (tokenPos < expr.length) {\r\n            securityLoopLvl1--;\r\n            if (securityLoopLvl1 === 0) {\r\n                console.log('SECURITY LEVEL 1 EXIT');\r\n                break;\r\n            }\r\n\r\n            // Get the next token and the corresponding new (ending) position\r\n            [token, tokenPos, tokenType] = this.NextToken2(expr, tokenPos);\r\n\r\n            switch (tokenType) {\r\n                case 'monom':\r\n                case 'coefficient':\r\n                case 'variable':\r\n                    outQueue.push({\r\n                        token,\r\n                        tokenType\r\n                    });\r\n                    // if(previousOpStatckLength == opStack.length && outQueue.length>=2){\r\n                    //     console.log('opStatckLength', outQueue, opStack.length)\r\n                    //     outQueue.push('*')\r\n                    // }\r\n                    break;\r\n                case 'operation':\r\n                    previousOpStatckLength = opStack.length;\r\n                    //If the token is an operator, o1, then:\r\n                    if (opStack.length > 0) {\r\n                        let opTop = opStack[opStack.length - 1];\r\n\r\n\r\n                        securityLoopLvl2 = +securityLoopLvl2_default;\r\n\r\n                        //while there is an operator token o2, at the top of the operator stack and\r\n                        while (opTop.token in this._tokenConfig && (\r\n                                //either o1 is left-associative and its precedence is less than or equal to that of o2,\r\n                                (this._tokenConfig[token].associative === 'left' && this._tokenConfig[token].precedence <= this._tokenConfig[opTop.token].precedence)\r\n                                ||\r\n                                //or o1 is right associative, and has precedence less than that of o2,\r\n                                (this._tokenConfig[token].associative === 'right' && this._tokenConfig[token].precedence < this._tokenConfig[opTop.token].precedence)\r\n                            )\r\n                            ) {\r\n\r\n                            /* Security exit ! */\r\n                            securityLoopLvl2--;\r\n                            if (securityLoopLvl2 === 0) {\r\n                                console.log('SECURITY LEVEL 2 OPERATION EXIT');\r\n                                break;\r\n                            }\r\n\r\n                            // Add the operation to the queue\r\n                            outQueue.push((opStack.pop()) || {token: '', tokenType: 'operation'});\r\n\r\n                            // Get the next operation on top of the Stack.\r\n                            if(opStack.length===0){break;}\r\n                            opTop = opStack[opStack.length - 1];\r\n                        }\r\n                    }\r\n                    //at the end of iteration push o1 onto the operator stack\r\n                    opStack.push({token,tokenType});\r\n                    break;\r\n                case 'function-argument':\r\n                    // TODO: check if the opStack exist.\r\n                    securityLoopLvl2 = +securityLoopLvl2_default;\r\n                    while (opStack[opStack.length - 1].token !== '(' && opStack.length > 0) {\r\n                        securityLoopLvl2--;\r\n                        if (securityLoopLvl2 === 0) {\r\n                            console.log('SECURITY LEVEL 2 FUNCTION ARGUMENT EXIT');\r\n                            break;\r\n                        }\r\n\r\n                        outQueue.push((opStack.pop()) || {token,tokenType});\r\n                    }\r\n                    break;\r\n                case '(':\r\n                    opStack.push({token,tokenType});\r\n                    // Add an empty value if next element is negative.\r\n                    if (expr[tokenPos] === '-') {\r\n                        outQueue.push({token: '0', tokenType: 'coefficient'});\r\n                    }\r\n                    break;\r\n                case ')':\r\n                    securityLoopLvl2 = +securityLoopLvl2_default;\r\n                    //Until the token at the top of the stack is a left parenthesis, pop operators off the stack onto the output queue.\r\n                    while (opStack[opStack.length - 1].token !== '(' && opStack.length > 1 /*Maybe zero !? */) {\r\n                        securityLoopLvl2--;\r\n                        if (securityLoopLvl2 === 0) {\r\n                            console.log('SECURITY LEVEL 2 CLOSING PARENTHESE EXIT');\r\n                            break;\r\n                        }\r\n\r\n                        outQueue.push((opStack.pop()) || {token,tokenType});\r\n                    }\r\n\r\n                    //Pop the left parenthesis from the stack, but not onto the output queue.\r\n                    opStack.pop();\r\n                    break;\r\n                case 'function':\r\n                    opStack.push({token, tokenType});\r\n                    break;\r\n                default:\r\n                    // In theory, everything should be handled.\r\n                    console.log(`SHUTING YARD: ${tokenType} : ${token} `);\r\n            }\r\n\r\n            // Output\r\n            // console.log(outQueue.concat(opStack.reverse()).join(\" \"));\r\n        }\r\n\r\n        // console.log(outQueue.concat(opStack.reverse()));\r\n        this._rpn = outQueue.concat(opStack.reverse());\r\n\r\n        return this;\r\n    }\r\n\r\n\r\n    // Getter\r\n    get rpn() {\r\n        // console.log(this._rpn)\r\n        return this._rpn;\r\n    }\r\n\r\n\r\n}\r\n","export class randomCore {\r\n    protected _config: Object\r\n    protected _defaultConfig: Object\r\n    mergeConfig = (config: Object, defaultConfig: Object): Object => {\r\n        if (config !== undefined) {\r\n            return {...defaultConfig, ...config}\r\n        }\r\n        return defaultConfig\r\n    }\r\n\r\n    generate = (): unknown => {\r\n        return undefined\r\n    }\r\n\r\n    config = (config: Object): randomCore => {\r\n        this._config = this.mergeConfig(config, this._defaultConfig)\r\n        return this\r\n    }\r\n}","import {Numeric} from \"../numeric\";\r\n\r\nexport class Fraction {\r\n    private _numerator: number;\r\n    private _denominator: number;\r\n\r\n    constructor(value?: any, denominatorOrPeriodic?: number) {\r\n        this._numerator = 1;\r\n        this._denominator = 1;\r\n\r\n        if (value !== undefined) {\r\n            this.parse(value, denominatorOrPeriodic);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    get isFraction() {\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n\r\n    get numerator(): number {\r\n        return this._numerator;\r\n    }\r\n\r\n    set numerator(value: number) {\r\n        this._numerator = value;\r\n    }\r\n\r\n    get denominator(): number {\r\n        return this._denominator;\r\n    }\r\n\r\n    set denominator(value: number) {\r\n        this._denominator = value;\r\n    }\r\n\r\n    get value(): number {\r\n        return this._numerator / this._denominator;\r\n    }\r\n\r\n    // Display getter\r\n    get tex(): string {\r\n        if (this._denominator === 1) {\r\n            return `${this._numerator}`;\r\n        } else if (this._numerator < 0) {\r\n            return `-\\\\frac{ ${-this._numerator} }{ ${this._denominator} }`;\r\n        } else {\r\n            return `\\\\frac{ ${this._numerator} }{ ${this._denominator} }`;\r\n        }\r\n    }\r\n\r\n    get display(): string {\r\n        if (this._denominator === 1) {\r\n            return `${this._numerator}`;\r\n        } else {\r\n            return `${this._numerator}/${this._denominator}`;\r\n        }\r\n    }\r\n\r\n    // Helper function to display fractions\r\n    get frac(): string {\r\n        return this.tex;\r\n    }\r\n\r\n    get dfrac(): string {\r\n        return this.tex.replace('\\\\frac', '\\\\dfrac');\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse the value to get the numerator and denominator\r\n     * @param value : number or string to parse to get the fraction\r\n     * @param denominatorOrPeriodic (optional|number) : length of the periodic part: 2.333333 => 1 or denominator value\r\n     */\r\n    parse = (value: any, denominatorOrPeriodic?: number): Fraction => {\r\n        let S: string[];\r\n\r\n        // A null value means a zero fraction.\r\n        if (value === null || value === \"\") {\r\n            this._numerator = 0;\r\n            this._denominator = 1;\r\n            return this;\r\n        }\r\n\r\n        switch (typeof value) {\r\n            case \"string\":\r\n                // Split the sting value in two parts: Numerator/Denominator\r\n                S = value.split('/');\r\n\r\n                // Security checks\r\n                    if (S.length > 2) throw \"Two many divide signs\";\r\n                    if (S.map(x => x === '' || isNaN(Number(x))).includes(true)) throw \"Not a number\"\r\n\r\n\r\n                if (S.length === 1) {\r\n                    // No divide sign\r\n                    return this.parse(+S[0]);\r\n                } else if (S.length === 2) {\r\n                    // One divide signe\r\n                    // We check if the denominator is zero\r\n                    if (S[1] === '0') {\r\n                        this._numerator = NaN;\r\n                        this._denominator = 1;\r\n                    } else {\r\n                        this._numerator = +S[0];\r\n                        this._denominator = +S[1];\r\n                    }\r\n                } else {\r\n                    // More than one divide sign ?\r\n                    this._numerator = NaN;\r\n                    this._denominator = 1;\r\n                }\r\n                break;\r\n            case \"number\":\r\n                if (Number.isSafeInteger(value)) {\r\n                    // The given value is an integer\r\n                    this._numerator = +value;\r\n\r\n                    if (denominatorOrPeriodic === undefined || !Number.isSafeInteger(denominatorOrPeriodic)) {\r\n                        this._denominator = 1;\r\n                    } else {\r\n                        this._denominator = +denominatorOrPeriodic;\r\n                    }\r\n                } else {\r\n                    // The given value is a float number\r\n\r\n                    // Get the number of decimals after the float sign\r\n                    let p: number = (value.toString()).split('.')[1].length;\r\n\r\n                    // Transform the float number in two integer\r\n                    if (denominatorOrPeriodic === undefined) {\r\n                        this._numerator = value * Math.pow(10, p);\r\n                        this._denominator = Math.pow(10, p);\r\n                    } else if (Number.isSafeInteger(denominatorOrPeriodic)) {\r\n                        this._numerator = value * Math.pow(10, p) - Math.floor(value * Math.pow(10, p - denominatorOrPeriodic));\r\n                        this.denominator = Math.pow(10, p) - Math.pow(10, p - denominatorOrPeriodic)\r\n                    }\r\n                }\r\n                break;\r\n            case \"object\":\r\n                if (value.isFraction) {\r\n                    this._numerator = +value.numerator;\r\n                    this._denominator = +value.denominator;\r\n                }\r\n                break;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    clone = (): Fraction => {\r\n        let F = new Fraction();\r\n        F.numerator = +this._numerator;\r\n        F.denominator = +this._denominator;\r\n        return F;\r\n    };\r\n\r\n    zero = (): Fraction => {\r\n        this._numerator = 0;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    one = (): Fraction => {\r\n        this._numerator = 1;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    infinite = (): Fraction => {\r\n        this._numerator = Infinity;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    invalid = (): Fraction => {\r\n        this._numerator = NaN;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    opposed = (): Fraction => {\r\n        this._numerator = -this._numerator;\r\n        return this;\r\n    };\r\n\r\n    add = (F: Fraction): Fraction => {\r\n        let N: number = this._numerator,\r\n            D: number = this._denominator;\r\n\r\n        this._numerator = N * F.denominator + F.numerator * D;\r\n        this._denominator = D * F.denominator;\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    subtract = (F: Fraction): Fraction => {\r\n        return this.add(F.clone().opposed());\r\n    };\r\n\r\n    multiply = (F: Fraction | number): Fraction => {\r\n        // Parse the value.\r\n        // If it's a fraction, return a clone of it\r\n        // If it's an integer, return the fraction F/1\r\n        let Q = new Fraction(F);\r\n\r\n        this._numerator = this._numerator * Q.numerator;\r\n        this._denominator = this._denominator * Q.denominator;\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    divide = (F: Fraction | number): Fraction => {\r\n        let Q = new Fraction(F);\r\n\r\n        if (Q.numerator === 0) {\r\n            return new Fraction().infinite();\r\n        }\r\n\r\n        let N: number = +this._numerator,\r\n            D: number = +this._denominator;\r\n\r\n        this._numerator = N * Q.denominator;\r\n        this._denominator = D * Q.numerator;\r\n        return this.reduce();\r\n    };\r\n\r\n    invert = (): Fraction => {\r\n        let n = +this._numerator, d = +this._denominator;\r\n        this._numerator = d;\r\n        this._denominator = n;\r\n\r\n        return this;\r\n    }\r\n    pow = (p: number): Fraction => {\r\n        if (!Number.isSafeInteger(p)) {\r\n            return this.invalid();\r\n        }\r\n        this.reduce();\r\n\r\n        if (p < 0) {\r\n            this.invert()\r\n        }\r\n\r\n        this._numerator = this._numerator ** Math.abs(p);\r\n        this._denominator = this._denominator ** Math.abs(p);\r\n        return this;\r\n    };\r\n\r\n    root = (p: number): Fraction => {\r\n        // TODO: nth - root of a fraction => this will return another type of coefficient.\r\n\r\n        // Check if they are perfect roots..\r\n        if (p === 0) {\r\n            return this;\r\n        }\r\n\r\n        // If negative, invert the fraction\r\n        if (p < 0) {\r\n            this.invert()\r\n        }\r\n\r\n        let n = Math.pow(this._numerator, Math.abs(1 / p)),\r\n            d = Math.pow(this._denominator, Math.abs(1 / p));\r\n\r\n        this._numerator = Math.pow(this._numerator, Math.abs(1 / p));\r\n        this._denominator = Math.pow(this._denominator, Math.abs(1 / p));\r\n        return this;\r\n    }\r\n\r\n    sqrt = (): Fraction => {\r\n        return this.root(2);\r\n    }\r\n\r\n    abs = (): Fraction => {\r\n        this._numerator = Math.abs(this._numerator);\r\n        this._denominator = Math.abs(this._denominator);\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations specific to fractions\r\n    // ------------------------------------------\r\n    reduce = (): Fraction => {\r\n        let g = Numeric.gcd(this._numerator, this._denominator);\r\n        this._numerator = this._numerator / g;\r\n        this._denominator = this._denominator / g;\r\n\r\n        if (this._denominator < 0) {\r\n            this._denominator = -this._denominator;\r\n            this._numerator = -this._numerator;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    amplify = (k: number): Fraction => {\r\n        if (Number.isSafeInteger(k)) {\r\n            this._numerator *= k;\r\n            this._denominator *= k;\r\n        }\r\n        return this;\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Compare the current coefficient with another coefficient\r\n     * @param F (Coefficient) The coefficient to compare\r\n     * @param sign (string| default is =): authorized values: =, <, <=, >, >= with some variations.\r\n     */\r\n    compare = (F: Fraction, sign?: string): boolean => {\r\n        if (sign === undefined) {\r\n            sign = '=';\r\n        }\r\n\r\n\r\n        switch (sign) {\r\n            case '>':\r\n                return this.value > F.value;\r\n            case \">=\" || \"=>\" || \"geq\":\r\n                return this.value >= F.value;\r\n            case \"<\":\r\n                return this.value < F.value;\r\n            case \"<=\" || \"=>\" || \"leq\":\r\n                return this.value <= F.value;\r\n            case \"=\":\r\n                // let F2: Fraction = F.clone().reduce(),\r\n                //     F1: Fraction = this.clone().reduce();\r\n                // return (F1.numerator === F2.numerator && F1.denominator === F2.denominator);\r\n                return this.value === F.value;\r\n            case \"<>\":\r\n                return this.value !== F.value;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /* Compare shortcuts */\r\n    lesser = (than: Fraction): Boolean => {\r\n        return this.compare(than, '<');\r\n    };\r\n    leq = (than: Fraction): Boolean => {\r\n        return this.compare(than, '<=');\r\n    };\r\n    greater = (than: Fraction): Boolean => {\r\n        return this.compare(than, '>');\r\n    };\r\n    geq = (than: Fraction): Boolean => {\r\n        return this.compare(than, '>=');\r\n    };\r\n    isEqual = (than: Fraction): boolean => {\r\n        return this.compare(than, '=');\r\n    }\r\n    isDifferent = (than: Fraction): boolean => {\r\n        return this.compare(than, '<>');\r\n    }\r\n    isOpposed = (p: Fraction): boolean => {\r\n        return this.isEqual(p.clone().opposed());\r\n    }\r\n    isInverted = (p: Fraction): boolean => {\r\n        return this.isEqual(new Fraction().one().divide(p.clone()));\r\n    }\r\n    isZero = (): boolean => {\r\n        return this._numerator === 0;\r\n    }\r\n    isOne = (): boolean => {\r\n        return this._numerator === 1 && this._denominator === 1;\r\n    }\r\n    isPositive = (): boolean => {\r\n        return this.sign()===1;\r\n    }\r\n    isNegative = (): boolean => {\r\n        return this.sign()===-1;\r\n    }\r\n    isNaN = (): boolean => {\r\n        return isNaN(this._numerator);\r\n    }\r\n    isInfinity = (): boolean => {\r\n        return this._numerator === Infinity;\r\n    }\r\n    isFinite = (): boolean => {\r\n        return !this.isInfinity();\r\n    }\r\n    isSquare = (): boolean => {\r\n        return Math.sqrt(this._numerator) % 1 === 0 && Math.sqrt(this._denominator) % 1 === 0\r\n    }\r\n    isReduced = (): boolean => {\r\n        return Math.abs(Numeric.gcd(this._numerator, this._denominator))===1\r\n    }\r\n    sign = (): number => {\r\n        return (this._numerator * this._denominator >= 0) ? 1 : -1;\r\n    };\r\n\r\n\r\n    // TODO: The rest of the functions are not used or unnecessary ?\r\n    /**\r\n     * Simple function to determine if it's a fraction\r\n     */\r\n    areEquals = (...F: Fraction[]): boolean => {\r\n        for (let i = 0; i < F.length; i++) {\r\n            if (!this.isEqual(F[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n}","/***\r\n * Monom class\r\n * Defined as coefficient * literal\r\n * Examples: 3x^2, 3/5x^2, ...\r\n */\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Numeric} from \"../numeric\";\r\n\r\n    export class Monom {\r\n        private _coefficient: Fraction;\r\n        private _literal: { [Key: string]: number };\r\n\r\n        /**\r\n         * Create the monom object.\r\n         * @param value (optional) string\r\n         */\r\n        constructor(value?: string) {\r\n            this.zero();\r\n\r\n            if (value !== undefined) {\r\n                // A string is given - try to parse the value.\r\n                this.parse(value);\r\n            }\r\n\r\n            return this;\r\n        }\r\n\r\n        // ------------------------------------------\r\n        // Getter and setter\r\n        // ------------------------------------------\r\n        get isMonom() {\r\n            return true;\r\n        }\r\n\r\n        /**\r\n         * Get the coefficient as fraction\r\n         */\r\n        get coefficient(): Fraction {\r\n            return this._coefficient;\r\n        }\r\n\r\n        /**\r\n         * Set the coefficient value of the monom\r\n         * @param F     Fraction\r\n         */\r\n        set coefficient(F: Fraction) {\r\n            this._coefficient = F;\r\n        }\r\n\r\n        /**\r\n         * Get the literal part, as dictionary\r\n         */\r\n        get literal(): { [Key: string]: number } {\r\n            return this._literal;\r\n        }\r\n\r\n        get literalSqrt(): { [Key: string]: number } {\r\n\r\n            if (this.isLitteralSquare()) {\r\n                let L: { [Key: string]: number } = {}\r\n                for (let key in this._literal) {\r\n                    L[key] = this._literal[key] / 2\r\n                }\r\n                return L;\r\n            } else {\r\n                return this._literal;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Set the literal part of the monom\r\n         * @param L     Literal part as dictionary: <setLetter: exposant>\r\n         */\r\n        set literal(L: { [Key: string]: number }) {\r\n            this._literal = L;\r\n        }\r\n\r\n        /**\r\n         * Set the literal part of the monom from a string\r\n         * @param inputStr  String like x^2y^3\r\n         */\r\n        set literalStr(inputStr: string) {\r\n            // Match all x^n\r\n            for (const v of [...inputStr.matchAll(/([a-z])\\^([+-]?[0-9]+)/g)]) {\r\n                if (!(v[1] in this._literal)) {\r\n                    this._literal[v[1]] = 0;\r\n                }\r\n                this._literal[v[1]] += +v[2];\r\n            }\r\n            for (const v of [...inputStr.matchAll(/([a-z](?!\\^))/g)]) {\r\n                // Match all single letters\r\n                if (!(v[1] in this._literal)) {\r\n                    this._literal[v[1]] = 0;\r\n                }\r\n                this._literal[v[1]] += 1;\r\n            }\r\n        }\r\n\r\n        // Getter heplers.\r\n        /**\r\n         * Get the variables letters\r\n         */\r\n        get variables(): string[] {\r\n            this.clone().clean();\r\n            return Object.keys(this._literal)\r\n        }\r\n\r\n        // Display getter\r\n        /**\r\n         * This display getter is to be used in the polynom display getter\r\n         */\r\n        get display(): string {\r\n            let L: string = '';\r\n            for (let letter in this._literal) {\r\n                if (this._literal[letter] !== 0) {\r\n                    L += `${letter}`;\r\n                    if (this._literal[letter] > 1) {\r\n                        L += `^${this._literal[letter]}`;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (L === '') {\r\n                // No setLetter - means it's only a number !\r\n                if (this._coefficient.value != 0) {\r\n                    return `${this._coefficient.display}`;\r\n                } else {\r\n                    return '';\r\n                }\r\n            } else {\r\n                if (this._coefficient.value === 1) {\r\n                    return L;\r\n                } else if (this._coefficient.value === -1) {\r\n                    return `-${L}`;\r\n                } else if (this._coefficient.value === 0) {\r\n                    return '0';\r\n                } else {\r\n                    return `${this._coefficient.display}${L}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        get dividers(): Monom[] {\r\n            // Decompose only if the coefficient it a complet value\r\n            if (this.coefficient.denominator !== 1) {\r\n                return [this.clone()]\r\n            }\r\n\r\n            // Security : do not do this if greater than 10000\r\n            if (this.coefficient.numerator > 10000) {\r\n                return [this.clone()]\r\n            }\r\n            const dividers = Numeric.dividers(Math.abs(this.coefficient.numerator))\r\n\r\n            // Decompose the litterals parts.\r\n            let litterals: { [key: string]: number }[] = [];\r\n            for (let L in this.literal) {\r\n                // L is the letter.\r\n                litterals = this._getLitteralDividers(litterals, L)\r\n            }\r\n\r\n            const monomDividers: Monom[] = [];\r\n            if (litterals.length > 0 && dividers.length > 0) {\r\n                for (let N of dividers) {\r\n                    for (let L of litterals) {\r\n                        let M = new Monom();\r\n                        M.coefficient = new Fraction(N)\r\n                        M.literal = L\r\n                        monomDividers.push(M)\r\n                    }\r\n                }\r\n            } else if (dividers.length === 0) {\r\n                for (let L of litterals) {\r\n                    let M = new Monom();\r\n                    M.coefficient = new Fraction().one()\r\n                    M.literal = L\r\n                    monomDividers.push(M)\r\n                }\r\n            } else {\r\n                for (let N of dividers) {\r\n                    let M = new Monom();\r\n                    M.coefficient = new Fraction(N)\r\n                    monomDividers.push(M)\r\n                }\r\n            }\r\n\r\n            return monomDividers.length === 0 ? [new Monom().one()] : monomDividers;\r\n        }\r\n\r\n        private _getLitteralDividers(arr: { [key: string]: number }[], letter: string): { [key: string]: number }[] {\r\n            let tmpList: { [key: string]: number }[] = [];\r\n\r\n            for (let d = 0; d <= this.literal[letter]; d++) {\r\n                if (arr.length === 0) {\r\n                    let litt: { [key: string]: number } = {}\r\n                    litt[letter] = d\r\n                    tmpList.push(litt)\r\n                } else {\r\n                    for (let item of arr) {\r\n                        let litt: { [key: string]: number } = {}\r\n                        for (let currentLetter in item) {\r\n                            litt[currentLetter] = item[currentLetter]\r\n                        }\r\n                        litt[letter] = d\r\n                        tmpList.push(litt)\r\n                    }\r\n                }\r\n            }\r\n            return tmpList;\r\n        }\r\n\r\n        /**\r\n         * Display the monom, forcing the '+' sign to appear\r\n         */\r\n        get displayWithSign(): string {\r\n            // TODO: Rename or remove this getter ?\r\n            let d: String = this.display;\r\n            return (d[0] !== '-' ? '+' : '') + d;\r\n        }\r\n\r\n        /**\r\n         * Get the tex output of the monom\r\n         */\r\n        get tex(): string {\r\n            let L: string = '';\r\n            for (let letter in this._literal) {\r\n                if (this._literal[letter] !== 0) {\r\n                    L += `${letter}`;\r\n                    if (this._literal[letter] > 1) {\r\n                        L += `^${this._literal[letter]}`;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (L === '') {\r\n                // No setLetter - means it's only a number !\r\n                if (this._coefficient.value != 0) {\r\n                    return `${this._coefficient.dfrac}`;\r\n                } else {\r\n                    return '0';\r\n                }\r\n            } else {\r\n                if (this._coefficient.value === 1) {\r\n                    return L;\r\n                } else if (this._coefficient.value === -1) {\r\n                    return `-${L}`;\r\n                } else if (this._coefficient.value === 0) {\r\n                    return '0';\r\n                } else {\r\n                    return `${this._coefficient.dfrac}${L}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        // ------------------------------------------\r\n        // Creation / parsing functions\r\n        // -----------------------------------------\r\n        /**\r\n         * Parse a string to a monom. The string may include fraction.\r\n         * @param inputStr\r\n         */\r\n        parse = (inputStr: string): Monom => {\r\n            // Set the literal part.\r\n            this.literalStr = inputStr;\r\n\r\n            // Get the coefficient\r\n            this._coefficient = new Fraction();\r\n\r\n            for (const v of [...inputStr.replace(/([a-z])|(\\^[+-]?[0-9]+)/g, ',').split(',')]) {\r\n                // The value is empty.\r\n                if (v.trim() === '') {\r\n                    continue;\r\n                }\r\n\r\n                // Multiple the current coefficient by the new found value.\r\n                this._coefficient.multiply(new Fraction(v.trim()));\r\n            }\r\n\r\n            return this;\r\n        };\r\n\r\n        /**\r\n         * Clone the current Monom.\r\n         */\r\n        clone = (): Monom => {\r\n            let F: Monom = new Monom();\r\n\r\n            F.coefficient = this._coefficient.clone();\r\n\r\n            // Copy the literal parts.\r\n            for (let k in this._literal) {\r\n                F.setLetter(k, this._literal[k]);\r\n            }\r\n            return F;\r\n        };\r\n\r\n        /**\r\n         * Create a zero value monom\r\n         */\r\n        zero = (): Monom => {\r\n            this._coefficient = new Fraction().zero();\r\n            this._literal = {};\r\n            return this;\r\n        };\r\n\r\n        /**\r\n         * Create a one value monom\r\n         */\r\n        one = (): Monom => {\r\n            this._coefficient = new Fraction().one();\r\n            this._literal = {};\r\n            return this;\r\n        };\r\n\r\n        /**\r\n         * Clean the monom by removing each letters with a power of zero.\r\n         */\r\n        clean = (): Monom => {\r\n            for (let letter in this._literal) {\r\n                if (this._literal[letter] === 0) {\r\n                    delete this._literal[letter];\r\n                }\r\n            }\r\n\r\n            return this;\r\n        };\r\n\r\n        // ------------------------------------------\r\n        // Mathematical operations\r\n        // ------------------------------------------\r\n\r\n        /**\r\n         * Get the opposed\r\n         * Returns a monom.\r\n         */\r\n        opposed = (): Monom => {\r\n            this._coefficient.opposed();\r\n            return this;\r\n        };\r\n\r\n        /**\r\n         * Add all similar monoms. If they aren't similar, they are simply skipped.\r\n         * @param M (Monom[]) The monoms to add.\r\n         */\r\n        add = (...M: Monom[]): Monom => {\r\n            for (let m of M) {\r\n                if (this.isSameAs(m)) {\r\n                    this._coefficient.add(m.coefficient);\r\n                } else {\r\n                    console.log('Add: Is not similar: ', m.display);\r\n                }\r\n            }\r\n            return this;\r\n        };\r\n\r\n        /**\r\n         * Subtract multiple monoms\r\n         * @param M (Monom[]) The monoms to subtract\r\n         */\r\n        subtract = (...M: Monom[]): Monom => {\r\n            for (let m of M) {\r\n                if (this.isSameAs(m)) {\r\n                    this._coefficient.add(m.coefficient.clone().opposed());\r\n                } else {\r\n                    console.log('Subtract: Is not similar: ', m.display);\r\n                }\r\n            }\r\n            return this;\r\n        };\r\n\r\n        /**\r\n         * Multiple multiple monoms to the current monom\r\n         * @param M (Monom[]) The monoms to multiply to.\r\n         */\r\n        multiply = (...M: Monom[]): Monom => {\r\n            for (let m of M) {\r\n                // Multiply the coefficient.\r\n                this._coefficient.multiply(m.coefficient);\r\n                // Multiply the literal parts.\r\n                for (let letter in m.literal) {\r\n                    this._literal[letter] = (this._literal[letter] === undefined) ? m.literal[letter] : this._literal[letter] + m.literal[letter];\r\n                }\r\n            }\r\n            return this;\r\n        };\r\n\r\n        multiplyByNumber = (F: Fraction | number): Monom => {\r\n            this._coefficient.multiply(F);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Divide the current monoms by multiple monoms\r\n         * @param M (Monom[])\r\n         */\r\n        divide = (...M: Monom[]): Monom => {\r\n            // Depending on the given value, choose the current item\r\n            for (let v of M) {\r\n                // Divide the coefficient\r\n                this._coefficient.divide(v.coefficient);\r\n\r\n                // Subtract the power values\r\n                for (let letter in v.literal) {\r\n                    this._literal[letter] = (this._literal[letter] === undefined) ? -v.literal[letter] : this._literal[letter] - v.literal[letter];\r\n\r\n                    // If the power of a particular setLetter is zero, delete it from the literal part..\r\n                    if (this._literal[letter] === 0) {\r\n                        delete this._literal[letter];\r\n                    }\r\n                }\r\n            }\r\n            return this;\r\n        };\r\n\r\n        /**\r\n         * Get the pow of a monom.\r\n         * @param nb (number) : Mathematical pow\r\n         */\r\n        pow = (nb: number): Monom => {\r\n            this._coefficient.pow(nb);\r\n            for (let letter in this._literal) {\r\n                this._literal[letter] *= nb;\r\n            }\r\n            return this;\r\n        };\r\n\r\n        /**\r\n         * Get the nth-root of the monom\r\n         * @param p\r\n         */\r\n        root = (p: number): Monom => {\r\n            // TODO: determiner the nth root of a monom\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Return the square root of a monom\r\n         */\r\n        sqrt = (): Monom => {\r\n            if (this.isSquare()) {\r\n                this._coefficient.sqrt();\r\n                for (let letter in this._literal) {\r\n                    this._literal[letter] /= 2;\r\n                }\r\n            }\r\n            return this.root(2);\r\n        }\r\n\r\n        // ------------------------------------------\r\n        // Compare functions\r\n        // ------------------------------------------\r\n        compare = (M: Monom, sign?: string): boolean => {\r\n            // TODO: Build the compare systems.\r\n            if (sign === undefined) {\r\n                sign = '=';\r\n            }\r\n\r\n\r\n            switch (sign) {\r\n                case '=':\r\n                    // To be equal, they must be the isSame\r\n                    if (!this.compare(M, 'same')) {\r\n                        return false;\r\n                    }\r\n\r\n                    // The litteral parts are the isSame. The coefficient must be equal\r\n                    return this._coefficient.isEqual(M.coefficient);\r\n                case 'same':\r\n                    // Get the list of all variables from both monoms.\r\n                    let M1: string[] = this.variables,\r\n                        M2: string[] = M.variables,\r\n                        K: string[] = M1.concat(M2.filter((item) => M1.indexOf(item) < 0));\r\n\r\n                    for (let key of K) {\r\n                        // The setLetter is not available in one of the monom\r\n                        if (this._literal[key] === undefined || M.literal[key] === undefined) {\r\n                            return false;\r\n                        }\r\n                        // The setLetter does not have the isSame power in each monoms.\r\n                        if (this._literal[key] !== M.literal[key]) {\r\n                            return false;\r\n                        }\r\n                    }\r\n\r\n                    // All are positive check - the monoms are the sames.\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Determine if the monom is null\r\n         */\r\n        isZero(): boolean {\r\n            return this._coefficient.value === 0;\r\n        }\r\n\r\n        /**\r\n         * Determine if the monom is one\r\n         */\r\n        isOne(): boolean {\r\n            return this._coefficient.value === 1 && this.variables.length === 0;\r\n        }\r\n\r\n        /**\r\n         * Determine if two monoms are equals\r\n         * @param M\r\n         */\r\n        isEqual = (M: Monom): boolean => {\r\n            return this.compare(M, '=');\r\n        };\r\n\r\n        /**\r\n         * Determine if two monoms are similar\r\n         * @param M\r\n         */\r\n        isSameAs = (M: Monom): boolean => {\r\n            return this.compare(M, 'same');\r\n        };\r\n\r\n        isSquare = (): boolean => {\r\n            if (!this.coefficient.isSquare()) {\r\n                return false;\r\n            }\r\n            return this.isLitteralSquare();\r\n        }\r\n\r\n        isLitteralSquare = (): boolean => {\r\n            for (let letter in this.literal) {\r\n                if (this.literal[letter] % 2 !== 0) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        // ------------------------------------------\r\n        // Misc monoms functions\r\n        // -------------------------------------\r\n        /**\r\n         * Determine if a monom contains a setLetter in it's literal part\r\n         * @param letter\r\n         */\r\n        hasLetter = (letter?: string): boolean => {\r\n            return this._literal[letter === undefined ? 'x' : letter] > 0;\r\n        };\r\n\r\n        /**\r\n         * Set the power of a particular setLetter\r\n         * @param letter (string) Letter to change\r\n         * @param pow (number) Power of the setLetter (must be positive integer.\r\n         */\r\n        setLetter = (letter: string, pow: number): void => {\r\n            // If the power is not legal or is zero, remove the setLetter from the dict\r\n            if (pow <= 0 || !Number.isSafeInteger(pow)) {\r\n                if (this._literal[letter] !== undefined) {\r\n                    delete this._literal[letter];\r\n                }\r\n            } else {\r\n                this._literal[letter] = pow;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Get the degree of a monom. If no setLetter is given, the result will be the global degree.\r\n         * @param letter (string) Letter to get to degree (power)\r\n         */\r\n        degree = (letter?: string): number => {\r\n            if (this.variables.length === 0) {\r\n                return 0;\r\n            }\r\n            if (letter === undefined) {\r\n                // Not setLetter given -> we get the global monom degree (sum of all the letters).\r\n                return Object.values(this._literal).reduce((t, n) => t + n);\r\n            } else {\r\n                // A setLetter is given -> get the corresponding power.\r\n                return this._literal[letter] === undefined ? 0 : this._literal[letter];\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Evaluate a monom. Each setLetter must be assigned to a Fraction.\r\n         * @param values    Dictionary of <setLetter: Fraction>\r\n         */\r\n        evaluate = (values: { [key: string]: Fraction | number } | Fraction | number): Fraction => {\r\n            let r = this.coefficient.clone();\r\n\r\n            if (typeof values === 'number' || values instanceof Fraction) {\r\n                let tmpValues: { [key: string]: Fraction | number } = {}\r\n\r\n                tmpValues[this.variables[0]] = new Fraction(values)\r\n                return this.evaluate(tmpValues);\r\n            }\r\n\r\n            if (typeof values === 'object') {\r\n                for (let L in this._literal) {\r\n                    if (values[L] === undefined) {\r\n                        return new Fraction().zero();\r\n                    }\r\n                    let value = new Fraction(values[L])\r\n                    r.multiply(value.pow(this._literal[L]));\r\n                }\r\n            }\r\n            return r;\r\n        };\r\n\r\n        /**\r\n         * Derivative the monom\r\n         * @param letter\r\n         */\r\n        derivative = (letter?: string): Monom => {\r\n            // No setLetter given - assume it's the setLetter 'x'\r\n            if (letter === undefined) {\r\n                letter = 'x';\r\n            }\r\n            if (this.hasLetter(letter)) {\r\n                let d = +this._literal[letter],\r\n                    dM = this.clone();\r\n\r\n                // Subtract one to the degree.\r\n                dM._literal[letter] -= 1;\r\n\r\n                // Multiply the coefficient by the previous degree\r\n                dM._coefficient.multiply(new Fraction('' + d));\r\n                return dM;\r\n            } else {\r\n                return new Monom().zero();\r\n            }\r\n        };\r\n\r\n        primitive = (letter?: string): Monom => {\r\n            if (letter === undefined) {\r\n                letter = 'x'\r\n            }\r\n\r\n            // Zero monom\r\n            let M = this.clone()\r\n\r\n            if (M.hasLetter(letter)) {\r\n                M.coefficient = M.coefficient.clone().divide(M.degree(letter) + 1)\r\n                M.setLetter(letter, M.degree(letter) + 1)\r\n            } else {\r\n                // There is no letter.\r\n\r\n                // The coefficient might be zero (=> x) or a number a (=> ax)\r\n                if (M.coefficient.isZero()) {\r\n                    M.coefficient = new Fraction().one()\r\n                }\r\n                M.setLetter(letter, 1)\r\n            }\r\n            return M\r\n        }\r\n        // ----------------------------------------\r\n        // Static functions\r\n        // ----------------------------------------\r\n\r\n        /**\r\n         * Get the least common multiple of monoms\r\n         * @param monoms    Array of monoms\r\n         */\r\n        static lcm = (...monoms: Monom[]): Monom => {\r\n            let M = new Monom(),\r\n                coeffN: number[] = monoms.map(value => value.coefficient.numerator),\r\n                coeffD: number[] = monoms.map(value => value.coefficient.denominator),\r\n                n = Numeric.gcd(...coeffN),\r\n                d = Numeric.lcm(...coeffD);\r\n\r\n            // Get the coefficient.\r\n            M.coefficient = new Fraction(n, d).reduce();\r\n\r\n            // Set the literal parts - go through each monoms literal parts and get only the lowest degree of each letters.\r\n            for (let m of monoms) {\r\n                // Remove the inexistant letters from the resulting monom\r\n                for (let letter in M.literal) {\r\n                    if (!(letter in m.literal)) {\r\n                        M.literal[letter] = 0;\r\n                    }\r\n                }\r\n                for (let letter in m.literal) {\r\n                    if (M.literal[letter] === undefined && m.literal[letter] > 0) {\r\n                        M.literal[letter] = m.literal[letter];\r\n                    } else {\r\n                        M.literal[letter] = Math.min(m.literal[letter], M.literal[letter]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return M;\r\n        };\r\n\r\n        /**\r\n         * Multiply two monoms and return a NEW monom.\r\n         * @param monoms\r\n         */\r\n        static xmultiply = (...monoms: Monom[]): Monom => {\r\n            let M = new Monom().one();\r\n\r\n            for (let m of monoms) {\r\n                M.multiply(m);\r\n            }\r\n\r\n            return M;\r\n        };\r\n\r\n\r\n        // TODO: The rest of the functions are not used or unnecessary ?\r\n        /**\r\n         * Determine if multiple monoms are similar\r\n         * @param M\r\n         */\r\n        areSameAs = (...M: Monom[]): boolean => {\r\n            let result: boolean = true;\r\n\r\n            // Check all monoms if they are the isSame as the \"this\" one.\r\n            for (let i = 0; i < M.length; i++) {\r\n                if (!this.isSameAs(M[i])) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            // All check passed -> all the monoms are similar.\r\n            return result;\r\n        };\r\n\r\n        /**\r\n         * Determine if multiple monoms are equals\r\n         * @param M\r\n         */\r\n        areEquals = (...M: Monom[]): boolean => {\r\n            // They are not similar.\r\n            if (!this.areSameAs(...M)) {\r\n                return false;\r\n            }\r\n\r\n            // Check all coefficient. They must be equals.\r\n            for (let m of M) {\r\n                if (!this._coefficient.isEqual(m.coefficient)) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            // All checks passed.\r\n            return true;\r\n        };\r\n\r\n    }\r\n","import {randomCore} from \"./randomCore\";\r\nimport {randomMonomConfig, randomPolynomConfig} from \"./rndTypes\";\r\nimport {Random} from \"./index\";\r\nimport {Monom} from \"../algebra/monom\";\r\n\r\n/**\r\n * Create a random monom based on a based configuration\r\n */\r\n    export class rndMonom extends randomCore {\r\n        declare protected _config: randomMonomConfig\r\n        declare protected _defaultConfig: randomPolynomConfig\r\n\r\n        constructor(userConfig?: randomMonomConfig) {\r\n            super();\r\n\r\n            this._defaultConfig = {\r\n                letters: 'x',\r\n                degree: 2,\r\n                fraction: true,\r\n                zero: false\r\n            }\r\n\r\n            this._config = this.mergeConfig(userConfig, this._defaultConfig)\r\n        }\r\n\r\n        generate = (): Monom => {\r\n            // Create a monom instance\r\n            let M = new Monom()\r\n\r\n            // Generate the coefficient\r\n            M.coefficient.parse(Random.numberSym(10, this._config.zero), (this._config.fraction) ? Random.number(1, 10) : 1).reduce();\r\n\r\n            // Calculate the degree of the monom\r\n            if (this._config.letters.length > 1) {\r\n                // Initialise each items...\r\n                for (let L of this._config.letters.split('')) {\r\n                    M.setLetter(L, 0);\r\n                }\r\n                for (let i = 0; i < this._config.degree; i++) {\r\n                    const L = Random.item(this._config.letters.split(\"\"))\r\n                    M.setLetter(L, M.degree(L) + 1)\r\n                }\r\n            } else {\r\n                M.setLetter(this._config.letters, this._config.degree)\r\n            }\r\n\r\n            return M\r\n        }\r\n    }\r\n","/**\r\n * Polynom module contains everything necessary to handle polynoms.*\r\n * @module Polynom\r\n */\r\n\r\nimport {Monom} from './monom';\r\nimport {Shutingyard} from '../shutingyard';\r\nimport {Numeric} from '../numeric';\r\nimport {Random, randomPolynomConfig} from \"../random\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\n/**\r\n * Polynom class can handle polynoms, reorder, resolve, ...\r\n * ```\r\n * let P = new Polynom('3x-4')\r\n * ```\r\n */\r\n    export class Polynom {\r\n        private _rawString: string;\r\n        private _monoms: Monom[];\r\n        private _factors: Polynom[];\r\n        private _texString: string;\r\n\r\n        /**\r\n         *\r\n         * @param {string} polynomString (optional) Default polynom to parse on class creation\r\n         * @param values\r\n         */\r\n        constructor(polynomString?: string, ...values: any[]) {\r\n            this._monoms = [];\r\n            this._factors = [];\r\n            if (polynomString !== undefined) {\r\n                this.parse(polynomString, ...values);\r\n            }\r\n            return this;\r\n        }\r\n\r\n        get isPolynom() {\r\n            return true;\r\n        };\r\n\r\n\r\n        // ------------------------------------------\r\n        // Getter and setter\r\n        // ------------------------------------------\r\n        get monoms() {\r\n            return this._monoms;\r\n        }\r\n\r\n        set monoms(M: Monom[]) {\r\n            this._monoms = M;\r\n        }\r\n\r\n        get factors(): Polynom[] {\r\n            return this._factors;\r\n        }\r\n\r\n        set factors(value: Polynom[]) {\r\n            this._factors = value;\r\n        }\r\n\r\n        get texFactors(): string {\r\n            this.factorize()\r\n\r\n            let tex = ''\r\n            for (let f of this.factors) {\r\n                if (f.monoms.length > 1) {\r\n                    tex += `(${f.tex})`\r\n                } else {\r\n                    tex = f.tex + tex;\r\n                }\r\n            }\r\n            return tex;\r\n        }\r\n\r\n        get texString(): string {\r\n            return this._texString;\r\n        }\r\n\r\n        get length() {\r\n            // TODO: Must reduce the monoms list to remove the zero coefficient.\r\n            return this._monoms.length;\r\n        }\r\n\r\n        get display(): string {\r\n            return this.genDisplay();\r\n        }\r\n\r\n        get raw(): string {\r\n            return this._rawString\r\n        }\r\n\r\n        get tex(): string {\r\n            return this.genDisplay('tex');\r\n        }\r\n\r\n        get isMultiVariable(): boolean {\r\n            const B = false;\r\n            for (const m of this._monoms) {\r\n                if (m.variables.length > 1) {\r\n                    return true;\r\n                }\r\n            }\r\n            return B;\r\n        }\r\n\r\n        get variables(): string[] {\r\n            let V: string[] = [];\r\n\r\n            for (const m of this._monoms) {\r\n                V = V.concat(m.variables);\r\n            }\r\n\r\n            // Remove duplicates.\r\n            V = [...new Set(V)];\r\n\r\n            return V;\r\n        }\r\n\r\n        get numberOfVars(): number {\r\n            return this.variables.length;\r\n        }\r\n\r\n        private genDisplay = (output?: string, forceSign?: boolean, wrapParentheses?: boolean): string => {\r\n            let P: string = '';\r\n\r\n            for (const k of this._monoms) {\r\n                if (k.coefficient.value === 0) {\r\n                    continue;\r\n                }\r\n\r\n                P += `${(k.coefficient.sign() === 1 && (P !== '' || forceSign === true)) ? '+' : ''}${(output === 'tex') ? k.tex : k.display}`;\r\n            }\r\n\r\n            if (wrapParentheses === true && this.length > 1) {\r\n                if (output === 'tex') {\r\n                    P = `\\\\left( ${P} \\\\right)`;\r\n                } else {\r\n                    P = `(${P})`;\r\n                }\r\n            }\r\n\r\n            if (P === '') {\r\n                P = '0';\r\n            }\r\n            return P;\r\n        };\r\n\r\n\r\n        // ------------------------------------------\r\n        // Creation / parsing functions\r\n        // ------------------------------------------\r\n        /**\r\n         * Parse a string to a polynom.\r\n         * @param inputStr\r\n         * @param values: as string, numbers or fractions\r\n         */\r\n        parse = (inputStr: string, ...values: any[]): Polynom => {\r\n            if (values === undefined || values.length === 0) {\r\n                inputStr = '' + inputStr;\r\n                this._rawString = inputStr;\r\n\r\n                // Parse the polynom using the shuting yard algorithm\r\n                if (inputStr !== '' && !isNaN(Number(inputStr))) {\r\n                    this.empty();\r\n                    // It's a simple number.\r\n                    let m = new Monom();\r\n                    m.coefficient = new Fraction(inputStr);\r\n                    m.literalStr = '';\r\n                    this.add(m);\r\n                    return this;\r\n                }\r\n\r\n                // Parse the string.\r\n                return this.shutingYardToReducedPolynom(inputStr);\r\n            } else if (/^[a-z]/.test(inputStr)) {\r\n                // We assume the inputStr contains only letters.\r\n                this.empty();\r\n\r\n                let fractions = values.map(x => new Fraction(x));\r\n                // Multiple setLetter version\r\n                if (inputStr.length > 1) {\r\n                    // TODO: check that the number of values given correspond to the letters (+1 eventually)\r\n                    let letters = inputStr.split(''),\r\n                        i = 0;\r\n                    for (let F of fractions) {\r\n                        let m = new Monom();\r\n                        m.coefficient = F.clone();\r\n                        m.literalStr = letters[i] || '';\r\n                        this.add(m);\r\n                        i++;\r\n                    }\r\n                }\r\n                // Single setLetter version\r\n                else {\r\n                    let n = fractions.length - 1;\r\n                    for (let F of fractions) {\r\n                        let m = new Monom()\r\n                        m.coefficient = F.clone();\r\n                        m.literalStr = `${inputStr}^${n}`\r\n                        this.add(m);\r\n                        n--;\r\n                    }\r\n                }\r\n                return this;\r\n            } else {\r\n                return this.zero();\r\n            }\r\n\r\n        };\r\n\r\n        /**\r\n         * Main parse using a shutting yard class\r\n         * @param inputStr\r\n         */\r\n        private shutingYardToReducedPolynom = (inputStr: string): Polynom => {\r\n            // Get the RPN array of the current expression\r\n            const SY: Shutingyard = new Shutingyard().parse(inputStr);\r\n            const rpn: { token: string, tokenType: string }[] = SY.rpn;\r\n            let m1: Polynom;\r\n            let m2: Polynom;\r\n\r\n            let stack: Polynom[] = [],\r\n                previousToken: string = null,\r\n                tempPolynom\r\n            for (const element of rpn) {\r\n                if (element.tokenType === 'coefficient' || element.tokenType === 'variable') {\r\n                    tempPolynom = new Polynom().zero();\r\n                    tempPolynom.monoms = [new Monom(element.token)]\r\n                    stack.push(tempPolynom.clone())\r\n                } else if (element.tokenType === 'operation') {\r\n                    m2 = (stack.pop()) || new Polynom().zero();\r\n                    m1 = (stack.pop()) || new Polynom().zero();\r\n                    switch (element.token) {\r\n                        case '+':\r\n                            stack.push(m1.add(m2))\r\n                            break;\r\n                        case '-':\r\n                            stack.push(m1.subtract(m2))\r\n                            break;\r\n                        case '*':\r\n                            stack.push(m1.multiply(m2))\r\n                            break;\r\n                        case '^':\r\n                            stack.push(m1.pow(+previousToken))\r\n                    }\r\n                }\r\n                previousToken = element.token;\r\n            }\r\n\r\n            this._monoms = stack[0].monoms;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Clone the polynom\r\n         */\r\n        clone = (): Polynom => {\r\n            const P = new Polynom();\r\n            const M: Monom[] = [];\r\n\r\n            for (const m of this._monoms) {\r\n                M.push(m.clone());\r\n            }\r\n\r\n            P.monoms = M;\r\n            return P;\r\n        };\r\n\r\n        /**\r\n         * Set the polynom to zero.\r\n         * @returns {this}\r\n         */\r\n        zero = (): Polynom => {\r\n            this._monoms = [];\r\n            this._monoms.push(new Monom().zero());\r\n            this._rawString = '0';\r\n            return this;\r\n        };\r\n\r\n        one = (): Polynom => {\r\n            this._monoms = [];\r\n            this._monoms.push(new Monom().one());\r\n            this._rawString = '1';\r\n            return this;\r\n        }\r\n\r\n        empty = (): Polynom => {\r\n            this._monoms = [];\r\n            this._rawString = '';\r\n            return this;\r\n        };\r\n\r\n        // -----------------------------------------------\r\n        // Polynom generators and randomizers\r\n        // -----------------------------------------------\r\n        random(config?:randomPolynomConfig){\r\n            return Random.polynom(config);\r\n        }\r\n\r\n        private _randomizeDefaults: { [key: string]: number | string | boolean } = {\r\n            degree: 2,\r\n            unit: true,\r\n            fractions: false,\r\n            factorable: false,\r\n            letters: 'x',\r\n            allowNullMonom: false,\r\n            numberOfMonoms: false\r\n        };\r\n        get randomizeDefaults(): { [key: string]: number | string | boolean } {\r\n            return this._randomizeDefaults;\r\n        }\r\n\r\n        set randomizeDefaults(value) {\r\n            this._randomizeDefaults = value;\r\n        }\r\n\r\n        randomize = (config: { [key: string]: number | string | boolean }): Polynom => {\r\n            let P = new Polynom();\r\n\r\n            // Check the config file and use the default values.\r\n            if (config === undefined) {\r\n                config = {};\r\n            }\r\n            for (let k in this._randomizeDefaults) {\r\n                if (config[k] === undefined) {\r\n                    config[k] = this._randomizeDefaults[k];\r\n                }\r\n            }\r\n\r\n            // TODO: Build a more robust randomize function\r\n            return P;\r\n        }\r\n\r\n        rndFactorable = (degree: number = 2, unit: boolean | number = false, letters: string = 'x'): Polynom => {\r\n            // TODO: Make rndFactorable polynom generator more user friendly\r\n            this._factors = [];\r\n            for (let i = 0; i < degree; i++) {\r\n                let factorUnit = unit === true || i >= unit,\r\n                    p = Random.polynom({\r\n                        degree: 1,\r\n                        unit: factorUnit,\r\n                        fraction: false,\r\n                        letters\r\n                    });\r\n                this._factors.push(p);\r\n            }\r\n\r\n            this.empty().monoms = this._factors[0].monoms;\r\n            for (let i = 1; i < this._factors.length; i++) {\r\n                this.multiply(this._factors[i]);\r\n            }\r\n            return this;\r\n        };\r\n\r\n        // ------------------------------------------\r\n        // Mathematical operations\r\n        // ------------------------------------------\r\n        opposed = (): Polynom => {\r\n            this._monoms = this._monoms.map(m => m.opposed());\r\n            return this;\r\n        };\r\n\r\n        add = (...values: any[]): Polynom => {\r\n\r\n            for (let value of values) {\r\n                if (value.isPolynom) {\r\n                    this._monoms = this._monoms.concat(value.monoms);\r\n                } else if (value.isMonom) {\r\n                    this._monoms.push(value.clone());\r\n                } else if (Number.isSafeInteger(value)) {\r\n                    this._monoms.push(new Monom(value.toString()));\r\n                } else {\r\n                    this._monoms.push(new Monom(value));\r\n                }\r\n            }\r\n\r\n            return this.reduce();\r\n        };\r\n\r\n        subtract = (...values: any[]): Polynom => {\r\n\r\n            for (let value of values) {\r\n                if (value.isPolynom) {\r\n                    this._monoms = this._monoms.concat(value.clone().opposed().monoms);\r\n                } else if (value.isMonom) {\r\n                    this._monoms.push(value.clone().opposed());\r\n                } else if (Number.isSafeInteger(value)) {\r\n                    this._monoms.push(new Monom(value.toString()).opposed());\r\n                } else {\r\n                    this._monoms.push(new Monom(value).opposed());\r\n                }\r\n            }\r\n\r\n            return this.reduce();\r\n        };\r\n\r\n        multiply = (value: any): Polynom => {\r\n            if (value.isPolynom) {\r\n                return this.multiplyByPolynom(value);\r\n            } else if (value.isFraction) {\r\n                return this.multiplyByFraction(value);\r\n            } else if (value.isMonom) {\r\n                return this.multiplyByMonom(value);\r\n            } else if (Number.isSafeInteger(value)) {\r\n                return this.multiplyByInteger(value);\r\n            }\r\n\r\n            // Something went wrong...\r\n            return this;\r\n        }\r\n\r\n        private multiplyByPolynom = (P: Polynom): Polynom => {\r\n            const M: Monom[] = [];\r\n            for (const m1 of this._monoms) {\r\n                for (const m2 of P.monoms) {\r\n                    M.push(Monom.xmultiply(m1, m2));\r\n                }\r\n            }\r\n\r\n            this._monoms = M;\r\n            return this.reduce();\r\n        };\r\n\r\n        private multiplyByFraction = (F: Fraction): Polynom => {\r\n            for (const m of this._monoms) {\r\n                m.coefficient.multiply(F);\r\n            }\r\n\r\n            return this.reduce();\r\n        };\r\n\r\n        private multiplyByInteger = (nb: number): Polynom => {\r\n            return this.multiplyByFraction(new Fraction(nb));\r\n        };\r\n\r\n        private multiplyByMonom = (M: Monom): Polynom => {\r\n            for (const m of this._monoms) {\r\n                m.multiply(M)\r\n            }\r\n            return this.reduce();\r\n        };\r\n\r\n        /**\r\n         * Divide the current polynom by another polynom.\r\n         * @param P\r\n         * returns {quotient: Polynom, reminder: Polynom}\r\n         */\r\n        euclidian = (P: Polynom): { quotient: Polynom, reminder: Polynom } => {\r\n            const letter: string = P.variables[0];\r\n            const quotient: Polynom = new Polynom().zero();\r\n            const reminder: Polynom = this.clone().reorder(letter);\r\n\r\n            // There is no variable !\r\n            if (P.variables.length === 0) {\r\n                return {quotient, reminder}\r\n            }\r\n\r\n            // Get at least a letter\r\n\r\n            const maxMP: Monom = P.monomByDegree(undefined, letter);\r\n            const degreeP: number = P.degree(letter);\r\n\r\n            let newM: Monom;\r\n\r\n            // Make the euclidian division of the two polynoms.\r\n            let MaxIteration = this.degree(letter) * 2;\r\n            while (reminder.degree(letter) >= degreeP && MaxIteration >= 0) {\r\n                // console.log('EUCLIDE Q', quotient.degree(letter), quotient.tex)\r\n                // console.log('EUCLIDE R', reminder.degree(letter), reminder.tex)\r\n                // console.log('ITERATION', MaxIteration)\r\n                MaxIteration--\r\n\r\n                // Get the greatest monom divided by the max monom of the divider\r\n                newM = reminder.monomByDegree(undefined, letter).clone().divide(maxMP);\r\n\r\n                if (newM.isZero()) {\r\n                    break;\r\n                }\r\n\r\n                // Get the new quotient and reminder.\r\n                quotient.add(newM);\r\n                reminder.subtract(P.clone().multiply(newM));\r\n            }\r\n\r\n            return {quotient, reminder};\r\n        };\r\n\r\n        divide = (value: any): Polynom => {\r\n            if (value.isFraction) {\r\n                this.divideByFraction(value);\r\n            } else if (Number.isSafeInteger(value)) {\r\n                return this.divideByInteger(value);\r\n            }\r\n        }\r\n\r\n        private divideByInteger = (nb: number): Polynom => {\r\n            const nbF = new Fraction(nb);\r\n            for (const m of this._monoms) {\r\n                m.coefficient.divide(nbF);\r\n            }\r\n            return this;\r\n        };\r\n\r\n        private divideByFraction = (F: Fraction): Polynom => {\r\n            for (const m of this._monoms) {\r\n                m.coefficient.divide(F);\r\n            }\r\n            return this;\r\n        };\r\n\r\n        pow = (nb: number): Polynom => {\r\n            if (!Number.isSafeInteger(nb)) {\r\n                return this.zero();\r\n            }\r\n            if (nb < 0) {\r\n                return this.zero();\r\n            }\r\n            if (nb === 0) {\r\n                return new Polynom();\r\n            }\r\n\r\n            const P = this.clone();\r\n            for (let i = 1; i < nb; i++) {\r\n                this.multiply(P);\r\n            }\r\n            return this.reduce();\r\n        };\r\n\r\n\r\n        // ------------------------------------------\r\n        // Compare functions\r\n        // ------------------------------------------\r\n        /**\r\n         * Compare the current coefficient with another coefficient\r\n         * @param P\r\n         * @param sign (string| default is =): authorized values: =, <, <=, >, >= with some variations.\r\n         */\r\n        compare = (P: Polynom, sign?: string): boolean => {\r\n            if (sign === undefined) {\r\n                sign = '='\r\n            }\r\n\r\n            // Create clone version to reduce them without altering the original polynoms.\r\n            const cP1 = this.clone().reduce().reorder();\r\n            const cP2 = P.clone().reduce().reorder();\r\n\r\n            switch (sign) {\r\n                case '=':\r\n                    // They must have the isSame length and the isSame degree\r\n                    if (cP1.length !== cP2.length || cP1.degree() !== cP2.degree()) {\r\n                        return false;\r\n                    }\r\n\r\n                    // Check if the coefficients are the isSame.\r\n                    for (const i in cP1.monoms) {\r\n                        if (!cP1.monoms[i].isEqual(cP2.monoms[i])) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    return true;\r\n                case 'same':\r\n                    // They must have the isSame length and the isSame degree\r\n                    if (cP1.length !== cP2.length || cP1.degree() !== cP2.degree()) {\r\n                        return false;\r\n                    }\r\n\r\n                    for (const i in cP1.monoms) {\r\n                        if (!cP1.monoms[i].isSameAs(cP2.monoms[i])) {\r\n                            return false;\r\n                        }\r\n                    }\r\n\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        };\r\n\r\n        isZero(): boolean {\r\n            return (this._monoms.length === 1 && this._monoms[0].coefficient.isZero()) || this._monoms.length === 0;\r\n        }\r\n\r\n        isOne(): boolean {\r\n            return this._monoms.length === 1 && this._monoms[0].coefficient.isOne();\r\n        }\r\n\r\n        isEqual = (P: Polynom): boolean => {\r\n            return this.compare(P, '=');\r\n        };\r\n\r\n        isSameAs = (P: Polynom): boolean => {\r\n            return this.compare(P, 'same');\r\n        };\r\n\r\n        isOpposedAt = (P: Polynom): boolean => {\r\n            return this.compare(P.clone().opposed(), '=');\r\n        };\r\n\r\n        isFactorized = (polynomString: string): boolean => {\r\n            let P;\r\n\r\n            // Check if polynom is complete...\r\n            if (polynomString.match(/\\(/g).length !== polynomString.match(/\\)/g).length) {\r\n                return false\r\n            }\r\n\r\n            // Try to build the polynom\r\n            try {\r\n                P = new Polynom(polynomString);\r\n            } catch (e) {\r\n                return false;\r\n            }\r\n\r\n            // Both polynom aren't the same (once developed and reduced => they cannot be equivalent)\r\n            if (!this.isEqual(P)) {\r\n                return false;\r\n            }\r\n\r\n            // Check if the provided (string) version is fully factorized.\r\n            // Run a regex on the string.\r\n            let polynomStringNormalized = polynomString.replaceAll('*', ''),\r\n                polynomStringReduced = '' + polynomStringNormalized,\r\n                factors: string[] = [];\r\n\r\n            for (let x of polynomStringNormalized.matchAll(/\\(([a-z0-9+\\-]+)\\)(\\^[0-9]*)?/g)) {\r\n                if (x[2] !== undefined) {\r\n                    for (let i = 0; i < +x[2].substr(1); i++) {\r\n                        factors.push(x[1])\r\n                    }\r\n                } else {\r\n                    factors.push(x[1]);\r\n                }\r\n                polynomStringReduced = polynomStringReduced.replaceAll(x[0], '');\r\n            }\r\n            if (polynomStringReduced !== '') {\r\n                factors.push(polynomStringReduced);\r\n            }\r\n            let polyFactors = factors.map(x => new Polynom(x));\r\n\r\n            // Factorize the current polynom.\r\n            this.factorize();\r\n\r\n            // Compare the given factors with the generated factors\r\n            let sign = 1;\r\n            for (let f of this.factors) {\r\n                for (let i = 0; i < polyFactors.length; i++) {\r\n                    if (f.isEqual(polyFactors[i])) {\r\n                        polyFactors.splice(i, 1);\r\n                        break;\r\n                    } else if (f.isOpposedAt(polyFactors[i])) {\r\n                        polyFactors.splice(i, 1);\r\n                        sign = -sign;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // The polyfactors must be empty and the cumulative opposite factors must be 1.\r\n            return (polyFactors.length === 0 && sign === 1);\r\n        }\r\n\r\n        isDeveloped = (polynomString: string): Boolean => {\r\n            let P: Polynom;\r\n\r\n            // There is at least one parenthese - it is not developed.\r\n            if (polynomString.match(/\\(/g).length + polynomString.match(/\\)/g).length) {\r\n                return false\r\n            }\r\n\r\n            // Try to build the polynom\r\n            try {\r\n                // Build the polynom\r\n                P = new Polynom(polynomString);\r\n            } catch (e) {\r\n                return false;\r\n            }\r\n\r\n            // Both polynom aren't the same (once developed and reduced => they cannot be equivalent)\r\n            if (!this.isEqual(P)) {\r\n                return false;\r\n            }\r\n\r\n            // Check that everything is completely developed. Actually, there are no parentheses... so it is fully developed\r\n\r\n            // maybe it wasn't reduced and not ordered...\r\n            // compare polynom string.\r\n\r\n            // normalize the string\r\n            let polynomStringNormalized = polynomString.replaceAll('[*\\s]', '')\r\n\r\n            // Determine if it's the exact same string.\r\n            // TODO: Maybe it's enough to just make this test !\r\n            return polynomStringNormalized === P.reduce().reorder().display\r\n        }\r\n        // ------------------------------------------\r\n        // Misc polynoms functions\r\n        // -------------------------------------\r\n        reduce = (): Polynom => {\r\n            for (let i = 0; i < this._monoms.length; i++) {\r\n                for (let j = i + 1; j < this._monoms.length; j++) {\r\n                    if (this._monoms[i].isSameAs(this.monoms[j])) {\r\n                        this._monoms[i].add(this.monoms[j]);\r\n                        this._monoms.splice(j, 1);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Remove all null monoms\r\n            this._monoms = this._monoms.filter((m) => {\r\n                return m.coefficient.value !== 0\r\n            });\r\n\r\n            // Reduce all monoms coefficient.\r\n            for (const m of this._monoms) {\r\n                m.coefficient.reduce();\r\n            }\r\n\r\n            if (this.length === 0) {\r\n                return new Polynom().zero();\r\n            }\r\n            return this;\r\n        };\r\n\r\n        reorder = (letter: string = 'x'): Polynom => {\r\n            // TODO: Must handle multiple setLetter reorder system\r\n            this._monoms.sort(function (a, b) {\r\n                return b.degree(letter) - a.degree(letter)\r\n            });\r\n            return this.reduce();\r\n        };\r\n\r\n        degree = (letter?: string): number => {\r\n            let d: number = 0;\r\n            for (const m of this._monoms) {\r\n                d = Math.max(m.degree(letter), d);\r\n            }\r\n            return d;\r\n        };\r\n\r\n        letters = (): string[] => {\r\n            let L: string[] = [], S = new Set();\r\n\r\n            for (let m of this._monoms) {\r\n                S = new Set([...S, ...m.variables]);\r\n            }\r\n\r\n            // @ts-ignore\r\n            return [...S];\r\n        }\r\n\r\n        /**\r\n         * Replace a variable (letter) by a polynom.\r\n         * @param letter\r\n         * @param P\r\n         */\r\n        replaceBy = (letter: string, P: Polynom): Polynom => {\r\n            let pow: number;\r\n            const resultPolynom: Polynom = new Polynom().zero();\r\n\r\n            for (const m of this.monoms) {\r\n                if (m.literal[letter] === undefined || m.literal[letter] === 0) {\r\n                    resultPolynom.add(m.clone());\r\n                } else {\r\n                    // We have found a setLetter.\r\n                    // Get the power and reset it.\r\n                    pow = +m.literal[letter];\r\n                    delete m.literal[letter];\r\n\r\n                    resultPolynom.add(P.clone().pow(pow).multiply(m));\r\n                }\r\n            }\r\n\r\n            this._monoms = resultPolynom.reduce().reorder().monoms;\r\n            return this;\r\n        };\r\n\r\n        // Evaluate a polynom.\r\n        evaluate = (values: { [key: string]: Fraction | number } | Fraction | number): Fraction => {\r\n            const r = new Fraction().zero();\r\n\r\n            this._monoms.forEach(monom => {\r\n                //console.log('Evaluate polynom: ', monom.display, values, monom.evaluate(values).display);\r\n                r.add(monom.evaluate(values));\r\n            });\r\n            return r;\r\n        };\r\n\r\n        derivative = (letter?: string): Polynom => {\r\n            let dP = new Polynom();\r\n\r\n            for (let m of this._monoms) {\r\n                dP.add(m.derivative(letter));\r\n            }\r\n            return dP;\r\n\r\n        }\r\n\r\n        primitive = (letter?: string): Polynom => {\r\n            let dP = new Polynom();\r\n\r\n            for (let m of this._monoms) {\r\n                dP.add(m.primitive(letter))\r\n            }\r\n            return dP\r\n        }\r\n\r\n        integrate = (a: Fraction | number, b: Fraction | number, letter?: string): Fraction => {\r\n            const primitive = this.primitive(letter)\r\n\r\n            if (letter === undefined) {\r\n                letter = 'x'\r\n            }\r\n\r\n            let valuesA: { [key: string]: Fraction | number } = {},\r\n                valuesB: { [key: string]: Fraction | number } = {}\r\n            valuesA[letter] = a;\r\n            valuesB[letter] = b;\r\n\r\n            return primitive.evaluate(valuesB).subtract(primitive.evaluate(valuesA))\r\n        }\r\n        // ------------------------------------------\r\n        // Polynoms factorization functions\r\n        // -------------------------------------\r\n        /**\r\n         * Factorize a polynom and store the best results in factors.\r\n         * @param maxValue Defines the greatest value to search to (default is 20).\r\n         */\r\n        factorize_OLD = (maxValue?: number): Polynom => {\r\n            // TODO: Must handle other letters than 'x'\r\n            this._factors = [];\r\n\r\n            // Duplicate the polynom\r\n            let P = this.clone(),\r\n                nbFactorsFound = 0;\r\n\r\n            // Determine if the polynom is \"negative\", eg has a max monom degree with a negative coefficient.\r\n            if (P.monomByDegree().coefficient.numerator < 0) {\r\n                this._factors.push(new Polynom('-1'));\r\n            }\r\n\r\n            // Determine if there is a 'common' monom\r\n            let M = P.commonMonom();\r\n            if (!M.isOne()) {\r\n                let commonPolynom = new Polynom()\r\n                commonPolynom.monoms = [M]\r\n                if (this._factors.length === 0) {\r\n                    this._factors.push(commonPolynom);\r\n                } else {\r\n                    this._factors = [];\r\n                    this._factors.push(commonPolynom.opposed());\r\n                }\r\n                P = P.euclidian(commonPolynom).quotient;\r\n\r\n                nbFactorsFound = commonPolynom.degree();\r\n            }\r\n\r\n            // Main loop.\r\n            //\r\n            // Do it only if degree is equal or less than one.\r\n            if (P.degree() <= 1) {\r\n                this._factors.push(P.clone());\r\n            } else {\r\n                // Force test.\r\n                let Q = new Fraction(),\r\n                    F,\r\n                    degree = P.degree();\r\n\r\n                maxValue = maxValue === undefined ? 20 : maxValue;\r\n\r\n                // Test all polynom similar to ax+b\r\n                for (let a = 1; a <= maxValue; a++) {\r\n                    // Skip a coefficient of 0\r\n                    for (let b = -maxValue; b <= maxValue; b++) {\r\n\r\n                        Q.parse(-b, a);\r\n\r\n                        if (P.evaluate({x: Q})) {\r\n                            F = new Polynom(`${a}x+${b}`);\r\n                            while (P.evaluate({x: Q}).value === 0) {\r\n                                this._factors.push(F.clone());\r\n                                nbFactorsFound++;\r\n\r\n                                // Means it can be divided without reminders.\r\n                                P = P.euclidian(F).quotient;\r\n                            }\r\n                        }\r\n\r\n                        // Continue if the numbers of factors found equals the degree.\r\n                        if (nbFactorsFound > degree) {\r\n                            return this;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (P.degree() > 1) {\r\n                    this._factors.push(P.clone());\r\n                    return this;\r\n                }\r\n            }\r\n\r\n            return this;\r\n        };\r\n\r\n        factorize = (letter?: string): Polynom[] => {\r\n            let factors: Polynom[] = [];\r\n\r\n            // Extract the common monom\r\n            let P = this.clone().reorder(),\r\n                M = P.commonMonom(),\r\n                tempPolynom: Polynom\r\n            // It has a common monom.\r\n            if (!M.isOne()) {\r\n                tempPolynom = new Polynom()\r\n                tempPolynom.monoms = [M]\r\n                factors = [tempPolynom.clone()]\r\n                P = P.euclidian(tempPolynom).quotient;\r\n            }\r\n\r\n            let securityLoop = P.degree() * 2\r\n            // securityLoop = 0\r\n            while (securityLoop >= 0) {\r\n                securityLoop--\r\n\r\n\r\n                if (P.monoms.length < 2) {\r\n                    if (!P.isOne()) {\r\n                        factors.push(P.clone());\r\n                    }\r\n                    break;\r\n                } else {\r\n                    // Get the first and last monom.\r\n                    let m1 = P.monoms[0].dividers,\r\n                        m2 = P.monoms[P.monoms.length - 1].dividers\r\n\r\n                    // console.log('CURRENT VALUE')\r\n                    // console.log(P.tex)\r\n                    // console.log('---------------------')\r\n                    for (let m1d of m1) {\r\n                        for (let m2d of m2) {\r\n                            // if(m1d.degree()===m2d.degree()){continue}\r\n                            let dividerPolynom = new Polynom(),\r\n                                result\r\n                            dividerPolynom.monoms = [m1d.clone(), m2d.clone()]\r\n                            result = P.euclidian(dividerPolynom)\r\n\r\n                            // console.log(dividerPolynom.tex, '=>', result.reminder.tex, '|||||', result.quotient.tex)\r\n                            if (result.reminder.isZero()) {\r\n                                P = result.quotient.clone();\r\n                                factors.push(dividerPolynom)\r\n                                continue;\r\n                            }\r\n\r\n                            dividerPolynom.monoms = [m1d.clone(), m2d.clone().opposed()]\r\n                            result = P.euclidian(dividerPolynom)\r\n                            if (result.reminder.isZero()) {\r\n                                P = result.quotient.clone();\r\n                                factors.push(dividerPolynom)\r\n                            }\r\n                            // console.log(dividerPolynom.tex, '=>', result.reminder.tex)\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            this.factors = factors\r\n            return factors;\r\n        }\r\n\r\n        private _factorize2ndDegree = (letter: string): Polynom[] => {\r\n            let P1: Polynom, P2: Polynom,\r\n                a, b, c, delta, x1, x2, factor;\r\n\r\n            // One variable only\r\n            if (this.numberOfVars === 1) {\r\n                a = this.monomByDegree(2, letter).coefficient;\r\n                b = this.monomByDegree(1, letter).coefficient;\r\n                c = this.monomByDegree(0, letter).coefficient;\r\n                delta = b.clone().pow(2).subtract(a.clone().multiply(c).multiply(4));\r\n\r\n                if (delta.isZero()) {\r\n                    x1 = b.clone().opposed().divide(a.clone().multiply(2))\r\n                    P1 = new Polynom(letter).subtract(x1.display).multiply(x1.denominator)\r\n                    P2 = new Polynom(letter).subtract(x1.display).multiply(x1.denominator)\r\n                    factor = a.divide(x1.denominator).divide(x1.denominator);\r\n\r\n                    if (!factor.isOne()) {\r\n                        // TODO: Update new Polynom to accept anything...\r\n                        return [new Polynom(factor.display), P1, P2]\r\n                    } else {\r\n                        return [P1, P2]\r\n                    }\r\n                } else if (delta.isPositive() && delta.isSquare()) {\r\n                    x1 = b.clone().opposed()\r\n                        .add(delta.clone().sqrt())\r\n                        .divide(a.clone().multiply(2))\r\n                    x2 = b.clone().opposed()\r\n                        .subtract(delta.clone().sqrt())\r\n                        .divide(a.clone().multiply(2))\r\n\r\n                    // (2x+5)(3x-2)\r\n                    // 6x^2+11x-10\r\n                    // a = 6, b = 11, c = -10\r\n                    // delta = 121-4*6*(-10) = 361= 19^2\r\n                    // x1 = (-11 + 19)  / 12 = 8/12 = 2/3\r\n                    // x2 = (-11 - 19)  / 12 = -30/12 = -5/2\r\n                    factor = a.divide(x1.denominator).divide(x2.denominator);\r\n                    if (factor.isOne()) {\r\n                        return [\r\n                            new Polynom(letter).subtract(x1.display).multiply(x1.denominator),\r\n                            new Polynom(letter).subtract(x2.display).multiply(x2.denominator),\r\n                        ]\r\n                    } else {\r\n                        return [\r\n                            new Polynom(factor.display),\r\n                            new Polynom(letter).subtract(x1.display).multiply(x1.denominator),\r\n                            new Polynom(letter).subtract(x2.display).multiply(x2.denominator),\r\n                        ]\r\n\r\n                    }\r\n                } else {\r\n                    // No solution possible - return the complete value.\r\n                    return [this.clone()]\r\n                }\r\n            } else {\r\n                // If multiple variables, only handle perfect squares...\r\n                a = this.monomByDegree(2, letter);\r\n                b = this.monomByDegree(1, letter);\r\n                c = this.monomByDegree(0, letter);\r\n\r\n\r\n                if (a.isLitteralSquare() && c.isLitteralSquare()) {\r\n                    // Check the middle item is same as...\r\n                    if (b.clone().pow(2).isSameAs(a.clone().multiply(c))) {\r\n                        // Determine if the coefficient values matches.\r\n\r\n                        // Search 4 values (r, s, t, u) that matches:\r\n                        // (r X + s Y)(t X + u Y) = rt X^2 + (ru + st) XY + su Y^2\r\n\r\n                        let xPolynom = new Polynom('x', a.coefficient, b.coefficient, c.coefficient);\r\n                        let xFactors = xPolynom._factorize2ndDegree('x');\r\n\r\n                        let factors = [], xyzPolynom: Polynom;\r\n\r\n                        if (xFactors.length >= 2) {\r\n                            for (let p of xFactors) {\r\n                                if (p.degree() === 0) {\r\n                                    factors.push(p.clone())\r\n                                } else {\r\n                                    xyzPolynom = p.clone();\r\n                                    xyzPolynom.monoms[0].literal = a.literalSqrt\r\n                                    xyzPolynom.monoms[1].literal = c.literalSqrt\r\n                                    factors.push(xyzPolynom.clone())\r\n                                }\r\n                            }\r\n                            return factors\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return [this.clone()]\r\n                //\r\n                // console.log(a.tex, b.tex, c.tex)\r\n                // if (a.isSquare() && c.isSquare()) {\r\n                //     console.log('A C squares')\r\n                //     if (a.clone().sqrt().multiply(c.clone().sqrt()).multiplyByNumber(2).isSameAs(b)) {\r\n                //         console.log('HERE')\r\n                //         if (a.coefficient.sign() === b.coefficient.sign()) {\r\n                //             return []\r\n                //         }else{\r\n                //             return []\r\n                //         }\r\n                //     }\r\n                // } else if(a.isLitteralSquare() && c.isLitteralSquare()) {\r\n                //     console.log('A C litteral SQUARES')\r\n                //     // Check that the middle element is the product of a and c.\r\n                //\r\n                //     if(b.clone().pow(2).isSameAs(a.clone().multiply(c))){\r\n                //         console.log('SAME')\r\n                //\r\n                //     }else{\r\n                //         console.log('NOT SAME')\r\n                //     }\r\n                //\r\n                //     return [this.clone()]\r\n                // } else {\r\n                //     console.log('NOT SQUARES AT ALL !!!!')\r\n                // }\r\n\r\n            }\r\n        }\r\n\r\n        private _factorizeByGroups = (): Polynom[] => {\r\n            // TODO: Factorize by groups.\r\n            return [];\r\n        }\r\n        // ------------------------------------------\r\n        // Polynoms helpers functions\r\n        // -------------------------------------\r\n        // TODO: get zeroes for more than first degree\r\n        getZeroes = (): (Fraction | boolean)[] => {\r\n            const Z: Fraction[] = [];\r\n\r\n            switch (this.degree()) {\r\n                case 0:\r\n                    if (this._monoms[0].coefficient.value === 0) {\r\n                        return [true];\r\n                    } else {\r\n                        return [false];\r\n                    }\r\n                case 1:\r\n                    // There is only one monoms,\r\n                    if (this._monoms.length === 1) {\r\n                        return [new Fraction().zero()];\r\n                    } else {\r\n                        const P = this.clone().reduce().reorder();\r\n                        return [P.monoms[1].coefficient.opposed().divide(P.monoms[0].coefficient)];\r\n                    }\r\n                // TODO: Determine the zeros of an equation of second degree.\r\n                //case 2:\r\n                default:\r\n                    // Make sure the polynom is factorized.\r\n                    if (this._factors.length === 0) {\r\n                        this.factorize()\r\n                    }\r\n\r\n                    let zeroes = [], zeroesAsTex = [];\r\n                    for (let P of this._factors) {\r\n                        if (P.degree() > 2) {\r\n                            // TODO: Handle other polynom.\r\n\r\n                        } else if (P.degree() === 2) {\r\n                            let A = P.monomByDegree(2).coefficient,\r\n                                B = P.monomByDegree(1).coefficient,\r\n                                C = P.monomByDegree(0).coefficient,\r\n                                D = B.clone().pow(2).subtract(A.clone().multiply(C).multiply(4));\r\n\r\n                            if (D.value > 0) {\r\n                                /*console.log('Two zeroes for ', P.tex); */\r\n                                let x1 = (-(B.value) + Math.sqrt(D.value)) / (2 * A.value),\r\n                                    x2 = (-(B.value) - Math.sqrt(D.value)) / (2 * A.value);\r\n\r\n                                zeroes.push(new Fraction(x1.toFixed(3)).reduce());\r\n                                zeroes.push(new Fraction(x2.toFixed(3)).reduce());\r\n                            } else if (D.value === 0) {\r\n                                /*console.log('One zero for ', P.tex); */\r\n\r\n                            } else {\r\n                                console.log('No zero for ', P.tex);\r\n                            }\r\n                        } else {\r\n                            for (let z of P.getZeroes()) {\r\n                                // Check if the zero is already in the list.\r\n                                if (z === false || z === true) {\r\n                                    continue;\r\n                                }\r\n                                if (zeroesAsTex.indexOf(z.frac) === -1) {\r\n                                    zeroes.push(z);\r\n                                    zeroesAsTex.push(z.frac);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    return zeroes;\r\n            }\r\n            return Z;\r\n        };\r\n\r\n\r\n        // TODO: analyse the next functions to determine if they are useful or not...\r\n        monomByDegree = (degree?: number, letter?: string): Monom => {\r\n            if (degree === undefined) {\r\n                // return the highest degree monom.\r\n                return this.monomByDegree(this.degree(letter), letter);\r\n            }\r\n\r\n            // Reduce the polynom.\r\n            const M = this.clone().reduce();\r\n            for (const m of M._monoms) {\r\n                if (m.degree(letter) === degree) {\r\n                    return m.clone();\r\n                }\r\n            }\r\n\r\n            // Nothing was found - return the null monom.\r\n            return new Monom().zero();\r\n        };\r\n\r\n        monomsByDegree = (degree?: number, letter?: string): Monom[] => {\r\n            if (degree === undefined) {\r\n                // return the highest degree monom.\r\n                return this.monomsByDegree(this.degree(letter));\r\n            }\r\n\r\n            // Reduce the polynom.\r\n            let Ms: Monom[] = [];\r\n\r\n            const M = this.clone().reduce();\r\n            for (const m of M._monoms) {\r\n                if (m.degree(letter) === degree) {\r\n                    Ms.push(m.clone())\r\n                }\r\n            }\r\n\r\n            return Ms\r\n            // Nothing was found - retur\r\n        }\r\n\r\n        // Used in LinearSystem.tex\r\n        monomByLetter = (letter: string): Monom => {\r\n            const M = this.clone().reduce();\r\n            for (const m of M._monoms) {\r\n                if (m.hasLetter(letter)) {\r\n                    return m.clone();\r\n                }\r\n            }\r\n\r\n            return new Monom().zero();\r\n        };\r\n\r\n\r\n        // Next functions are used for for commonMonom, which is used in the factorize method.\r\n        getDenominators = (): number[] => {\r\n            const denominators: number[] = [];\r\n            for (const m of this._monoms) {\r\n                denominators.push(m.coefficient.denominator);\r\n            }\r\n            return denominators;\r\n        };\r\n\r\n        getNumerators = (): number[] => {\r\n            const numerators: number[] = [];\r\n            for (const m of this._monoms) {\r\n                numerators.push(m.coefficient.numerator);\r\n            }\r\n            return numerators;\r\n        };\r\n\r\n        lcmDenominator = (): number => {\r\n            return Numeric.lcm(...this.getDenominators());\r\n        };\r\n\r\n        gcdDenominator = (): number => {\r\n            return Numeric.gcd(...this.getDenominators());\r\n        };\r\n\r\n        lcmNumerator = (): number => {\r\n            return Numeric.lcm(...this.getNumerators());\r\n        };\r\n\r\n        gcdNumerator = (): number => {\r\n            return Numeric.gcd(...this.getNumerators());\r\n        };\r\n\r\n        commonMonom = (): Monom => {\r\n            let M = new Monom().one(), numerator: number, denominator: number, degree = this.degree();\r\n\r\n            numerator = this.gcdNumerator();\r\n            denominator = this.gcdDenominator();\r\n\r\n            M.coefficient = new Fraction(numerator, denominator);\r\n            for (let L of this.variables) {\r\n                // Initialize the setLetter with the max degree\r\n                M.setLetter(L, degree);\r\n                for (let m of this._monoms) {\r\n                    M.setLetter(L, Math.min(m.degree(L), M.degree(L)));\r\n                    if (M.degree(L) === 0) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            return M;\r\n        }\r\n\r\n\r\n        // TODO: The rest of the functions are not used or unnecessary ?\r\n        /**\r\n         * This will generate a not reduced tex string of the polynom.\r\n         * @param complexity : Number of iteration to increase the complexity.\r\n         */\r\n        makeItComplicate = (complexity: number = 1): Polynom => {\r\n            this._texString = '';\r\n\r\n            // The polynom must be at least of the first degree.\r\n            if (this.degree() < 1) {\r\n                return this;\r\n            }\r\n\r\n            // TODO: update this function !\r\n\r\n            const mDegree = Random.number(0, this.degree() - 1);\r\n            // const A = new Polynom().rndSimple(mDegree, false, complexity > 1, 'x', false, complexity > 1 ? -1 : 1);\r\n            // const B = new Polynom().rndSimple(1, false, complexity > 1);\r\n            // const C = this.clone().subtract(A.clone().multiply(B));\r\n\r\n            // Try to factorize a little bit the C polynom.\r\n            // C.factorizePartial(true);\r\n            // this._texString = `${A.genDisplay('tex', false, true)} \\\\cdot ${B.genDisplay('tex', false, true)} ${C.texString} `;\r\n            //\r\n            return this;\r\n        };\r\n        factorizePartial = (forceSign?: boolean): Polynom => {\r\n            this._texString = '';\r\n            // Try to find two monoms with a common coefficient.\r\n            if (this.length <= 1) {\r\n                return this;\r\n            }\r\n\r\n            let mMain: Monom,\r\n                mCheck: Monom,\r\n                mFactor: Monom,\r\n                pFactor: Polynom,\r\n                // pRemain: Polynom,\r\n                g: number, sign: string;\r\n\r\n            for (let i = 0; i < this.length; i++) {\r\n                mMain = this._monoms[i].clone();\r\n                // We factorize only if the main coefficient isn't a fraction\r\n                // if(mMain.coefficient.denominator!==1){continue;}\r\n                for (let j = i + 1; j < this.length; j++) {\r\n                    mCheck = this._monoms[j].clone();\r\n                    // if(mCheck.coefficient.denominator!==1){continue;}\r\n\r\n                    g = Numeric.gcd(mMain.coefficient.numerator, mCheck.coefficient.numerator);\r\n                    if (g !== 1) {\r\n                        // mFactor = mMain.clone().divide(mCheck); // This gets the literal part.\r\n                        // mFactor.coefficient = new Fraction(g); // Set the coefficient to the gcd.\r\n                        mFactor = Monom.lcm(mMain, mCheck);\r\n                        sign = mMain.coefficient.sign() === 1 ? '+' : '-';\r\n                        this._texString = `${forceSign === true ? sign : (sign === '+' ? '' : sign)}${mFactor.tex}`;\r\n\r\n                        pFactor = new Polynom().add(mMain.divide(mFactor)).add(mCheck.divide(mFactor));\r\n                        this._texString += pFactor.genDisplay('tex', false, true);\r\n\r\n                        this._texString += this.clone().subtract(pFactor.clone().multiply(mFactor)).genDisplay('tex', true, false);\r\n                        return this;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this._texString = this.genDisplay('tex', forceSign);\r\n\r\n            return this;\r\n        };\r\n        /**\r\n         * reduce the coefficient value as if the polynom was equal to zero.\r\n         */\r\n        minify = (): Polynom => {\r\n            // First multiply by the common denominator.\r\n            this.multiply(this.lcmDenominator()).divide(this.gcdNumerator()).reduce();\r\n            return this.reduce();\r\n        };\r\n        /**\r\n         * Determine if the current polynom is divisible by P\r\n         * TODO: should work with any polynom, not only first degree polynoms and the setLetter should disappear\r\n         * @param P\r\n         * @param letter - default setLetter\r\n         */\r\n        canDivide = (P: Polynom, letter: string = 'x'): boolean => {\r\n            const d = P.degree();\r\n\r\n            const evalValue: { [key: string]: Fraction } = {};\r\n            // A zero degree polynom can always divide, except if it's the zero polynom.\r\n            if (d === 0) {\r\n                return !P.isZero;\r\n            }\r\n\r\n            // The polynom is of degree one.\r\n            if (d === 1) {\r\n                const z = P.getZeroes();\r\n                // The zero is an undefined zero.\r\n                if (z[0] === true || z[0] === false) {\r\n                    return false;\r\n                }\r\n\r\n                evalValue[letter] = z[0];\r\n                return this.evaluate(evalValue).value === 0;\r\n            }\r\n\r\n            // The polynom is of degree 2 or more...\r\n            if (d > 1) {\r\n                console.log('Currently, only first degree polynom are supported');\r\n                return false;\r\n            }\r\n\r\n            return false;\r\n        };\r\n\r\n\r\n    }\r\n","import {randomCore} from \"./randomCore\";\r\nimport {randomPolynomConfig} from \"./rndTypes\";\r\nimport {rndMonom} from \"./rndMonom\";\r\nimport {Random} from \"./index\";\r\nimport {Polynom} from \"../algebra/polynom\";\r\nimport {Monom} from \"../algebra/monom\";\r\n\r\n/**\r\n * Random polynoms\r\n */\r\nexport class rndPolynom extends randomCore {\r\n    declare protected _config: randomPolynomConfig\r\n    declare protected _defaultConfig: randomPolynomConfig\r\n\r\n    constructor(userConfig?: randomPolynomConfig) {\r\n        super();\r\n\r\n        // Default config for a random polynom\r\n        this._defaultConfig = {\r\n            letters: 'x',\r\n            degree: 2,\r\n            fraction: false,\r\n            zero: false,\r\n            unit: false,\r\n            factorable: false,\r\n            allowNullMonom: true,\r\n            numberOfMonoms: 0\r\n        }\r\n\r\n        // Merge config with initialiser\r\n        this._config = this.mergeConfig(userConfig, this._defaultConfig)\r\n    }\r\n\r\n    generate = (): Polynom => {\r\n        // Create the polynom\r\n        let P = new Polynom().empty(),\r\n            M: Monom\r\n\r\n        for (let i = this._config.degree; i >= 0; i--) {\r\n            // Create monom of corresponding degree.\r\n            M = new rndMonom({\r\n                letters: this._config.letters,\r\n                degree: i,\r\n                fraction: this._config.fraction,\r\n                zero: (i === this._config.degree) ? false : this._config.allowNullMonom\r\n            }).generate()\r\n\r\n            // If degree is the greatest and unit is true, set the monom value to one.\r\n            if (this._config.unit && this._config.degree === i) {\r\n                M.coefficient.one()\r\n            }\r\n\r\n            // Add to the polynom\r\n            P.add(M)\r\n        }\r\n\r\n        // If the number of monoms is greater than the allowed value, remove some of them...\r\n        if (this._config.numberOfMonoms > 0 && this._config.numberOfMonoms < P.length) {\r\n            console.log(P.monoms.length)\r\n            P.monoms = Random.array(P.monoms, this._config.numberOfMonoms)\r\n        }\r\n        return P\r\n    }\r\n\r\n    factorable = (): Polynom => {\r\n        let P = new Polynom()\r\n\r\n        return P\r\n    }\r\n}","/**\r\n * Random helpers\r\n */\r\nexport class rndHelpers {\r\n\r\n    /**\r\n     * Random boolean with a percent ratio\r\n     * @param percent\r\n     */\r\n    static randomBool(percent:number=0.5):boolean{\r\n        return Math.random()<percent;\r\n    }\r\n\r\n    /**\r\n     * Random integer between two values.\r\n     * @param a (number) : From this value to the second value. If the second is ommited, this value is the max value.\r\n     * @param b (number) : To this value. If this is ommited.\r\n     */\r\n    static randomInt(a:number, b?:number):number{\r\n        if(b===undefined){return this.randomInt(0,a);}\r\n\r\n        return Math.floor(Math.random() * (b - a + 1) + a);\r\n    }\r\n\r\n    /**\r\n     * Random integer between -max and max value.\r\n     * @param max (number) : determine the limits.\r\n     * @param zero (bool) : determine if zero is allowed or not.\r\n     */\r\n    static randomIntSym(max:number, zero?:boolean):number{\r\n        if(zero===false){\r\n            return this.randomBool()?this.randomInt(1,max):-this.randomInt(1,max);\r\n        }else{\r\n            return this.randomInt(-max, max);\r\n        }\r\n    }\r\n\r\n    static randomArray(arr: any[], number?:number):any[]{\r\n        if(number===undefined){number = 1}\r\n\r\n        // Return a clone array\r\n        if(arr.length<=0){return Object.values(arr)}\r\n\r\n        // Randomize the array and return the n first elements.\r\n        return rndHelpers.shuffleArray(arr).slice(0,number);\r\n    }\r\n\r\n    static randomItem(arr: any[]): any{\r\n        if(arr.length===0){return ''}\r\n        return this.randomArray(arr, 1)[0]\r\n    }\r\n\r\n    static shuffleArray(arr: any[]): any[] {\r\n        // The Fisher-Yates algorithm\r\n        let shuffleArray = Object.values(arr)\r\n        for (let i = shuffleArray.length - 1; i > 0; i--) {\r\n            const j = Math.floor(Math.random() * (i + 1));\r\n            const temp = shuffleArray[i];\r\n            shuffleArray[i] = shuffleArray[j];\r\n            shuffleArray[j] = temp;\r\n        }\r\n\r\n        return shuffleArray;\r\n    }\r\n\r\n}","import {rndPolynom} from \"./rndPolynom\";\r\nimport {rndMonom} from \"./rndMonom\";\r\nimport {rndHelpers} from \"./rndHelpers\";\r\nimport {randomMonomConfig, randomPolynomConfig} from \"./rndTypes\";\r\nimport {Monom, Polynom} from \"../algebra\";\r\n\r\nexport * from \"./rndTypes\"\r\nexport namespace Random {\r\n    export function polynom(config?: randomPolynomConfig): Polynom {\r\n        return (new rndPolynom(config)).generate()\r\n    }\r\n\r\n    export function monom(config?: randomMonomConfig): Monom {\r\n        return new rndMonom(config).generate()\r\n    }\r\n\r\n    export function number(from:number, to:number):number { return rndHelpers.randomInt(from,to)}\r\n    export function numberSym(max:number, allowZero?:boolean):number { return rndHelpers.randomIntSym(max, allowZero)}\r\n    export function bool(percent?:number):boolean { return rndHelpers.randomBool(percent)}\r\n    export function array(arr:any[], number?:number):any[] { return rndHelpers.randomArray(arr, number)}\r\n    export function item(arr:any[]):any { return rndHelpers.randomItem(arr)}\r\n    export function shuffle(arr:any[]):any { rndHelpers.shuffleArray(arr)}\r\n}","export * from \"./equation\"\r\nexport * from \"./linearSystem\"\r\nexport * from \"./logicalset\"\r\nexport * from \"./monom\"\r\nexport * from \"./polynom\"\r\nexport * from \"./rational\"\r\n\r\nimport {Polynom as _Polynom} from \"./polynom\";\r\nimport {Monom as _Monom} from \"./monom\";\r\nimport {LinearSystem as _LinearSystem} from \"./linearSystem\";\r\nimport {Equation as _Equation} from \"./equation\";\r\nimport {Logicalset as _LogicalSet} from \"./logicalset\"\r\nimport {Rational as _Rational} from \"./rational\";\r\n\r\nexport namespace Algebra {\r\n    export class Polynom extends _Polynom{}\r\n    export class Monom extends _Monom{}\r\n    export class LinearSystem extends _LinearSystem{}\r\n    export class Equation extends _Equation{}\r\n    export class LogicalSet extends _LogicalSet{}\r\n    export class Rational extends _Rational{}\r\n}","export * from \"./vector\"\r\nexport * from \"./triangle\"\r\nexport * from \"./point\"\r\nexport * from \"./circle\"\r\nexport * from \"./line\"\r\n\r\nimport {Circle as _Circle} from \"./circle\";\r\nimport {Line as _Line} from \"./line\";\r\nimport {Point as _Point} from \"./point\";\r\nimport {Triangle as _Triangle} from \"./triangle\";\r\nimport {Vector as _Vector} from \"./vector\";\r\n\r\nexport namespace Geometry {\r\n    export class Circle extends _Circle{}\r\n    export class Line extends _Line{}\r\n    export class Point extends _Point{}\r\n    export class Triangle extends _Triangle{}\r\n    export class Vector extends _Vector{}\r\n}","export class Nthroot {\r\n    private _radical: number;\r\n    private _nth: number;\r\n    private _coefficient: number;\r\n    private _isValid:boolean;\r\n\r\n    constructor() {\r\n        this._radical = 1;\r\n        this._coefficient = 1;\r\n        this._nth = 2;\r\n        this._isValid = true;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get radical(): number {\r\n        return this._radical;\r\n    }\r\n\r\n    set radical(value: number) {\r\n        this._radical = value;\r\n    }\r\n\r\n    get nth(): number {\r\n        return this._nth;\r\n    }\r\n\r\n    set nth(value: number) {\r\n        if (Number.isSafeInteger(value) && value >= 2) {\r\n            this._nth = value;\r\n        } else {\r\n            // Error setting the nth root.\r\n            console.log('Error setting the nth root');\r\n            this._nth = 2;\r\n        }\r\n    }\r\n\r\n    get coefficient(): number {\r\n        return this._coefficient;\r\n    }\r\n\r\n    set coefficient(value: number) {\r\n        this._coefficient = value;\r\n    }\r\n\r\n    get tex(): string {\r\n        let C: string;\r\n\r\n        if (this._coefficient === 1) {\r\n            C = '';\r\n        } else if (this._coefficient === -1) {\r\n            C = '-';\r\n        } else {\r\n            C = this._coefficient.toString();\r\n        }\r\n\r\n        if (this._radical === 1) {\r\n            return `${this._coefficient}`;\r\n        } else {\r\n            if (this._nth === 2) {\r\n                return `${C}\\\\sqrt{${this._radical}}`\r\n            } else {\r\n                return `${C}\\\\sqrt[${this._nth}]{${this._radical}}`\r\n            }\r\n        }\r\n    }\r\n\r\n    get value(): number {\r\n        return this._coefficient * Math.pow(this._radical, 1 / this._nth);\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (radical: number, nthroot?: number, coefficient?: number): Nthroot => {\r\n        this._coefficient = (coefficient === undefined) ? 1 : coefficient;\r\n        this._nth = (nthroot === undefined) ? 2 : nthroot;\r\n        this._radical = (radical === undefined) ? 1 : radical;\r\n\r\n        if(this._nth%2===0 && this._radical<0){\r\n            this._isValid = false;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    reduce = (): Nthroot => {\r\n        // Max value to test.\r\n        let V = Math.floor(Math.pow(this._radical, 1 / this._nth));\r\n        while (V > 1) {\r\n            if (this._radical % Math.pow(V, this._nth) === 0) {\r\n                // It's dividable by V^n\r\n                this._coefficient *= V;\r\n                this._radical = this._radical / Math.pow(V, this._nth);\r\n\r\n                // Redifine the new testing value (this is optimization)\r\n                V = Math.floor(Math.pow(this._radical, 1 / this._nth));\r\n                continue;\r\n            }\r\n            V--;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    multiply = (N: Nthroot): Nthroot => {\r\n        this._radical *= N.radical;\r\n        return this.reduce();\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Help functions\r\n    // ------------------------------------------\r\n    hasRadical = ():boolean => {\r\n        return !(this._radical===1 || this._radical===0 || this._isValid===false)\r\n    };\r\n}","import {Polynom} from \"./polynom\";\r\nimport {Monom} from \"./monom\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Fraction} from \"../coefficients\";\r\nimport {Nthroot} from \"../coefficients\";\r\n\r\n/**\r\n * Equation is a class to manage equations...\r\n */\r\nexport class Equation {\r\n    private _left: Polynom;  // Left part of the equation\r\n    private _right: Polynom; // Right part of the equation\r\n    private _sign: string;   // Signe of the equation, by default =\r\n\r\n    private _polynom: Polynom;  // Used to solve the equation // TODO: remove the private value ?\r\n    private _solutions: string[];    // Array of the solutions\r\n\r\n    // Undetermined solutions.\r\n    private _varnothing: string = '\\\\varnothing';\r\n    private _real: string = '\\\\mathbb{R}';\r\n\r\n    /**\r\n     * Create an Equation using two polynoms.\r\n     * Markdown *support* is cool\r\n     * @param equations\r\n     */\r\n    constructor(...equations: any) {\r\n        // Default equation\r\n        this._left = new Polynom().zero();\r\n        this._right = new Polynom().zero();\r\n        this._sign = '=';\r\n\r\n        if (equations.length === 1) {\r\n            if (equations[0].isEquation === true) {\r\n                return equations[0].clone();\r\n            } else {\r\n                this.parse(equations[0]);\r\n            }\r\n        } else if (equations.length === 2) {\r\n            this.left = equations[0].isPolynom ? equations[0].clone() : new Polynom(equations[0]);\r\n            this.right = equations[1].isPolynom ? equations[1].clone() : new Polynom(equations[1]);\r\n        } else {\r\n            // Return default empty equation\r\n            return this;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    get isEquation() {\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    // TODO: Check the getters and setters.\r\n    get solutions(): string[] {\r\n        return this._solutions;\r\n    }\r\n\r\n    get solution(): string {\r\n        if (this._solutions.length === 1\r\n            &&\r\n            (\r\n                this._solutions[0] === this._real\r\n                || this._solutions[0] === this._varnothing\r\n                || this._solutions[0].includes('\\\\left')\r\n            )\r\n        ) {\r\n            return `S = ${this._solutions[0]}`;\r\n        }\r\n        return `S = \\\\left{ ${this._solutions.join(';')} \\\\right}`;\r\n    }\r\n\r\n    get isReal(): boolean {\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n        return this._solutions[0] === this._real;\r\n    }\r\n\r\n    get isVarnothing(): boolean {\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n        return this._solutions[0] === this._varnothing;\r\n    }\r\n\r\n    get signAsTex(): string {\r\n        if (this._sign === '>=' || this._sign === '=>' || this._sign === 'geq') {\r\n            return '\\\\geq';\r\n        }\r\n        if (this._sign === '<=' || this._sign === '=<' || this._sign === 'leq') {\r\n            return '\\\\leq';\r\n        }\r\n        return this._sign;\r\n    }\r\n\r\n    get tex(): string {\r\n        return `${this._left.tex}${this.signAsTex}${this._right.tex}`;\r\n    }\r\n\r\n    get raw(): string {\r\n        return `${this._left.raw}${this.signAsTex}${this._right.raw}`;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        return [...new Set(this._right.variables.concat(this._left.variables))];\r\n    }\r\n\r\n    get numberOfVars(): number {\r\n        return this.variables.length;\r\n    }\r\n\r\n    get left(): Polynom {\r\n        return this._left;\r\n    }\r\n\r\n    set left(value: Polynom) {\r\n        this._left = value;\r\n    }\r\n\r\n    get right(): Polynom {\r\n        return this._right;\r\n    }\r\n\r\n    set right(value: Polynom) {\r\n        this._right = value;\r\n    }\r\n\r\n    get sign(): string {\r\n        return this._sign;\r\n    }\r\n\r\n    set sign(value: string) {\r\n        // Set the sign value as formatted.\r\n        this._sign = this._formatSign(value);\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (equationString: string): Equation => {\r\n        let pStr: string[], strSign: string | false;\r\n        // Find the string separator\r\n        strSign = this._findSign(equationString);\r\n\r\n        if (strSign === false) {\r\n            console.log('The equation is not valid (no sign found)');\r\n            return;\r\n        }\r\n\r\n        // The StrSign is found\r\n        pStr = equationString.split(strSign);\r\n\r\n        return this.create(new Polynom(pStr[0]), new Polynom(pStr[1]), this._formatSign(strSign));\r\n    };\r\n\r\n    private _findSign = (equationString: string): string | false => {\r\n        let strSign: string = '';\r\n\r\n        if (equationString.includes('geq')) {\r\n            return (equationString.includes('\\\\geq')) ? '\\\\geq' : 'geq';\r\n        } else if (equationString.includes('leq')) {\r\n            return (equationString.includes('\\\\leq')) ? '\\\\leq' : 'leq';\r\n        } else if (equationString.includes('>=')) {\r\n            return '>=';\r\n        } else if (equationString.includes('=>')) {\r\n            return '=>';\r\n        } else if (equationString.includes('>')) {\r\n            return '>';\r\n        } else if (equationString.includes('<=')) {\r\n            return '<=';\r\n        } else if (equationString.includes('=<')) {\r\n            return '=<';\r\n        } else if (equationString.includes('<')) {\r\n            return '<';\r\n        } else if (equationString.includes('=')) {\r\n            return '='\r\n        }\r\n        if (strSign === '') {\r\n            console.log('Equation: parse string : sign not found');\r\n            return false;\r\n        }\r\n    };\r\n\r\n    private _formatSign = (signStr: string): string => {\r\n        if (signStr === undefined) {\r\n            return '=';\r\n        }\r\n\r\n        if (signStr.includes('geq')) {\r\n            return '>=';\r\n        } else if (signStr.includes('>=')) {\r\n            return '>=';\r\n        } else if (signStr.includes('=>')) {\r\n            return '>=';\r\n        } else if (signStr.includes('>')) {\r\n            return '>';\r\n        } else if (signStr.includes('leq')) {\r\n            return '<=';\r\n        } else if (signStr.includes('<=')) {\r\n            return '<=';\r\n        } else if (signStr.includes('=<')) {\r\n            return '<=';\r\n        } else if (signStr.includes('<')) {\r\n            return '<';\r\n        } else {\r\n            return '='\r\n        }\r\n    };\r\n\r\n    private _reverseSign = (): Equation => {\r\n        if (this._sign === '=') {\r\n            return this;\r\n        }\r\n\r\n        if (this._sign.includes('<')) {\r\n            this._sign.replace('<', '>');\r\n            return this;\r\n        }\r\n        if (this._sign.includes('>')) {\r\n            this._sign.replace('>', '<');\r\n            return this;\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    create = (left: Polynom, right: Polynom, sign?: string): Equation => {\r\n        this._left = left;\r\n        this._right = right;\r\n        this._sign = this._formatSign(sign);\r\n        return this;\r\n    };\r\n\r\n    clone = (): Equation => {\r\n        return new Equation().create(this._left.clone(), this._right.clone(), this._sign + '');\r\n    };\r\n\r\n    // -----------------------------------------------\r\n    // Equations generators and randomizers\r\n    // -----------------------------------------------\r\n    private _randomizeDefaults: { [key: string]: number | string | boolean } = {\r\n        degree: 2\r\n    };\r\n    get randomizeDefaults(): { [key: string]: number | string | boolean } {\r\n        return this._randomizeDefaults;\r\n    }\r\n\r\n    set randomizeDefaults(value) {\r\n        this._randomizeDefaults = value;\r\n    }\r\n\r\n    randomize = (opts?: {}, sign?: string): Equation => {\r\n        // TODO: Generate equations randomly, using config.\r\n        return new Equation().create(new Polynom(), new Polynom(), sign);\r\n    };\r\n\r\n\r\n    // -----------------------------------------------\r\n    // Equations operations\r\n    // -----------------------------------------------\r\n    /**\r\n     * Reorder will move all monoms containing a letter on the left, all the other on the right.\r\n     */\r\n    moveLeft = (): Equation => {\r\n        this._left = this._left.clone().subtract(this._right)\r\n        this._right.zero()\r\n        return this;\r\n    }\r\n    reorder = (allLeft?: boolean): Equation => {\r\n        // Move all monoms of degree greater than 0 to the left.\r\n        // and all zero degree monoms to the right.\r\n        this._left.subtract(this._right);\r\n        this._right.zero();\r\n\r\n        if (allLeft) {\r\n            return this.moveLeft()\r\n        }\r\n        let mMove: Monom;\r\n        for (let m of this._left.monoms) {\r\n            if (m.degree() === 0) {\r\n                mMove = m.clone();\r\n                this._left.subtract(mMove);\r\n                this._right.subtract(mMove);\r\n            }\r\n        }\r\n\r\n        // Reorder the left and right polynoms\r\n        this._left.reorder();\r\n        this._right.reorder();\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Multiply by the lcm denominator and divide by the gcm numerators.\r\n     */\r\n    simplify = (): Equation => {\r\n        this.multiply(Numeric.lcm(...this._left.getDenominators(),...this._right.getDenominators()));\r\n        this.divide(Numeric.gcd(...this._left.getNumerators(),...this._right.getNumerators()));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reorder the polynom to have only one letter on the left, the rest on the right.\r\n     * @param letter\r\n     */\r\n    isolate = (letter?: string): Equation | false => {\r\n        // Determine if we can isolate the variables.\r\n\r\n        // Both part of the equations must be of the first degree.\r\n        //TODO: handle equations of degree two or more ?\r\n        if (this.degree(letter) !== 1) {\r\n            return false;\r\n        }\r\n\r\n        // Modify the equation to isolate the asked variable.\r\n        // TODO: must handle equations like 3xy+5y=4 => y = 4/(3x-5)\r\n        if (this.isMultiVariable()) {\r\n            return false;\r\n        }\r\n\r\n        // Isolate the letter.\r\n        let mMove: Monom, cMove: Fraction;\r\n        // Start by moving everything to the left.\r\n        this._left.subtract(this._right);\r\n        this._right.zero();\r\n        for (let m of this._left.monoms) {\r\n            if (!m.hasLetter(letter)) {\r\n                mMove = m.clone();\r\n                this._left.add(mMove.clone().opposed());\r\n                this._right.add(mMove.clone().opposed());\r\n            }\r\n        }\r\n\r\n        // In theory, we should have only one item on the left.\r\n        if (this._left.length !== 1) {\r\n            return false;\r\n        }\r\n        cMove = this._left.monoms[0].coefficient.clone();\r\n        this._left.divide(cMove);\r\n        this._right.divide(cMove);\r\n        return this;\r\n    };\r\n\r\n    replaceBy = (letter: string, P: Polynom): Equation => {\r\n        this._left.replaceBy(letter, P)\r\n        this._right.replaceBy(letter, P)\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiple an equation by a fraction value.\r\n     * @param value\r\n     */\r\n    multiply = (value: any): Equation => {\r\n\r\n        // Make sure we have a fraction.\r\n        let F: Fraction = new Fraction(value);\r\n\r\n        // Multiply each part of the equation by the fraction\r\n        this._left.multiply(F);\r\n        this._right.multiply(F);\r\n\r\n        // The sign of the inequation must be changed.\r\n        if (this._sign !== '=' && F.sign() === -1) {\r\n            this._reverseSign();\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * divide an equation by a given value (transformed as a fraction)\r\n     *\r\n     * ```\r\n     * 8x+10=6x \\vert 2\r\n     * 4x+5=3x\r\n     * ```\r\n     *\r\n     * |>Alternatively with $3x-4$ maybe it's working ?\r\n     * $$\\frac{3x}{5}$$\r\n     *\r\n     * @param value\r\n     * @returns {Equation}\r\n     */\r\n    divide = (value: any): Equation => {\r\n        // Make sure we have a fraction.\r\n        let F: Fraction = new Fraction(value);\r\n\r\n        if(F.isZero()){\r\n            return this;\r\n        }else {\r\n            return this.multiply(F.invert());\r\n        }\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations helpers\r\n    // -----------------------------------------------\r\n\r\n    /**\r\n     * Get the degree of the equation\r\n     * @param letter\r\n     */\r\n    degree = (letter?: string): number => {\r\n        return Math.max(this._left.degree(letter), this._right.degree(letter));\r\n    };\r\n\r\n    /**\r\n     * Determine if the equation contains more than one letter/variable.\r\n     */\r\n    isMultiVariable = (): boolean => {\r\n        return this._left.isMultiVariable || this._right.isMultiVariable;\r\n    };\r\n\r\n    letters = (): string[] => {\r\n        // @ts-ignore\r\n        return [...new Set([...this._left.letters(), ...this._right.letters()])];\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations solving algorithms\r\n    // -----------------------------------------------\r\n    solve = (letter?: string): Equation => {\r\n        // Initialise the variables:\r\n        this._solutions = [];\r\n\r\n        // TODO: this._polynom could be removed.\r\n        // TODO: consolidate solving equations (inequations vs equations)\r\n        this._polynom = this._left.clone().subtract(this._right);\r\n\r\n        switch (this._polynom.degree(letter)) {\r\n            case 0:\r\n            case 1:\r\n                this._solveDegree1(letter);\r\n                break;\r\n            case 2:\r\n                this._solveDegree2(letter);\r\n                break;\r\n            default:\r\n                this._solveDegree3plus(letter);\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    private isGreater = (): boolean => {\r\n        if (this._sign.indexOf('>') !== -1) {\r\n            return true;\r\n        }\r\n        return this._sign.indexOf('geq') !== -1;\r\n\r\n    };\r\n    private isStrictEqual = (): boolean => {\r\n        return this._sign === '=';\r\n    };\r\n    private isAlsoEqual = (): boolean => {\r\n        if (this._sign.indexOf('=') !== -1) {\r\n            return true;\r\n        }\r\n        if (this._sign.indexOf('geq') !== -1) {\r\n            return true;\r\n        }\r\n        if (this._sign.indexOf('leq') !== -1) {\r\n            return true;\r\n        }\r\n    };\r\n\r\n    private _solveDegree1 = (letter?: string): string[] => {\r\n        const m1 = this._polynom.monomByDegree(1, letter).coefficient,\r\n            m0 = this._polynom.monomByDegree(0, letter).coefficient,\r\n            v = m0.clone().opposed().divide(m1).display;\r\n        let s: string;\r\n\r\n        if (this.isStrictEqual()) {\r\n            if (m1.value === 0) {\r\n                // In this case, the coefficient of the x variable is zero.\r\n                if (m0.value === 0) {\r\n                    this._solutions = [this._real];\r\n                } else {\r\n                    this._solutions = [this._varnothing];\r\n                }\r\n            } else {\r\n                this._solutions = [v];\r\n            }\r\n        } else {\r\n            if (m1.value === 0) {\r\n                // In this case, the coefficient of the x variable is zero.\r\n                if (m0.value === 0 && this.isAlsoEqual()) {\r\n                    s = '\\\\mathbb{R}';\r\n                } else {\r\n                    if (m0.value > 0) {\r\n                        s = this.isGreater() ? this._real : this._varnothing;\r\n                    } else {\r\n                        s = !this.isGreater() ? this._real : this._varnothing;\r\n                    }\r\n                }\r\n            } else {\r\n                // Must handle the case if the m1 monom is negative.\r\n                if ((this.isGreater() && m1.sign() === 1) || (!this.isGreater() && m1.sign() === -1)) {\r\n                    s = `\\\\left${this.isAlsoEqual() ? '\\\\[' : '\\\\]'}${v};+\\\\infty\\\\right\\\\[`;\r\n                } else {\r\n                    s = `\\\\left\\\\]-\\\\infty;${v} \\\\right\\\\${this.isAlsoEqual() ? '\\\\]' : '\\\\['}`;\r\n                }\r\n            }\r\n            this._solutions = [s];\r\n        }\r\n\r\n        return this._solutions;\r\n    };\r\n\r\n    private _solveDegree2 = (letter?: string): string[] => {\r\n        let aF = this._polynom.monomByDegree(2, letter).coefficient,\r\n            bF = this._polynom.monomByDegree(1, letter).coefficient,\r\n            cF = this._polynom.monomByDegree(0, letter).coefficient,\r\n            delta: number, nthDelta: Nthroot,\r\n            lcm = Numeric.lcm(aF.denominator, bF.denominator, cF.denominator),\r\n            a = aF.multiply(lcm).value,\r\n            b = bF.multiply(lcm).value,\r\n            c = cF.multiply(lcm).value,\r\n            realX1: number, realX2: number,\r\n            sX1: string, sX2: string;\r\n\r\n        delta = b * b - 4 * a * c;\r\n\r\n        if (delta > 0) {\r\n            realX1 = (-b - Math.sqrt(delta)) / (2 * a);\r\n            realX2 = (-b + Math.sqrt(delta)) / (2 * a);\r\n\r\n            if(delta>1.0e5){\r\n                // The delta is too big to be parsed !\r\n                this._solutions = [\r\n                    ((-b - Math.sqrt(delta))/(2 * a)).toFixed(5),\r\n                    ((-b + Math.sqrt(delta))/(2 * a)).toFixed(5)\r\n                ]\r\n            }else {\r\n                nthDelta = new Nthroot().parse(delta).reduce();\r\n                if (nthDelta.hasRadical()) {\r\n                    // -b +- coeff\\sqrt{radical}\r\n                    // -------------------------\r\n                    //           2a\r\n                    let gcd = Numeric.gcd(b, 2 * a, nthDelta.coefficient);\r\n                    nthDelta.coefficient = nthDelta.coefficient / gcd;\r\n\r\n                    // TODO: Can i delete the next line ?\r\n                    // let deltaC = nthDelta.coefficient, deltaR = nthDelta.radical;\r\n                    if (b !== 0) {\r\n                        if (2 * a / gcd === 1) {\r\n                            this._solutions = [\r\n                                `${-b / gcd} - ${nthDelta.tex}`,\r\n                                `${-b / gcd} + ${nthDelta.tex}`,\r\n                            ]\r\n                        } else {\r\n                            this._solutions = [\r\n                                `\\\\dfrac{${-b / gcd} - ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                                `\\\\dfrac{${-b / gcd} + ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                            ]\r\n                        }\r\n                    } else {\r\n                        if (2 * a / gcd === 1) {\r\n                            this._solutions = [\r\n                                `- ${nthDelta.tex}`,\r\n                                `${nthDelta.tex}`,\r\n                            ]\r\n                        } else {\r\n                            this._solutions = [\r\n                                `\\\\dfrac{- ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                                `\\\\dfrac{${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                            ]\r\n                        }\r\n                    }\r\n                } else {\r\n                    // -b +- d / 2a\r\n                    this._solutions = [\r\n                        new Fraction(-b - nthDelta.coefficient, 2 * a).reduce().dfrac,\r\n                        new Fraction(-b + nthDelta.coefficient, 2 * a).reduce().dfrac\r\n                    ]\r\n                }\r\n            }\r\n\r\n        } else if (delta === 0) {\r\n            this._solutions = [new Fraction(-b, 2 * a).reduce().dfrac];\r\n        } else {\r\n            this._solutions = [this._varnothing];\r\n        }\r\n\r\n\r\n        // Handle now the inequations.\r\n        if (!this.isStrictEqual()) {\r\n            if (this._solutions.length === 2) {\r\n                sX1 = (realX1 < realX2) ? this._solutions[0] : this._solutions[1];\r\n                sX2 = (realX1 < realX2) ? this._solutions[1] : this._solutions[0];\r\n\r\n                if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                    this._solutions = [\r\n                        `\\\\left]-\\\\infty ; ${sX1}\\\\right${this.isAlsoEqual() ? ']' : '['} \\\\cup \\\\left${this.isAlsoEqual() ? '[' : ']'}${sX2};+\\\\infty\\\\right[`\r\n                    ];\r\n                } else {\r\n                    this._solutions = [\r\n                        `\\\\left${this.isAlsoEqual() ? '[' : ']'}${sX1} ; ${sX2}\\\\right${this.isAlsoEqual() ? ']' : '['}`\r\n                    ]\r\n                }\r\n            } else if (this._solutions.length === 1 && this._solutions[0] !== this._varnothing) {\r\n                if (!this.isAlsoEqual()) {\r\n                    if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                        this._solutions = [\r\n                            `\\\\left]-\\\\infty ; ${this._solutions[0]}\\\\right[ \\\\cup \\\\left]${this._solutions[0]};+\\\\infty\\\\right[`\r\n                        ];\r\n                    } else {\r\n                        this._solutions = [this._varnothing];\r\n                    }\r\n                } else {\r\n                    if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                        this._solutions = [this._real];\r\n                    } else {\r\n                        // this._solutions = [ this._solutions[0] ];\r\n                    }\r\n                }\r\n            } else {\r\n                if (this.isGreater()) {\r\n                    this._solutions = [aF.sign() === 1 ? this._real : this._varnothing];\r\n                } else {\r\n                    this._solutions = [aF.sign() === -1 ? this._real : this._varnothing];\r\n                }\r\n            }\r\n        }\r\n        return this._solutions;\r\n    };\r\n\r\n    private _solveDegree3plus = (letter?: string): string[] => {\r\n        // TODO: try to resolve equations with a degree superior than 2.\r\n        this._solutions = [letter];  // ESLint remove system :(\r\n        return this._solutions;\r\n    };\r\n\r\n}","import {Fraction} from \"../coefficients\";\r\nimport {Equation} from \"./equation\";\r\nimport {Polynom} from \"./polynom\";\r\nimport {Monom} from \"./monom\";\r\nimport {Random} from \"../random\";\r\n\r\n    export class LinearSystem {\r\n        private _solutions: { [letter: string]: { value: Fraction, isReal: boolean, isVarnothing: boolean } };\r\n        private _resolutionSteps: LinearSystem[];\r\n        private _equations: Equation[];\r\n        private _letters: string[];\r\n\r\n        constructor(...equationStrings: string[]) {\r\n            this._equations = [];\r\n            this._letters = 'xy'.split('');\r\n\r\n            if (equationStrings !== undefined && equationStrings.length > 0) {\r\n                this.parse(...equationStrings);\r\n            }\r\n\r\n            return this;\r\n        }\r\n\r\n        get isLinerarSystem() {\r\n            return true;\r\n        }\r\n\r\n        // ------------------------------------------\r\n        // Getter and setter\r\n        // ------------------------------------------\r\n        get equations(): Equation[] {\r\n            return this._equations;\r\n        }\r\n\r\n        set equations(value) {\r\n            this._equations = value;\r\n        }\r\n\r\n        get letters(): string {\r\n            return this._letters.join('')\r\n        }\r\n\r\n        set letters(value: string) {\r\n            this._letters = value.split('');\r\n        }\r\n\r\n        get isSolvable(): boolean {\r\n            let V = this.variables;\r\n\r\n            // TODO: in some case, it is possible to resolve systems if there isn't the isSame number of vars and equations\r\n            if (V.length !== this._equations.length) {\r\n                return false;\r\n            }\r\n\r\n            //TOOD: Must check if two equations isn't a linear combination of the others ?\r\n\r\n            return true;\r\n        }\r\n\r\n        get variables(): string[] {\r\n            let V: string[] = [];\r\n            for (let E of this._equations) {\r\n                V = V.concat(E.variables);\r\n            }\r\n            return [...new Set(V)].sort();\r\n        }\r\n\r\n        get tex(): string {\r\n            // Build the array of values.\r\n            // Reorder\r\n            // This clone the system :!!!\r\n            //TODO: Avoid cloning this linear system\r\n            let LS = this.clone().reorder(),\r\n                letters = LS.variables,\r\n                equStr: string[],\r\n                equArray: string[] = [],\r\n                m: Monom;\r\n\r\n            // TODO: Manage tex output of linear equations\r\n            for (let equ of LS.equations) {\r\n                equStr = [];\r\n                for (let L of letters) {\r\n                    m = equ.left.monomByLetter(L);\r\n\r\n                    if (equStr.length === 0) {\r\n                        equStr.push(m.isZero() ? '' : m.tex);\r\n                    } else {\r\n                        equStr.push(m.isZero() ? '' : ((m.coefficient.sign() === 1) ? '+' : '') + m.tex);\r\n                    }\r\n                }\r\n\r\n                // Add the equal sign\r\n                equStr.push('=');\r\n\r\n                // Add the right hand part of the equation (should be only a number, because it has been reorderd)\r\n                equStr.push(equ.right.tex);\r\n\r\n                // Add to the list.\r\n                equArray.push(equStr.join('&'));\r\n            }\r\n\r\n\r\n            return `\\\\left\\\\{\\\\begin{array}{${\"r\".repeat(letters.length)}cl}${equArray.join('\\\\\\\\\\ ')}\\\\end{array}\\\\right.`;\r\n            //return `\\\\left\\\\{\\\\begin{array}{rrrcl}${this._equations.map(equ => `${equ.tex}`).join('\\\\\\\\\\ \\n')}\\\\end{array}\\\\right.`;\r\n        }\r\n\r\n        get texSolution(): string {\r\n            let tex: string[] = [];\r\n\r\n            if (this._solutions === undefined) {\r\n                this.solve();\r\n            }\r\n\r\n            for (let letter in this._solutions) {\r\n                if (this._solutions[letter].isReal) {\r\n                    console.log(`Undetermined (letter ${letter})`);\r\n                    return;\r\n                }\r\n                if (this._solutions[letter].isVarnothing) {\r\n                    console.log(`Undefined (letter ${letter})`);\r\n                    return;\r\n                }\r\n\r\n                tex.push(this._solutions[letter].value.dfrac);\r\n            }\r\n            return `(${tex.join(';')})`;\r\n        }\r\n\r\n        // ------------------------------------------\r\n        // Creation / parsing functions\r\n        // ------------------------------------------\r\n        parse = (...equations: any[]): LinearSystem => {\r\n            this._equations = equations.map(value => new Equation(value));\r\n            this._findLetters();\r\n            return this;\r\n        };\r\n\r\n        setCoefficient = (...coefficients: string[]): LinearSystem => {\r\n            // Reset the equations list\r\n            this._equations = [];\r\n\r\n            let i = 0;\r\n            while (i < coefficients.length - this._letters.length) {\r\n                let left = new Polynom().parse(this._letters.join(''), ...coefficients.slice(i, i + this._letters.length)),\r\n                    right = new Polynom(coefficients[i + this._letters.length].toString()),\r\n                    equ = new Equation().create(left, right);\r\n                this._equations.push(equ.clone());\r\n\r\n                i = i + this._letters.length + 1;\r\n            }\r\n            return this;\r\n        };\r\n\r\n        clone = (): LinearSystem => {\r\n            return new LinearSystem().parse(...this._equations.map(equ => equ.clone()));\r\n        };\r\n\r\n        setLetters = (...letters: string[]): LinearSystem => {\r\n            this._letters = letters;\r\n            return this\r\n        }\r\n        private _findLetters = (): LinearSystem => {\r\n            // Find all letters used.\r\n            let variables = new Set();\r\n\r\n            for (let equ of this._equations) {\r\n                variables = new Set([...variables, ...equ.variables]);\r\n            }\r\n\r\n            // TODO: How to transform (Set of string) to string[]\r\n            // @ts-ignore\r\n            this._letters = [...variables];\r\n            return this;\r\n        }\r\n\r\n        // -----------------------------------------------\r\n        // Equations generators and randomizers\r\n        // -----------------------------------------------\r\n        generate = (...solutions: Fraction[] | number[]): LinearSystem => {\r\n            let solutionsF: Fraction[] = [];\r\n\r\n            // Convert the numbers to fractions if necessary\r\n            for (let s of solutions) {\r\n                if (typeof s === \"number\") {\r\n                    solutionsF.push(new Fraction(s.toString()));\r\n                } else {\r\n                    solutionsF.push(s.clone());\r\n                }\r\n            }\r\n\r\n            // Create the equations and make sure they are not linear combined.\r\n            this._equations = [];\r\n            for (let i = 0; i < solutions.length; i++) {\r\n                this._equations.push(this._generateOneEquation(...solutionsF));\r\n            }\r\n            return this;\r\n        };\r\n        private _generateOneEquation = (...solutions: Fraction[]): Equation => {\r\n            let coeff: number[] = [], leftValue: Fraction = new Fraction().zero(),\r\n                letters: string[] = ['x', 'y', 'z', 't', 'u', 'v', 'w', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l'],\r\n                equString: string = '', equ: Equation;\r\n            for (let i = 0; i < solutions.length; i++) {\r\n                coeff.push(Random.numberSym(5));\r\n                leftValue.add(solutions[i].clone().multiply(coeff[i]));\r\n                equString += `${(coeff[i] < 0) ? coeff[i] : '+' + coeff[i]}${letters[i]}`\r\n            }\r\n\r\n            // LeftValue contains the left part oof the equation - and is then the isSame as the right part.\r\n            // It might be a Fraction.\r\n\r\n            // Must check if it's not a linear combination\r\n            equ = new Equation(`${equString}=${leftValue.display}`);\r\n            if (equ.right.monoms[0].coefficient.denominator != 1) {\r\n                equ.multiply(new Fraction(equ.right.monoms[0].coefficient.denominator, 1));\r\n            }\r\n            if (this._checkIfLinerCombination(equ)) {\r\n                return equ;\r\n            } else {\r\n                return this._generateOneEquation(...solutions);\r\n            }\r\n        };\r\n\r\n\r\n        // ------------------------------------------\r\n        // Mathematical operations\r\n        // ------------------------------------------\r\n        private _linearReduction(eq1: Equation, eq2: Equation, letter: string): Equation {\r\n            // TODO: handle other signs for equations ?\r\n            // Get the monom for the particular letter.\r\n            let c1 = eq1.left.monomByDegree(1, letter).coefficient.clone(),\r\n                c2 = eq2.left.monomByDegree(1, letter).coefficient.clone().opposed();\r\n\r\n            return this.mergeEquations(eq1, eq2, c2, c1);\r\n        }\r\n\r\n        mergeEquations = (eq1: Equation, eq2: Equation, factor1: any, factor2: any): Equation => {\r\n            // Set and clone the equations.\r\n\r\n            let eq1multiplied = eq1.clone().multiply(new Fraction(factor1)),\r\n                eq2multiplied = eq2.clone().multiply(new Fraction(factor2));\r\n\r\n            // Add both equations together.\r\n            eq1multiplied.left.add(eq2multiplied.left);\r\n            eq1multiplied.right.add(eq2multiplied.right);\r\n\r\n            return eq1multiplied;\r\n        }\r\n\r\n\r\n        // ------------------------------------------\r\n        // Solvers algorithm\r\n        // ------------------------------------------\r\n        reorder = (): LinearSystem => {\r\n            for (let E of this._equations) {\r\n                E.reorder();\r\n            }\r\n            return this;\r\n        };\r\n\r\n        solve = (): LinearSystem => {\r\n            // Solve it by linear\r\n            this._solutions = {};\r\n            this._resolutionSteps = [];\r\n\r\n            // Reorder all equations.\r\n            this.reorder();\r\n\r\n            // Get all variables in the linear system\r\n            let V = this.variables.sort();\r\n\r\n            for (let letter of V) {\r\n                this._solutions[letter] = this._solveOneLetter(letter, V)\r\n            }\r\n\r\n            // TODO: LinearSystem - solve: optimization and handle undetermined and undefined systems.\r\n            return this;\r\n        };\r\n\r\n        private _checkIfLinerCombination = (equ: Equation): boolean => {\r\n\r\n            return true;\r\n        };\r\n\r\n        private _solveOneLetter(letter: string, V: string[]): { value: Fraction, isReal: boolean, isVarnothing: boolean } {\r\n            // list of equations.\r\n            let LE: Equation[] = this.clone().equations,\r\n                reducedEquations: Equation[] = [];\r\n\r\n            // Reduce the equations.\r\n            // Do it as long as there is more than one step, but no more than the number of equations.\r\n            for (let L of V) {\r\n                // remove the setLetter from all equations using linear combinations\r\n                if (L === letter) {\r\n                    continue;\r\n                }\r\n\r\n                // Linear reduction.\r\n                // TODO: Search for better association\r\n                for (let i = 0; i < LE.length - 1; i++) {\r\n                    reducedEquations.push(this._linearReduction(LE[i], LE[i + 1], L));\r\n                }\r\n\r\n                // Keep track of each steps.\r\n                this._resolutionSteps.push(new LinearSystem().parse(...reducedEquations));\r\n\r\n                // Set the list of equations to the new version.\r\n                LE = this._resolutionSteps[this._resolutionSteps.length - 1].clone().equations;\r\n\r\n                // Reset the stack\r\n                reducedEquations = [];\r\n            }\r\n\r\n            // Solve the equations\r\n            let E = this._resolutionSteps[this._resolutionSteps.length - 1].equations[0];\r\n            E.solve();\r\n\r\n            return {\r\n                value: new Fraction(E.solutions[0]),\r\n                isReal: E.isReal,\r\n                isVarnothing: E.isVarnothing\r\n            }\r\n        }\r\n\r\n        // ------------------------------------------\r\n        // Helpers\r\n        // ------------------------------------------\r\n        log = (): string => {\r\n            let str: string = '';\r\n\r\n            for (let E of this._equations) {\r\n                console.log(E.tex);\r\n                str += `${E.tex}\\\\n}`;\r\n            }\r\n\r\n            return str;\r\n        };\r\n    }\r\n","/**\r\n * Polynom module contains everything necessary to handle polynoms.\r\n * @module Logicalset\r\n */\r\n\r\nimport {Shutingyard} from '../shutingyard';\r\n\r\n/**\r\n * Polynom class can handle polynoms, reorder, resolve, ...\r\n */\r\n    export class Logicalset {\r\n        private _rawString: string;\r\n        private _rpn: { token: string, tokenType: string }[]\r\n\r\n        /**\r\n         *\r\n         * @param {string} value (optional) Default polynom to parse on class creation\r\n         */\r\n        constructor(value: string) {\r\n            this._rawString = value\r\n            this.parse(value)\r\n            return this;\r\n        }\r\n\r\n        get isLogicalset() {\r\n            return true;\r\n        };\r\n\r\n        private parse = (value: string): Logicalset => {\r\n            // TODO: Must format the value string to convert some items...\r\n\r\n            // Parse the updated value to the shutingyard algorithm\r\n            this._rpn = new Shutingyard('set').parse(value).rpn;\r\n\r\n            return this;\r\n        }\r\n\r\n        evaluate(tokenSets: { [key: string]: any[] }, reference?: any[]): any[] {\r\n            let varStack: (Set<unknown>)[] = []\r\n\r\n            let referenceSet: Set<unknown>\r\n            if (reference === undefined) {\r\n                referenceSet = new Set()\r\n                for (let key in tokenSets) {\r\n                    referenceSet = new Set([...referenceSet, ...tokenSets[key]])\r\n                }\r\n            } else {\r\n                referenceSet = new Set(reference)\r\n            }\r\n\r\n            for (let token of this._rpn) {\r\n                if (token.tokenType === 'variable') {\r\n                    // The variable has no token - assume it's empty.\r\n                    if (tokenSets[token.token] === undefined) {\r\n                        varStack.push(new Set())\r\n                    } else {\r\n                        varStack.push(new Set(tokenSets[token.token]));\r\n                    }\r\n\r\n                } else {\r\n                    switch (token.token) {\r\n                        case '&':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                varStack.push(new Set([...first].filter(x => second.has(x))))\r\n                            }\r\n                            break\r\n                        case '|':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n                                varStack.push(new Set([...first, ...second]))\r\n                            }\r\n                            break\r\n                        case '-':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n                                varStack.push(new Set([...first].filter(x => !second.has(x))))\r\n                            }\r\n                            break\r\n                        case '!':\r\n                            if (varStack.length >= 1) {\r\n                                let first = varStack.pop()\r\n\r\n                                varStack.push(new Set([...referenceSet].filter(x => !first.has(x))))\r\n                            }\r\n                            break\r\n                    }\r\n                }\r\n            }\r\n\r\n            return [...varStack[0]].sort();\r\n        }\r\n\r\n        vennAB(): any[] {\r\n            return this.evaluate({\r\n                    A: ['A', 'AB'],\r\n                    B: ['B', 'AB']\r\n                },\r\n                ['A', 'B', 'AB', 'E']\r\n            )\r\n        }\r\n\r\n        vennABC(): any[] {\r\n            return this.evaluate({\r\n                    A: ['A', 'AB', 'AC', 'ABC'],\r\n                    B: ['B', 'AB', 'BC', 'ABC'],\r\n                    C: ['C', 'AC', 'BC', 'ABC']\r\n                },\r\n                ['A', 'B', 'C', 'AB', 'AC', 'BC', 'E']\r\n            )\r\n        }\r\n\r\n        get rpn(): { token: string, tokenType: string }[] {\r\n            return this._rpn\r\n        }\r\n\r\n        get tex(): string {\r\n            let varStack: { token: string, tokenType: string } [] = []\r\n\r\n            for (let token of this._rpn) {\r\n                if (token.tokenType === 'variable') {\r\n                    varStack.push(token);\r\n                } else {\r\n                    switch (token.token) {\r\n                        case '&':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\cap ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                            break\r\n                        case '|':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\cup ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                            break\r\n                        case '-':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\setminus ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                            break\r\n                        case '!':\r\n                            if (varStack.length >= 1) {\r\n                                let first = varStack.pop()\r\n                                varStack.push({token: `\\\\overline{ ${first.token} }`, tokenType: 'variable'})\r\n                            }\r\n                            break\r\n                    }\r\n                }\r\n            }\r\n\r\n            return varStack[0].token\r\n        }\r\n    }","/**\r\n * Rational polynom module contains everything necessary to handle rational polynoms.\r\n * @module Polynom\r\n */\r\n\r\nimport {Polynom} from \"./polynom\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\n/**\r\n * Rational class can handle rational polynoms\r\n */\r\n    export class Rational {\r\n        private _rawString: string;\r\n        private _numerator: Polynom;\r\n        private _denominator: Polynom;\r\n\r\n        /**\r\n         *\r\n         * @param numerator\r\n         * @param denominator\r\n         */\r\n        constructor(numerator?: Polynom, denominator?: Polynom) {\r\n            this._numerator = numerator ? numerator.clone() : new Polynom();\r\n            this._denominator = denominator ? denominator.clone() : new Polynom();\r\n        }\r\n\r\n        clone = (): Rational => {\r\n            this._numerator = this._numerator.clone()\r\n            this._denominator = this._denominator.clone()\r\n\r\n            return this;\r\n        }\r\n\r\n        get tex(): string {\r\n            return `\\\\dfrac{ ${this._numerator.tex} }{ ${this._denominator.tex} }`;\r\n        }\r\n\r\n        get texFactors(): string {\r\n            this._numerator.factorize()\r\n            this._denominator.factorize()\r\n\r\n            return `\\\\dfrac{ ${this._numerator.texFactors} }{ ${this._denominator.texFactors} }`\r\n        }\r\n\r\n        get numerator(): Polynom {\r\n            return this._numerator\r\n        }\r\n\r\n        get denominator(): Polynom {\r\n            return this._denominator\r\n        }\r\n\r\n        domain = (): string => {\r\n            let zeroes = this._denominator.getZeroes();\r\n            if (zeroes.length === 0 || zeroes[0] === false) {\r\n                return '\\\\mathbb{R}'\r\n            } else if (zeroes[0] === true) {\r\n                return '\\\\varnothing'\r\n            } else {\r\n                return '\\\\mathbb{R}\\\\setminus\\\\left{' +\r\n                    zeroes.map(x => {\r\n                        return (typeof x === 'boolean') ? '' : x.frac\r\n                    })\r\n                        .join(';') + '\\\\right}'\r\n            }\r\n        }\r\n\r\n        amplify = (P: Polynom): Rational => {\r\n            this._numerator.multiply(P);\r\n            this._denominator.multiply(P);\r\n\r\n            return this;\r\n        }\r\n\r\n        simplify = (P: Polynom): Rational => {\r\n            let NumeratorEuclidien = this._numerator.euclidian(P);\r\n            if (!NumeratorEuclidien.reminder.isZero()) {\r\n                return this;\r\n            }\r\n\r\n            let DenominatorEuclidien = this._denominator.euclidian(P);\r\n            if (!DenominatorEuclidien.reminder.isZero()) {\r\n                return this;\r\n            }\r\n\r\n            this._numerator = NumeratorEuclidien.quotient;\r\n            this._denominator = DenominatorEuclidien.quotient;\r\n            return this;\r\n        }\r\n\r\n        reduce = (): Rational => {\r\n            console.log(this._numerator.tex)\r\n            this._numerator.factorize();\r\n            console.log(this._numerator.factors.map(x => x.tex))\r\n            for (let f of this._numerator.factors) {\r\n                this.simplify(f);\r\n            }\r\n\r\n            return this;\r\n        }\r\n\r\n        opposed = (): Rational => {\r\n            this._numerator.opposed();\r\n            return this;\r\n        }\r\n        add = (R: Rational): Rational => {\r\n            // 1. Make sure both rational are at the same denominator\r\n            // 2. Add the numerators.\r\n            // 3. Simplify\r\n\r\n            // Store the adding denominator\r\n            let denominator = this._denominator.clone()\r\n\r\n            // Amplif the main rational polynom by the adding denominator\r\n            this.amplify(R._denominator)\r\n\r\n            // Add to the numerator the adding value...\r\n            this._numerator.add(R._numerator.clone().multiply(denominator));\r\n\r\n            return this;\r\n        }\r\n\r\n        subtract = (R: Rational): Rational => {\r\n            return this.add(R.clone().opposed())\r\n        }\r\n\r\n        limits = (value: Fraction | number, letter?: string): Fraction | number => {\r\n            if (value === Infinity || value === -Infinity) {\r\n                let N = this._numerator.monomByDegree(this._numerator.degree(letter), letter),\r\n                    D = this._denominator.monomByDegree(this._denominator.degree(letter), letter)\r\n\r\n                N.divide(D)\r\n\r\n                if (N.degree(letter) > 0) {\r\n                    return N.coefficient.sign() * (Math.pow((value > 0 ? 1 : -1), N.degree(letter) % 2)) === 1 ? Infinity : -Infinity\r\n                }\r\n                if (N.degree(letter) === 0) {\r\n                    return N.coefficient\r\n                }\r\n                if (N.degree(letter) > 0) {\r\n                    return N.coefficient.sign() * (Math.pow(-1, N.degree(letter) % 2)) === 1 ? 0 : -0\r\n                }\r\n            } else {\r\n                return this._numerator.evaluate({letter: value}).divide(this._denominator.evaluate({letter: value}))\r\n            }\r\n        }\r\n    }\r\n","/**\r\n * Vector module contains everything necessary to handle 2d or 3d vectors.\r\n * @module Vector\r\n */\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Numeric} from \"../numeric\";\r\n\r\nexport class Vector {\r\n    private _x: Fraction;   // 1st component\r\n    private _y: Fraction;   // 2nd component\r\n\r\n    constructor(...values: any) {\r\n        this._x = new Fraction().zero();\r\n        this._y = new Fraction().zero();\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values);\r\n        }\r\n    };\r\n\r\n    get isVector() {\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get x(): Fraction {\r\n        return this._x;\r\n    }\r\n\r\n    set x(value: Fraction) {\r\n        this._x = value;\r\n    }\r\n\r\n    get y(): Fraction {\r\n        return this._y;\r\n    }\r\n\r\n    set y(value: Fraction) {\r\n        this._y = value;\r\n    }\r\n\r\n    get normSquare(): Fraction {\r\n        return this._x.clone().pow(2).add(this._y.clone().pow(2));\r\n    }\r\n\r\n    get norm(): number {\r\n        return Math.sqrt(this.normSquare.value);\r\n    }\r\n\r\n    get tex(): string {\r\n        return `\\\\begin{pmatrix}${this._x.tex} \\\\\\\\\\ ${this._y.tex} \\\\end{pmatrix}`\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n    parse = (...values: any): Vector => {\r\n        // TODO: Must be more strict about what is given and limit to two dimensional vectors.p\r\n        // Maybe more than one value was given...\r\n        // Initialize the vector\r\n        this.zero();\r\n\r\n        if (values.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        if (values.length === 1) {\r\n            if (values[0].isVector) {\r\n                return values[0].clone()\r\n            } else {\r\n                return this._parseString(values[0])\r\n            }\r\n        }\r\n\r\n        if (values.length >= 2) {\r\n            // Two points are given - skip the third value.\r\n            if (values[0].isPoint && values[1].isPoint) {\r\n                this._x = values[1].x.clone().subtract(values[0].x)\r\n                this._y = values[1].y.clone().subtract(values[0].y)\r\n                return this;\r\n            }\r\n\r\n            // Fractions or a number are give\r\n            if (values[0].isFraction || !isNaN(values[0])) {\r\n                this._x = new Fraction(values[0])\r\n            }\r\n            if (values[1].isFraction || !isNaN(values[1])) {\r\n                this._y = new Fraction(values[1])\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    clone = (): Vector => {\r\n        let V = new Vector();\r\n\r\n        if (this._x !== null) {\r\n            V.x = this._x.clone();\r\n        }\r\n        if (this._y !== null) {\r\n            V.y = this._y.clone();\r\n        }\r\n        return V;\r\n    }\r\n\r\n    reset = (): Vector => {\r\n        this._x = null;\r\n        this._y = null;\r\n        return this;\r\n    }\r\n\r\n    zero = (): Vector => {\r\n        this.reset();\r\n        this._x = new Fraction(null);\r\n        this._y = new Fraction(null);\r\n        return this;\r\n    }\r\n\r\n    one = (): Vector => {\r\n        this._x = new Fraction();\r\n        this._y = new Fraction();\r\n        return this;\r\n    }\r\n\r\n    private _parseString = (value: string): Vector => {\r\n        // Split comma, semi colon or single space.\r\n        let components = value.split(/[,;\\s]/g);\r\n\r\n        // Validate the fraction values.\r\n        this.x = new Fraction(components[0] || null);\r\n        this.y = new Fraction(components[1] || null);\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    opposed = (): Vector => {\r\n        this._x.opposed();\r\n        this._y.opposed();\r\n        return this;\r\n    }\r\n\r\n    add = (V: Vector): Vector => {\r\n        this._x.add(V.x);\r\n        this._y.add(V.y);\r\n\r\n        return this;\r\n    }\r\n\r\n    subtract = (V: Vector): Vector => {\r\n        return this.add(V.clone().opposed());\r\n    }\r\n\r\n    scalarProductWithVector = (V: Vector): Fraction => {\r\n        // TODO: Add the scalar factor !!!!\r\n        return this._x.clone().multiply(V.x).add(this._y.clone().multiply(V.y));\r\n    }\r\n\r\n    static scalarProduct = (v1: Vector, v2: Vector): number => {\r\n        // TODO: Transform to fraction with nthroot.\r\n        return  v1.x.value * v2.x.value + v1.y.value * v2.y.value;\r\n    };\r\n\r\n    normal = (): Vector => {\r\n        let x = this.x.clone().opposed(), y = this.y.clone();\r\n        this._x = y;\r\n        this._y = x;\r\n        return this;\r\n    }\r\n\r\n    isNormalTo = (v: Vector): boolean => {\r\n        return this.scalarProductWithVector(v).isZero()\r\n    }\r\n\r\n    multiplyByScalar = (k: any): Vector => {\r\n        let scalar = new Fraction(k);\r\n        this._x.multiply(scalar);\r\n        this._y.multiply(scalar);\r\n        return this;\r\n    }\r\n\r\n    divideByScalar = (k:any): Vector => {\r\n        return this.multiplyByScalar(new Fraction(k).invert());\r\n    }\r\n    // ------------------------------------------\r\n    // Vector functions\r\n    // ------------------------------------------\r\n\r\n    simplify = (): Vector => {\r\n        // Multiply by the lcm of denominators.\r\n        return this.multiplyByScalar(Numeric.lcm(this._x.denominator, this._y.denominator))\r\n            .divideByScalar(Numeric.gcd(this._x.numerator, this._y.numerator));\r\n    }\r\n\r\n    angleWith = (V: Vector, sharp?: Boolean, radian?: Boolean): number => {\r\n        let scalar = this.scalarProductWithVector(V).value,\r\n            toDegree = radian ? 1 : 180 / Math.PI;\r\n        if (sharp) {\r\n            scalar = Math.abs(scalar);\r\n        }\r\n\r\n        return toDegree * Math.acos(scalar / (this.norm * V.norm));\r\n    }\r\n}\r\n","/**\r\n * Vector module contains everything necessary to handle 2d or 3d vectors.\r\n * @module Vector\r\n */\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\n//TODO: Ajouter une vérification si la droite existe.\r\nexport class Point {\r\n    private _x: Fraction;   // 1st component\r\n    private _y: Fraction;   // 2nd component\r\n    private _exist: Boolean;\r\n\r\n    constructor(...values: any) {\r\n        this._x = new Fraction().zero();\r\n        this._y = new Fraction().zero();\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values);\r\n        }\r\n\r\n        return this\r\n    };\r\n\r\n    get isPoint() {\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get x(): Fraction {\r\n        return this._x;\r\n    }\r\n\r\n    set x(value: Fraction) {\r\n        this._x = value;\r\n    }\r\n\r\n    get y(): Fraction {\r\n        return this._y;\r\n    }\r\n\r\n    set y(value: Fraction) {\r\n        this._y = value;\r\n    }\r\n\r\n    get tex(): string {\r\n        let pts = [];\r\n\r\n        pts.push(this._x.tex);\r\n        pts.push(this._y.tex);\r\n\r\n        return `\\\\left(${pts.join(';')}\\\\right)`\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n    parse = (...values: any): Point => {\r\n        // Initialize the value.\r\n        this.zero();\r\n\r\n        // Nothing is given\r\n        if (values.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        // One element is given - might be already a point !\r\n        if (values.length === 1) {\r\n            // it's already a point - clone it\r\n            if (values[0] instanceof Point) {\r\n                this._x = values[0].x.clone()\r\n                this._y = values[0].y.clone()\r\n                return this;\r\n            }\r\n\r\n            // Value is given as string, comma separated.\r\n            if(typeof values[0] === 'string'){\r\n                let xy = values[0].split(',')\r\n                if(xy.length===2){\r\n                    this._x = new Fraction(xy[0]).reduce()\r\n                    this._y = new Fraction(xy[1]).reduce()\r\n                    return this;\r\n                }\r\n            }\r\n\r\n            // Value given as an object with {x: value, y: value}\r\n            if (values[0].x !== undefined && values[0].y !== undefined) {\r\n                this._x = new Fraction(values[0].x).reduce()\r\n                this._y = new Fraction(values[0].y).reduce()\r\n            } else {\r\n                return this.zero();\r\n            }\r\n        }\r\n        if (values.length === 2) {\r\n            this._x = new Fraction(values[0]).reduce()\r\n            this._y = new Fraction(values[1]).reduce()\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    clone = (): Point => {\r\n        this._x = this._x.clone()\r\n        this._y = this._y.clone()\r\n\r\n        return this\r\n    }\r\n\r\n    zero = (): Point => {\r\n        this._x = new Fraction(null);\r\n        this._y = new Fraction(null);\r\n        return this;\r\n    }\r\n\r\n    origin = (): Point => {\r\n        this.zero();\r\n        return this;\r\n    }\r\n\r\n    middleOf = (P1: Point, P2: Point): Point => {\r\n        this._x = P1.x.clone().add(P2.x).divide(2);\r\n        this._y = P1.y.clone().add(P2.y).divide(2);\r\n\r\n        return this;\r\n    }\r\n    // ------------------------------------------\r\n    // Display functions\r\n    // ------------------------------------------\r\n    texValues = (numberOfDigits: number): string => {\r\n        let pts = [];\r\n\r\n        pts.push(this._x.value.toFixed(numberOfDigits===undefined?2:numberOfDigits));\r\n        pts.push(this._y.value.toFixed(numberOfDigits===undefined?2:numberOfDigits));\r\n\r\n        return `\\\\left(${pts.join(';')}\\\\right)`\r\n    }\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n\r\n    // ------------------------------------------\r\n    // Vector functions\r\n    // ------------------------------------------\r\n\r\n    // ------------------------------------------\r\n    // Static functions\r\n    // ------------------------------------------\r\n    static pmatrix = (a: any, b: any, c?: any): string => {\r\n        if (c === undefined) {\r\n            return `\\\\begin{pmatrix} ${a.tex ? a.tex : a} \\\\\\\\ ${b.tex ? b.tex : b} \\\\end{pmatrix}`;\r\n        } else {\r\n            return `\\\\begin{pmatrix} ${a.tex ? a.tex : a} \\\\\\\\ ${b.tex ? b.tex : b} \\\\\\\\ ${c.tex ? c.tex : c} \\\\end{pmatrix}`;\r\n        }\r\n    };\r\n\r\n}\r\n","/**\r\n * This class works for 2d line in a plane.\r\n */\r\n\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Vector} from \"./vector\";\r\nimport {Point} from \"./point\";\r\nimport {Polynom} from \"../algebra/polynom\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Equation} from \"../algebra/equation\";\r\n\r\nexport class Line {\r\n    // A line is defined as the canonical form\r\n    // ax + by + c = 0\r\n    private _a: Fraction;\r\n    private _b: Fraction;\r\n    private _c: Fraction;\r\n    private _OA: Point;\r\n    private _d: Vector;\r\n    private _n: Vector;\r\n    private _exists: boolean\r\n\r\n    constructor(...values: any) {\r\n\r\n        this._exists = false;\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    get isLine():boolean {return true;}\r\n    get exists(): boolean {return this._exists; }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get equation(): Equation {\r\n        return new Equation(new Polynom().parse('xy', this._a, this._b, this._c), new Polynom('0')).simplify();\r\n    }\r\n    get tex(): { canonical: string, mxh: string, parametric: string } {\r\n        // canonical    =>  ax + by + c = 0\r\n        // mxh          =>  y = -a/b x - c/b\r\n        // parametric   =>  (xy) = OA + k*d\r\n\r\n        let canonical = this.equation;\r\n        // Make sur the first item is positive.\r\n        if(this._a.isNegative()){\r\n            canonical.multiply(-1);\r\n        }\r\n\r\n        return {\r\n            canonical: canonical.tex,\r\n            mxh: this.slope.isInfinity() ? 'x=' + this.OA.x.tex : 'y=' + new Polynom().parse('x', this.slope, this.height).tex,\r\n            parametric: `${Point.pmatrix('x', 'y')} = ${Point.pmatrix(this._OA.x, this._OA.y)} + k\\\\cdot ${Point.pmatrix(this._d.x, this._d.y)}`\r\n        }\r\n    }\r\n\r\n    get a(): Fraction {\r\n        return this._a;\r\n    }\r\n\r\n    set a(value: Fraction) {\r\n        this._a = value;\r\n    }\r\n\r\n    get b(): Fraction {\r\n        return this._b;\r\n    }\r\n\r\n    set b(value: Fraction) {\r\n        this._b = value;\r\n    }\r\n\r\n    get c(): Fraction {\r\n        return this._c;\r\n    }\r\n\r\n    set c(value: Fraction) {\r\n        this._c = value;\r\n    }\r\n\r\n    get OA(): Point {\r\n        return this._OA;\r\n    }\r\n\r\n    set OA(value: Point) {\r\n        this._OA = value;\r\n    }\r\n\r\n    get d(): Vector {\r\n        return this._d;\r\n    }\r\n\r\n    get n(): Vector {\r\n        return this._n;\r\n    }\r\n\r\n    get normal(): Vector {\r\n        return new Vector(this._a, this._b);\r\n    }\r\n\r\n    set d(value: Vector) {\r\n        this._d = value;\r\n    }\r\n\r\n    get slope(): Fraction {\r\n        return this._a.clone().opposed().divide(this._b);\r\n    }\r\n\r\n    get height(): Fraction {\r\n        return this._c.clone().opposed().divide(this._b);\r\n    }\r\n\r\n// ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (...values: any): Line => {\r\n        this._exists = false;\r\n\r\n        if (values.length === 3) {\r\n            return this.parseByCoefficient(values[0], values[1], values[2]);\r\n        } else if (values.length === 2) {\r\n            if (values[0].isPoint && values[1].isVector) {\r\n                return this.parseByPointAndVector(values[0], values[1]);\r\n            } else if (values[0].isPoint && values[1].isPoint) {\r\n                return this.parseByPointAndVector(values[0], new Vector(values[0], values[1]));\r\n            }\r\n        } else if (values.length === 1){\r\n            // It's a already a line - clone it !\r\n            if(values[0].isLine){\r\n                return values[0].clone();\r\n            }\r\n\r\n            // Maybe it's a string or an equation\r\n            let equ = new Equation(values[0]);\r\n            if(equ.isEquation){\r\n                // Check if it's a valid equation.\r\n                equ.reorder(true)\r\n\r\n                // It must contain either x, y or both.\r\n                let letters = new Set(equ.letters());\r\n\r\n                // No 'x', no 'y' in the equations\r\n                if(!(letters.has('x') || letters.has('y'))){return;}\r\n\r\n                // Another letter in the equation.\r\n                for(let elem of ['x', 'y']){\r\n                    if(letters.has(elem)){\r\n                        letters.delete(elem)}\r\n                }\r\n\r\n                if(letters.size>0){\r\n                    console.log('Extra variable in the equation.')\r\n                    return this;\r\n                }\r\n\r\n                // Everything should be ok now...\r\n                return this.parseByCoefficient(equ.left.monomByLetter('x').coefficient, equ.left.monomByLetter('y').coefficient, equ.left.monomByDegree(0).coefficient)\r\n            }\r\n        }\r\n        // TODO: Add the ability to create line from a normal vector\r\n        console.log('Someting wrong happend while creating the line')\r\n        return this;\r\n    }\r\n\r\n    parseByCoefficient = (a: Fraction, b: Fraction, c: Fraction): Line => {\r\n        this._a = new Fraction(a);\r\n        this._b = new Fraction(b);\r\n        this._c = new Fraction(c);\r\n\r\n        // TODO: initialize direction and reference point\r\n        this._d = new Vector(this._b.clone(), this._a.clone().opposed());\r\n        this._OA = new Point(new Fraction().zero(), this._c.clone());\r\n        this._n = this._d.clone().normal();\r\n\r\n        this._exists = true;\r\n        return this;\r\n    }\r\n\r\n    parseByPointAndVector = (P: Point, d: Vector): Line => {\r\n        // OX = OP + k*d\r\n        // x = px + kdx     * dy\r\n        // y = py + kdy     * dx\r\n        // ------------------\r\n        // dy * x = px * dy + kdxdy\r\n        // dx * y = py * dx + kdxdy\r\n        // ------------------\r\n        // dy * x - dx * y = px * dy - py * dx\r\n        // dy * x - dx * y - (px * dy - py * dx) = 0\r\n        this.parseByCoefficient(\r\n            d.y,\r\n            d.x.clone().opposed(),\r\n            P.x.clone().multiply(d.y).subtract(P.y.clone().multiply(d.x)).opposed()\r\n        )\r\n\r\n        // Choose the current values as point and direction vector instead of the automatic version.\r\n        this._OA = P.clone();\r\n        this._d = d.clone();\r\n        this._n = this._d.clone().normal();\r\n\r\n        this._exists = true;\r\n        return this;\r\n    }\r\n\r\n    clone = (): Line => {\r\n        this._a = this._a.clone();\r\n        this._b = this._b.clone();\r\n        this._c = this._c.clone();\r\n\r\n        this._d = this._d.clone();\r\n        this._OA = this._OA.clone();\r\n        this._n = this._n.clone();\r\n\r\n        return this;\r\n    }\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    isParellelTo = (line: Line): Boolean => {\r\n        // Do they have the isSame direction ?\r\n        return this.slope.isEqual(line.slope) && this.height.isDifferent(line.height);\r\n    }\r\n    isSameAs = (line: Line): Boolean => {\r\n        return this.slope.isEqual(line.slope) && this.height.isEqual(line.height);\r\n    }\r\n    simplifyDirection = (): Line => {\r\n        let lcm = Numeric.lcm(this._d.x.denominator, this._d.y.denominator),\r\n            gcd = Numeric.gcd(this._d.x.numerator, this._d.y.numerator);\r\n\r\n        this._d.x.multiply(lcm).divide(gcd);\r\n        this._d.y.multiply(lcm).divide(gcd);\r\n        return this;\r\n    }\r\n    intersection = (line: Line): { point: Point, hasIntersection: boolean, isParallel: boolean, isSame: boolean } => {\r\n        let Pt = new Point(), isParallel = false, isSame = false, hasIntersection = true;\r\n\r\n        // this         => ax+by+c = 0\r\n        // line         => dx+ey+f = 0\r\n        //\r\n        //  aex + bey + ce = 0\r\n        //  dbx + bey + bf = 0\r\n        // (ae-db)x + ce-bf = 0\r\n        //\r\n        //  adx + bdy + cd = 0\r\n        //  adx + aey + af = 0\r\n        // (bd-ae)y + (cd-af)\r\n        //\r\n        // x = (bf-ce)/(ae-db)\r\n        // y = (af-cd)/(bd-ae)\r\n\r\n\r\n        // Theres is no 'y'\r\n        if (this._b.isZero() || line.b.isZero()) {\r\n            // TODO : handle no y in the line canonical form\r\n        }\r\n\r\n        if (this.isParellelTo(line)) {\r\n            Pt.x = null;\r\n            Pt.y = null;\r\n            isParallel = true;\r\n        } else if (this.isSameAs(line)) {\r\n            Pt.x = null;\r\n            Pt.y = null;\r\n            isSame = true;\r\n        } else {\r\n            Pt.x = this._b.clone().multiply(line.c).subtract(this._c.clone().multiply(line.b))\r\n                .divide(this._a.clone().multiply(line.b).subtract(this._b.clone().multiply(line.a)));\r\n            Pt.y = this._a.clone().multiply(line.c).subtract(this._c.clone().multiply(line.a))\r\n                .divide(this._b.clone().multiply(line.a).subtract(this._a.clone().multiply(line.b)));\r\n        }\r\n\r\n        return {\r\n            point: Pt,\r\n            hasIntersection: !(isParallel || isSame),\r\n            isParallel,\r\n            isSame\r\n        };\r\n    }\r\n\r\n    distanceTo(pt: Point): { value: number, fraction: Fraction, tex: string } {\r\n        let numerator = pt.x.clone().multiply(this._a)\r\n                .add(pt.y.clone().multiply(this._b))\r\n                .add(this._c).abs(),\r\n            d2 = this.normal.normSquare;\r\n\r\n        // The denominator is null - shouldn't be possible\r\n        if (d2.isZero()) {\r\n            return {\r\n                value: NaN,\r\n                tex: 'Not a line',\r\n                fraction: new Fraction().infinite()\r\n            }\r\n        }\r\n        // The denominator is a perfect square - simplify the tex result\r\n        let value = numerator.value / Math.sqrt(d2.value),\r\n            F = numerator.clone().divide(d2.clone().sqrt());\r\n\r\n        // The denominator is a perfect square.\r\n        if (d2.isSquare()) {\r\n            return {\r\n                value,\r\n                tex: F.tex,\r\n                fraction: F\r\n            }\r\n        }\r\n        // Complete answer...\r\n        return {\r\n            value,\r\n            tex: `\\\\frac{${numerator.tex}}{\\\\sqrt{${d2.tex}}}`,\r\n            fraction: F\r\n        };\r\n    }\r\n\r\n    hitSegment(A: Point, B: Point): boolean {\r\n        let iPt = this.intersection(\r\n            new Line(A, B)\r\n        )\r\n\r\n        // There is an intersection point\r\n        if(iPt.hasIntersection) {\r\n            return iPt.point.x.value >= Math.min(A.x.value, B.x.value)\r\n                && iPt.point.x.value <= Math.max(A.x.value, B.x.value)\r\n                && iPt.point.y.value >= Math.min(A.y.value, B.y.value)\r\n                && iPt.point.y.value <= Math.max(A.y.value, B.y.value)\r\n        }\r\n        return false;\r\n    }\r\n    // ------------------------------------------\r\n    // Special functions\r\n    // ------------------------------------------\r\n    canonicalAsFloatCoefficient(decimals: number): string{\r\n        if(decimals===undefined){\r\n            decimals = 2;\r\n        }\r\n\r\n        let ca = this._a.value,\r\n            cb = this._b.value,\r\n            cc= this._c.value,\r\n            canonical = '';\r\n\r\n        if(!this._a.isZero()){\r\n            if(this._a.isOne()){\r\n                canonical = 'x'\r\n            }else if(this._a.clone().opposed().isOne()){\r\n                canonical = '-x'\r\n            }else{\r\n                canonical = this._a.value.toFixed(decimals)+'x'\r\n            }\r\n        }\r\n\r\n        if(!this._b.isZero()){\r\n            if(this._b.isPositive()){canonical+='+'}\r\n            canonical += this._b.value.toFixed(decimals) + 'y'\r\n        }\r\n\r\n        if(!this._c.isZero()){\r\n            if(this._c.isPositive()){canonical+='+'}\r\n            canonical += this._c.value.toFixed(decimals)\r\n        }\r\n\r\n\r\n        return canonical + '=0';\r\n    }\r\n}","import {Point} from \"./point\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Vector} from \"./vector\";\r\nimport {Line} from \"./line\";\r\nimport {Equation} from \"../algebra/equation\";\r\n\r\nexport interface remarquableLines {\r\n    'medians': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    },\r\n    'mediators': {\r\n        'AB': Line,\r\n        'AC': Line,\r\n        'BC': Line,\r\n        'intersection': Point\r\n    },\r\n    'heights': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    },\r\n    'bisectors': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    }\r\n}\r\n\r\nexport class Triangle {\r\n    private _A: Point;\r\n    private _B: Point;\r\n    private _C: Point;\r\n    private _lines: {\r\n        'AB': Line,\r\n        'AC': Line,\r\n        'BC': Line\r\n    };\r\n    private _middles: {\r\n        'AB': Point,\r\n        'AC': Point,\r\n        'BC': Point\r\n    };\r\n    private _remarquables: remarquableLines;\r\n\r\n\r\n    constructor(...values: any) {\r\n\r\n        if (values.length > 0) {\r\n            this.parse(...values);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    get isTriangle():boolean {return true;}\r\n\r\n    // ------------------------------------------\r\n    // Getter and setters\r\n    // ------------------------------------------\r\n\r\n    get A(): Point {\r\n        return this._A;\r\n    }\r\n\r\n    get B(): Point {\r\n        return this._B;\r\n    }\r\n\r\n    get C(): Point {\r\n        return this._C;\r\n    }\r\n\r\n    get AB(): Vector {\r\n        return this.getSegment('A', 'B');\r\n    }\r\n\r\n    get BA(): Vector {\r\n        return this.getSegment('B', 'A');\r\n    }\r\n\r\n    get BC(): Vector {\r\n        return this.getSegment('B', 'C');\r\n    }\r\n\r\n    get CB(): Vector {\r\n        return this.getSegment('C', 'B');\r\n    }\r\n\r\n    get AC(): Vector {\r\n        return this.getSegment('A', 'C');\r\n    }\r\n\r\n    get CA(): Vector {\r\n        return this.getSegment('C', 'A');\r\n    }\r\n\r\n    get isRectangle(): boolean {\r\n        if (this.AB.isNormalTo(this.BC)) {\r\n            return true;\r\n        }\r\n        if (this.AB.isNormalTo(this.AC)) {\r\n            return true;\r\n        }\r\n        if (this.BC.isNormalTo(this.AC)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    get isEquilateral(): boolean {\r\n        return this.AB.normSquare.isEqual(this.BC.normSquare) &&\r\n            this.AB.normSquare.isEqual(this.AC.normSquare);\r\n    }\r\n\r\n    get isIsocele(): boolean {\r\n        return this.AB.normSquare.isEqual(this.BC.normSquare) ||\r\n            this.AB.normSquare.isEqual(this.AC.normSquare) ||\r\n            this.BC.normSquare.isEqual(this.AC.normSquare)\r\n    }\r\n\r\n    get lines(): { 'AB': Line, 'BC': Line, 'AC': Line } {\r\n        return this._lines;\r\n    }\r\n\r\n    get remarquables(): remarquableLines {\r\n        return this._remarquables;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Parse values to a triangle. Supported formats:\r\n     * Point, Point, Point\r\n     * x1, y1, x2, y2, x3, y3\r\n     * TODO: Something else ?\r\n     * @param values\r\n     */\r\n    parse = (...values: any): Triangle => {\r\n        if (values.length === 6) {\r\n            // Check if all values are number or fractions.\r\n            let v = values.map((x: any) => new Fraction(x));\r\n            return this.parse(\r\n                new Point(v[0], v[1]),\r\n                new Point(v[2], v[3]),\r\n                new Point(v[4], v[5]),\r\n            )\r\n        } else if (values.length === 3) {\r\n            // Possibilities:\r\n            // - Three points (or part of points, only dict for example, or array (TODO: Add the array syntax for point)\r\n            // - Three lines\r\n            // - Three lines as text.\r\n            if(values.filter((x:any) => typeof x === 'string').length===3) {\r\n                return this.parse( ...values.map((x:string) => new Line(x)) )\r\n            }else if(values.filter((x:any) => x.isLine === true).length===3) {\r\n                // We have three lines\r\n                this._lines = {\r\n                    'AB': values[0],\r\n                    'BC': values[1],\r\n                    'AC': values[2]\r\n                };\r\n\r\n                // Get the intersection points -> build the triangle using these intersection points.\r\n                let intersect = values[0].intersection(values[1]);\r\n                if (intersect.hasIntersection) {\r\n                    this._B = intersect.point.clone();\r\n                } else {\r\n                    return this;\r\n                }\r\n                intersect = values[1].intersection(values[2]);\r\n                if (intersect.hasIntersection) {\r\n                    this._C = intersect.point.clone();\r\n                } else {\r\n                    return this;\r\n                }\r\n                intersect = values[2].intersection(values[0]);\r\n                if (intersect.hasIntersection) {\r\n                    this._A = intersect.point.clone();\r\n                } else {\r\n                    return this;\r\n                }\r\n            }else {\r\n                // At least, one of the value is not a point.\r\n                if (values.filter((x: any) => x.isPoint === true).length < 3) {\r\n                    return this.parse(\r\n                        new Point(values[0]),\r\n                        new Point(values[1]),\r\n                        new Point(values[2])\r\n                    )\r\n                }\r\n\r\n                // We have three points.\r\n                this._A = values[0].clone();\r\n                this._B = values[1].clone();\r\n                this._C = values[2].clone();\r\n\r\n                this._lines = {\r\n                    'AB': new Line(this._A, this._B),\r\n                    'BC': new Line(this._B, this._C),\r\n                    'AC': new Line(this._A, this._C)\r\n                };\r\n            }\r\n        } else if (values.length === 1) {\r\n            if (values[0].isTriangle === true) {\r\n                return values[0].clone();\r\n            }\r\n        }\r\n\r\n        this._updateTriangle();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clone the Triangle class\r\n     */\r\n    clone = (): Triangle => {\r\n        this._A = this._A.clone();\r\n        this._B = this._B.clone();\r\n        this._C = this._C.clone();\r\n\r\n        this._lines = {\r\n            'AB': this._lines.AB.clone(),\r\n            'BC': this._lines.BC.clone(),\r\n            'AC': this._lines.AC.clone()\r\n        }\r\n\r\n        this._updateTriangle();\r\n        return this;\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Triangle operations and properties\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Generate the Line object for the three segments of the triangle\r\n     */\r\n    private _updateTriangle = () => {\r\n        this._middles = {\r\n            'AB': new Point().middleOf(this._A, this._B),\r\n            'AC': new Point().middleOf(this._A, this._C),\r\n            'BC': new Point().middleOf(this._B, this._C)\r\n        }\r\n\r\n        this._remarquables = this._calculateRemarquableLines();\r\n    }\r\n\r\n\r\n    /**\r\n     * Get the Point class for the given name\r\n     * @param ptName\r\n     */\r\n    private getPointByName = (ptName: string): Point => {\r\n        switch (ptName.toUpperCase()) {\r\n            case 'A':\r\n                return this._A;\r\n            case 'B':\r\n                return this._B;\r\n            case 'C':\r\n                return this._C;\r\n        }\r\n\r\n        // Something went wrong ! Return the first point\r\n        return this._A;\r\n    }\r\n    /**\r\n     * Get the vector for the segment given by name.\r\n     * @param ptName1\r\n     * @param ptName2\r\n     */\r\n    private getSegment = (ptName1: string, ptName2: string): Vector => {\r\n        return new Vector(\r\n            this.getPointByName(ptName1),\r\n            this.getPointByName(ptName2)\r\n        );\r\n    }\r\n\r\n    private _calculateRemarquableLines = (): remarquableLines => {\r\n        let remarquables: remarquableLines = {\r\n            'medians': {\r\n                'A': new Line(this._A, this._middles.BC),\r\n                'B': new Line(this._B, this._middles.AC),\r\n                'C': new Line(this._C, this._middles.AB),\r\n                'intersection': null\r\n            },\r\n            'mediators': {\r\n                'AB': new Line(this._middles.AB, new Vector(this._A, this._B).normal()),\r\n                'AC': new Line(this._middles.AC, new Vector(this._A, this._C).normal()),\r\n                'BC': new Line(this._middles.BC, new Vector(this._B, this._C).normal()),\r\n                'intersection': null\r\n            },\r\n            'heights': {\r\n                'A': new Line(this._A, new Vector(this._B, this._C).normal()),\r\n                'B': new Line(this._B, new Vector(this._A, this._C).normal()),\r\n                'C': new Line(this._C, new Vector(this._A, this._B).normal()),\r\n                'intersection': null\r\n            },\r\n            'bisectors': {\r\n                'A': this._calculateBisectors('A'),\r\n                'B': this._calculateBisectors('B'),\r\n                'C': this._calculateBisectors('C'),\r\n                'intersection': null\r\n            }\r\n        }\r\n\r\n        // As it's a triangle, we assume the lines are intersecting and aren't parallel or superposed.\r\n        remarquables.medians.intersection = remarquables.medians.A.intersection(remarquables.medians.B).point;\r\n        remarquables.mediators.intersection = remarquables.mediators.AB.intersection(remarquables.mediators.BC).point;\r\n        remarquables.heights.intersection = remarquables.heights.A.intersection(remarquables.heights.B).point;\r\n        remarquables.bisectors.intersection = remarquables.bisectors.A.intersection(remarquables.bisectors.B).point;\r\n\r\n        // Everything was calculated for the remarquable lines.\r\n        return remarquables;\r\n    }\r\n\r\n    private _calculateBisectors = (pt: string): Line => {\r\n        let tlines = this.lines, d1, d2;\r\n\r\n        if(pt==='A'){\r\n            d1 = tlines.AB;\r\n            d2 = tlines.AC;\r\n        }else if(pt==='B'){\r\n            d1 = tlines.AB;\r\n            d2 = tlines.BC;\r\n        }else if(pt==='C'){\r\n            d1 = tlines.BC;\r\n            d2 = tlines.AC;\r\n        }\r\n\r\n        let b1 = new Line(new Equation(d1.equation.left.clone().multiply(d2.n.simplify().norm), d2.equation.left.clone().multiply(d1.n.simplify().norm)).reorder(true).simplify()),\r\n            b2 = new Line(new Equation(d1.equation.left.clone().multiply(d2.n.simplify().norm), d2.equation.left.clone().multiply(d1.n.simplify().norm).opposed()).reorder(true).simplify());\r\n\r\n        // Must determine which bisectors is in the triangle\r\n        if(pt==='A'){\r\n            return b1.hitSegment(this.B, this.C)?b1:b2;\r\n        }\r\n        if(pt==='B'){\r\n            return b1.hitSegment(this.A, this.C)?b1:b2;\r\n        }\r\n        if(pt==='C'){\r\n            return b1.hitSegment(this.B, this.A)?b1:b2;\r\n        }\r\n\r\n        // Default returns the first bisector\r\n        return b1;\r\n    }\r\n}","import {Point} from \"./point\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Equation} from \"../algebra/equation\";\r\nimport {Polynom} from \"../algebra/polynom\";\r\n\r\n\r\nexport class Circle {\r\n    private _center: Point;\r\n    private _radius: Fraction;\r\n    private _exists: boolean;\r\n    constructor(...values: any) {\r\n        this._exists = false\r\n\r\n        if(values!==undefined){this.parse(...values)}\r\n    }\r\n\r\n    private parse(...values: any) {\r\n        if(values.length===2){\r\n            this._center = new Point(values[0])\r\n            this._radius = new Fraction(values[1])\r\n        }\r\n    }\r\n\r\n    get tex(): string {\r\n        let cx, cy\r\n        if(this._center.x.isZero()){\r\n            cx = 'x^2'\r\n        }else{\r\n            cx = `\\\\left(x-${this._center.x.tex}\\\\right)^2`\r\n        }\r\n        if(this._center.y.isZero()){\r\n            cy = 'y^2'\r\n        }else{\r\n            cy = `\\\\left(y-${this._center.y.tex}\\\\right)^2`\r\n        }\r\n        return `${cx}+${cy}=${this._radius.pow(2).tex}`\r\n    }\r\n\r\n    get developed():string {\r\n        let equ = new Equation(\r\n            new Polynom(`(x-(${this._center.x.display}))^2+(y-(${this._center.y.display}))^2`),\r\n            new Polynom(`${this._radius.pow(2).display}`)\r\n        )\r\n\r\n        return equ.moveLeft().tex;\r\n    }\r\n}","import {Numeric} from \"./maths/numeric\";\r\nimport {Shutingyard} from \"./maths/shutingyard\";\r\nimport {Random} from \"./maths/random\";\r\nimport {Fraction, Nthroot} from \"./maths/coefficients\";\r\nimport {Monom, Polynom, Equation, LinearSystem, Rational, Logicalset} from \"./maths/algebra\";\r\nimport {Line, Circle, Triangle, Point, Vector} from \"./maths/geometry\";\r\n\r\n// Expose as global\r\n// export let Pi = {\r\n(<any>window).Pi = {\r\n    ShutingYard: Shutingyard,\r\n    Numeric: Numeric,\r\n    Fraction: Fraction,\r\n    Root: Nthroot,\r\n    Monom: Monom,\r\n    Polynom: Polynom,\r\n    Equation: Equation,\r\n    LinearSystem: LinearSystem,\r\n    Rational: Rational,\r\n    Logicalset: Logicalset,\r\n    Random: Random,\r\n    Geometry: {\r\n        Vector: Vector,\r\n        Point: Point,\r\n        Line: Line,\r\n        Triangle: Triangle,\r\n        Circle: Circle\r\n    }\r\n};\r\n"],"names":["Numeric","static","value","decimals","Number","Math","round","nb","primes","undefined","slice","max","length","D","maxV","sqrt","abs","i","push","sort","a","b","Set","values","gcd2","g","reduce","gcd","Shutingyard","_rpn","_mode","_tokenConfig","_uniformize","constructor","mode","this","tokenConfigInitialization","isOperation","token","match","precedence","associative","NextToken2","expr","start","tokenType","keys","Object","key","substr","console","log","NextToken","tokenMatch","Uniformizer","expr2","replace","fnToken","RegExp","parse","operators","outQueue","opStack","tokenPos","previousOpStatckLength","securityLoopLvl2","securityLoopLvl1","opTop","pop","concat","reverse","rpn","randomCore","_config","_defaultConfig","mergeConfig","config","defaultConfig","generate","Fraction","_numerator","_denominator","denominatorOrPeriodic","isFraction","numerator","denominator","tex","display","frac","dfrac","S","split","map","x","isNaN","includes","NaN","isSafeInteger","p","toString","pow","floor","clone","F","zero","one","infinite","Infinity","invalid","opposed","add","N","subtract","multiply","Q","divide","invert","n","d","root","amplify","k","compare","sign","lesser","than","leq","greater","geq","isEqual","isDifferent","isOpposed","isInverted","isZero","isOne","isPositive","isNegative","isInfinity","isFinite","isSquare","isReduced","areEquals","_coefficient","_literal","isMonom","coefficient","literal","literalSqrt","isLitteralSquare","L","literalStr","inputStr","v","matchAll","variables","clean","letter","dividers","litterals","_getLitteralDividers","monomDividers","M","arr","tmpList","litt","item","currentLetter","displayWithSign","trim","setLetter","m","isSameAs","multiplyByNumber","M1","M2","K","filter","indexOf","hasLetter","degree","t","evaluate","r","tmpValues","derivative","dM","primitive","monoms","coeffN","coeffD","lcm","min","areSameAs","rndMonom","userConfig","super","letters","fraction","Random","numberSym","number","_rawString","_monoms","_factors","_texString","polynomString","isPolynom","factors","texFactors","factorize","f","texString","genDisplay","raw","isMultiVariable","V","numberOfVars","output","forceSign","wrapParentheses","P","empty","shutingYardToReducedPolynom","test","fractions","m1","m2","tempPolynom","stack","previousToken","element","random","polynom","_randomizeDefaults","unit","factorable","allowNullMonom","numberOfMonoms","randomizeDefaults","randomize","rndFactorable","factorUnit","multiplyByPolynom","multiplyByFraction","multiplyByMonom","multiplyByInteger","euclidian","quotient","reminder","reorder","maxMP","monomByDegree","degreeP","newM","MaxIteration","divideByFraction","divideByInteger","nbF","cP1","cP2","isOpposedAt","isFactorized","e","polynomStringNormalized","replaceAll","polynomStringReduced","polyFactors","splice","isDeveloped","j","replaceBy","resultPolynom","forEach","monom","dP","integrate","valuesA","valuesB","factorize_OLD","maxValue","nbFactorsFound","commonMonom","commonPolynom","securityLoop","m1d","m2d","result","dividerPolynom","_factorize2ndDegree","P1","P2","c","delta","x1","x2","factor","xyzPolynom","xFactors","_factorizeByGroups","getZeroes","zeroes","zeroesAsTex","A","B","C","toFixed","z","monomsByDegree","Ms","monomByLetter","getDenominators","denominators","getNumerators","numerators","lcmDenominator","gcdDenominator","lcmNumerator","gcdNumerator","makeItComplicate","complexity","factorizePartial","mMain","mCheck","mFactor","pFactor","minify","canDivide","evalValue","rndPolynom","array","rndHelpers","percent","randomInt","randomBool","shuffleArray","randomArray","temp","Algebra","Geometry","from","to","allowZero","randomIntSym","bool","randomItem","shuffle","Nthroot","_radical","_nth","_isValid","radical","nth","nthroot","hasRadical","_left","_right","_sign","_polynom","_solutions","_varnothing","_real","equations","isEquation","left","right","solutions","solution","join","isReal","solve","isVarnothing","signAsTex","_formatSign","equationString","pStr","strSign","_findSign","create","signStr","_reverseSign","opts","moveLeft","allLeft","mMove","simplify","isolate","cMove","_solveDegree1","_solveDegree2","_solveDegree3plus","isGreater","isStrictEqual","isAlsoEqual","m0","s","nthDelta","realX1","realX2","sX1","sX2","aF","bF","cF","_resolutionSteps","_equations","_letters","equationStrings","isLinerarSystem","isSolvable","E","equStr","LS","equArray","equ","repeat","texSolution","_findLetters","setCoefficient","coefficients","setLetters","solutionsF","_generateOneEquation","coeff","leftValue","equString","_checkIfLinerCombination","_linearReduction","eq1","eq2","c1","c2","mergeEquations","factor1","factor2","eq1multiplied","eq2multiplied","_solveOneLetter","LE","reducedEquations","str","Logicalset","isLogicalset","tokenSets","reference","referenceSet","varStack","second","first","has","vennAB","vennABC","domain","NumeratorEuclidien","DenominatorEuclidien","R","limits","Polynom","Monom","LinearSystem","Equation","LogicalSet","Rational","_x","_y","isVector","y","normSquare","norm","_parseString","isPoint","reset","components","scalarProductWithVector","v1","v2","normal","isNormalTo","multiplyByScalar","scalar","divideByScalar","angleWith","sharp","radian","toDegree","PI","acos","_exist","pts","xy","origin","middleOf","texValues","numberOfDigits","_a","_b","_c","_OA","_d","_n","_exists","isLine","exists","equation","canonical","mxh","slope","OA","height","parametric","parseByCoefficient","parseByPointAndVector","elem","delete","size","isParellelTo","line","simplifyDirection","intersection","Pt","isParallel","isSame","point","hasIntersection","distanceTo","pt","d2","hitSegment","iPt","canonicalAsFloatCoefficient","_A","_B","_C","_lines","_middles","_remarquables","isTriangle","AB","getSegment","BA","BC","CB","AC","CA","isRectangle","isEquilateral","isIsocele","lines","remarquables","intersect","_updateTriangle","_calculateRemarquableLines","getPointByName","ptName","toUpperCase","ptName1","ptName2","_calculateBisectors","medians","mediators","heights","bisectors","d1","tlines","b1","b2","_center","_radius","cx","cy","developed","Circle","Line","Point","Triangle","Vector","window","Pi","ShutingYard","Root"],"sourceRoot":""}