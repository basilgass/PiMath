{"version":3,"file":"pi.js","mappings":"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AK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KA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","sources":["webpack://pimath/./src/maths/algebra/equation.ts","webpack://pimath/./src/maths/algebra/index.ts","webpack://pimath/./src/maths/algebra/linearSystem.ts","webpack://pimath/./src/maths/algebra/logicalset.ts","webpack://pimath/./src/maths/algebra/monom.ts","webpack://pimath/./src/maths/algebra/polynom.ts","webpack://pimath/./src/maths/algebra/rational.ts","webpack://pimath/./src/maths/coefficients/fraction.ts","webpack://pimath/./src/maths/coefficients/index.ts","webpack://pimath/./src/maths/coefficients/nthroot.ts","webpack://pimath/./src/maths/geometry/circle.ts","webpack://pimath/./src/maths/geometry/index.ts","webpack://pimath/./src/maths/geometry/line.ts","webpack://pimath/./src/maths/geometry/point.ts","webpack://pimath/./src/maths/geometry/triangle.ts","webpack://pimath/./src/maths/geometry/vector.ts","webpack://pimath/./src/maths/numeric.ts","webpack://pimath/./src/maths/random/index.ts","webpack://pimath/./src/maths/random/randomCore.ts","webpack://pimath/./src/maths/random/rndFraction.ts","webpack://pimath/./src/maths/random/rndHelpers.ts","webpack://pimath/./src/maths/random/rndMonom.ts","webpack://pimath/./src/maths/random/rndPolynom.ts","webpack://pimath/./src/maths/shutingyard.ts","webpack://pimath/webpack/bootstrap","webpack://pimath/./src/main.ts"],"sourcesContent":["import {Polynom} from \"./polynom\";\r\nimport {Monom} from \"./monom\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Fraction, Nthroot} from \"../coefficients\";\r\n\r\n/**\r\n * Equation is a class to manage equations...\r\n */\r\ninterface ISolution {\r\n    tex: string,\r\n    value: number,\r\n    exact: unknown\r\n}\r\n\r\nexport class Equation {\r\n    private _left: Polynom;  // Left part of the equation\r\n    private _right: Polynom; // Right part of the equation\r\n    private _sign: string;   // Signe of the equation, by default =\r\n\r\n    private _polynom: Polynom;  // Used to solve the equation // TODO: remove the private value ?\r\n    private _solutions: ISolution[]\r\n\r\n    // Undetermined texSolutions.\r\n    private _varnothing: string = '\\\\varnothing';\r\n    private _real: string = '\\\\mathbb{R}';\r\n\r\n    /**\r\n     * Create an Equation using two polynoms.\r\n     * Markdown *support* is cool\r\n     * @param equations\r\n     */\r\n    constructor(...equations: unknown[]) {\r\n        // Default equation\r\n        this._left = new Polynom().zero();\r\n        this._right = new Polynom().zero();\r\n        this._sign = '=';\r\n\r\n        if (equations.length === 1) {\r\n            if(equations[0] instanceof Equation) {\r\n                return equations[0].clone();\r\n            } else if(typeof equations[0] === 'string') {\r\n                this.parse(equations[0]);\r\n            }\r\n        } else if (equations.length === 2) {\r\n            if(equations[0] instanceof Polynom){\r\n                this.left = equations[0].clone()\r\n            }else if(typeof equations[0] === 'string'){\r\n                this.left = new Polynom(equations[0])\r\n            }\r\n\r\n            if(equations[1] instanceof Polynom){\r\n                this.right = equations[1].clone()\r\n            }else if(typeof equations[1] === 'string'){\r\n                this.right = new Polynom(equations[1])\r\n            }\r\n        } else {\r\n            // Return default empty equation\r\n            return this;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    get isEquation() {\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get solutions(): ISolution[] {\r\n        return this._solutions\r\n    }\r\n    get solution(): string {\r\n        if (this._solutions.length === 1\r\n            &&\r\n            (\r\n                this._solutions[0].tex === this._real\r\n                || this._solutions[0].tex === this._varnothing\r\n                || this._solutions[0].tex.includes('\\\\left')\r\n            )\r\n        ) {\r\n            return `S = ${this._solutions[0]}`;\r\n        }\r\n        return `S = \\\\left{ ${this._solutions.map(x => x.tex).join(';')} \\\\right}`;\r\n    }\r\n\r\n    get isReal(): boolean {\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n        return this._solutions[0].tex === this._real;\r\n    }\r\n\r\n    get isVarnothing(): boolean {\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n        return this._solutions[0].tex === this._varnothing;\r\n    }\r\n\r\n    get signAsTex(): string {\r\n        if (this._sign === '>=' || this._sign === '=>' || this._sign === 'geq') {\r\n            return '\\\\geq';\r\n        }\r\n        if (this._sign === '<=' || this._sign === '=<' || this._sign === 'leq') {\r\n            return '\\\\leq';\r\n        }\r\n        return this._sign;\r\n    }\r\n\r\n    get tex(): string {\r\n        return `${this._left.tex}${this.signAsTex}${this._right.tex}`;\r\n    }\r\n\r\n    get display(): string {\r\n        return `${this._left.display}${this.signAsTex}${this._right.display}`;\r\n    }\r\n\r\n\r\n    get raw(): string {\r\n        return `${this._left.raw}${this.signAsTex}${this._right.raw}`;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        return [...new Set(this._right.variables.concat(this._left.variables))];\r\n    }\r\n\r\n    get numberOfVars(): number {\r\n        return this.variables.length;\r\n    }\r\n\r\n    get left(): Polynom {\r\n        return this._left;\r\n    }\r\n\r\n    set left(value: Polynom) {\r\n        this._left = value;\r\n    }\r\n\r\n    get right(): Polynom {\r\n        return this._right;\r\n    }\r\n\r\n    set right(value: Polynom) {\r\n        this._right = value;\r\n    }\r\n\r\n    get sign(): string {\r\n        return this._sign;\r\n    }\r\n\r\n    set sign(value: string) {\r\n        // Set the sign value as formatted.\r\n        this._sign = this._formatSign(value);\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (equationString: string): Equation => {\r\n        let pStr: string[], strSign: string | false;\r\n        // Find the string separator\r\n        strSign = this._findSign(equationString);\r\n\r\n        if (strSign === false) {\r\n            console.log('The equation is not valid (no sign found)');\r\n            return;\r\n        }\r\n\r\n        // The StrSign is found\r\n        pStr = equationString.split(strSign);\r\n\r\n        return this.create(new Polynom(pStr[0]), new Polynom(pStr[1]), this._formatSign(strSign));\r\n    };\r\n\r\n    private _findSign = (equationString: string): string | false => {\r\n        let strSign: string = '';\r\n\r\n        if (equationString.includes('geq')) {\r\n            return (equationString.includes('\\\\geq')) ? '\\\\geq' : 'geq';\r\n        } else if (equationString.includes('leq')) {\r\n            return (equationString.includes('\\\\leq')) ? '\\\\leq' : 'leq';\r\n        } else if (equationString.includes('>=')) {\r\n            return '>=';\r\n        } else if (equationString.includes('=>')) {\r\n            return '=>';\r\n        } else if (equationString.includes('>')) {\r\n            return '>';\r\n        } else if (equationString.includes('<=')) {\r\n            return '<=';\r\n        } else if (equationString.includes('=<')) {\r\n            return '=<';\r\n        } else if (equationString.includes('<')) {\r\n            return '<';\r\n        } else if (equationString.includes('=')) {\r\n            return '='\r\n        }\r\n        if (strSign === '') {\r\n            console.log('Equation: parse string : sign not found');\r\n            return false;\r\n        }\r\n    };\r\n\r\n    private _formatSign = (signStr: string): string => {\r\n        if (signStr === undefined) {\r\n            return '=';\r\n        }\r\n\r\n        if (signStr.includes('geq')) {\r\n            return '>=';\r\n        } else if (signStr.includes('>=')) {\r\n            return '>=';\r\n        } else if (signStr.includes('=>')) {\r\n            return '>=';\r\n        } else if (signStr.includes('>')) {\r\n            return '>';\r\n        } else if (signStr.includes('leq')) {\r\n            return '<=';\r\n        } else if (signStr.includes('<=')) {\r\n            return '<=';\r\n        } else if (signStr.includes('=<')) {\r\n            return '<=';\r\n        } else if (signStr.includes('<')) {\r\n            return '<';\r\n        } else {\r\n            return '='\r\n        }\r\n    };\r\n\r\n    private _reverseSign = (): Equation => {\r\n        if (this._sign === '=') {\r\n            return this;\r\n        }\r\n\r\n        if (this._sign.includes('<')) {\r\n            this._sign.replace('<', '>');\r\n            return this;\r\n        }\r\n        if (this._sign.includes('>')) {\r\n            this._sign.replace('>', '<');\r\n            return this;\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    create = (left: Polynom, right: Polynom, sign?: string): Equation => {\r\n        this._left = left;\r\n        this._right = right;\r\n        this._sign = this._formatSign(sign);\r\n        return this;\r\n    };\r\n\r\n    clone = (): Equation => {\r\n        return new Equation().create(this._left.clone(), this._right.clone(), this._sign + '');\r\n    };\r\n\r\n    // -----------------------------------------------\r\n    // Equations generators and randomizers\r\n    // -----------------------------------------------\r\n    private _randomizeDefaults: { [key: string]: number | string | boolean } = {\r\n        degree: 2\r\n    };\r\n    get randomizeDefaults(): { [key: string]: number | string | boolean } {\r\n        return this._randomizeDefaults;\r\n    }\r\n\r\n    set randomizeDefaults(value) {\r\n        this._randomizeDefaults = value;\r\n    }\r\n\r\n    randomize = (opts?: {}, sign?: string): Equation => {\r\n        // TODO: Generate equations randomly, using config.\r\n        return new Equation().create(new Polynom(), new Polynom(), sign);\r\n    };\r\n\r\n\r\n    // -----------------------------------------------\r\n    // Equations operations\r\n    // -----------------------------------------------\r\n    /**\r\n     * Reorder will move all monoms containing a letter on the left, all the other on the right.\r\n     */\r\n    moveLeft = (): Equation => {\r\n        this._left = this._left.clone().subtract(this._right)\r\n        this._right.zero()\r\n        return this;\r\n    }\r\n    reorder = (allLeft?: boolean): Equation => {\r\n        // Move all monoms of degree greater than 0 to the left.\r\n        // and all zero degree monoms to the right.\r\n        this._left.subtract(this._right);\r\n        this._right.zero();\r\n\r\n        if (allLeft) {\r\n            return this.moveLeft()\r\n        }\r\n        let mMove: Monom;\r\n        for (let m of this._left.monoms) {\r\n            if (m.degree().isZero()) {\r\n                mMove = m.clone();\r\n                this._left.subtract(mMove);\r\n                this._right.subtract(mMove);\r\n            }\r\n        }\r\n\r\n        // Reorder the left and right polynoms\r\n        this._left.reorder();\r\n        this._right.reorder();\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Multiply by the lcm denominator and divide by the gcm numerators.\r\n     */\r\n    simplify = (): Equation => {\r\n        this.multiply(Numeric.lcm(...this._left.getDenominators(), ...this._right.getDenominators()));\r\n        this.divide(Numeric.gcd(...this._left.getNumerators(), ...this._right.getNumerators()));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reorder the polynom to have only one letter on the left, the rest on the right.\r\n     * @param letter\r\n     */\r\n    isolate = (letter?: string): Equation | false => {\r\n        // Determine if we can isolate the variables.\r\n\r\n        // Both part of the equations must be of the first degree.\r\n        //TODO: handle equations of degree two or more ?\r\n        if (!this.degree(letter).isOne()) {\r\n            return false;\r\n        }\r\n\r\n        // Modify the equation to isolate the asked variable.\r\n        // TODO: must handle equations like 3xy+5y=4 => y = 4/(3x-5)\r\n        if (this.isMultiVariable()) {\r\n            return false;\r\n        }\r\n\r\n        // Isolate the letter.\r\n        let mMove: Monom, cMove: Fraction;\r\n        // Start by moving everything to the left.\r\n        this._left.subtract(this._right);\r\n        this._right.zero();\r\n        for (let m of this._left.monoms) {\r\n            if (!m.hasLetter(letter)) {\r\n                mMove = m.clone();\r\n                this._left.add(mMove.clone().opposed());\r\n                this._right.add(mMove.clone().opposed());\r\n            }\r\n        }\r\n\r\n        // In theory, we should have only one item on the left.\r\n        if (this._left.length !== 1) {\r\n            return false;\r\n        }\r\n        cMove = this._left.monoms[0].coefficient.clone();\r\n        this._left.divide(cMove);\r\n        this._right.divide(cMove);\r\n        return this;\r\n    };\r\n\r\n    replaceBy = (letter: string, P: Polynom): Equation => {\r\n        this._left.replaceBy(letter, P)\r\n        this._right.replaceBy(letter, P)\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiple an equation by a fraction value.\r\n     * @param value\r\n     */\r\n    multiply = (value: unknown): Equation => {\r\n\r\n        // Make sure we have a fraction.\r\n        let F: Fraction = new Fraction(value);\r\n\r\n        // Multiply each part of the equation by the fraction\r\n        this._left.multiply(F);\r\n        this._right.multiply(F);\r\n\r\n        // The sign of the inequation must be changed.\r\n        if (this._sign !== '=' && F.sign() === -1) {\r\n            this._reverseSign();\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * divide an equation by a given value (transformed as a fraction)\r\n     *\r\n     * ```\r\n     * 8x+10=6x \\vert 2\r\n     * 4x+5=3x\r\n     * ```\r\n     *\r\n     * |>Alternatively with $3x-4$ maybe it's working ?\r\n     * $$\\frac{3x}{5}$$\r\n     *\r\n     * @param value\r\n     * @returns {Equation}\r\n     */\r\n    divide = (value: unknown): Equation => {\r\n        // Make sure we have a fraction.\r\n        let F: Fraction = new Fraction(value);\r\n\r\n        if (F.isZero()) {\r\n            return this;\r\n        } else {\r\n            return this.multiply(F.invert());\r\n        }\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations helpers\r\n    // -----------------------------------------------\r\n\r\n    /**\r\n     * Get the degree of the equation\r\n     * @param letter\r\n     */\r\n    degree = (letter?: string): Fraction => {\r\n        return Fraction.max(this._left.degree(letter), this._right.degree(letter));\r\n    };\r\n\r\n    /**\r\n     * Determine if the equation contains more than one letter/variable.\r\n     */\r\n    isMultiVariable = (): boolean => {\r\n        return this._left.isMultiVariable || this._right.isMultiVariable;\r\n    };\r\n\r\n    letters = (): string[] => {\r\n        // @ts-ignore\r\n        return [...new Set([...this._left.letters(), ...this._right.letters()])];\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations solving algorithms\r\n    // -----------------------------------------------\r\n    solve = (): Equation => {\r\n        // Initialise the variables:\r\n        this._solutions = [];\r\n\r\n        // TODO: consolidate solving equations (inequations vs equations)\r\n        // TODO: work with not natural degrees ?\r\n        this._polynom = this._left.clone().subtract(this._right);\r\n\r\n        switch (this._polynom.degree().value) {\r\n            case 0:\r\n            case 1:\r\n                this._solveDegree1();\r\n                break;\r\n            case 2:\r\n                this._solveDegree2();\r\n                break;\r\n            default:\r\n                this._solveDegree3plus();\r\n        }\r\n        return this;\r\n    };\r\n\r\n    private isGreater = (): boolean => {\r\n        if (this._sign.indexOf('>') !== -1) {\r\n            return true;\r\n        }\r\n        return this._sign.indexOf('geq') !== -1;\r\n\r\n    };\r\n    private isStrictEqual = (): boolean => {\r\n        return this._sign === '=';\r\n    };\r\n    private isAlsoEqual = (): boolean => {\r\n        if (this._sign.indexOf('=') !== -1) {\r\n            return true;\r\n        }\r\n        if (this._sign.indexOf('geq') !== -1) {\r\n            return true;\r\n        }\r\n        if (this._sign.indexOf('leq') !== -1) {\r\n            return true;\r\n        }\r\n    };\r\n\r\n    private _solveDegree1 = (letter?: string): ISolution[] => {\r\n        const m1 = this._polynom.monomByDegree(1, letter).coefficient,\r\n            m0 = this._polynom.monomByDegree(0, letter).coefficient,\r\n            v = m0.clone().opposed().divide(m1);\r\n        let s: string;\r\n\r\n        if (this.isStrictEqual()) {\r\n            if (m1.value === 0) {\r\n                // In this case, the coefficient of the x variable is zero.\r\n                if (m0.value === 0) {\r\n                    this._solutions = [{\r\n                        tex: this._real,\r\n                        value: NaN,\r\n                        exact: false\r\n                    }];\r\n                } else {\r\n                    this._solutions = [{\r\n                        tex: this._varnothing,\r\n                        value: NaN,\r\n                        exact: false\r\n                    }];\r\n                }\r\n            } else {\r\n                this._solutions = [{\r\n                    tex: v.display,\r\n                    value: v.value,\r\n                    exact: v\r\n                }]\r\n            }\r\n        } else {\r\n            if (m1.value === 0) {\r\n                // In this case, the coefficient of the x variable is zero.\r\n                if (m0.value === 0 && this.isAlsoEqual()) {\r\n                    s = '\\\\mathbb{R}';\r\n                } else {\r\n                    if (m0.value > 0) {\r\n                        s = this.isGreater() ? this._real : this._varnothing;\r\n                    } else {\r\n                        s = !this.isGreater() ? this._real : this._varnothing;\r\n                    }\r\n                }\r\n            } else {\r\n                // Must handle the case if the m1 monom is negative.\r\n                if ((this.isGreater() && m1.sign() === 1) || (!this.isGreater() && m1.sign() === -1)) {\r\n                    s = `\\\\left${this.isAlsoEqual() ? '\\\\[' : '\\\\]'}${v};+\\\\infty\\\\right\\\\[`;\r\n                } else {\r\n                    s = `\\\\left\\\\]-\\\\infty;${v} \\\\right\\\\${this.isAlsoEqual() ? '\\\\]' : '\\\\['}`;\r\n                }\r\n            }\r\n            this._solutions = [{\r\n                tex: s,\r\n                value: NaN,\r\n                exact: false\r\n            }];\r\n        }\r\n\r\n        return this._solutions;\r\n    };\r\n\r\n    private _solveDegree2 = (letter?: string): ISolution[] => {\r\n        let aF = this._polynom.monomByDegree(2, letter).coefficient,\r\n            bF = this._polynom.monomByDegree(1, letter).coefficient,\r\n            cF = this._polynom.monomByDegree(0, letter).coefficient,\r\n            delta: number, nthDelta: Nthroot,\r\n            lcm = Numeric.lcm(aF.denominator, bF.denominator, cF.denominator),\r\n            a = aF.multiply(lcm).value,\r\n            b = bF.multiply(lcm).value,\r\n            c = cF.multiply(lcm).value,\r\n            realX1: number, realX2: number,\r\n            sX1: string, sX2: string;\r\n\r\n        delta = b * b - 4 * a * c;\r\n\r\n        if (delta > 0) {\r\n            realX1 = (-b - Math.sqrt(delta)) / (2 * a);\r\n            realX2 = (-b + Math.sqrt(delta)) / (2 * a);\r\n\r\n            if (delta > 1.0e5) {\r\n                // The delta is too big to be parsed !\r\n                this._solutions = [\r\n                    {\r\n                        tex: ((-b - Math.sqrt(delta)) / (2 * a)).toFixed(5),\r\n                        value: realX1,\r\n                        exact: false\r\n                    },\r\n                    {\r\n                        tex: ((-b + Math.sqrt(delta)) / (2 * a)).toFixed(5),\r\n                        value: realX2,\r\n                        exact: false\r\n                    }\r\n                ]\r\n            } else {\r\n                nthDelta = new Nthroot(delta).reduce();\r\n                if (nthDelta.hasRadical()) {\r\n                    // -b +- coeff\\sqrt{radical}\r\n                    // -------------------------\r\n                    //           2a\r\n                    let gcd = Numeric.gcd(b, 2 * a, nthDelta.coefficient);\r\n                    nthDelta.coefficient = nthDelta.coefficient / gcd;\r\n\r\n                    // TODO: Can i delete the next line ?\r\n                    // let deltaC = nthDelta.coefficient, deltaR = nthDelta.radical;\r\n                    if (b !== 0) {\r\n                        if (2 * a / gcd === 1) {\r\n                            this._solutions = [\r\n                                {\r\n                                    tex: `${-b / gcd} - ${nthDelta.tex}`,\r\n                                    value: realX1,\r\n                                    exact: false // TODO: implement exact value with nthroot\r\n                                },\r\n                                {\r\n                                    tex: `${-b / gcd} + ${nthDelta.tex}`,\r\n                                    value: realX2,\r\n                                    exact: false\r\n                                },\r\n\r\n                            ]\r\n                        } else {\r\n                            this._solutions = [\r\n                                {\r\n                                    tex: `\\\\dfrac{${-b / gcd} - ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                                    value: realX1,\r\n                                    exact: false\r\n                                },\r\n                                {\r\n                                    tex: `\\\\dfrac{${-b / gcd} + ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                                    value: realX2,\r\n                                    exact: false\r\n                                },\r\n                            ]\r\n                        }\r\n                    } else {\r\n                        if (2 * a / gcd === 1) {\r\n                            this._solutions = [\r\n                                {\r\n                                    tex: `- ${nthDelta.tex}`,\r\n                                    value: realX1,\r\n                                    exact: false\r\n                                },\r\n                                {\r\n                                    tex: `${nthDelta.tex}`,\r\n                                    value: realX2,\r\n                                    exact: false\r\n                                },\r\n                            ]\r\n                        } else {\r\n                            this._solutions = [\r\n                                {\r\n                                    tex: `\\\\dfrac{- ${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                                    value: realX1,\r\n                                    exact: false\r\n                                },\r\n                                {\r\n                                    tex: `\\\\dfrac{${nthDelta.tex} }{ ${2 * a / gcd} }`,\r\n                                    value: realX2,\r\n                                    exact: false\r\n                                },\r\n                            ]\r\n                        }\r\n                    }\r\n                } else {\r\n                    // -b +- d / 2a\r\n                    const S1 = new Fraction(-b - nthDelta.coefficient, 2 * a).reduce(),\r\n                        S2 = new Fraction(-b + nthDelta.coefficient, 2 * a).reduce()\r\n                    this._solutions = [\r\n                        {\r\n                            tex: S1.dfrac,\r\n                            value: realX1,\r\n                            exact: S1\r\n                        },\r\n                        {\r\n                            tex: S2.dfrac,\r\n                            value: realX2,\r\n                            exact: S2\r\n                        }\r\n                    ]\r\n                }\r\n            }\r\n\r\n        } else if (delta === 0) {\r\n            const sol = new Fraction(-b, 2 * a).reduce()\r\n            this._solutions = [{\r\n                tex: sol.dfrac,\r\n                value: sol.value,\r\n                exact: sol\r\n            }];\r\n        } else {\r\n            this._solutions = [{\r\n                tex: this._varnothing,\r\n                value: NaN,\r\n                exact: false\r\n            }];\r\n        }\r\n\r\n\r\n        // Handle now the inequations.\r\n        if (!this.isStrictEqual()) {\r\n            if (this._solutions.length === 2) {\r\n                sX1 = (realX1 < realX2) ? this._solutions[0].tex : this._solutions[1].tex;\r\n                sX2 = (realX1 < realX2) ? this._solutions[1].tex : this._solutions[0].tex;\r\n\r\n                if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                    this._solutions = [{\r\n                        tex: `\\\\left]-\\\\infty ; ${sX1}\\\\right${this.isAlsoEqual() ? ']' : '['} \\\\cup \\\\left${this.isAlsoEqual() ? '[' : ']'}${sX2};+\\\\infty\\\\right[`,\r\n                        value: NaN,\r\n                        exact: false\r\n                    }\r\n                    ];\r\n                } else {\r\n                    this._solutions = [{\r\n                        tex: `\\\\left${this.isAlsoEqual() ? '[' : ']'}${sX1} ; ${sX2}\\\\right${this.isAlsoEqual() ? ']' : '['}`,\r\n                        value: NaN,\r\n                        exact: false\r\n                    }]\r\n                }\r\n            } else if (this._solutions.length === 1 && this._solutions[0].tex !== this._varnothing) {\r\n                if (!this.isAlsoEqual()) {\r\n                    if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                        this._solutions = [{\r\n                            tex: `\\\\left]-\\\\infty ; ${this._solutions[0].tex}\\\\right[ \\\\cup \\\\left]${this._solutions[0].tex};+\\\\infty\\\\right[`,\r\n                            value: NaN,\r\n                            exact: false\r\n                        }\r\n                        ];\r\n                    } else {\r\n                        this._solutions = [{\r\n                            tex: this._varnothing,\r\n                            value: NaN,\r\n                            exact: false\r\n                        }];\r\n                    }\r\n                } else {\r\n                    if ((this.isGreater() && aF.sign() === 1) || (!this.isGreater() && aF.sign() === -1)) {\r\n                        this._solutions = [{\r\n                            tex: this._real,\r\n                            value: NaN,\r\n                            exact: false\r\n                        }];\r\n                    } else {\r\n                        // this._texSolutions = [ this._texSolutions[0] ];\r\n                    }\r\n                }\r\n            } else {\r\n                if (this.isGreater()) {\r\n                    this._solutions = [{\r\n                        tex: aF.sign() === 1 ? this._real : this._varnothing,\r\n                        value: NaN,\r\n                        exact: false\r\n                    }];\r\n                } else {\r\n                    this._solutions = [{\r\n                        tex: aF.sign() === -1 ? this._real : this._varnothing,\r\n                        value: NaN,\r\n                        exact: false\r\n                    }];\r\n                }\r\n            }\r\n        }\r\n        return this._solutions;\r\n    };\r\n\r\n    private _solveDegree3plus = (): ISolution[] => {\r\n        // TODO: try to resolve equations with a degree superior than 2.\r\n        this._solutions = [{tex: 'solve x - not yet handled', value: NaN, exact: false}];  // ESLint remove system :(\r\n        return this._solutions;\r\n    };\r\n\r\n}","export * from \"./equation\"\r\nexport * from \"./linearSystem\"\r\nexport * from \"./logicalset\"\r\nexport * from \"./monom\"\r\nexport * from \"./polynom\"\r\nexport * from \"./rational\"","import {Fraction} from \"../coefficients\";\r\nimport {Equation} from \"./equation\";\r\nimport {Polynom} from \"./polynom\";\r\nimport {Monom} from \"./monom\";\r\nimport {Random} from \"../random\";\r\n\r\n// TODO: Must check and rework\r\nexport class LinearSystem {\r\n    private _solutions: { [letter: string]: { value: Fraction, isReal: boolean, isVarnothing: boolean } };\r\n    private _resolutionSteps: LinearSystem[];\r\n    private _equations: Equation[];\r\n    private _letters: string[];\r\n\r\n    constructor(...equationStrings: string[]) {\r\n        this._equations = [];\r\n        this._letters = 'xy'.split('');\r\n\r\n        if (equationStrings !== undefined && equationStrings.length > 0) {\r\n            this.parse(...equationStrings);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get equations(): Equation[] {\r\n        return this._equations;\r\n    }\r\n\r\n    set equations(value) {\r\n        this._equations = value;\r\n    }\r\n\r\n    get letters(): string {\r\n        return this._letters.join('')\r\n    }\r\n\r\n    set letters(value: string) {\r\n        this._letters = value.split('');\r\n    }\r\n\r\n    get isSolvable(): boolean {\r\n        let V = this.variables;\r\n\r\n        // TODO: in some case, it is possible to resolve systems if there isn't the isSame number of vars and equations\r\n        if (V.length !== this._equations.length) {\r\n            return false;\r\n        }\r\n\r\n        //TODO: Must check if two equations isn't a linear combination of the others ?\r\n\r\n        return true;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        let V: string[] = [];\r\n        for (let E of this._equations) {\r\n            V = V.concat(E.variables);\r\n        }\r\n        return [...new Set(V)].sort();\r\n    }\r\n\r\n    get tex(): string {\r\n        // Build the array of values.\r\n        // Reorder\r\n        // This clone the system :!!!\r\n        //TODO: Avoid cloning this linear system\r\n        let LS = this.clone().reorder(),\r\n            letters = LS.variables,\r\n            equStr: string[],\r\n            equArray: string[] = [],\r\n            m: Monom;\r\n\r\n        // TODO: Manage tex output of linear equations\r\n        for (let equ of LS.equations) {\r\n            equStr = [];\r\n            for (let L of letters) {\r\n                m = equ.left.monomByLetter(L);\r\n\r\n                if (equStr.length === 0) {\r\n                    equStr.push(m.isZero() ? '' : m.tex);\r\n                } else {\r\n                    equStr.push(m.isZero() ? '' : ((m.coefficient.sign() === 1) ? '+' : '') + m.tex);\r\n                }\r\n            }\r\n\r\n            // Add the equal sign\r\n            equStr.push('=');\r\n\r\n            // Add the right hand part of the equation (should be only a number, because it has been reordered)\r\n            equStr.push(equ.right.tex);\r\n\r\n            // Add to the list.\r\n            equArray.push(equStr.join('&'));\r\n        }\r\n\r\n\r\n        return `\\\\left\\\\{\\\\begin{array}{${\"r\".repeat(letters.length)}cl}${equArray.join('\\\\\\\\\\ ')}\\\\end{array}\\\\right.`;\r\n        //return `\\\\left\\\\{\\\\begin{array}{rrrcl}${this._equations.map(equ => `${equ.tex}`).join('\\\\\\\\\\ \\n')}\\\\end{array}\\\\right.`;\r\n    }\r\n\r\n    get solution(): string {\r\n        let tex: string[] = [];\r\n\r\n        if (this._solutions === undefined) {\r\n            this.solve();\r\n        }\r\n\r\n        for (let letter in this._solutions) {\r\n            if (this._solutions[letter].isReal) {\r\n                console.log(`Undetermined (letter ${letter})`);\r\n                return;\r\n            }\r\n            if (this._solutions[letter].isVarnothing) {\r\n                console.log(`Undefined (letter ${letter})`);\r\n                return;\r\n            }\r\n\r\n            tex.push(this._solutions[letter].value.dfrac);\r\n        }\r\n        return `(${tex.join(';')})`;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (...equations: unknown[]): LinearSystem => {\r\n        this._equations = equations.map(value => new Equation(value));\r\n        this._findLetters();\r\n        return this;\r\n    };\r\n\r\n    setCoefficient = (...coefficients: string[]): LinearSystem => {\r\n        // Reset the equations list\r\n        this._equations = [];\r\n\r\n        let i = 0;\r\n        while (i < coefficients.length - this._letters.length) {\r\n            let left = new Polynom().parse(this._letters.join(''), ...coefficients.slice(i, i + this._letters.length)),\r\n                right = new Polynom(coefficients[i + this._letters.length].toString()),\r\n                equ = new Equation().create(left, right);\r\n            this._equations.push(equ.clone());\r\n\r\n            i = i + this._letters.length + 1;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    clone = (): LinearSystem => {\r\n        return new LinearSystem().parse(...this._equations.map(equ => equ.clone()));\r\n    };\r\n\r\n    setLetters = (...letters: string[]): LinearSystem => {\r\n        this._letters = letters;\r\n        return this\r\n    }\r\n    private _findLetters = (): LinearSystem => {\r\n        // Find all letters used.\r\n        let variables = new Set();\r\n\r\n        for (let equ of this._equations) {\r\n            variables = new Set([...variables, ...equ.variables]);\r\n        }\r\n\r\n        // TODO: How to transform (Set of string) to string[]\r\n        // @ts-ignore\r\n        this._letters = [...variables];\r\n        return this;\r\n    }\r\n\r\n    // -----------------------------------------------\r\n    // Equations generators and randomizers\r\n    // -----------------------------------------------\r\n    generate = (...solutions: Fraction[] | number[]): LinearSystem => {\r\n        let solutionsF: Fraction[] = [];\r\n\r\n        // Convert the numbers to fractions if necessary\r\n        for (let s of solutions) {\r\n            if (typeof s === \"number\") {\r\n                solutionsF.push(new Fraction(s.toString()));\r\n            } else {\r\n                solutionsF.push(s.clone());\r\n            }\r\n        }\r\n\r\n        // Create the equations and make sure they are not linear combined.\r\n        this._equations = [];\r\n        for (let i = 0; i < solutions.length; i++) {\r\n            this._equations.push(this._generateOneEquation(...solutionsF));\r\n        }\r\n        return this;\r\n    };\r\n    private _generateOneEquation = (...solutions: Fraction[]): Equation => {\r\n        let coeff: number[] = [], leftValue: Fraction = new Fraction().zero(),\r\n            letters: string[] = ['x', 'y', 'z', 't', 'u', 'v', 'w', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l'],\r\n            equString: string = '', equ: Equation;\r\n        for (let i = 0; i < solutions.length; i++) {\r\n            coeff.push(Random.numberSym(5));\r\n            leftValue.add(solutions[i].clone().multiply(coeff[i]));\r\n            equString += `${(coeff[i] < 0) ? coeff[i] : '+' + coeff[i]}${letters[i]}`\r\n        }\r\n\r\n        // LeftValue contains the left part oof the equation - and is then the isSame as the right part.\r\n        // It might be a Fraction.\r\n\r\n        // Must check if it's not a linear combination\r\n        equ = new Equation(`${equString}=${leftValue.display}`);\r\n        if (equ.right.monoms[0].coefficient.denominator != 1) {\r\n            equ.multiply(new Fraction(equ.right.monoms[0].coefficient.denominator, 1));\r\n        }\r\n        if (this._checkIfLinerCombination(equ)) {\r\n            return equ;\r\n        } else {\r\n            return this._generateOneEquation(...solutions);\r\n        }\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    private _linearReduction(eq1: Equation, eq2: Equation, letter: string): Equation {\r\n        // TODO: handle other signs for equations ?\r\n        // Get the monom for the particular letter.\r\n        let c1 = eq1.left.monomByDegree(1, letter).coefficient.clone(),\r\n            c2 = eq2.left.monomByDegree(1, letter).coefficient.clone().opposed();\r\n\r\n        return this.mergeEquations(eq1, eq2, c2, c1);\r\n    }\r\n\r\n    mergeEquations = (eq1: Equation, eq2: Equation, factor1: unknown, factor2: unknown): Equation => {\r\n        // Set and clone the equations.\r\n\r\n        let eq1multiplied = eq1.clone().multiply(new Fraction(factor1)),\r\n            eq2multiplied = eq2.clone().multiply(new Fraction(factor2));\r\n\r\n        // Add both equations together.\r\n        eq1multiplied.left.add(eq2multiplied.left);\r\n        eq1multiplied.right.add(eq2multiplied.right);\r\n\r\n        return eq1multiplied;\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Solvers algorithm\r\n    // ------------------------------------------\r\n    reorder = (): LinearSystem => {\r\n        for (let E of this._equations) {\r\n            E.reorder();\r\n        }\r\n        return this;\r\n    };\r\n\r\n    solve = (): LinearSystem => {\r\n        // Solve it by linear\r\n        this._solutions = {};\r\n        this._resolutionSteps = [];\r\n\r\n        // Reorder all equations.\r\n        this.reorder();\r\n\r\n        // Get all variables in the linear system\r\n        let V = this.variables.sort();\r\n\r\n        for (let letter of V) {\r\n            this._solutions[letter] = this._solveOneLetter(letter, V)\r\n        }\r\n\r\n        // TODO: LinearSystem - solve: optimization and handle undetermined and undefined systems.\r\n        return this;\r\n    };\r\n\r\n    private _checkIfLinerCombination = (equ: Equation): boolean => {\r\n\r\n        return true;\r\n    };\r\n\r\n    private _solveOneLetter(letter: string, V: string[]): { value: Fraction, isReal: boolean, isVarnothing: boolean } {\r\n        // list of equations.\r\n        let LE: Equation[] = this.clone().equations,\r\n            reducedEquations: Equation[] = [];\r\n\r\n        // Reduce the equations.\r\n        // Do it as long as there is more than one step, but no more than the number of equations.\r\n        for (let L of V) {\r\n            // remove the setLetter from all equations using linear combinations\r\n            if (L === letter) {\r\n                continue;\r\n            }\r\n\r\n            // Linear reduction.\r\n            // TODO: Search for better association\r\n            for (let i = 0; i < LE.length - 1; i++) {\r\n                reducedEquations.push(this._linearReduction(LE[i], LE[i + 1], L));\r\n            }\r\n\r\n            // Keep track of each steps.\r\n            this._resolutionSteps.push(new LinearSystem().parse(...reducedEquations));\r\n\r\n            // Set the list of equations to the new version.\r\n            LE = this._resolutionSteps[this._resolutionSteps.length - 1].clone().equations;\r\n\r\n            // Reset the stack\r\n            reducedEquations = [];\r\n        }\r\n\r\n        // Solve the equations\r\n        let E = this._resolutionSteps[this._resolutionSteps.length - 1].equations[0];\r\n        E.solve();\r\n\r\n        return {\r\n            value: new Fraction(E.solutions[0].value),\r\n            isReal: E.isReal,\r\n            isVarnothing: E.isVarnothing\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Helpers\r\n    // ------------------------------------------\r\n    log = (): string => {\r\n        let str: string = '';\r\n\r\n        for (let E of this._equations) {\r\n            console.log(E.tex);\r\n            str += `${E.tex}\\\\n}`;\r\n        }\r\n\r\n        return str;\r\n    };\r\n}\r\n","/**\r\n * Polynom module contains everything necessary to handle polynoms.\r\n * @module Logicalset\r\n */\r\n\r\nimport {Shutingyard} from '../shutingyard';\r\n\r\n/**\r\n * Polynom class can handle polynoms, reorder, resolve, ...\r\n */\r\n    export class Logicalset {\r\n        private _rawString: string;\r\n        private _rpn: { token: string, tokenType: string }[]\r\n\r\n        /**\r\n         *\r\n         * @param {string} value (optional) Default polynom to parse on class creation\r\n         */\r\n        constructor(value: string) {\r\n            this._rawString = value\r\n            this.parse(value)\r\n            return this;\r\n        }\r\n\r\n        get isLogicalset() {\r\n            return true;\r\n        };\r\n\r\n        private parse = (value: string): Logicalset => {\r\n            // TODO: Must format the value string to convert some items...\r\n\r\n            // Parse the updated value to the shutingyard algorithm\r\n            this._rpn = new Shutingyard('set').parse(value).rpn;\r\n\r\n            return this;\r\n        }\r\n\r\n        evaluate(tokenSets: { [key: string]: unknown[] }, reference?: unknown[]): unknown[] {\r\n            let varStack: (Set<unknown>)[] = []\r\n\r\n            let referenceSet: Set<unknown>\r\n            if (reference === undefined) {\r\n                referenceSet = new Set()\r\n                for (let key in tokenSets) {\r\n                    referenceSet = new Set([...referenceSet, ...tokenSets[key]])\r\n                }\r\n            } else {\r\n                referenceSet = new Set(reference)\r\n            }\r\n\r\n            for (let token of this._rpn) {\r\n                if (token.tokenType === 'variable') {\r\n                    // The variable has no token - assume it's empty.\r\n                    if (tokenSets[token.token] === undefined) {\r\n                        varStack.push(new Set())\r\n                    } else {\r\n                        varStack.push(new Set(tokenSets[token.token]));\r\n                    }\r\n\r\n                } else {\r\n                    switch (token.token) {\r\n                        case '&':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                varStack.push(new Set([...first].filter(x => second.has(x))))\r\n                            }\r\n                            break\r\n                        case '|':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n                                varStack.push(new Set([...first, ...second]))\r\n                            }\r\n                            break\r\n                        case '-':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n                                varStack.push(new Set([...first].filter(x => !second.has(x))))\r\n                            }\r\n                            break\r\n                        case '!':\r\n                            if (varStack.length >= 1) {\r\n                                let first = varStack.pop()\r\n\r\n                                varStack.push(new Set([...referenceSet].filter(x => !first.has(x))))\r\n                            }\r\n                            break\r\n                    }\r\n                }\r\n            }\r\n\r\n            return [...varStack[0]].sort();\r\n        }\r\n\r\n        vennAB(): any[] {\r\n            return this.evaluate({\r\n                    A: ['A', 'AB'],\r\n                    B: ['B', 'AB']\r\n                },\r\n                ['A', 'B', 'AB', 'E']\r\n            )\r\n        }\r\n\r\n        vennABC(): any[] {\r\n            return this.evaluate({\r\n                    A: ['A', 'AB', 'AC', 'ABC'],\r\n                    B: ['B', 'AB', 'BC', 'ABC'],\r\n                    C: ['C', 'AC', 'BC', 'ABC']\r\n                },\r\n                ['A', 'B', 'C', 'AB', 'AC', 'BC', 'E']\r\n            )\r\n        }\r\n\r\n        get rpn(): { token: string, tokenType: string }[] {\r\n            return this._rpn\r\n        }\r\n\r\n        get tex(): string {\r\n            let varStack: { token: string, tokenType: string } [] = []\r\n\r\n            for (let token of this._rpn) {\r\n                if (token.tokenType === 'variable') {\r\n                    varStack.push(token);\r\n                } else {\r\n                    switch (token.token) {\r\n                        case '&':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\cap ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                            break\r\n                        case '|':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\cup ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                            break\r\n                        case '-':\r\n                            if (varStack.length >= 2) {\r\n                                let second = varStack.pop(),\r\n                                    first = varStack.pop()\r\n\r\n                                if (first.tokenType === 'mix') {\r\n                                    first.token = `( ${first.token} )`\r\n                                }\r\n                                if (second.tokenType === 'mix') {\r\n                                    second.token = `( ${second.token} )`\r\n                                }\r\n                                varStack.push({token: `${first.token} \\\\setminus ${second.token}`, tokenType: 'mix'})\r\n                            }\r\n                            break\r\n                        case '!':\r\n                            if (varStack.length >= 1) {\r\n                                let first = varStack.pop()\r\n                                varStack.push({token: `\\\\overline{ ${first.token} }`, tokenType: 'variable'})\r\n                            }\r\n                            break\r\n                    }\r\n                }\r\n            }\r\n\r\n            return varStack[0].token\r\n        }\r\n    }","/***\r\n * Monom class\r\n * Defined as coefficient * literal\r\n * Examples: 3x^2, 3/5x^2, ...\r\n */\r\nimport {Fraction} from \"../coefficients\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Shutingyard} from \"../shutingyard\";\r\n\r\nexport type literalType = {\r\n    [Key: string]: Fraction\r\n}\r\n\r\nexport class Monom {\r\n    private _coefficient: Fraction;\r\n    private _literal: literalType;\r\n\r\n    /**\r\n     * Create the monom object.\r\n     * @param value (optional) string\r\n     */\r\n    constructor(value?: unknown) {\r\n        this.zero();\r\n\r\n        if (value !== undefined) {\r\n            // A string is given - try to parse the value.\r\n            this.parse(value);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    /**\r\n     * Get the coefficient as fraction\r\n     */\r\n    get coefficient(): Fraction {\r\n        return this._coefficient;\r\n    }\r\n\r\n    /**\r\n     * Set the coefficient value of the monom\r\n     * @param F     Fraction\r\n     */\r\n    set coefficient(F: Fraction) {\r\n        this._coefficient = F;\r\n    }\r\n\r\n    /**\r\n     * Get the literal part, as dictionary\r\n     */\r\n    get literal(): literalType {\r\n        return this._literal;\r\n    }\r\n\r\n    get literalSqrt(): literalType {\r\n\r\n        if (this.isLiteralSquare()) {\r\n            let L: literalType = {}\r\n            for (let key in this._literal) {\r\n                L[key] = this._literal[key].clone().sqrt()\r\n            }\r\n            return L;\r\n        } else {\r\n            return this._literal;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom\r\n     * @param L     Literal part as dictionary: <setLetter: exposant>\r\n     */\r\n    set literal(L: literalType) {\r\n        this._literal = L;\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom from a string\r\n     * @param inputStr  String like x^2y^3\r\n     */\r\n    set literalStr(inputStr: string) {\r\n        // TODO : parse using shutingyard tree !\r\n\r\n        // Match all x^n\r\n        for (const v of [...inputStr.matchAll(/([a-z])\\^([+-]?[0-9]+)/g)]) {\r\n            // Create the default letter entry if necessary.\r\n            if (!(v[1] in this._literal)) {\r\n                this._literal[v[1]] = new Fraction().zero();\r\n            }\r\n\r\n            // Add the new value.\r\n            // TODO: actually, it adds only numeric value\r\n            this._literal[v[1]].add(+v[2]);\r\n        }\r\n\r\n        // Match all x\r\n        for (const v of [...inputStr.matchAll(/([a-z](?!\\^))/g)]) {\r\n            // Match all single letters\r\n            if (!(v[1] in this._literal)) {\r\n                this._literal[v[1]] = new Fraction().zero();\r\n            }\r\n\r\n            // Add one to the value.\r\n            this._literal[v[1]].add(1)\r\n        }\r\n    }\r\n\r\n    // Getter helpers.\r\n    /**\r\n     * Get the variables letters\r\n     */\r\n    get variables(): string[] {\r\n        this.clone().clean();\r\n        return Object.keys(this._literal)\r\n    }\r\n\r\n    // Display getter\r\n    /**\r\n     * This display getter is to be used in the polynom display getter\r\n     */\r\n    get display(): string {\r\n        let L: string = '',\r\n            letters = Object.keys(this._literal).sort()\r\n        for (let letter of letters) {\r\n            if (this._literal[letter].isNotZero()) {\r\n                L += `${letter}`;\r\n                if (this._literal[letter].isNotEqual(1)) {\r\n                    L += `^${this._literal[letter].display}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.display}`;\r\n            } else {\r\n                return '';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.display}${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    get dividers(): Monom[] {\r\n        // Decompose only if the coefficient is a natural number\r\n        if (this.coefficient.denominator !== 1) {\r\n            return [this.clone()]\r\n        }\r\n        // Decompose only if the power values are natural numbers.\r\n        if (this.hasFractionCoefficient) {\r\n            return [this.clone()]\r\n        }\r\n\r\n        // Security : do not do this if greater than 10000\r\n        if (this.coefficient.numerator > 10000) {\r\n            return [this.clone()]\r\n        }\r\n        const dividers = Numeric.dividers(Math.abs(this.coefficient.numerator))\r\n\r\n        // Decompose the literals parts.\r\n        let literals: literalType[] = [];\r\n        for (let L in this.literal) {\r\n            // L is the letter.\r\n            literals = this._getLiteralDividers(literals, L)\r\n        }\r\n\r\n        const monomDividers: Monom[] = [];\r\n        if (literals.length > 0 && dividers.length > 0) {\r\n            for (let N of dividers) {\r\n                for (let L of literals) {\r\n                    let M = new Monom();\r\n                    M.coefficient = new Fraction(N)\r\n                    M.literal = L\r\n                    monomDividers.push(M)\r\n                }\r\n            }\r\n        } else if (dividers.length === 0) {\r\n            for (let L of literals) {\r\n                let M = new Monom();\r\n                M.coefficient = new Fraction().one()\r\n                M.literal = L\r\n                monomDividers.push(M)\r\n            }\r\n        } else {\r\n            for (let N of dividers) {\r\n                let M = new Monom();\r\n                M.coefficient = new Fraction(N)\r\n                monomDividers.push(M)\r\n            }\r\n        }\r\n\r\n        return monomDividers.length === 0 ? [new Monom().one()] : monomDividers;\r\n    }\r\n\r\n    private _getLiteralDividers(arr: literalType[], letter: string): literalType[] {\r\n        let tmpList: { [key: string]: Fraction }[] = [];\r\n\r\n        // Be default, this.literal[letter] should be a rational number.\r\n        for (let d = 0; d <= this.literal[letter].value; d++) {\r\n            if (arr.length === 0) {\r\n                let litt: literalType = {}\r\n                litt[letter] = new Fraction(d)\r\n                tmpList.push(litt)\r\n            } else {\r\n                for (let item of arr) {\r\n                    let litt: literalType = {}\r\n                    for (let currentLetter in item) {\r\n                        litt[currentLetter] = item[currentLetter]\r\n                    }\r\n                    litt[letter] = new Fraction(d)\r\n                    tmpList.push(litt)\r\n                }\r\n            }\r\n        }\r\n        return tmpList;\r\n    }\r\n\r\n    /**\r\n     * Display the monom, forcing the '+' sign to appear\r\n     */\r\n    get displayWithSign(): string {\r\n        // TODO: Rename or remove this getter ?\r\n        let d: String = this.display;\r\n        return (d[0] !== '-' ? '+' : '') + d;\r\n    }\r\n\r\n    /**\r\n     * Get the tex output of the monom\r\n     */\r\n    get tex(): string {\r\n        // TODO: display with square root !\r\n        let L: string = '',\r\n            letters = Object.keys(this._literal).sort()\r\n\r\n        for (let letter of letters) {\r\n            if (this._literal[letter].isNotZero()) {\r\n                L += `${letter}`;\r\n                if (this._literal[letter].isNotEqual(1)) {\r\n                    L += `^{${this._literal[letter].display}}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.dfrac}`;\r\n            } else {\r\n                return '0';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.dfrac}${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // -----------------------------------------\r\n    /**\r\n     * Parse a string to a monom. The string may include fraction.\r\n     * @param inputStr\r\n     */\r\n    parse = (inputStr: unknown): Monom => {\r\n\r\n        if(typeof inputStr === 'string') {\r\n            this._shutingYardToReducedMonom(inputStr)\r\n        }else if(typeof inputStr ==='number') {\r\n            this._coefficient = new Fraction(inputStr)\r\n            this._literal = {}\r\n        }else if(inputStr instanceof Fraction) {\r\n            this._coefficient = inputStr.clone()\r\n            this._literal = {}\r\n        }else if(inputStr instanceof Monom){\r\n            this._coefficient = inputStr._coefficient.clone()\r\n            this._literal = this.copyLiterals(inputStr.literal)\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    private _shutingYardToReducedMonom = (inputStr: string): Monom => {\r\n        // Get the RPN array of the current expression\r\n        const SY: Shutingyard = new Shutingyard().parse(inputStr);\r\n        const rpn: { token: string, tokenType: string }[] = SY.rpn;\r\n\r\n        let stack: Monom[] = [], m, pow, letter, q1, q2\r\n\r\n        if (rpn.length === 0) {\r\n            this.zero()\r\n            return this\r\n        } else if (rpn.length === 1) {\r\n            const element = rpn[0]\r\n\r\n            this.one()\r\n            if (element.tokenType === 'coefficient') {\r\n                this.coefficient = new Fraction(element.token)\r\n            } else if (element.tokenType === 'variable') {\r\n                this.setLetter(element.token, 1)\r\n            }\r\n            return this\r\n        } else {\r\n            // Reset the monom\r\n            for (const element of rpn) {\r\n                if (element.tokenType === 'coefficient') {\r\n                    let M = new Monom().one()\r\n                    M.coefficient = new Fraction(element.token)\r\n                    stack.push(M.clone())\r\n                } else if (element.tokenType === 'variable') {\r\n                    let M = new Monom().one()\r\n                    M.setLetter(element.token, 1)\r\n                    stack.push(M.clone())\r\n                } else if (element.tokenType === 'operation') {\r\n                    switch (element.token) {\r\n                        case '-':\r\n                            // this should only happen for negative powers or for negative coefficient.\r\n                            q2 = (stack.pop()) || new Monom().zero()\r\n                            q1 = (stack.pop()) || new Monom().zero()\r\n\r\n                            stack.push(q1.subtract(q2))\r\n\r\n                            break;\r\n                        case '*':\r\n                            // Get the last element in the stack\r\n                            q2 = (stack.pop()) || new Monom().one()\r\n                            q1 = (stack.pop()) || new Monom().one()\r\n\r\n                            stack.push(q1.multiply(q2))\r\n                            break\r\n                        case '^':\r\n                            // get the two last elements in the stack\r\n                            pow = (stack.pop().coefficient) || new Fraction().one()\r\n                            m = (stack.pop()) || new Monom().one()\r\n\r\n                            letter = m.variables[0]\r\n\r\n                            if (letter !== undefined) {\r\n                                m.setLetter(letter, pow)\r\n                            }\r\n\r\n                            stack.push(m)\r\n                            // this.multiply(m.clone())\r\n                            break\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.one()\r\n        this.multiply(stack[0])\r\n        return this\r\n    }\r\n    /**\r\n     * Clone the current Monom.\r\n     */\r\n    clone = (): Monom => {\r\n        let F: Monom = new Monom();\r\n\r\n        F.coefficient = this._coefficient.clone();\r\n\r\n        // Copy the literal parts.\r\n        for (let k in this._literal) {\r\n            F.setLetter(k, this._literal[k].clone());\r\n        }\r\n        return F;\r\n    };\r\n\r\n    copyLiterals = (literal: literalType): literalType => {\r\n        let L:literalType = {}\r\n\r\n        for (let k in literal) {\r\n            L[k] = literal[k].clone()\r\n        }\r\n        return L\r\n    }\r\n\r\n    makeSame = (M: Monom):Monom => {\r\n        // Copy the literal parts.\r\n        for (let k in M._literal) {\r\n            this.setLetter(k, M._literal[k].clone());\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Create a zero value monom\r\n     */\r\n    zero = (): Monom => {\r\n        this._coefficient = new Fraction().zero();\r\n        this._literal = {};\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Create a one value monom\r\n     */\r\n    one = (): Monom => {\r\n        this._coefficient = new Fraction().one();\r\n        this._literal = {};\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Clean the monom by removing each letters with a power of zero.\r\n     */\r\n    clean = (): Monom => {\r\n        for (let letter in this._literal) {\r\n            if (this._literal[letter].isZero()) {\r\n                delete this._literal[letter];\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Get the opposed\r\n     * Returns a monom.\r\n     */\r\n    opposed = (): Monom => {\r\n        this._coefficient.opposed();\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Add all similar monoms. If they aren't similar, they are simply skipped.\r\n     * @param M (Monom[]) The monoms to add.\r\n     */\r\n    add = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            if (this.isSameAs(m)) {\r\n                if(this.isZero()){\r\n                    this.makeSame(m)\r\n                }\r\n                this._coefficient.add(m.coefficient);\r\n            } else {\r\n                console.log('Add: Is not similar: ', m.display);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Subtract multiple monoms\r\n     * @param M (Monom[]) The monoms to subtract\r\n     */\r\n    subtract = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            if (this.isSameAs(m)) {\r\n                if(this.isZero()){\r\n                    this.makeSame(m)\r\n                }\r\n                this._coefficient.add(m.clone().coefficient.opposed());\r\n            } else {\r\n                console.log('Subtract: Is not similar: ', m.display);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Multiple multiple monoms to the current monom\r\n     * @param M (Monom[]) The monoms to multiply to.\r\n     */\r\n    multiply = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            // Multiply the coefficient.\r\n            this._coefficient.multiply(m.coefficient);\r\n\r\n            // Multiply the literal parts.\r\n            for (let letter in m.literal) {\r\n                if (this._literal[letter] === undefined) {\r\n                    this._literal[letter] = m.literal[letter].clone()\r\n                } else {\r\n                    this._literal[letter].add(m.literal[letter])\r\n                }\r\n\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    multiplyByNumber = (F: Fraction | number): Monom => {\r\n        this._coefficient.multiply(F);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Divide the current monoms by multiple monoms\r\n     * @param M (Monom[])\r\n     */\r\n    divide = (...M: Monom[]): Monom => {\r\n        // Depending on the given value, choose the current item\r\n        for (let v of M) {\r\n            // Divide the coefficient\r\n            this._coefficient.divide(v.coefficient);\r\n\r\n            // Subtract the power values\r\n            for (let letter in v.literal) {\r\n                this._literal[letter] = (this._literal[letter] === undefined) ? v.literal[letter].clone().opposed() : this._literal[letter].subtract(v.literal[letter])\r\n\r\n                // If the power of a particular setLetter is zero, delete it from the literal part..\r\n                if (this._literal[letter].isZero()) {\r\n                    delete this._literal[letter];\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Get the pow of a monom.\r\n     * @param nb (number) : Mathematical pow\r\n     */\r\n    pow = (nb: number): Monom => {\r\n        this._coefficient.pow(nb);\r\n        for (let letter in this._literal) {\r\n            this._literal[letter].pow(nb)\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Get the nth-root of the monom\r\n     * @param p\r\n     */\r\n    root = (p: number): Monom => {\r\n        // TODO: determiner the nth root of a monom\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Return the square root of a monom\r\n     */\r\n    sqrt = (): Monom => {\r\n        if (this.isSquare()) {\r\n            this._coefficient.sqrt();\r\n            for (let letter in this._literal) {\r\n                this._literal[letter].clone().divide(2)\r\n            }\r\n        }\r\n        return this.root(2);\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n    // ------------------------------------------\r\n    compare = (M: Monom, sign?: string): boolean => {\r\n        // TODO: Build the compare systems.\r\n        if (sign === undefined) {\r\n            sign = '=';\r\n        }\r\n\r\n\r\n        switch (sign) {\r\n            case '=':\r\n                // To be equal, they must be the isSame\r\n                if (!this.compare(M, 'same')) {\r\n                    return false;\r\n                }\r\n\r\n                // The literal parts are the isSame. The coefficient must be equal\r\n                return this._coefficient.isEqual(M.coefficient);\r\n            case 'same':\r\n                // Get the list of all variables from both monoms.\r\n                let M1: string[] = this.variables,\r\n                    M2: string[] = M.variables,\r\n                    K: string[] = M1.concat(M2.filter((item) => M1.indexOf(item) < 0));\r\n\r\n                // To compare, both must be different than zero.\r\n                if (!this.isZero() && !M.isZero()) {\r\n                    for (let key of K) {\r\n                        // The setLetter is not available in one of the monom\r\n                        if (this._literal[key] === undefined || M.literal[key] === undefined) {\r\n                            return false;\r\n                        }\r\n                        // The setLetter does not have the isSame power in each monoms.\r\n                        if (!this._literal[key].isEqual(M.literal[key])) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // All are positive check - the monoms are the sames.\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is null\r\n     */\r\n    isZero(): boolean {\r\n        return this._coefficient.value === 0;\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is one\r\n     */\r\n    isOne(): boolean {\r\n        return this._coefficient.value === 1 && this.variables.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Determine if two monoms are equals\r\n     * @param M\r\n     */\r\n    isEqual = (M: Monom): boolean => {\r\n        return this.compare(M, '=');\r\n    };\r\n\r\n    /**\r\n     * Determine if two monoms are similar\r\n     * @param M\r\n     */\r\n    isSameAs = (M: Monom): boolean => {\r\n        return this.compare(M, 'same');\r\n    };\r\n\r\n    isSquare = (): boolean => {\r\n        if (!this.coefficient.isSquare()) {\r\n            return false;\r\n        }\r\n        return this.isLiteralSquare();\r\n    }\r\n\r\n    isLiteralSquare = (): boolean => {\r\n        for (let letter in this.literal) {\r\n            // A literal square must have a natural power\r\n            if (this.literal[letter].isRational()) {\r\n                return false\r\n            }\r\n\r\n            // The natural power must be be even\r\n            if (this.literal[letter].isEven()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    hasFractionCoefficient = (): boolean => {\r\n        for (let letter in this._literal) {\r\n            if (this._literal[letter].isRational()) {\r\n                return true\r\n            }\r\n        }\r\n\r\n        return false\r\n    }\r\n    // ------------------------------------------\r\n    // Misc monoms functions\r\n    // -------------------------------------\r\n    /**\r\n     * Determine if a monom contains a setLetter in it's literal part\r\n     * @param letter\r\n     */\r\n    hasLetter = (letter?: string): boolean => {\r\n        // The letter was not found\r\n        if (this._literal[letter === undefined ? 'x' : letter] === undefined) {\r\n            return false\r\n        }\r\n\r\n        // The letter is found and is not zero !\r\n        return this._literal[letter === undefined ? 'x' : letter].isNotZero();\r\n    };\r\n\r\n    /**\r\n     * Set the power of a particular setLetter\r\n     * @param letter (string) Letter to change\r\n     * @param pow (number) Power of the setLetter (must be positive integer.\r\n     */\r\n    setLetter = (letter: string, pow: Fraction | number): void => {\r\n        if (pow instanceof Fraction) {\r\n            // Set the power of the letter to zero => remove it\r\n            if (this.hasLetter(letter) && pow.isZero()) {\r\n                delete this._literal[letter]\r\n            }\r\n\r\n            this._literal[letter] = pow.clone()\r\n        } else {\r\n            this.setLetter(letter, new Fraction(pow))\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Get the degree of a monom. If no setLetter is given, the result will be the global degree.\r\n     * @param letter (string) Letter to get to degree (power)\r\n     */\r\n    degree = (letter?: string): Fraction => {\r\n        if (this.variables.length === 0) {\r\n            return new Fraction().zero();\r\n        }\r\n        if (letter === undefined) {\r\n            // Not setLetter given -> we get the global monom degree (sum of all the letters).\r\n            return Object.values(this._literal).reduce((t, n) => t.clone().add(n));\r\n        } else {\r\n            // A setLetter is given -> get the corresponding power.\r\n            return this._literal[letter] === undefined ? new Fraction().zero() : this._literal[letter].clone();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Evaluate a monom. Each setLetter must be assigned to a Fraction.\r\n     * @param values    Dictionary of <setLetter: Fraction>\r\n     */\r\n    evaluate = (values: literalType | Fraction | number): Fraction => {\r\n        let r = this.coefficient.clone();\r\n\r\n        if (typeof values === 'number' || values instanceof Fraction) {\r\n            let tmpValues: literalType = {}\r\n\r\n            tmpValues[this.variables[0]] = new Fraction(values)\r\n            return this.evaluate(tmpValues);\r\n        }\r\n\r\n        if (typeof values === 'object') {\r\n            for (let L in this._literal) {\r\n                if (values[L] === undefined) {\r\n                    return new Fraction().zero();\r\n                }\r\n\r\n                let value = new Fraction(values[L])\r\n                r.multiply(value.pow(this._literal[L]))\r\n            }\r\n        }\r\n        return r;\r\n    };\r\n\r\n    /**\r\n     * Derivative the monom\r\n     * @param letter\r\n     */\r\n    derivative = (letter?: string): Monom => {\r\n        // No setLetter given - assume it's the setLetter 'x'\r\n        if (letter === undefined) {\r\n            letter = 'x';\r\n        }\r\n\r\n        if (this.hasLetter(letter)) {\r\n            let d = this._literal[letter].clone(),\r\n                dM = this.clone();\r\n\r\n            // Subtract one to the degree.\r\n            dM._literal[letter].subtract(1)\r\n\r\n            // Multiply the coefficient by the previous degree\r\n            dM._coefficient.multiply(new Fraction(d.clone()));\r\n            return dM;\r\n        } else {\r\n            return new Monom().zero();\r\n        }\r\n    };\r\n\r\n    primitive = (letter?: string): Monom => {\r\n        // TODO: derivative including the ln value => implies creating different monom system ?\r\n        if (letter === undefined) {\r\n            letter = 'x'\r\n        }\r\n\r\n        // Zero monom\r\n        let M = this.clone(), degree\r\n\r\n        if (M.hasLetter(letter)) {\r\n            degree = M.degree(letter).clone().add(1)\r\n            M.coefficient = M.coefficient.clone().divide(degree)\r\n            M.setLetter(letter, degree)\r\n        } else {\r\n            // There is no letter.\r\n\r\n            // The coefficient might be zero (=> x) or a number a (=> ax)\r\n            if (M.coefficient.isZero()) {\r\n                M.coefficient = new Fraction().one()\r\n            }\r\n            M.setLetter(letter, 1)\r\n        }\r\n        return M\r\n    }\r\n    // ----------------------------------------\r\n    // Static functions\r\n    // ----------------------------------------\r\n\r\n    /**\r\n     * Get the least common multiple of monoms\r\n     * @param monoms    Array of monoms\r\n     */\r\n    static lcm = (...monoms: Monom[]): Monom => {\r\n        // All the monoms must be with natural powers...\r\n        for (let m of monoms) {\r\n            if (m.hasFractionCoefficient()) {\r\n                return new Monom().zero()\r\n            }\r\n        }\r\n\r\n\r\n        let M = new Monom(),\r\n            coeffN: number[] = monoms.map(value => value.coefficient.numerator),\r\n            coeffD: number[] = monoms.map(value => value.coefficient.denominator),\r\n            n = Numeric.gcd(...coeffN),\r\n            d = Numeric.lcm(...coeffD);\r\n\r\n        // Get the coefficient.\r\n        M.coefficient = new Fraction(n, d).reduce();\r\n\r\n        // Set the literal parts - go through each monoms literal parts and get only the lowest degree of each letters.\r\n        for (let m of monoms) {\r\n            // Remove the inexistant letters from the resulting monom\r\n            for (let letter in M.literal) {\r\n                if (!(letter in m.literal)) {\r\n                    M.literal[letter].zero();\r\n                }\r\n            }\r\n            for (let letter in m.literal) {\r\n                if (M.literal[letter] === undefined && m.literal[letter].isStrictlyPositive()) {\r\n                    M.literal[letter] = m.literal[letter].clone();\r\n                } else {\r\n                    M.literal[letter] = new Fraction(Math.min(m.literal[letter].value, M.literal[letter].value))\r\n                }\r\n            }\r\n        }\r\n\r\n        return M;\r\n    };\r\n\r\n    /**\r\n     * Multiply two monoms and return a NEW monom.\r\n     * @param monoms\r\n     */\r\n    static xmultiply = (...monoms: Monom[]): Monom => {\r\n        let M = new Monom().one();\r\n\r\n        for (let m of monoms) {\r\n            M.multiply(m);\r\n        }\r\n\r\n        return M;\r\n    };\r\n\r\n\r\n    // TODO: The rest of the functions are not used or unnecessary ?\r\n    /**\r\n     * Determine if multiple monoms are similar\r\n     * @param M\r\n     */\r\n    areSameAs = (...M: Monom[]): boolean => {\r\n        let result: boolean = true;\r\n\r\n        // Check all monoms if they are the isSame as the \"this\" one.\r\n        for (let i = 0; i < M.length; i++) {\r\n            if (!this.isSameAs(M[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // All check passed -> all the monoms are similar.\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Determine if multiple monoms are equals\r\n     * @param M\r\n     */\r\n    areEquals = (...M: Monom[]): boolean => {\r\n        // They are not similar.\r\n        if (!this.areSameAs(...M)) {\r\n            return false;\r\n        }\r\n\r\n        // Check all coefficient. They must be equals.\r\n        for (let m of M) {\r\n            if (!this._coefficient.isEqual(m.coefficient)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // All checks passed.\r\n        return true;\r\n    };\r\n\r\n}\r\n","/**\r\n * Polynom module contains everything necessary to handle polynoms.*\r\n */\r\n\r\nimport {literalType, Monom} from './monom';\r\nimport {Shutingyard} from '../shutingyard';\r\nimport {Numeric} from '../numeric';\r\nimport {Random, randomPolynomConfig} from \"../random\";\r\nimport {Fraction} from \"../coefficients\";\r\n\r\n/**\r\n * Polynom class can handle polynoms, reorder, resolve, ...\r\n * ```\r\n * let P = new Polynom('3x-4')\r\n * ```\r\n */\r\nexport class Polynom {\r\n    private _rawString: string;\r\n    private _monoms: Monom[];\r\n    private _factors: Polynom[];\r\n    private _texString: string;\r\n\r\n    /**\r\n     *\r\n     * @param {string} polynomString (optional) Default polynom to parse on class creation\r\n     * @param values\r\n     */\r\n    constructor(polynomString?: string, ...values: unknown[]) {\r\n        this._monoms = [];\r\n        this._factors = [];\r\n        if (polynomString !== undefined) {\r\n            this.parse(polynomString, ...values);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get monoms() {\r\n        return this._monoms;\r\n    }\r\n\r\n    set monoms(M: Monom[]) {\r\n        this._monoms = M;\r\n    }\r\n\r\n    get factors(): Polynom[] {\r\n        return this._factors;\r\n    }\r\n\r\n    set factors(value: Polynom[]) {\r\n        this._factors = value;\r\n    }\r\n\r\n    get texFactors(): string {\r\n        this.factorize()\r\n\r\n        let tex = ''\r\n        for (let f of this.factors) {\r\n            if (f.monoms.length > 1) {\r\n                tex += `(${f.tex})`\r\n            } else {\r\n                tex = f.tex + tex;\r\n            }\r\n        }\r\n        return tex;\r\n    }\r\n\r\n    get texString(): string {\r\n        return this._texString;\r\n    }\r\n\r\n    get length() {\r\n        // TODO: Must reduce the monoms list to remove the zero coefficient.\r\n        return this._monoms.length;\r\n    }\r\n\r\n    get display(): string {\r\n        return this.genDisplay();\r\n    }\r\n\r\n    get raw(): string {\r\n        return this._rawString\r\n    }\r\n\r\n    get tex(): string {\r\n        return this.genDisplay('tex');\r\n    }\r\n\r\n    get isMultiVariable(): boolean {\r\n        const B = false;\r\n        for (const m of this._monoms) {\r\n            if (m.variables.length > 1) {\r\n                return true;\r\n            }\r\n        }\r\n        return B;\r\n    }\r\n\r\n    get variables(): string[] {\r\n        let V: string[] = [];\r\n\r\n        for (const m of this._monoms) {\r\n            V = V.concat(m.variables);\r\n        }\r\n\r\n        // Remove duplicates.\r\n        V = [...new Set(V)];\r\n\r\n        return V;\r\n    }\r\n\r\n    get numberOfVars(): number {\r\n        return this.variables.length;\r\n    }\r\n\r\n    private genDisplay = (output?: string, forceSign?: boolean, wrapParentheses?: boolean): string => {\r\n        let P: string = '';\r\n\r\n        for (const k of this._monoms) {\r\n            if (k.coefficient.value === 0) {\r\n                continue;\r\n            }\r\n\r\n            P += `${(k.coefficient.sign() === 1 && (P !== '' || forceSign === true)) ? '+' : ''}${(output === 'tex') ? k.tex : k.display}`;\r\n        }\r\n\r\n        if (wrapParentheses === true && this.length > 1) {\r\n            if (output === 'tex') {\r\n                P = `\\\\left( ${P} \\\\right)`;\r\n            } else {\r\n                P = `(${P})`;\r\n            }\r\n        }\r\n\r\n        if (P === '') {\r\n            P = '0';\r\n        }\r\n        return P;\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse a string to a polynom.\r\n     * @param inputStr\r\n     * @param values: as string, numbers or fractions\r\n     */\r\n    parse = (inputStr: string, ...values: unknown[]): Polynom => {\r\n\r\n        if (values === undefined || values.length === 0) {\r\n            inputStr = '' + inputStr;\r\n            this._rawString = inputStr;\r\n\r\n            // Parse the polynom using the shuting yard algorithm\r\n            if (inputStr !== '' && !isNaN(Number(inputStr))) {\r\n                this.empty();\r\n                // It's a simple number.\r\n                let m = new Monom(inputStr);\r\n                // m.coefficient = new Fraction(inputStr);\r\n                // m.literalStr = '';\r\n                this.add(m);\r\n                return this;\r\n            }\r\n\r\n            // Parse the string.\r\n            return this.shutingYardToReducedPolynom(inputStr);\r\n        } else if (/^[a-z]/.test(inputStr)) {\r\n            // We assume the inputStr contains only letters.\r\n            this.empty();\r\n\r\n            let fractions = values.map(x => new Fraction(x));\r\n            // Multiple setLetter version\r\n            if (inputStr.length > 1) {\r\n                // TODO: check that the number of values given correspond to the letters (+1 eventually)\r\n                let letters = inputStr.split(''),\r\n                    i = 0;\r\n                for (let F of fractions) {\r\n                    let m = new Monom();\r\n                    m.coefficient = F.clone();\r\n                    m.literalStr = letters[i] || '';\r\n                    this.add(m);\r\n                    i++;\r\n                }\r\n            }\r\n            // Single setLetter version\r\n            else {\r\n                let n = fractions.length - 1;\r\n                for (let F of fractions) {\r\n                    let m = new Monom()\r\n                    m.coefficient = F.clone();\r\n                    m.literalStr = `${inputStr}^${n}`\r\n                    this.add(m);\r\n                    n--;\r\n                }\r\n            }\r\n            return this;\r\n        } else {\r\n            return this.zero();\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * Main parse using a shutting yard class\r\n     * @param inputStr\r\n     */\r\n    private shutingYardToReducedPolynom = (inputStr: string): Polynom => {\r\n        // Get the RPN array of the current expression\r\n        const SY: Shutingyard = new Shutingyard().parse(inputStr);\r\n        const rpn: { token: string, tokenType: string }[] = SY.rpn;\r\n        let m1: Polynom;\r\n        let m2: Polynom;\r\n\r\n        let stack: Polynom[] = [],\r\n            previousToken: string = null,\r\n            tempPolynom\r\n\r\n        for (const element of rpn) {\r\n            if (element.tokenType === 'coefficient' || element.tokenType === 'variable') {\r\n                tempPolynom = new Polynom().zero();\r\n                tempPolynom.monoms = [new Monom(element.token)]\r\n                stack.push(tempPolynom.clone())\r\n            } else if (element.tokenType === 'operation') {\r\n                m2 = (stack.pop()) || new Polynom().zero();\r\n                m1 = (stack.pop()) || new Polynom().zero();\r\n                switch (element.token) {\r\n                    case '+':\r\n                        stack.push(m1.add(m2))\r\n                        break;\r\n                    case '-':\r\n                        stack.push(m1.subtract(m2))\r\n                        break;\r\n                    case '*':\r\n                        stack.push(m1.multiply(m2))\r\n                        break;\r\n                    case '^':\r\n                        stack.push(m1.pow(+previousToken))\r\n                }\r\n            }\r\n            previousToken = element.token;\r\n        }\r\n\r\n        this._monoms = stack[0].monoms;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clone the polynom\r\n     */\r\n    clone = (): Polynom => {\r\n        const P = new Polynom();\r\n        const M: Monom[] = [];\r\n\r\n        for (const m of this._monoms) {\r\n            M.push(m.clone());\r\n        }\r\n\r\n        P.monoms = M;\r\n        return P;\r\n    };\r\n\r\n    /**\r\n     * Set the polynom to zero.\r\n     * @returns {this}\r\n     */\r\n    zero = (): Polynom => {\r\n        this._monoms = [];\r\n        this._monoms.push(new Monom().zero());\r\n        this._rawString = '0';\r\n        return this;\r\n    };\r\n\r\n    one = (): Polynom => {\r\n        this._monoms = [];\r\n        this._monoms.push(new Monom().one());\r\n        this._rawString = '1';\r\n        return this;\r\n    }\r\n\r\n    empty = (): Polynom => {\r\n        this._monoms = [];\r\n        this._rawString = '';\r\n        return this;\r\n    };\r\n\r\n    // // -----------------------------------------------\r\n    // // Polynom generators and randomizers\r\n    // // -----------------------------------------------\r\n    // random(config?: randomPolynomConfig) {\r\n    //     return Random.polynom(config);\r\n    // }\r\n    //\r\n    // private _randomizeDefaults: { [key: string]: number | string | boolean } = {\r\n    //     degree: 2,\r\n    //     unit: true,\r\n    //     fractions: false,\r\n    //     factorable: false,\r\n    //     letters: 'x',\r\n    //     allowNullMonom: false,\r\n    //     numberOfMonoms: false\r\n    // };\r\n    // get randomizeDefaults(): { [key: string]: number | string | boolean } {\r\n    //     return this._randomizeDefaults;\r\n    // }\r\n    //\r\n    // set randomizeDefaults(value) {\r\n    //     this._randomizeDefaults = value;\r\n    // }\r\n    //\r\n    // randomize = (config: { [key: string]: number | string | boolean }): Polynom => {\r\n    //     let P = new Polynom();\r\n    //\r\n    //     // Check the config file and use the default values.\r\n    //     if (config === undefined) {\r\n    //         config = {};\r\n    //     }\r\n    //     for (let k in this._randomizeDefaults) {\r\n    //         if (config[k] === undefined) {\r\n    //             config[k] = this._randomizeDefaults[k];\r\n    //         }\r\n    //     }\r\n    //\r\n    //     // TODO: Build a more robust randomize function\r\n    //     return P;\r\n    // }\r\n    //\r\n    // rndFactorable = (degree: number = 2, unit: boolean | number = false, letters: string = 'x'): Polynom => {\r\n    //     // TODO: Make rndFactorable polynom generator more user friendly\r\n    //     this._factors = [];\r\n    //     for (let i = 0; i < degree; i++) {\r\n    //         let factorUnit = unit === true || i >= unit,\r\n    //             p = Random.polynom({\r\n    //                 degree: 1,\r\n    //                 unit: factorUnit,\r\n    //                 fraction: false,\r\n    //                 letters\r\n    //             });\r\n    //         this._factors.push(p);\r\n    //     }\r\n    //\r\n    //     this.empty().monoms = this._factors[0].monoms;\r\n    //     for (let i = 1; i < this._factors.length; i++) {\r\n    //         this.multiply(this._factors[i]);\r\n    //     }\r\n    //     return this;\r\n    // };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    opposed = (): Polynom => {\r\n        this._monoms = this._monoms.map(m => m.opposed());\r\n        return this;\r\n    };\r\n\r\n    add = (...values: unknown[]): Polynom => {\r\n\r\n        for (let value of values) {\r\n            if (value instanceof Polynom) {\r\n                this._monoms = this._monoms.concat(value.monoms);\r\n            } else if (value instanceof Monom) {\r\n                this._monoms.push(value.clone());\r\n            } else if (Number.isSafeInteger(value)) {\r\n                this._monoms.push(new Monom(value.toString()));\r\n            } else {\r\n                this._monoms.push(new Monom(value));\r\n            }\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    subtract = (...values: unknown[]): Polynom => {\r\n\r\n        for (let value of values) {\r\n            if (value instanceof Polynom) {\r\n                this._monoms = this._monoms.concat(value.clone().opposed().monoms);\r\n            } else if (value instanceof Monom) {\r\n                this._monoms.push(value.clone().opposed());\r\n            } else if (Number.isSafeInteger(value)) {\r\n                this._monoms.push(new Monom(value.toString()).opposed());\r\n            } else {\r\n                this._monoms.push(new Monom(value).opposed());\r\n            }\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    multiply = (value: unknown): Polynom => {\r\n        if (value instanceof Polynom) {\r\n            return this.multiplyByPolynom(value);\r\n        } else if (value instanceof Fraction) {\r\n            return this.multiplyByFraction(value);\r\n        } else if (value instanceof Monom) {\r\n            return this.multiplyByMonom(value);\r\n        } else if (Number.isSafeInteger(value) && typeof value==='number') {\r\n            return this.multiplyByInteger(value);\r\n        }\r\n\r\n        // Something went wrong...\r\n        return this;\r\n    }\r\n\r\n    private multiplyByPolynom = (P: Polynom): Polynom => {\r\n        const M: Monom[] = [];\r\n        for (const m1 of this._monoms) {\r\n            for (const m2 of P.monoms) {\r\n                M.push(Monom.xmultiply(m1, m2));\r\n            }\r\n        }\r\n\r\n        this._monoms = M;\r\n        return this.reduce();\r\n    };\r\n\r\n    private multiplyByFraction = (F: Fraction): Polynom => {\r\n        for (const m of this._monoms) {\r\n            m.coefficient.multiply(F);\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    private multiplyByInteger = (nb: number): Polynom => {\r\n        return this.multiplyByFraction(new Fraction(nb));\r\n    };\r\n\r\n    private multiplyByMonom = (M: Monom): Polynom => {\r\n        for (const m of this._monoms) {\r\n            m.multiply(M)\r\n        }\r\n        return this.reduce();\r\n    };\r\n\r\n    /**\r\n     * Divide the current polynom by another polynom.\r\n     * @param P\r\n     * returns {quotient: Polynom, reminder: Polynom}\r\n     */\r\n    euclidian = (P: Polynom): { quotient: Polynom, reminder: Polynom } => {\r\n        const letter: string = P.variables[0];\r\n        const quotient: Polynom = new Polynom().zero();\r\n        const reminder: Polynom = this.clone().reorder(letter);\r\n\r\n        // There is no variable !\r\n        if (P.variables.length === 0) {\r\n            return {quotient, reminder}\r\n        }\r\n\r\n        // Get at least a letter\r\n\r\n        const maxMP: Monom = P.monomByDegree(undefined, letter);\r\n        const degreeP: Fraction = P.degree(letter);\r\n\r\n        let newM: Monom;\r\n\r\n        // Make the euclidian division of the two polynoms.\r\n        let MaxIteration = this.degree(letter).clone().multiply(2);\r\n        while (reminder.degree(letter).geq(degreeP) && MaxIteration.isPositive()) {\r\n            MaxIteration.subtract(1)\r\n\r\n            // Get the greatest monom divided by the max monom of the divider\r\n            newM = reminder.monomByDegree(undefined, letter).clone().divide(maxMP);\r\n\r\n            if (newM.isZero()) {\r\n                break;\r\n            }\r\n\r\n            // Get the new quotient and reminder.\r\n            quotient.add(newM);\r\n            reminder.subtract(P.clone().multiply(newM));\r\n        }\r\n\r\n        return {quotient, reminder};\r\n    };\r\n\r\n    divide = (value: unknown): Polynom => {\r\n        if (value instanceof Fraction) {\r\n            this.divideByFraction(value);\r\n        } else if (typeof value==='number' && Number.isSafeInteger(value)) {\r\n            return this.divideByInteger(value);\r\n        }\r\n    }\r\n\r\n    private divideByInteger = (nb: number): Polynom => {\r\n        const nbF = new Fraction(nb);\r\n        for (const m of this._monoms) {\r\n            m.coefficient.divide(nbF);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    private divideByFraction = (F: Fraction): Polynom => {\r\n        for (const m of this._monoms) {\r\n            m.coefficient.divide(F);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    pow = (nb: number): Polynom => {\r\n        if (!Number.isSafeInteger(nb)) {\r\n            return this.zero();\r\n        }\r\n        if (nb < 0) {\r\n            return this.zero();\r\n        }\r\n        if (nb === 0) {\r\n            return new Polynom();\r\n        }\r\n\r\n        const P = this.clone();\r\n        for (let i = 1; i < nb; i++) {\r\n            this.multiply(P);\r\n        }\r\n        return this.reduce();\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Compare the current coefficient with another coefficient\r\n     * @param P\r\n     * @param sign (string| default is =): authorized values: =, <, <=, >, >= with some variations.\r\n     */\r\n    compare = (P: Polynom, sign?: string): boolean => {\r\n        if (sign === undefined) {\r\n            sign = '='\r\n        }\r\n\r\n        // Create clone version to reduce them without altering the original polynoms.\r\n        const cP1 = this.clone().reduce().reorder();\r\n        const cP2 = P.clone().reduce().reorder();\r\n\r\n        switch (sign) {\r\n            case '=':\r\n                // They must have the isSame length and the isSame degree\r\n                if (cP1.length !== cP2.length || cP1.degree().isNotEqual(cP2.degree())) {\r\n                    return false;\r\n                }\r\n\r\n                // Check if the coefficients are the isSame.\r\n                for (const i in cP1.monoms) {\r\n                    if (!cP1.monoms[i].isEqual(cP2.monoms[i])) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            case 'same':\r\n                // They must have the isSame length and the isSame degree\r\n                if (cP1.length !== cP2.length || cP1.degree() !== cP2.degree()) {\r\n                    return false;\r\n                }\r\n\r\n                for (const i in cP1.monoms) {\r\n                    if (!cP1.monoms[i].isSameAs(cP2.monoms[i])) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n\r\n    isZero(): boolean {\r\n        return (this._monoms.length === 1 && this._monoms[0].coefficient.isZero()) || this._monoms.length === 0;\r\n    }\r\n\r\n    isOne(): boolean {\r\n        return this._monoms.length === 1 && this._monoms[0].coefficient.isOne();\r\n    }\r\n\r\n    isEqual = (P: Polynom): boolean => {\r\n        return this.compare(P, '=');\r\n    };\r\n\r\n    isSameAs = (P: Polynom): boolean => {\r\n        return this.compare(P, 'same');\r\n    };\r\n\r\n    isOpposedAt = (P: Polynom): boolean => {\r\n        return this.compare(P.clone().opposed(), '=');\r\n    };\r\n\r\n    isFactorized = (polynomString: string): boolean => {\r\n        let P;\r\n\r\n        // Check if polynom is complete...\r\n        if (polynomString.match(/\\(/g).length !== polynomString.match(/\\)/g).length) {\r\n            return false\r\n        }\r\n\r\n        // Try to build the polynom\r\n        try {\r\n            P = new Polynom(polynomString);\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n\r\n        // Both polynom aren't the same (once developed and reduced => they cannot be equivalent)\r\n        if (!this.isEqual(P)) {\r\n            return false;\r\n        }\r\n\r\n        // Check if the provided (string) version is fully factorized.\r\n        // Run a regex on the string.\r\n        let polynomStringNormalized = polynomString.replaceAll('*', ''),\r\n            polynomStringReduced = '' + polynomStringNormalized,\r\n            factors: string[] = [];\r\n\r\n        for (let x of polynomStringNormalized.matchAll(/\\(([a-z0-9+\\-]+)\\)(\\^[0-9]*)?/g)) {\r\n            if (x[2] !== undefined) {\r\n                for (let i = 0; i < +x[2].substr(1); i++) {\r\n                    factors.push(x[1])\r\n                }\r\n            } else {\r\n                factors.push(x[1]);\r\n            }\r\n            polynomStringReduced = polynomStringReduced.replaceAll(x[0], '');\r\n        }\r\n        if (polynomStringReduced !== '') {\r\n            factors.push(polynomStringReduced);\r\n        }\r\n        let polyFactors = factors.map(x => new Polynom(x));\r\n\r\n        // Factorize the current polynom.\r\n        this.factorize();\r\n\r\n        // Compare the given factors with the generated factors\r\n        let sign = 1;\r\n        for (let f of this.factors) {\r\n            for (let i = 0; i < polyFactors.length; i++) {\r\n                if (f.isEqual(polyFactors[i])) {\r\n                    polyFactors.splice(i, 1);\r\n                    break;\r\n                } else if (f.isOpposedAt(polyFactors[i])) {\r\n                    polyFactors.splice(i, 1);\r\n                    sign = -sign;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // The polyfactors must be empty and the cumulative opposite factors must be 1.\r\n        return (polyFactors.length === 0 && sign === 1);\r\n    }\r\n\r\n    isDeveloped = (polynomString: string): Boolean => {\r\n        let P: Polynom;\r\n\r\n        // There is at least one parenthese - it is not developed.\r\n        if (polynomString.match(/\\(/g).length + polynomString.match(/\\)/g).length) {\r\n            return false\r\n        }\r\n\r\n        // Try to build the polynom\r\n        try {\r\n            // Build the polynom\r\n            P = new Polynom(polynomString);\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n\r\n        // Both polynom aren't the same (once developed and reduced => they cannot be equivalent)\r\n        if (!this.isEqual(P)) {\r\n            return false;\r\n        }\r\n\r\n        // Check that everything is completely developed. Actually, there are no parentheses... so it is fully developed\r\n\r\n        // maybe it wasn't reduced and not ordered...\r\n        // compare polynom string.\r\n\r\n        // normalize the string\r\n        let polynomStringNormalized = polynomString.replaceAll('[*\\s]', '')\r\n\r\n        // Determine if it's the exact same string.\r\n        // TODO: Maybe it's enough to just make this test !\r\n        return polynomStringNormalized === P.reduce().reorder().display\r\n    }\r\n    // ------------------------------------------\r\n    // Misc polynoms functions\r\n    // -------------------------------------\r\n    reduce = (): Polynom => {\r\n        for (let i = 0; i < this._monoms.length; i++) {\r\n            for (let j = i + 1; j < this._monoms.length; j++) {\r\n                if (this._monoms[i].isSameAs(this.monoms[j])) {\r\n                    this._monoms[i].add(this.monoms[j]);\r\n                    this._monoms.splice(j, 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Remove all null monoms\r\n        this._monoms = this._monoms.filter((m) => {\r\n            return m.coefficient.value !== 0\r\n        });\r\n\r\n        // Reduce all monoms coefficient.\r\n        for (const m of this._monoms) {\r\n            m.coefficient.reduce();\r\n        }\r\n\r\n        if (this.length === 0) {\r\n            return new Polynom().zero();\r\n        }\r\n        return this;\r\n    };\r\n\r\n    reorder = (letter: string = 'x'): Polynom => {\r\n        // TODO: Must handle multiple setLetter reorder system\r\n        this._monoms.sort(function (a, b) {\r\n            return b.degree(letter).clone().subtract(a.degree(letter)).value\r\n        });\r\n        return this.reduce();\r\n    };\r\n\r\n    degree = (letter?: string): Fraction => {\r\n        let d: Fraction = new Fraction().zero();\r\n        for (const m of this._monoms) {\r\n            d = Fraction.max(m.degree(letter).value, d);\r\n        }\r\n        return d;\r\n    };\r\n\r\n    letters = (): string[] => {\r\n        let L: string[] = [], S = new Set();\r\n\r\n        for (let m of this._monoms) {\r\n            S = new Set([...S, ...m.variables]);\r\n        }\r\n\r\n        // @ts-ignore\r\n        return [...S];\r\n    }\r\n\r\n    /**\r\n     * Replace a variable (letter) by a polynom.\r\n     * @param letter\r\n     * @param P\r\n     */\r\n    replaceBy = (letter: string, P: Polynom): Polynom => {\r\n        let pow: Fraction;\r\n        const resultPolynom: Polynom = new Polynom().zero();\r\n\r\n        for (const m of this.monoms) {\r\n            if (m.literal[letter] === undefined || m.literal[letter].isZero()) {\r\n                resultPolynom.add(m.clone());\r\n            } else {\r\n                // We have found a setLetter.\r\n                // Get the power and reset it.\r\n                pow = m.literal[letter].clone();\r\n                delete m.literal[letter];\r\n\r\n                // TODO: replaceBy works only with positive and natural pow\r\n                resultPolynom.add(P.clone().pow(Math.abs(pow.numerator)).multiply(m));\r\n            }\r\n        }\r\n\r\n        this._monoms = resultPolynom.reduce().reorder().monoms;\r\n        return this;\r\n    };\r\n\r\n    // Evaluate a polynom.\r\n    evaluate = (values: literalType | Fraction | number): Fraction => {\r\n        const r = new Fraction().zero();\r\n\r\n        this._monoms.forEach(monom => {\r\n            //console.log('Evaluate polynom: ', monom.display, values, monom.evaluate(values).display);\r\n            r.add(monom.evaluate(values));\r\n        });\r\n        return r;\r\n    };\r\n\r\n    derivative = (letter?: string): Polynom => {\r\n        let dP = new Polynom();\r\n\r\n        for (let m of this._monoms) {\r\n            dP.add(m.derivative(letter));\r\n        }\r\n        return dP;\r\n\r\n    }\r\n\r\n    primitive = (letter?: string): Polynom => {\r\n        let dP = new Polynom();\r\n\r\n        for (let m of this._monoms) {\r\n            dP.add(m.primitive(letter))\r\n        }\r\n        return dP\r\n    }\r\n\r\n    integrate = (a: Fraction | number, b: Fraction | number, letter?: string): Fraction => {\r\n        const primitive = this.primitive(letter)\r\n\r\n        if (letter === undefined) {\r\n            letter = 'x'\r\n        }\r\n\r\n        let valuesA: literalType = {},\r\n            valuesB: literalType = {}\r\n        valuesA[letter] = new Fraction(a);\r\n        valuesB[letter] = new Fraction(b);\r\n\r\n        return primitive.evaluate(valuesB).subtract(primitive.evaluate(valuesA))\r\n    }\r\n    // ------------------------------------------\r\n    // Polynoms factorization functions\r\n    // -------------------------------------\r\n    /**\r\n     * Factorize a polynom and store the best results in factors.\r\n     * @param maxValue Defines the greatest value to search to (default is 20).\r\n     */\r\n    factorize = (letter?: string): Polynom[] => {\r\n        let factors: Polynom[] = [];\r\n\r\n        // Extract the common monom\r\n        let P = this.clone().reorder(),\r\n            M = P.commonMonom(),\r\n            tempPolynom: Polynom\r\n        // It has a common monom.\r\n        if (!M.isOne()) {\r\n            tempPolynom = new Polynom()\r\n            tempPolynom.monoms = [M]\r\n            factors = [tempPolynom.clone()]\r\n            P = P.euclidian(tempPolynom).quotient;\r\n        }\r\n\r\n        let securityLoop = P.degree().clone().multiply(2).value\r\n        // securityLoop = 0\r\n        while (securityLoop >= 0) {\r\n            securityLoop--\r\n\r\n\r\n            if (P.monoms.length < 2) {\r\n                if (!P.isOne()) {\r\n                    factors.push(P.clone());\r\n                }\r\n                break;\r\n            } else {\r\n                // Get the first and last monom.\r\n                let m1 = P.monoms[0].dividers,\r\n                    m2 = P.monoms[P.monoms.length - 1].dividers\r\n\r\n                // console.log('CURRENT VALUE')\r\n                // console.log(P.tex)\r\n                // console.log('---------------------')\r\n                for (let m1d of m1) {\r\n                    for (let m2d of m2) {\r\n                        // if(m1d.degree()===m2d.degree()){continue}\r\n                        let dividerPolynom = new Polynom(),\r\n                            result\r\n                        dividerPolynom.monoms = [m1d.clone(), m2d.clone()]\r\n                        result = P.euclidian(dividerPolynom)\r\n\r\n                        // console.log(dividerPolynom.tex, '=>', result.reminder.tex, '|||||', result.quotient.tex)\r\n                        if (result.reminder.isZero()) {\r\n                            P = result.quotient.clone();\r\n                            factors.push(dividerPolynom)\r\n                            continue;\r\n                        }\r\n\r\n                        dividerPolynom.monoms = [m1d.clone(), m2d.clone().opposed()]\r\n                        result = P.euclidian(dividerPolynom)\r\n                        if (result.reminder.isZero()) {\r\n                            P = result.quotient.clone();\r\n                            factors.push(dividerPolynom)\r\n                        }\r\n                        // console.log(dividerPolynom.tex, '=>', result.reminder.tex)\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        this.factors = factors\r\n        return factors;\r\n    }\r\n\r\n    private _factorize2ndDegree = (letter: string): Polynom[] => {\r\n        let P1: Polynom, P2: Polynom,\r\n            a, b, c, delta, x1, x2, factor;\r\n\r\n        // One variable only\r\n        if (this.numberOfVars === 1) {\r\n            a = this.monomByDegree(2, letter).coefficient;\r\n            b = this.monomByDegree(1, letter).coefficient;\r\n            c = this.monomByDegree(0, letter).coefficient;\r\n            delta = b.clone().pow(2).subtract(a.clone().multiply(c).multiply(4));\r\n\r\n            if (delta.isZero()) {\r\n                x1 = b.clone().opposed().divide(a.clone().multiply(2))\r\n                P1 = new Polynom(letter).subtract(x1.display).multiply(x1.denominator)\r\n                P2 = new Polynom(letter).subtract(x1.display).multiply(x1.denominator)\r\n                factor = a.divide(x1.denominator).divide(x1.denominator);\r\n\r\n                if (!factor.isOne()) {\r\n                    // TODO: Update new Polynom to accept anything...\r\n                    return [new Polynom(factor.display), P1, P2]\r\n                } else {\r\n                    return [P1, P2]\r\n                }\r\n            } else if (delta.isPositive() && delta.isSquare()) {\r\n                x1 = b.clone().opposed()\r\n                    .add(delta.clone().sqrt())\r\n                    .divide(a.clone().multiply(2))\r\n                x2 = b.clone().opposed()\r\n                    .subtract(delta.clone().sqrt())\r\n                    .divide(a.clone().multiply(2))\r\n\r\n                // (2x+5)(3x-2)\r\n                // 6x^2+11x-10\r\n                // a = 6, b = 11, c = -10\r\n                // delta = 121-4*6*(-10) = 361= 19^2\r\n                // x1 = (-11 + 19)  / 12 = 8/12 = 2/3\r\n                // x2 = (-11 - 19)  / 12 = -30/12 = -5/2\r\n                factor = a.divide(x1.denominator).divide(x2.denominator);\r\n                if (factor.isOne()) {\r\n                    return [\r\n                        new Polynom(letter).subtract(x1.display).multiply(x1.denominator),\r\n                        new Polynom(letter).subtract(x2.display).multiply(x2.denominator),\r\n                    ]\r\n                } else {\r\n                    return [\r\n                        new Polynom(factor.display),\r\n                        new Polynom(letter).subtract(x1.display).multiply(x1.denominator),\r\n                        new Polynom(letter).subtract(x2.display).multiply(x2.denominator),\r\n                    ]\r\n\r\n                }\r\n            } else {\r\n                // No solution possible - return the complete value.\r\n                return [this.clone()]\r\n            }\r\n        } else {\r\n            // If multiple variables, only handle perfect squares...\r\n            a = this.monomByDegree(2, letter);\r\n            b = this.monomByDegree(1, letter);\r\n            c = this.monomByDegree(0, letter);\r\n\r\n\r\n            if (a.isLiteralSquare() && c.isLiteralSquare()) {\r\n                // Check the middle item is same as...\r\n                if (b.clone().pow(2).isSameAs(a.clone().multiply(c))) {\r\n                    // Determine if the coefficient values matches.\r\n\r\n                    // Search 4 values (r, s, t, u) that matches:\r\n                    // (r X + s Y)(t X + u Y) = rt X^2 + (ru + st) XY + su Y^2\r\n\r\n                    let xPolynom = new Polynom('x', a.coefficient, b.coefficient, c.coefficient);\r\n                    let xFactors = xPolynom._factorize2ndDegree('x');\r\n\r\n                    let factors = [], xyzPolynom: Polynom;\r\n\r\n                    if (xFactors.length >= 2) {\r\n                        for (let p of xFactors) {\r\n                            if (p.degree().isZero()) {\r\n                                factors.push(p.clone())\r\n                            } else {\r\n                                xyzPolynom = p.clone();\r\n                                xyzPolynom.monoms[0].literal = a.literalSqrt\r\n                                xyzPolynom.monoms[1].literal = c.literalSqrt\r\n                                factors.push(xyzPolynom.clone())\r\n                            }\r\n                        }\r\n                        return factors\r\n                    }\r\n                }\r\n            }\r\n\r\n            return [this.clone()]\r\n            //\r\n            // console.log(a.tex, b.tex, c.tex)\r\n            // if (a.isSquare() && c.isSquare()) {\r\n            //     console.log('A C squares')\r\n            //     if (a.clone().sqrt().multiply(c.clone().sqrt()).multiplyByNumber(2).isSameAs(b)) {\r\n            //         console.log('HERE')\r\n            //         if (a.coefficient.sign() === b.coefficient.sign()) {\r\n            //             return []\r\n            //         }else{\r\n            //             return []\r\n            //         }\r\n            //     }\r\n            // } else if(a.isLiteralSquare() && c.isLiteralSquare()) {\r\n            //     console.log('A C litteral SQUARES')\r\n            //     // Check that the middle element is the product of a and c.\r\n            //\r\n            //     if(b.clone().pow(2).isSameAs(a.clone().multiply(c))){\r\n            //         console.log('SAME')\r\n            //\r\n            //     }else{\r\n            //         console.log('NOT SAME')\r\n            //     }\r\n            //\r\n            //     return [this.clone()]\r\n            // } else {\r\n            //     console.log('NOT SQUARES AT ALL !!!!')\r\n            // }\r\n\r\n        }\r\n    }\r\n\r\n    private _factorizeByGroups = (): Polynom[] => {\r\n        // TODO: Factorize by groups.\r\n        return [];\r\n    }\r\n    // ------------------------------------------\r\n    // Polynoms helpers functions\r\n    // -------------------------------------\r\n    // TODO: get zeroes for more than first degree and for more than natural degrees\r\n    getZeroes = (): (Fraction | boolean)[] => {\r\n        const Z: Fraction[] = [];\r\n\r\n        switch (this.degree().value) {\r\n            case 0:\r\n                if (this._monoms[0].coefficient.value === 0) {\r\n                    return [true];\r\n                } else {\r\n                    return [false];\r\n                }\r\n            case 1:\r\n                // There is only one monoms,\r\n                if (this._monoms.length === 1) {\r\n                    return [new Fraction().zero()];\r\n                } else {\r\n                    const P = this.clone().reduce().reorder();\r\n                    return [P.monoms[1].coefficient.opposed().divide(P.monoms[0].coefficient)];\r\n                }\r\n            // TODO: Determine the zeros of an equation of second degree.\r\n            //case 2:\r\n            default:\r\n                // Make sure the polynom is factorized.\r\n                if (this._factors.length === 0) {\r\n                    this.factorize()\r\n                }\r\n\r\n                let zeroes = [], zeroesAsTex = [];\r\n                for (let P of this._factors) {\r\n                    if (P.degree().greater(2)) {\r\n                        // TODO: Handle other polynom.\r\n\r\n                    } else if (P.degree().value === 2) {\r\n                        let A = P.monomByDegree(2).coefficient,\r\n                            B = P.monomByDegree(1).coefficient,\r\n                            C = P.monomByDegree(0).coefficient,\r\n                            D = B.clone().pow(2).subtract(A.clone().multiply(C).multiply(4));\r\n\r\n                        if (D.value > 0) {\r\n                            /*console.log('Two zeroes for ', P.tex); */\r\n                            let x1 = (-(B.value) + Math.sqrt(D.value)) / (2 * A.value),\r\n                                x2 = (-(B.value) - Math.sqrt(D.value)) / (2 * A.value);\r\n\r\n                            zeroes.push(new Fraction(x1.toFixed(3)).reduce());\r\n                            zeroes.push(new Fraction(x2.toFixed(3)).reduce());\r\n                        } else if (D.value === 0) {\r\n                            /*console.log('One zero for ', P.tex); */\r\n\r\n                        } else {\r\n                            console.log('No zero for ', P.tex);\r\n                        }\r\n                    } else {\r\n                        for (let z of P.getZeroes()) {\r\n                            // Check if the zero is already in the list.\r\n                            if (z === false || z === true) {\r\n                                continue;\r\n                            }\r\n                            if (zeroesAsTex.indexOf(z.frac) === -1) {\r\n                                zeroes.push(z);\r\n                                zeroesAsTex.push(z.frac);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return zeroes;\r\n        }\r\n        return Z;\r\n    };\r\n\r\n\r\n    // TODO: analyse the next functions to determine if they are useful or not...\r\n    monomByDegree = (degree?: Fraction|number, letter?: string): Monom => {\r\n        if (degree === undefined) {\r\n            // return the highest degree monom.\r\n            return this.monomByDegree(this.degree(letter), letter);\r\n        }\r\n\r\n        // Reduce the polynom.\r\n        const M = this.clone().reduce();\r\n        for (const m of M._monoms) {\r\n            if (m.degree(letter).isEqual(degree)) {\r\n                return m.clone();\r\n            }\r\n        }\r\n\r\n        // Nothing was found - return the null monom.\r\n        return new Monom().zero();\r\n    };\r\n\r\n    monomsByDegree = (degree?: number|Fraction, letter?: string): Monom[] => {\r\n        if (degree === undefined) {\r\n            // return the highest degree monom.\r\n            return this.monomsByDegree(this.degree(letter));\r\n        }\r\n\r\n        // Reduce the polynom.\r\n        let Ms: Monom[] = [];\r\n\r\n        const M = this.clone().reduce();\r\n        for (const m of M._monoms) {\r\n            if (m.degree(letter) === degree) {\r\n                Ms.push(m.clone())\r\n            }\r\n        }\r\n\r\n        return Ms\r\n        // Nothing was found - retur\r\n    }\r\n\r\n    // Used in LinearSystem.tex\r\n    monomByLetter = (letter: string): Monom => {\r\n        const M = this.clone().reduce();\r\n        for (const m of M._monoms) {\r\n            if (m.hasLetter(letter)) {\r\n                return m.clone();\r\n            }\r\n        }\r\n\r\n        return new Monom().zero();\r\n    };\r\n\r\n\r\n    // Next functions are used for for commonMonom, which is used in the factorize method.\r\n    getDenominators = (): number[] => {\r\n        const denominators: number[] = [];\r\n        for (const m of this._monoms) {\r\n            denominators.push(m.coefficient.denominator);\r\n        }\r\n        return denominators;\r\n    };\r\n\r\n    getNumerators = (): number[] => {\r\n        const numerators: number[] = [];\r\n        for (const m of this._monoms) {\r\n            numerators.push(m.coefficient.numerator);\r\n        }\r\n        return numerators;\r\n    };\r\n\r\n    lcmDenominator = (): number => {\r\n        return Numeric.lcm(...this.getDenominators());\r\n    };\r\n\r\n    gcdDenominator = (): number => {\r\n        return Numeric.gcd(...this.getDenominators());\r\n    };\r\n\r\n    lcmNumerator = (): number => {\r\n        return Numeric.lcm(...this.getNumerators());\r\n    };\r\n\r\n    gcdNumerator = (): number => {\r\n        return Numeric.gcd(...this.getNumerators());\r\n    };\r\n\r\n    commonMonom = (): Monom => {\r\n        let M = new Monom().one(), numerator: number, denominator: number, degree = this.degree();\r\n\r\n        numerator = this.gcdNumerator();\r\n        denominator = this.gcdDenominator();\r\n\r\n        M.coefficient = new Fraction(numerator, denominator);\r\n        for (let L of this.variables) {\r\n            // Initialize the setLetter with the max degree\r\n            M.setLetter(L, degree);\r\n            for (let m of this._monoms) {\r\n                M.setLetter(L, Fraction.min(m.degree(L), M.degree(L)));\r\n                if (M.degree(L).isZero()) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return M;\r\n    }\r\n}\r\n","/**\r\n * Rational polynom module contains everything necessary to handle rational polynoms.\r\n * @module Polynom\r\n */\r\n\r\nimport {Polynom} from \"./polynom\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\n/**\r\n * Rational class can handle rational polynoms\r\n */\r\n    export class Rational {\r\n        private _rawString: string;\r\n        private _numerator: Polynom;\r\n        private _denominator: Polynom;\r\n\r\n        /**\r\n         *\r\n         * @param numerator\r\n         * @param denominator\r\n         */\r\n        constructor(numerator?: Polynom, denominator?: Polynom) {\r\n            this._numerator = numerator ? numerator.clone() : new Polynom();\r\n            this._denominator = denominator ? denominator.clone() : new Polynom();\r\n        }\r\n\r\n        clone = (): Rational => {\r\n            this._numerator = this._numerator.clone()\r\n            this._denominator = this._denominator.clone()\r\n\r\n            return this;\r\n        }\r\n\r\n        get tex(): string {\r\n            return `\\\\dfrac{ ${this._numerator.tex} }{ ${this._denominator.tex} }`;\r\n        }\r\n\r\n        get texFactors(): string {\r\n            this._numerator.factorize()\r\n            this._denominator.factorize()\r\n\r\n            return `\\\\dfrac{ ${this._numerator.texFactors} }{ ${this._denominator.texFactors} }`\r\n        }\r\n\r\n        get numerator(): Polynom {\r\n            return this._numerator\r\n        }\r\n\r\n        get denominator(): Polynom {\r\n            return this._denominator\r\n        }\r\n\r\n        domain = (): string => {\r\n            let zeroes = this._denominator.getZeroes();\r\n            if (zeroes.length === 0 || zeroes[0] === false) {\r\n                return '\\\\mathbb{R}'\r\n            } else if (zeroes[0] === true) {\r\n                return '\\\\varnothing'\r\n            } else {\r\n                return '\\\\mathbb{R}\\\\setminus\\\\left{' +\r\n                    zeroes.map(x => {\r\n                        return (typeof x === 'boolean') ? '' : x.frac\r\n                    })\r\n                        .join(';') + '\\\\right}'\r\n            }\r\n        }\r\n\r\n        amplify = (P: Polynom): Rational => {\r\n            this._numerator.multiply(P);\r\n            this._denominator.multiply(P);\r\n\r\n            return this;\r\n        }\r\n\r\n        simplify = (P: Polynom): Rational => {\r\n            let NumeratorEuclidien = this._numerator.euclidian(P);\r\n            if (!NumeratorEuclidien.reminder.isZero()) {\r\n                return this;\r\n            }\r\n\r\n            let DenominatorEuclidien = this._denominator.euclidian(P);\r\n            if (!DenominatorEuclidien.reminder.isZero()) {\r\n                return this;\r\n            }\r\n\r\n            this._numerator = NumeratorEuclidien.quotient;\r\n            this._denominator = DenominatorEuclidien.quotient;\r\n            return this;\r\n        }\r\n\r\n        reduce = (): Rational => {\r\n            console.log(this._numerator.tex)\r\n            this._numerator.factorize();\r\n            console.log(this._numerator.factors.map(x => x.tex))\r\n            for (let f of this._numerator.factors) {\r\n                this.simplify(f);\r\n            }\r\n\r\n            return this;\r\n        }\r\n\r\n        opposed = (): Rational => {\r\n            this._numerator.opposed();\r\n            return this;\r\n        }\r\n        add = (R: Rational): Rational => {\r\n            // 1. Make sure both rational are at the same denominator\r\n            // 2. Add the numerators.\r\n            // 3. Simplify\r\n\r\n            // Store the adding denominator\r\n            let denominator = this._denominator.clone()\r\n\r\n            // Amplif the main rational polynom by the adding denominator\r\n            this.amplify(R._denominator)\r\n\r\n            // Add to the numerator the adding value...\r\n            this._numerator.add(R._numerator.clone().multiply(denominator));\r\n\r\n            return this;\r\n        }\r\n\r\n        subtract = (R: Rational): Rational => {\r\n            return this.add(R.clone().opposed())\r\n        }\r\n\r\n        limits = (value: Fraction | number, letter?: string): Fraction | number => {\r\n            if (value === Infinity || value === -Infinity) {\r\n                let N = this._numerator.monomByDegree(this._numerator.degree(letter), letter),\r\n                    D = this._denominator.monomByDegree(this._denominator.degree(letter), letter)\r\n\r\n                N.divide(D)\r\n\r\n                if (N.degree(letter).isStrictlyPositive()) {\r\n                    return N.coefficient.sign() * (Math.pow((value > 0 ? 1 : -1), N.degree(letter).value % 2)) === 1 ? Infinity : -Infinity\r\n                }\r\n                if (N.degree(letter).isZero()) {\r\n                    return N.coefficient\r\n                }\r\n                if (N.degree(letter).isStrictlyPositive()) {\r\n                    return N.coefficient.sign() * (Math.pow(-1, N.degree(letter).value % 2)) === 1 ? 0 : -0\r\n                }\r\n            } else {\r\n                return this._numerator.evaluate({letter: new Fraction(value)}).divide(this._denominator.evaluate({letter: new Fraction(value)}))\r\n            }\r\n        }\r\n    }\r\n","import {Numeric} from \"../numeric\";\r\n\r\n/**\r\n * The fraction class make possible to handle\r\n * TODO: Write the documentation correctly.\r\n * \\\\(\\frac{a}{b}\\\\) or \\\\[\\frac{a}{b}\\\\]  values.\r\n */\r\nexport class Fraction {\r\n    private _numerator: number;\r\n    private _denominator: number;\r\n\r\n    constructor(value?: unknown, denominatorOrPeriodic?: number) {\r\n        this._numerator = 1;\r\n        this._denominator = 1;\r\n\r\n        if (value !== undefined) {\r\n            this.parse(value, denominatorOrPeriodic);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    get isFraction() {\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n\r\n    get numerator(): number {\r\n        return this._numerator;\r\n    }\r\n\r\n    set numerator(value: number) {\r\n        this._numerator = value;\r\n    }\r\n\r\n    get denominator(): number {\r\n        return this._denominator;\r\n    }\r\n\r\n    set denominator(value: number) {\r\n        this._denominator = value;\r\n    }\r\n\r\n    get value(): number {\r\n        return this._numerator / this._denominator;\r\n    }\r\n\r\n    // Display getter\r\n    get tex(): string {\r\n        if (this._denominator === 1) {\r\n            return `${this._numerator}`;\r\n        } else if (this._numerator < 0) {\r\n            return `-\\\\frac{ ${-this._numerator} }{ ${this._denominator} }`;\r\n        } else {\r\n            return `\\\\frac{ ${this._numerator} }{ ${this._denominator} }`;\r\n        }\r\n    }\r\n\r\n    get display(): string {\r\n        if (this._denominator === 1) {\r\n            return `${this._numerator}`;\r\n        } else {\r\n            return `${this._numerator}/${this._denominator}`;\r\n        }\r\n    }\r\n\r\n    // Helper function to display fractions\r\n    get frac(): string {\r\n        return this.tex;\r\n    }\r\n\r\n    get dfrac(): string {\r\n        return this.tex.replace('\\\\frac', '\\\\dfrac');\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse the value to get the numerator and denominator\r\n     * @param value : number or string to parse to get the fraction\r\n     * @param denominatorOrPeriodic (optional|number) : length of the periodic part: 2.333333 => 1 or denominator value\r\n     */\r\n    parse = (value: unknown, denominatorOrPeriodic?: number): Fraction => {\r\n        let S: string[];\r\n\r\n        // A null value means a zero fraction.\r\n        if (value === null || value === \"\") {\r\n            this._numerator = 0;\r\n            this._denominator = 1;\r\n            return this;\r\n        }\r\n\r\n        switch (typeof value) {\r\n            case \"string\":\r\n                // Split the sting value in two parts: Numerator/Denominator\r\n                S = value.split('/');\r\n\r\n                // Security checks\r\n                if (S.length > 2) throw \"Two many divide signs\";\r\n                if (S.map(x => x === '' || isNaN(Number(x))).includes(true)) throw \"Not a number\"\r\n\r\n\r\n                if (S.length === 1) {\r\n                    // No divide sign\r\n                    return this.parse(+S[0]);\r\n                } else if (S.length === 2) {\r\n                    // One divide signe\r\n                    // We check if the denominator is zero\r\n                    if (S[1] === '0') {\r\n                        this._numerator = NaN;\r\n                        this._denominator = 1;\r\n                    } else {\r\n                        this._numerator = +S[0];\r\n                        this._denominator = +S[1];\r\n                    }\r\n                } else {\r\n                    // More than one divide sign ?\r\n                    this._numerator = NaN;\r\n                    this._denominator = 1;\r\n                }\r\n                break;\r\n            case \"number\":\r\n                if (Number.isSafeInteger(value)) {\r\n                    // The given value is an integer\r\n                    this._numerator = +value;\r\n\r\n                    if (denominatorOrPeriodic === undefined || !Number.isSafeInteger(denominatorOrPeriodic)) {\r\n                        this._denominator = 1;\r\n                    } else {\r\n                        this._denominator = +denominatorOrPeriodic;\r\n                    }\r\n                } else {\r\n                    // The given value is a float number\r\n\r\n                    // Get the number of decimals after the float sign\r\n                    let p: number = (value.toString()).split('.')[1].length;\r\n\r\n                    // Transform the float number in two integer\r\n                    if (denominatorOrPeriodic === undefined) {\r\n                        this._numerator = value * Math.pow(10, p);\r\n                        this._denominator = Math.pow(10, p);\r\n                    } else if (Number.isSafeInteger(denominatorOrPeriodic)) {\r\n                        this._numerator = value * Math.pow(10, p) - Math.floor(value * Math.pow(10, p - denominatorOrPeriodic));\r\n                        this.denominator = Math.pow(10, p) - Math.pow(10, p - denominatorOrPeriodic)\r\n                    }\r\n                }\r\n                break;\r\n            case \"object\":\r\n                if (value instanceof Fraction) {\r\n                    this._numerator = +value.numerator;\r\n                    this._denominator = +value.denominator;\r\n                }\r\n                break;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    clone = (): Fraction => {\r\n        let F = new Fraction();\r\n        F.numerator = +this._numerator;\r\n        F.denominator = +this._denominator;\r\n        return F;\r\n    };\r\n\r\n    zero = (): Fraction => {\r\n        this._numerator = 0;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    one = (): Fraction => {\r\n        this._numerator = 1;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    infinite = (): Fraction => {\r\n        this._numerator = Infinity;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    invalid = (): Fraction => {\r\n        this._numerator = NaN;\r\n        this._denominator = 1;\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    opposed = (): Fraction => {\r\n        this._numerator = -this._numerator;\r\n        return this;\r\n    };\r\n\r\n    add = (F: Fraction | number): Fraction => {\r\n        if (F instanceof Fraction) {\r\n            let N: number = this._numerator,\r\n                D: number = this._denominator;\r\n\r\n            this._numerator = N * F.denominator + F.numerator * D;\r\n            this._denominator = D * F.denominator;\r\n        } else {\r\n            return this.add(new Fraction(F))\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    subtract = (F: Fraction | number): Fraction => {\r\n        if (F instanceof Fraction) {\r\n            return this.add(F.clone().opposed());\r\n        } else {\r\n            return this.add(-F)\r\n        }\r\n    };\r\n\r\n    multiply = (F: Fraction | number): Fraction => {\r\n        // Parse the value.\r\n        // If it's a fraction, return a clone of it\r\n        // If it's an integer, return the fraction F/1\r\n        let Q = new Fraction(F);\r\n\r\n        this._numerator = this._numerator * Q.numerator;\r\n        this._denominator = this._denominator * Q.denominator;\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    divide = (F: Fraction | number): Fraction => {\r\n        let Q = new Fraction(F);\r\n\r\n        if (Q.numerator === 0) {\r\n            return new Fraction().infinite();\r\n        }\r\n\r\n        let N: number = +this._numerator,\r\n            D: number = +this._denominator;\r\n\r\n        this._numerator = N * Q.denominator;\r\n        this._denominator = D * Q.numerator;\r\n        return this.reduce();\r\n    };\r\n\r\n    invert = (): Fraction => {\r\n        let n = +this._numerator, d = +this._denominator;\r\n        this._numerator = d;\r\n        this._denominator = n;\r\n\r\n        return this;\r\n    }\r\n    pow = (p: number | Fraction): Fraction => {\r\n        // TODO: Fraction.pow with a value different than a safe integer ?\r\n        if (p instanceof Fraction) {\r\n            return this.pow(p.value)\r\n        }\r\n\r\n        if (!Number.isSafeInteger(p)) {\r\n            return this.invalid();\r\n        }\r\n\r\n        this.reduce();\r\n\r\n        if (p < 0) {\r\n            this.invert()\r\n        }\r\n\r\n        this._numerator = this._numerator ** Math.abs(p);\r\n        this._denominator = this._denominator ** Math.abs(p);\r\n        return this;\r\n    };\r\n\r\n    root = (p: number): Fraction => {\r\n        // TODO: nth - root of a fraction => this will return another type of coefficient.\r\n\r\n        // Check if they are perfect roots..\r\n        if (p === 0) {\r\n            return this;\r\n        }\r\n\r\n        // If negative, invert the fraction\r\n        if (p < 0) {\r\n            this.invert()\r\n        }\r\n\r\n        let n = Math.pow(this._numerator, Math.abs(1 / p)),\r\n            d = Math.pow(this._denominator, Math.abs(1 / p));\r\n\r\n        this._numerator = Math.pow(this._numerator, Math.abs(1 / p));\r\n        this._denominator = Math.pow(this._denominator, Math.abs(1 / p));\r\n        return this;\r\n    }\r\n\r\n    sqrt = (): Fraction => {\r\n        return this.root(2);\r\n    }\r\n\r\n    abs = (): Fraction => {\r\n        this._numerator = Math.abs(this._numerator);\r\n        this._denominator = Math.abs(this._denominator);\r\n        return this;\r\n    };\r\n\r\n\r\n    static max = (...fractions: (Fraction | number)[]): Fraction => {\r\n        let M = new Fraction(fractions[0])\r\n\r\n        for (let m of fractions) {\r\n            let compare = new Fraction(m)\r\n            if (compare.greater(M)) {\r\n                M = compare.clone()\r\n            }\r\n        }\r\n\r\n        return M\r\n    }\r\n    static min = (...fractions: (Fraction | number)[]): Fraction => {\r\n        let M = new Fraction(fractions[0])\r\n\r\n        for (let m of fractions) {\r\n            let compare = new Fraction(m)\r\n            if (compare.lesser(M)) {\r\n                M = compare.clone()\r\n            }\r\n        }\r\n\r\n        return M\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations specific to fractions\r\n    // ------------------------------------------\r\n    reduce = (): Fraction => {\r\n        let g = Numeric.gcd(this._numerator, this._denominator);\r\n        this._numerator = this._numerator / g;\r\n        this._denominator = this._denominator / g;\r\n\r\n        if (this._denominator < 0) {\r\n            this._denominator = -this._denominator;\r\n            this._numerator = -this._numerator;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    amplify = (k: number): Fraction => {\r\n        if (Number.isSafeInteger(k)) {\r\n            this._numerator *= k;\r\n            this._denominator *= k;\r\n        }\r\n        return this;\r\n    };\r\n\r\n\r\n    // ------------------------------------------\r\n    // Compare functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Compare the current coefficient with another coefficient\r\n     * @param F (Coefficient) The coefficient to compare\r\n     * @param sign (string| default is =): authorized values: =, <, <=, >, >= with some variations.\r\n     */\r\n    compare = (F: unknown, sign?: string): boolean => {\r\n        if (sign === undefined) {\r\n            sign = '=';\r\n        }\r\n\r\n        let compareFraction: Fraction\r\n        if (F instanceof Fraction) {\r\n            compareFraction = F.clone()\r\n        } else {\r\n            compareFraction = new Fraction(F)\r\n        }\r\n\r\n        switch (sign) {\r\n            case '>':\r\n                return this.value > compareFraction.value;\r\n            case \">=\" || \"=>\" || \"geq\":\r\n                return this.value >= compareFraction.value;\r\n            case \"<\":\r\n                return this.value < compareFraction.value;\r\n            case \"<=\" || \"=>\" || \"leq\":\r\n                return this.value <= compareFraction.value;\r\n            case \"=\":\r\n                // let F2: Fraction = compareFraction.clone().reduce(),\r\n                //     F1: Fraction = this.clone().reduce();\r\n                // return (F1.numerator === F2.numerator && F1.denominator === F2.denominator);\r\n                return this.value === compareFraction.value;\r\n            case \"<>\":\r\n                return this.value !== compareFraction.value;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /* Compare shortcuts */\r\n    lesser = (than: Fraction | number): Boolean => {\r\n        return this.compare(than, '<');\r\n    };\r\n    leq = (than: Fraction | number): Boolean => {\r\n        return this.compare(than, '<=');\r\n    };\r\n    greater = (than: Fraction | number): Boolean => {\r\n        return this.compare(than, '>');\r\n    };\r\n    geq = (than: Fraction | number): Boolean => {\r\n        return this.compare(than, '>=');\r\n    };\r\n    isEqual = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '=');\r\n    }\r\n    isNotEqual = (than: Fraction | number): boolean => {\r\n        return this.compare(than, '<>');\r\n    }\r\n    isOpposed = (p: Fraction): boolean => {\r\n        return this.isEqual(p.clone().opposed());\r\n    }\r\n    isInverted = (p: Fraction): boolean => {\r\n        return this.isEqual(new Fraction().one().divide(p.clone()));\r\n    }\r\n    isZero = (): boolean => {\r\n        return this._numerator === 0;\r\n    }\r\n    isNotZero = (): boolean => {\r\n        return this._numerator !== 0;\r\n    }\r\n    isOne = (): boolean => {\r\n        return this._numerator === 1 && this._denominator === 1;\r\n    }\r\n    isNegativeOne = (): boolean => {\r\n        return this._numerator === -1 && this._denominator === 1;\r\n    }\r\n    isPositive = (): boolean => {\r\n        return this.sign() === 1;\r\n    }\r\n    isNegative = (): boolean => {\r\n        return this.sign() === -1;\r\n    }\r\n    isStrictlyPositive = (): boolean => {\r\n        return this.value > 0\r\n    }\r\n    isStrictlyNegative = (): Boolean => {\r\n        return this.value < 0\r\n    }\r\n    isNaN = (): boolean => {\r\n        return isNaN(this._numerator);\r\n    }\r\n    isInfinity = (): boolean => {\r\n        return this._numerator === Infinity;\r\n    }\r\n    isFinite = (): boolean => {\r\n        return !this.isInfinity();\r\n    }\r\n    isSquare = (): boolean => {\r\n        return Math.sqrt(this._numerator) % 1 === 0 && Math.sqrt(this._denominator) % 1 === 0\r\n    }\r\n    isReduced = (): boolean => {\r\n        return Math.abs(Numeric.gcd(this._numerator, this._denominator)) === 1\r\n    }\r\n    isNatural = (): boolean => {\r\n        return this.clone().reduce().denominator === 1\r\n    }\r\n    isRational = (): boolean => {\r\n        return !this.isNatural()\r\n    }\r\n    isEven = (): boolean => {\r\n        return this.isNatural() && this.value % 2 === 0\r\n    }\r\n    isOdd = (): boolean => {\r\n        return this.isNatural() && this.value % 2 === 1\r\n    }\r\n    sign = (): number => {\r\n        return (this._numerator * this._denominator >= 0) ? 1 : -1;\r\n    };\r\n\r\n\r\n    // TODO: The rest of the functions are not used or unnecessary ?\r\n    /**\r\n     * Simple function to determine if it's a fraction\r\n     */\r\n    areEquals = (...F: Fraction[]): boolean => {\r\n        for (let i = 0; i < F.length; i++) {\r\n            if (!this.isEqual(F[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n}","export * from \"./fraction\"\r\nexport * from \"./nthroot\"","/**\r\n * Nthroot is something like \"a+b\\sqrt{3}\r\n */\r\nexport class Nthroot {\r\n    private _radical: number;\r\n    private _nth: number;\r\n    private _coefficient: number;\r\n    private _isValid:boolean;\r\n\r\n    constructor(...values: number[]) {\r\n        this._radical = 1;\r\n        this._coefficient = 1;\r\n        this._nth = 2;\r\n        this._isValid = true;\r\n\r\n        if(values !== undefined){\r\n            this.parse(values[0], values[1], values[2])\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get radical(): number {\r\n        return this._radical;\r\n    }\r\n\r\n    set radical(value: number) {\r\n        this._radical = value;\r\n    }\r\n\r\n    get nth(): number {\r\n        return this._nth;\r\n    }\r\n\r\n    set nth(value: number) {\r\n        if (Number.isSafeInteger(value) && value >= 2) {\r\n            this._nth = value;\r\n        } else {\r\n            // Error setting the nth root.\r\n            console.log('Error setting the nth root');\r\n            this._nth = 2;\r\n        }\r\n    }\r\n\r\n    get coefficient(): number {\r\n        return this._coefficient;\r\n    }\r\n\r\n    set coefficient(value: number) {\r\n        this._coefficient = value;\r\n    }\r\n\r\n    get tex(): string {\r\n        let C: string;\r\n\r\n        if (this._coefficient === 1) {\r\n            C = '';\r\n        } else if (this._coefficient === -1) {\r\n            C = '-';\r\n        } else {\r\n            C = this._coefficient.toString();\r\n        }\r\n\r\n        if (this._radical === 1) {\r\n            return `${this._coefficient}`;\r\n        } else {\r\n            if (this._nth === 2) {\r\n                return `${C}\\\\sqrt{${this._radical}}`\r\n            } else {\r\n                return `${C}\\\\sqrt[${this._nth}]{${this._radical}}`\r\n            }\r\n        }\r\n    }\r\n\r\n    get value(): number {\r\n        return this._coefficient * Math.pow(this._radical, 1 / this._nth);\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    parse = (radical: number, nthroot?: number, coefficient?: number): Nthroot => {\r\n        this._coefficient = (coefficient === undefined) ? 1 : coefficient;\r\n        this._nth = (nthroot === undefined) ? 2 : nthroot;\r\n        this._radical = (radical === undefined) ? 1 : radical;\r\n\r\n        if(this._nth%2===0 && this._radical<0){\r\n            this._isValid = false;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    reduce = (): Nthroot => {\r\n        // Max value to test.\r\n        let V = Math.floor(Math.pow(this._radical, 1 / this._nth));\r\n        while (V > 1) {\r\n            if (this._radical % Math.pow(V, this._nth) === 0) {\r\n                // It's dividable by V^n\r\n                this._coefficient *= V;\r\n                this._radical = this._radical / Math.pow(V, this._nth);\r\n\r\n                // Redifine the new testing value (this is optimization)\r\n                V = Math.floor(Math.pow(this._radical, 1 / this._nth));\r\n                continue;\r\n            }\r\n            V--;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    multiply = (N: Nthroot): Nthroot => {\r\n        this._radical *= N.radical;\r\n        return this.reduce();\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Help functions\r\n    // ------------------------------------------\r\n    hasRadical = ():boolean => {\r\n        return !(this._radical===1 || this._radical===0 || this._isValid===false)\r\n    };\r\n}","import {Point} from \"./point\";\r\nimport {Fraction} from \"../coefficients\";\r\nimport {Equation, Monom, Polynom} from \"../algebra\";\r\nimport {Line} from \"./line\";\r\nimport {Vector} from \"./vector\";\r\nimport {Triangle} from \"./triangle\";\r\n\r\nexport class Circle {\r\n    private _center: Point;\r\n    private _squareRadius: Fraction;\r\n    private _cartesian: Equation;\r\n    private _exists: boolean;\r\n\r\n    constructor(...values: unknown[]) {\r\n        this._exists = false\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values)\r\n        }\r\n    }\r\n\r\n\r\n    get center(): Point {\r\n        return this._center;\r\n    }\r\n\r\n\r\n    get exists(): boolean {\r\n        return this._exists;\r\n    }\r\n\r\n    get squareRadius(): Fraction {\r\n        return this._squareRadius\r\n    }\r\n\r\n    get radius(): { tex: string, display: string } {\r\n        if (this._squareRadius.isSquare()) {\r\n            return {\r\n                tex: this._squareRadius.clone().sqrt().tex,\r\n                display: this._squareRadius.clone().sqrt().display,\r\n            }\r\n        } else {\r\n            return {\r\n                tex: `\\\\sqrt{${this._squareRadius.tex}}`,\r\n                display: `sqrt(${this._squareRadius.display})`\r\n            }\r\n        }\r\n        return this._squareRadius\r\n    }\r\n\r\n    get tex(): string {\r\n\r\n        if (this._exists) {\r\n            let cx, cy\r\n            if (this._center.x.isZero()) {\r\n                cx = 'x^2'\r\n            } else {\r\n                cx = `\\\\left(x${this._center.x.isNegative() ? '+' : '-'}${this._center.x.clone().abs().tex}\\\\right)^2`\r\n            }\r\n            if (this._center.y.isZero()) {\r\n                cy = 'y^2'\r\n            } else {\r\n                cy = `\\\\left(y${this._center.y.isNegative() ? '+' : '-'}${this._center.y.clone().abs().tex}\\\\right)^2`\r\n            }\r\n            return `${cx}+${cy}=${this._squareRadius.tex}`\r\n        } else {\r\n            return `\\\\text{le cercle n'existe pas.}`\r\n        }\r\n    }\r\n\r\n    get developed(): string {\r\n        return this._cartesian.tex\r\n    }\r\n\r\n\r\n    // TODO: reformat code for better display.\r\n    get display(): string {\r\n        return this._cartesian.display\r\n    }\r\n\r\n    get cartesian(): Equation {\r\n        return this._cartesian\r\n    }\r\n\r\n    clone(): Circle {\r\n        this._center = this._center.clone()\r\n        this._squareRadius = this._squareRadius.clone()\r\n        this._calculateCartesian()\r\n        return this\r\n    }\r\n\r\n    private _reset(): Circle {\r\n        this._center = null\r\n        this._squareRadius = null\r\n        this._cartesian = null\r\n        this._exists = false\r\n\r\n        return this\r\n    }\r\n\r\n    private parse(...values: unknown[]): Circle {\r\n        // Data can be given in these formats:\r\n        // one value, a string -> make it an Equation\r\n        // one value, an Equation\r\n        // one value, a circle -> clone it\r\n        // two values: two points (center and pointThrough)\r\n        // two values: point and Fraction (center and radius)\r\n        // three values: Point, Fraction, Boolean (center, square radius, true)\r\n\r\n        this._reset()\r\n\r\n        if (typeof values[0] === 'string') {\r\n            this._parseEquation(new Equation(values[0]))\r\n        } else if (values[0] instanceof Equation) {\r\n            this._parseEquation(values[0])\r\n        } else if (values[0] instanceof Circle) {\r\n            this._parseCopyCircle(values[0])\r\n        } else if (values[0] instanceof Point && values.length > 1) {\r\n            if (values[1] instanceof Point) {\r\n                if (values[2] instanceof Point) {\r\n                    this._parseThroughtThreePoints(values[0], values[1], values[2])\r\n                } else {\r\n                    this._parseCenterAndPointThrough(values[0], values[1])\r\n                }\r\n            } else if (values[1] instanceof Fraction || typeof values[1] === 'number') {\r\n                this._parseCenterAndRadius(values[0], values[1], (typeof values[2] === \"boolean\") ? values[2] : false)\r\n            }\r\n        }\r\n\r\n        // Calculate once the different values.\r\n        if(this._exists) {\r\n            this._calculateCartesian()\r\n\r\n            // If the square radius is zero or positive, the circle exists.\r\n            if (this._squareRadius !== undefined && this._squareRadius.isNegative()) {\r\n                this._exists = false\r\n            }\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    private _calculateCartesian() {\r\n        this._cartesian = (new Equation(\r\n            new Polynom(`(x-(${this._center.x.display}))^2+(y-(${this._center.y.display}))^2`),\r\n            new Polynom(`${this._squareRadius.display}`)\r\n        )).moveLeft()\r\n    }\r\n\r\n    private _parseCopyCircle(circle: Circle): Circle {\r\n        this._center = circle.center.clone()\r\n        this._squareRadius = circle.squareRadius.clone()\r\n        this._calculateCartesian()\r\n        this._exists = circle.exists\r\n        return this\r\n    }\r\n\r\n    private _parseCenterAndRadius(center: Point, radius: Fraction | number, square?: boolean): Circle {\r\n        this._center = center.clone()\r\n\r\n        if (square) {\r\n            this._squareRadius = (new Fraction(radius))\r\n        } else {\r\n            this._squareRadius = new Fraction(radius).pow(2)\r\n        }\r\n\r\n        this._exists = true\r\n        return this\r\n    }\r\n\r\n    private _parseCenterAndPointThrough(center: Point, pointThrough: Point): Circle {\r\n        this._center = center.clone()\r\n        this._squareRadius = new Vector(this._center, pointThrough).normSquare\r\n        this._exists = true\r\n        return this\r\n    }\r\n\r\n    private _parseEquation(equ: Equation): Circle {\r\n        this._exists = false\r\n\r\n        // Move everything to the left.\r\n        equ.moveLeft()\r\n\r\n        if (equ.degree('x').value === 2 && equ.degree('y').value === 2) {\r\n            // Both must be of degree 2.\r\n            let x2 = equ.left.monomByDegree(2, 'x'),\r\n                y2 = equ.left.monomByDegree(2, 'y'),\r\n                x1: Monom, y1: Monom, c: Monom\r\n\r\n            // Both square monoms must have the same coefficient.\r\n            if (x2.coefficient.isEqual(y2.coefficient)) {\r\n                equ.divide(x2.coefficient)\r\n\r\n                x1 = equ.left.monomByDegree(1, 'x')\r\n                y1 = equ.left.monomByDegree(1, 'y')\r\n\r\n                c = equ.left.monomByDegree(0)\r\n\r\n                this._center = new Point(\r\n                    x1.coefficient.clone().divide(2).opposed(),\r\n                    y1.coefficient.clone().divide(2).opposed()\r\n                )\r\n\r\n                this._squareRadius = c.coefficient.clone().opposed()\r\n                    .add(this._center.x.clone().pow(2))\r\n                    .add(this._center.y.clone().pow(2))\r\n\r\n                this._calculateCartesian()\r\n                this._exists = true\r\n            }else{\r\n                // The circle is not a valid circle\r\n                this._center = null\r\n                this._squareRadius = null\r\n                this._exists = false\r\n            }\r\n        }\r\n        return this\r\n    }\r\n\r\n    private _parseThroughtThreePoints(A: Point, B: Point, C: Point): Circle {\r\n        let T = new Triangle(A, B, C),\r\n            mAB = T.remarquables.mediators.AB.clone(),\r\n            mAC = T.remarquables.mediators.AC.clone()\r\n        this.parse(mAB.intersection(mAC).point, A)\r\n\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Get the relative position between circle and line. It corresponds to the number of intersection.\r\n     * @param {Line} L\r\n     * @returns {number}\r\n     */\r\n    relativePosition = (L: Line): number => {\r\n        let distance = L.distanceTo(this.center),\r\n            radius = Math.sqrt(this._squareRadius.value)\r\n\r\n        if (distance.value - radius > 0.0000000001) {\r\n            return 0 // external\r\n        } else if (Math.abs(distance.value - radius) < 0.0000000001) {\r\n            return 1 // tangent\r\n        } else {\r\n            return 2 // external\r\n        }\r\n    }\r\n\r\n    lineIntersection = (L: Line): Point[] => {\r\n        let intersectionPoints: Point[] = [], solX: Fraction\r\n\r\n        if(this._cartesian===null){return []}\r\n        const equX = this._cartesian.clone(),\r\n            lineX = L.equation.clone().isolate('x'),\r\n            lineY = L.equation.clone().isolate('y')\r\n\r\n        if (lineX instanceof Equation && lineY instanceof Equation) {\r\n            equX.replaceBy('y', lineY.right).simplify()\r\n            equX.solve()\r\n\r\n            for(let x of equX.solutions){\r\n                if(x.exact===false && isNaN(x.value)){continue}\r\n\r\n                solX = new Fraction(x.exact===false?x.value:x.exact)\r\n                intersectionPoints.push(\r\n                    new Point(\r\n                        solX.clone(),\r\n                        lineY.right.evaluate(solX)\r\n                    )\r\n                )\r\n            }\r\n        }\r\n\r\n        return intersectionPoints\r\n    }\r\n}","export * from \"./vector\"\r\nexport * from \"./triangle\"\r\nexport * from \"./point\"\r\nexport * from \"./circle\"\r\nexport * from \"./line\"\r\n","/**\r\n * This class works for 2d line in a plane.\r\n */\r\n\r\nimport {Fraction} from \"../coefficients\";\r\nimport {Vector} from \"./vector\";\r\nimport {Point} from \"./point\";\r\nimport {Equation, Polynom} from \"../algebra\";\r\nimport {Numeric} from \"../numeric\";\r\n\r\nenum LinePropriety {\r\n    None,\r\n    Parallel,\r\n    Perpendicular\r\n}\r\n\r\nexport class Line {\r\n    // A line is defined as the canonical form\r\n    // ax + by + c = 0\r\n    private _a: Fraction;\r\n    private _b: Fraction;\r\n    private _c: Fraction;\r\n    private _OA: Point;\r\n    private _d: Vector;\r\n    private _n: Vector;\r\n    private _exists: boolean\r\n\r\n    private _referencePropriety: LinePropriety\r\n    private _referenceLine: Line\r\n\r\n    static PERPENDICULAR = LinePropriety.Perpendicular\r\n    static PARALLEL = LinePropriety.Parallel\r\n\r\n    constructor(...values: unknown[]) {\r\n\r\n        this._exists = false;\r\n\r\n        if (values.length > 0) {\r\n            this.parse(...values);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    get exists(): boolean {\r\n        return this._exists;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get equation(): Equation {\r\n        return new Equation(new Polynom().parse('xy', this._a, this._b, this._c), new Polynom('0')).simplify();\r\n    }\r\n\r\n    get tex(): { canonical: string, mxh: string, parametric: string } {\r\n        // canonical    =>  ax + by + c = 0\r\n        // mxh          =>  y = -a/b x - c/b\r\n        // parametric   =>  (xy) = OA + k*d\r\n\r\n        let canonical = this.equation;\r\n        // Make sur the first item is positive.\r\n        if (this._a.isNegative()) {\r\n            canonical.multiply(-1);\r\n        }\r\n\r\n        return {\r\n            canonical: canonical.tex,\r\n            mxh: this.slope.isInfinity() ? 'x=' + this.OA.x.tex : 'y=' + new Polynom().parse('x', this.slope, this.height).tex,\r\n            parametric: `${Point.pmatrix('x', 'y')} = ${Point.pmatrix(this._OA.x, this._OA.y)} + k\\\\cdot ${Point.pmatrix(this._d.x, this._d.y)}`\r\n        }\r\n    }\r\n\r\n    get a(): Fraction {\r\n        return this._a;\r\n    }\r\n\r\n    set a(value: Fraction) {\r\n        this._a = value;\r\n    }\r\n\r\n    get b(): Fraction {\r\n        return this._b;\r\n    }\r\n\r\n    set b(value: Fraction) {\r\n        this._b = value;\r\n    }\r\n\r\n    get c(): Fraction {\r\n        return this._c;\r\n    }\r\n\r\n    set c(value: Fraction) {\r\n        this._c = value;\r\n    }\r\n\r\n    get OA(): Point {\r\n        return this._OA;\r\n    }\r\n\r\n    set OA(value: Point) {\r\n        this._OA = value;\r\n    }\r\n\r\n    get d(): Vector {\r\n        return this._d;\r\n    }\r\n\r\n    get n(): Vector {\r\n        return this._n;\r\n    }\r\n\r\n    get normal(): Vector {\r\n        return new Vector(this._a, this._b);\r\n    }\r\n\r\n    get director(): Vector {\r\n        return this._d.clone()\r\n    }\r\n\r\n    set d(value: Vector) {\r\n        this._d = value;\r\n    }\r\n\r\n    get slope(): Fraction {\r\n        return this._a.clone().opposed().divide(this._b);\r\n    }\r\n\r\n    get height(): Fraction {\r\n        return this._c.clone().opposed().divide(this._b);\r\n    }\r\n\r\n// ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n    /**\r\n     * Parse data to a line\r\n     * @param {any} values\r\n     * @returns {Line}\r\n     */\r\n    parse = (...values: unknown[]): Line => {\r\n        this._exists = false;\r\n\r\n        // Nothing is given...\r\n        if (values.length === 0) {\r\n            return this\r\n        }\r\n\r\n        // One value only: already a line (clone it), an Equation, a string (as Equation)\r\n        if (values.length === 1) {\r\n            if (values[0] instanceof Line) {\r\n                // Already a Line\r\n                return values[0].clone()\r\n            } else if (values[0] instanceof Equation) {\r\n                // It's an Equation\r\n                return this.parseEquation(values[0])\r\n            } else if (typeof values[0] === \"string\") {\r\n                // It's a string - create an Equation from it.\r\n                try {\r\n                    let E = new Equation(values[0])\r\n                    return this.parse(E)\r\n                } catch (e) {\r\n                    return this\r\n                }\r\n            }\r\n        }\r\n\r\n        if (values.length === 2) {\r\n            if (values[0] instanceof Point && values[1] instanceof Vector) {\r\n                return this.parseByPointAndVector(values[0], values[1]);\r\n            } else if (values[0] instanceof Point && values[1] instanceof Point) {\r\n                return this.parseByPointAndVector(values[0], new Vector(values[0], values[1]));\r\n            } else if (values[0] instanceof Vector && values[1] instanceof Point) {\r\n                return this.parseByPointAndNormal(values[1], values[0])\r\n            }\r\n        }\r\n\r\n        if (values.length === 3) {\r\n            if (\r\n                (values[0] instanceof Fraction || typeof values[0] === 'number')\r\n                &&\r\n                (values[1] instanceof Fraction || typeof values[1] === 'number')\r\n                &&\r\n                (values[2] instanceof Fraction || typeof values[2] === 'number')\r\n            ) {\r\n                return this.parseByCoefficient(values[0], values[1], values[2]);\r\n            }else if (\r\n                values[0] instanceof Point && values[1] instanceof Vector\r\n            ){\r\n                if(values[2] === LinePropriety.Perpendicular){\r\n                    return this.parseByPointAndNormal(values[0], values[1])\r\n                }else if (values[2] === LinePropriety.Parallel){\r\n                    return this.parseByPointAndVector(values[0], values[1])\r\n                }\r\n            }\r\n        }\r\n\r\n        // TODO: Add the ability to create line from a normal vector\r\n        console.log('Someting wrong happend while creating the line')\r\n        return this;\r\n    }\r\n\r\n    parseEquation = (equ: Equation): Line => {\r\n        // Reorder the eequation\r\n        equ.reorder(true)\r\n\r\n        // It must contain either x, y or both.\r\n        let letters = new Set(equ.letters());\r\n\r\n        // No 'x', no 'y' in the equations\r\n        if (!(letters.has('x') || letters.has('y'))) {\r\n            return this\r\n        }\r\n\r\n        // Another letter in the equation ?\r\n        for (let elem of ['x', 'y']) {\r\n            if (letters.has(elem)) {\r\n                letters.delete(elem)\r\n            }\r\n        }\r\n\r\n        if (letters.size > 0) {\r\n            return this\r\n        }\r\n\r\n        // Everything should be ok now...\r\n        return this.parseByCoefficient(equ.left.monomByLetter('x').coefficient, equ.left.monomByLetter('y').coefficient, equ.left.monomByDegree(0).coefficient)\r\n    }\r\n    parseByCoefficient = (a: Fraction | number, b: Fraction | number, c: Fraction | number): Line => {\r\n        this._a = new Fraction(a);\r\n        this._b = new Fraction(b);\r\n        this._c = new Fraction(c);\r\n\r\n        this._d = new Vector(this._b.clone(), this._a.clone().opposed());\r\n        this._OA = new Point(new Fraction().zero(), this._c.clone());\r\n        this._n = this._d.clone().normal();\r\n\r\n        this._exists = true;\r\n        return this;\r\n    }\r\n\r\n    parseByPointAndVector = (P: Point, d: Vector): Line => {\r\n        // OX = OP + k*d\r\n        // x = px + kdx     * dy\r\n        // y = py + kdy     * dx\r\n        // ------------------\r\n        // dy * x = px * dy + kdxdy\r\n        // dx * y = py * dx + kdxdy\r\n        // ------------------\r\n        // dy * x - dx * y = px * dy - py * dx\r\n        // dy * x - dx * y - (px * dy - py * dx) = 0\r\n        this.parseByCoefficient(\r\n            d.y,\r\n            d.x.clone().opposed(),\r\n            P.x.clone().multiply(d.y).subtract(P.y.clone().multiply(d.x)).opposed()\r\n        )\r\n\r\n        // Choose the current values as point and direction vector instead of the automatic version.\r\n        this._OA = P.clone();\r\n        this._d = d.clone();\r\n        this._n = this._d.clone().normal();\r\n\r\n        this._exists = true;\r\n        return this;\r\n    }\r\n\r\n    parseByPointAndNormal = (P: Point, n: Vector): Line => {\r\n        return this.parseByCoefficient(\r\n            n.x,\r\n            n.y,\r\n            P.x.clone().multiply(n.x)\r\n                .add(P.y.clone().multiply(n.y)).opposed()\r\n        )\r\n    }\r\n\r\n    parseByPointAndLine = (P: Point, L: Line, orientation?: LinePropriety): Line => {\r\n\r\n        if (orientation === undefined) {\r\n            orientation = LinePropriety.Parallel\r\n        }\r\n\r\n        if (orientation === LinePropriety.Parallel) {\r\n            return this.parseByPointAndNormal(P, L.normal)\r\n        } else if (orientation === LinePropriety.Perpendicular) {\r\n            return this.parseByPointAndNormal(P, L.director)\r\n        }\r\n\r\n        this._exists = false\r\n        return this\r\n    }\r\n\r\n    clone = (): Line => {\r\n        this._a = this._a.clone();\r\n        this._b = this._b.clone();\r\n        this._c = this._c.clone();\r\n\r\n        this._d = this._d.clone();\r\n        this._OA = this._OA.clone();\r\n        this._n = this._n.clone();\r\n\r\n        this._exists = this.exists\r\n        return this;\r\n    }\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    isParellelTo = (line: Line): Boolean => {\r\n        // Do they have the isSame direction ?\r\n        return this.slope.isEqual(line.slope) && this.height.isNotEqual(line.height);\r\n    }\r\n    isSameAs = (line: Line): Boolean => {\r\n        return this.slope.isEqual(line.slope) && this.height.isEqual(line.height);\r\n    }\r\n    simplify = (): Line => {\r\n        let lcm = Numeric.lcm(this._a.denominator, this._b.denominator, this._c.denominator),\r\n            gcd = Numeric.gcd(this._a.numerator, this._b.numerator, this._c.numerator);\r\n\r\n        this.parseByCoefficient(\r\n            this._a.clone().multiply(lcm).divide(gcd),\r\n            this._b.clone().multiply(lcm).divide(gcd),\r\n            this._c.clone().multiply(lcm).divide(gcd),\r\n        )\r\n\r\n        return this\r\n    }\r\n\r\n    simplifyDirection = (): Line => {\r\n        let lcm = Numeric.lcm(this._d.x.denominator, this._d.y.denominator),\r\n            gcd = Numeric.gcd(this._d.x.numerator, this._d.y.numerator);\r\n\r\n        this._d.x.multiply(lcm).divide(gcd);\r\n        this._d.y.multiply(lcm).divide(gcd);\r\n        return this;\r\n    }\r\n    intersection = (line: Line): { point: Point, hasIntersection: boolean, isParallel: boolean, isSame: boolean } => {\r\n        let Pt = new Point(), isParallel = false, isSame = false, hasIntersection = true;\r\n\r\n        // this         => ax+by+c = 0\r\n        // line         => dx+ey+f = 0\r\n        //\r\n        //  aex + bey + ce = 0\r\n        //  dbx + bey + bf = 0\r\n        // (ae-db)x + ce-bf = 0\r\n        //\r\n        //  adx + bdy + cd = 0\r\n        //  adx + aey + af = 0\r\n        // (bd-ae)y + (cd-af)\r\n        //\r\n        // x = (bf-ce)/(ae-db)\r\n        // y = (af-cd)/(bd-ae)\r\n\r\n\r\n        // Theres is no 'y'\r\n        if (this._b.isZero() || line.b.isZero()) {\r\n            // TODO : handle no y in the line canonical form\r\n        }\r\n\r\n        if (this.isParellelTo(line)) {\r\n            Pt.x = null;\r\n            Pt.y = null;\r\n            isParallel = true;\r\n        } else if (this.isSameAs(line)) {\r\n            Pt.x = null;\r\n            Pt.y = null;\r\n            isSame = true;\r\n        } else {\r\n            Pt.x = this._b.clone().multiply(line.c).subtract(this._c.clone().multiply(line.b))\r\n                .divide(this._a.clone().multiply(line.b).subtract(this._b.clone().multiply(line.a)));\r\n            Pt.y = this._a.clone().multiply(line.c).subtract(this._c.clone().multiply(line.a))\r\n                .divide(this._b.clone().multiply(line.a).subtract(this._a.clone().multiply(line.b)));\r\n        }\r\n\r\n        return {\r\n            point: Pt,\r\n            hasIntersection: !(isParallel || isSame),\r\n            isParallel,\r\n            isSame\r\n        };\r\n    }\r\n\r\n    distanceTo(pt: Point): { value: number, fraction: Fraction, tex: string } {\r\n        let numerator = pt.x.clone().multiply(this._a)\r\n                .add(pt.y.clone().multiply(this._b))\r\n                .add(this._c).abs(),\r\n            d2 = this.normal.normSquare;\r\n\r\n        // The denominator is null - shouldn't be possible\r\n        if (d2.isZero()) {\r\n            return {\r\n                value: NaN,\r\n                tex: 'Not a line',\r\n                fraction: new Fraction().infinite()\r\n            }\r\n        }\r\n        // The denominator is a perfect square - simplify the tex result\r\n        let value = numerator.value / Math.sqrt(d2.value),\r\n            F = numerator.clone().divide(d2.clone().sqrt());\r\n\r\n        // The denominator is a perfect square.\r\n        if (d2.isSquare()) {\r\n            return {\r\n                value,\r\n                tex: F.tex,\r\n                fraction: F\r\n            }\r\n        }\r\n        // Complete answer...\r\n        return {\r\n            value,\r\n            tex: `\\\\frac{${numerator.tex}}{\\\\sqrt{${d2.tex}}}`,\r\n            fraction: F\r\n        };\r\n    }\r\n\r\n    hitSegment(A: Point, B: Point): boolean {\r\n        let iPt = this.intersection(\r\n            new Line(A, B)\r\n        )\r\n\r\n        // There is an intersection point\r\n        if (iPt.hasIntersection) {\r\n            return iPt.point.x.value >= Math.min(A.x.value, B.x.value)\r\n                && iPt.point.x.value <= Math.max(A.x.value, B.x.value)\r\n                && iPt.point.y.value >= Math.min(A.y.value, B.y.value)\r\n                && iPt.point.y.value <= Math.max(A.y.value, B.y.value)\r\n        }\r\n        return false;\r\n    }\r\n\r\n    getValueAtX = (value: Fraction|number): Fraction => {\r\n        const equ = this.equation.clone().isolate('y'),\r\n            F = new Fraction(value)\r\n\r\n        if(equ instanceof Equation){\r\n            return equ.right.evaluate({x: F})\r\n        }\r\n        return\r\n    }\r\n    getValueAtY = (value: Fraction|number): Fraction => {\r\n        const equ = this.equation.clone().isolate('x'),\r\n            F = new Fraction(value)\r\n\r\n        if(equ instanceof Equation){\r\n            return equ.right.evaluate({y: F})\r\n        }\r\n        return\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Special functions\r\n    // ------------------------------------------\r\n    canonicalAsFloatCoefficient(decimals: number): string {\r\n        if (decimals === undefined) {\r\n            decimals = 2;\r\n        }\r\n\r\n        let ca = this._a.value,\r\n            cb = this._b.value,\r\n            cc = this._c.value,\r\n            canonical = '';\r\n\r\n        if (!this._a.isZero()) {\r\n            if (this._a.isOne()) {\r\n                canonical = 'x'\r\n            } else if (this._a.clone().opposed().isOne()) {\r\n                canonical = '-x'\r\n            } else {\r\n                canonical = this._a.value.toFixed(decimals) + 'x'\r\n            }\r\n        }\r\n\r\n        if (!this._b.isZero()) {\r\n            if (this._b.isPositive()) {\r\n                canonical += '+'\r\n            }\r\n            canonical += this._b.value.toFixed(decimals) + 'y'\r\n        }\r\n\r\n        if (!this._c.isZero()) {\r\n            if (this._c.isPositive()) {\r\n                canonical += '+'\r\n            }\r\n            canonical += this._c.value.toFixed(decimals)\r\n        }\r\n\r\n\r\n        return canonical + '=0';\r\n    }\r\n}","/**\r\n * Vector module contains everything necessary to handle 2d or 3d vectors.\r\n * @module Vector\r\n */\r\nimport {Fraction} from \"../coefficients\"\r\n\r\n/**\r\n * Helper class - a way to identify an object {x: number, y: number}\r\n */\r\nclass PointXY {\r\n    public x: number\r\n    public y: number\r\n}\r\n\r\nexport class Point {\r\n    private _x: Fraction;   // 1st component\r\n    private _y: Fraction;   // 2nd component\r\n    private _exist: Boolean;\r\n\r\n    constructor(...values: unknown[]) {\r\n        this._x = new Fraction().zero();\r\n        this._y = new Fraction().zero();\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values);\r\n        }\r\n\r\n        return this\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get x(): Fraction {\r\n        return this._x;\r\n    }\r\n\r\n    set x(value: Fraction) {\r\n        this._x = value;\r\n    }\r\n\r\n    get y(): Fraction {\r\n        return this._y;\r\n    }\r\n\r\n    set y(value: Fraction) {\r\n        this._y = value;\r\n    }\r\n\r\n    get tex(): string {\r\n        let pts = [];\r\n\r\n        pts.push(this._x.tex);\r\n        pts.push(this._y.tex);\r\n\r\n        return `\\\\left(${pts.join(';')}\\\\right)`\r\n    }\r\n\r\n    get display(): string {\r\n        let pts = [];\r\n\r\n        pts.push(this._x.tex);\r\n        pts.push(this._y.tex);\r\n\r\n        return `(${pts.join(';')})`\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n\r\n    parse = (...values: unknown[]): Point => {\r\n        // Initialize the value.\r\n        this.zero();\r\n\r\n        // Nothing is given\r\n        if (values.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        // One element is given - might be already a point !\r\n        if (values.length === 1) {\r\n            // it's already a point - clone it\r\n            if (values[0] instanceof Point) {\r\n                this._x = values[0].x.clone()\r\n                this._y = values[0].y.clone()\r\n                return this\r\n            }\r\n\r\n            // Value is given as string, comma separated.\r\n            if (typeof values[0] === 'string') {\r\n                let xy = values[0].split(',')\r\n                if (xy.length === 2) {\r\n                    this._x = new Fraction(xy[0]).reduce()\r\n                    this._y = new Fraction(xy[1]).reduce()\r\n                    return this\r\n                }\r\n            }\r\n\r\n            // Value given as an object with {x: value, y: value}\r\n            if(values[0] instanceof PointXY){\r\n                    this._x = new Fraction(values[0].x).reduce()\r\n                    this._y = new Fraction(values[0].y).reduce()\r\n                return this\r\n            } else {\r\n                return this.zero()\r\n            }\r\n        }\r\n\r\n        if (values.length === 2) {\r\n            this._x = new Fraction(values[0]).reduce()\r\n            this._y = new Fraction(values[1]).reduce()\r\n            return this\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    clone = (): Point => {\r\n        this._x = this._x.clone()\r\n        this._y = this._y.clone()\r\n\r\n        return this\r\n    }\r\n\r\n    zero = (): Point => {\r\n        this._x = new Fraction(null);\r\n        this._y = new Fraction(null);\r\n        return this;\r\n    }\r\n\r\n    origin = (): Point => {\r\n        this.zero();\r\n        return this;\r\n    }\r\n\r\n    middleOf = (P1: Point, P2: Point): Point => {\r\n        this._x = P1.x.clone().add(P2.x).divide(2);\r\n        this._y = P1.y.clone().add(P2.y).divide(2);\r\n\r\n        return this;\r\n    }\r\n    // ------------------------------------------\r\n    // Display functions\r\n    // ------------------------------------------\r\n    texValues = (numberOfDigits: number): string => {\r\n        let pts = [];\r\n\r\n        pts.push(this._x.value.toFixed(numberOfDigits === undefined ? 2 : numberOfDigits));\r\n        pts.push(this._y.value.toFixed(numberOfDigits === undefined ? 2 : numberOfDigits));\r\n\r\n        return `\\\\left(${pts.join(';')}\\\\right)`\r\n    }\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n\r\n    // ------------------------------------------\r\n    // Vector functions\r\n    // ------------------------------------------\r\n\r\n    // ------------------------------------------\r\n    // Static functions\r\n    // ------------------------------------------\r\n    static pmatrix = (a: any, b: any, c?: any): string => {\r\n        if (c === undefined) {\r\n            return `\\\\begin{pmatrix} ${a.tex ? a.tex : a} \\\\\\\\ ${b.tex ? b.tex : b} \\\\end{pmatrix}`;\r\n        } else {\r\n            return `\\\\begin{pmatrix} ${a.tex ? a.tex : a} \\\\\\\\ ${b.tex ? b.tex : b} \\\\\\\\ ${c.tex ? c.tex : c} \\\\end{pmatrix}`;\r\n        }\r\n    };\r\n\r\n}\r\n","import {Point} from \"./point\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Vector} from \"./vector\";\r\nimport {Line} from \"./line\";\r\nimport {Equation} from \"../algebra/equation\";\r\n\r\nexport interface remarquableLines {\r\n    'medians': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    },\r\n    'mediators': {\r\n        'AB': Line,\r\n        'AC': Line,\r\n        'BC': Line,\r\n        'intersection': Point\r\n    },\r\n    'heights': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    },\r\n    'bisectors': {\r\n        'A': Line,\r\n        'B': Line,\r\n        'C': Line,\r\n        'intersection': Point\r\n    }\r\n}\r\n\r\nexport class Triangle {\r\n    private _A: Point;\r\n    private _B: Point;\r\n    private _C: Point;\r\n    private _lines: {\r\n        'AB': Line,\r\n        'AC': Line,\r\n        'BC': Line\r\n    };\r\n    private _middles: {\r\n        'AB': Point,\r\n        'AC': Point,\r\n        'BC': Point\r\n    };\r\n    private _remarquables: remarquableLines;\r\n\r\n\r\n    constructor(...values: any) {\r\n\r\n        if (values.length > 0) {\r\n            this.parse(...values);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setters\r\n    // ------------------------------------------\r\n\r\n    get A(): Point {\r\n        return this._A;\r\n    }\r\n\r\n    get B(): Point {\r\n        return this._B;\r\n    }\r\n\r\n    get C(): Point {\r\n        return this._C;\r\n    }\r\n\r\n    get AB(): Vector {\r\n        return this.getSegment('A', 'B');\r\n    }\r\n\r\n    get BA(): Vector {\r\n        return this.getSegment('B', 'A');\r\n    }\r\n\r\n    get BC(): Vector {\r\n        return this.getSegment('B', 'C');\r\n    }\r\n\r\n    get CB(): Vector {\r\n        return this.getSegment('C', 'B');\r\n    }\r\n\r\n    get AC(): Vector {\r\n        return this.getSegment('A', 'C');\r\n    }\r\n\r\n    get CA(): Vector {\r\n        return this.getSegment('C', 'A');\r\n    }\r\n\r\n    get isRectangle(): boolean {\r\n        if (this.AB.isNormalTo(this.BC)) {\r\n            return true;\r\n        }\r\n        if (this.AB.isNormalTo(this.AC)) {\r\n            return true;\r\n        }\r\n        if (this.BC.isNormalTo(this.AC)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    get isEquilateral(): boolean {\r\n        return this.AB.normSquare.isEqual(this.BC.normSquare) &&\r\n            this.AB.normSquare.isEqual(this.AC.normSquare);\r\n    }\r\n\r\n    get isIsocele(): boolean {\r\n        return this.AB.normSquare.isEqual(this.BC.normSquare) ||\r\n            this.AB.normSquare.isEqual(this.AC.normSquare) ||\r\n            this.BC.normSquare.isEqual(this.AC.normSquare)\r\n    }\r\n\r\n    get lines(): { 'AB': Line, 'BC': Line, 'AC': Line } {\r\n        return this._lines;\r\n    }\r\n\r\n    get remarquables(): remarquableLines {\r\n        return this._remarquables;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Parse values to a triangle. Supported formats:\r\n     * Point, Point, Point\r\n     * x1, y1, x2, y2, x3, y3\r\n     * TODO: Something else ?\r\n     * @param values\r\n     */\r\n    parse = (...values: any): Triangle => {\r\n        if (values.length === 6) {\r\n            // Check if all values are number or fractions.\r\n            let v = values.map((x: any) => new Fraction(x));\r\n            return this.parse(\r\n                new Point(v[0], v[1]),\r\n                new Point(v[2], v[3]),\r\n                new Point(v[4], v[5]),\r\n            )\r\n        } else if (values.length === 3) {\r\n            // Possibilities:\r\n            // - Three points (or part of points, only dict for example, or array (TODO: Add the array syntax for point)\r\n            // - Three lines\r\n            // - Three lines as text.\r\n            if(values.filter((x:any) => typeof x === 'string').length===3) {\r\n                return this.parse( ...values.map((x:string) => new Line(x)) )\r\n            }else if(values.filter((x:any) => x instanceof Line).length===3) {\r\n                // We have three lines\r\n                this._lines = {\r\n                    'AB': values[0],\r\n                    'BC': values[1],\r\n                    'AC': values[2]\r\n                };\r\n\r\n                // Get the intersection points -> build the triangle using these intersection points.\r\n                let intersect = values[0].intersection(values[1]);\r\n                if (intersect.hasIntersection) {\r\n                    this._B = intersect.point.clone();\r\n                } else {\r\n                    return this;\r\n                }\r\n                intersect = values[1].intersection(values[2]);\r\n                if (intersect.hasIntersection) {\r\n                    this._C = intersect.point.clone();\r\n                } else {\r\n                    return this;\r\n                }\r\n                intersect = values[2].intersection(values[0]);\r\n                if (intersect.hasIntersection) {\r\n                    this._A = intersect.point.clone();\r\n                } else {\r\n                    return this;\r\n                }\r\n            }else {\r\n                // At least, one of the value is not a point.\r\n                if (values.filter((x: any) => (x instanceof Point)).length < 3) {\r\n                    return this.parse(\r\n                        new Point(values[0]),\r\n                        new Point(values[1]),\r\n                        new Point(values[2])\r\n                    )\r\n                }\r\n\r\n                // We have three points.\r\n                this._A = values[0].clone();\r\n                this._B = values[1].clone();\r\n                this._C = values[2].clone();\r\n\r\n                this._lines = {\r\n                    'AB': new Line(this._A, this._B),\r\n                    'BC': new Line(this._B, this._C),\r\n                    'AC': new Line(this._A, this._C)\r\n                };\r\n            }\r\n        } else if (values.length === 1) {\r\n            if (values[0] instanceof Triangle) {\r\n                return values[0].clone();\r\n            }\r\n        }\r\n\r\n        this._updateTriangle();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clone the Triangle class\r\n     */\r\n    clone = (): Triangle => {\r\n        this._A = this._A.clone();\r\n        this._B = this._B.clone();\r\n        this._C = this._C.clone();\r\n\r\n        this._lines = {\r\n            'AB': this._lines.AB.clone(),\r\n            'BC': this._lines.BC.clone(),\r\n            'AC': this._lines.AC.clone()\r\n        }\r\n\r\n        this._updateTriangle();\r\n        return this;\r\n    }\r\n\r\n\r\n    // ------------------------------------------\r\n    // Triangle operations and properties\r\n    // ------------------------------------------\r\n\r\n    /**\r\n     * Generate the Line object for the three segments of the triangle\r\n     */\r\n    private _updateTriangle = () => {\r\n        this._middles = {\r\n            'AB': new Point().middleOf(this._A, this._B),\r\n            'AC': new Point().middleOf(this._A, this._C),\r\n            'BC': new Point().middleOf(this._B, this._C)\r\n        }\r\n\r\n        this._remarquables = this._calculateRemarquableLines();\r\n    }\r\n\r\n\r\n    /**\r\n     * Get the Point class for the given name\r\n     * @param ptName\r\n     */\r\n    private getPointByName = (ptName: string): Point => {\r\n        switch (ptName.toUpperCase()) {\r\n            case 'A':\r\n                return this._A;\r\n            case 'B':\r\n                return this._B;\r\n            case 'C':\r\n                return this._C;\r\n        }\r\n\r\n        // Something went wrong ! Return the first point\r\n        return this._A;\r\n    }\r\n    /**\r\n     * Get the vector for the segment given by name.\r\n     * @param ptName1\r\n     * @param ptName2\r\n     */\r\n    private getSegment = (ptName1: string, ptName2: string): Vector => {\r\n        return new Vector(\r\n            this.getPointByName(ptName1),\r\n            this.getPointByName(ptName2)\r\n        );\r\n    }\r\n\r\n    private _calculateRemarquableLines = (): remarquableLines => {\r\n        let remarquables: remarquableLines = {\r\n            'medians': {\r\n                'A': new Line(this._A, this._middles.BC),\r\n                'B': new Line(this._B, this._middles.AC),\r\n                'C': new Line(this._C, this._middles.AB),\r\n                'intersection': null\r\n            },\r\n            'mediators': {\r\n                'AB': new Line(this._middles.AB, new Vector(this._A, this._B).normal()),\r\n                'AC': new Line(this._middles.AC, new Vector(this._A, this._C).normal()),\r\n                'BC': new Line(this._middles.BC, new Vector(this._B, this._C).normal()),\r\n                'intersection': null\r\n            },\r\n            'heights': {\r\n                'A': new Line(this._A, new Vector(this._B, this._C).normal()),\r\n                'B': new Line(this._B, new Vector(this._A, this._C).normal()),\r\n                'C': new Line(this._C, new Vector(this._A, this._B).normal()),\r\n                'intersection': null\r\n            },\r\n            'bisectors': {\r\n                'A': this._calculateBisectors('A'),\r\n                'B': this._calculateBisectors('B'),\r\n                'C': this._calculateBisectors('C'),\r\n                'intersection': null\r\n            }\r\n        }\r\n\r\n        // As it's a triangle, we assume the lines are intersecting and aren't parallel or superposed.\r\n        remarquables.medians.intersection = remarquables.medians.A.intersection(remarquables.medians.B).point;\r\n        remarquables.mediators.intersection = remarquables.mediators.AB.intersection(remarquables.mediators.BC).point;\r\n        remarquables.heights.intersection = remarquables.heights.A.intersection(remarquables.heights.B).point;\r\n        remarquables.bisectors.intersection = remarquables.bisectors.A.intersection(remarquables.bisectors.B).point;\r\n\r\n        // Everything was calculated for the remarquable lines.\r\n        return remarquables;\r\n    }\r\n\r\n    private _calculateBisectors = (pt: string): Line => {\r\n        let tlines = this.lines, d1, d2;\r\n\r\n        if(pt==='A'){\r\n            d1 = tlines.AB;\r\n            d2 = tlines.AC;\r\n        }else if(pt==='B'){\r\n            d1 = tlines.AB;\r\n            d2 = tlines.BC;\r\n        }else if(pt==='C'){\r\n            d1 = tlines.BC;\r\n            d2 = tlines.AC;\r\n        }\r\n\r\n        let b1 = new Line(new Equation(d1.equation.left.clone().multiply(d2.n.simplify().norm), d2.equation.left.clone().multiply(d1.n.simplify().norm)).reorder(true).simplify()),\r\n            b2 = new Line(new Equation(d1.equation.left.clone().multiply(d2.n.simplify().norm), d2.equation.left.clone().multiply(d1.n.simplify().norm).opposed()).reorder(true).simplify());\r\n\r\n        // Must determine which bisectors is in the triangle\r\n        if(pt==='A'){\r\n            return b1.hitSegment(this.B, this.C)?b1:b2;\r\n        }\r\n        if(pt==='B'){\r\n            return b1.hitSegment(this.A, this.C)?b1:b2;\r\n        }\r\n        if(pt==='C'){\r\n            return b1.hitSegment(this.B, this.A)?b1:b2;\r\n        }\r\n\r\n        // Default returns the first bisector\r\n        return b1;\r\n    }\r\n}","/**\r\n * Vector module contains everything necessary to handle 2d or 3d vectors.\r\n * @module Vector\r\n */\r\nimport {Fraction} from \"../coefficients/fraction\";\r\nimport {Numeric} from \"../numeric\";\r\nimport {Point} from \"./point\";\r\n\r\nexport class Vector {\r\n    private _x: Fraction;   // 1st component\r\n    private _y: Fraction;   // 2nd component\r\n\r\n    constructor(...values: any) {\r\n        this._x = new Fraction().zero();\r\n        this._y = new Fraction().zero();\r\n\r\n        if (values !== undefined) {\r\n            this.parse(...values);\r\n        }\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n    // ------------------------------------------\r\n    get x(): Fraction {\r\n        return this._x;\r\n    }\r\n\r\n    set x(value: Fraction) {\r\n        this._x = value;\r\n    }\r\n\r\n    get y(): Fraction {\r\n        return this._y;\r\n    }\r\n\r\n    set y(value: Fraction) {\r\n        this._y = value;\r\n    }\r\n\r\n    get normSquare(): Fraction {\r\n        return this._x.clone().pow(2).add(this._y.clone().pow(2));\r\n    }\r\n\r\n    get norm(): number {\r\n        return Math.sqrt(this.normSquare.value);\r\n    }\r\n\r\n    get tex(): string {\r\n        return `\\\\begin{pmatrix}${this._x.tex} \\\\\\\\\\ ${this._y.tex} \\\\end{pmatrix}`\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n    // ------------------------------------------\r\n\r\n    parse = (...values: any): Vector => {\r\n        // TODO: Must be more strict about what is given and limit to two dimensional vectors.p\r\n        // Maybe more than one value was given...\r\n        // Initialize the vector\r\n        this.zero();\r\n\r\n        if (values.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        if (values.length === 1) {\r\n            if (values[0] instanceof Vector) {\r\n                return values[0].clone()\r\n            } else {\r\n                return this._parseString(values[0])\r\n            }\r\n        }\r\n\r\n        if (values.length >= 2) {\r\n            // Two points are given - skip the third value.\r\n            if (values[0] instanceof Point && values[1] instanceof Point) {\r\n                this._x = values[1].x.clone().subtract(values[0].x)\r\n                this._y = values[1].y.clone().subtract(values[0].y)\r\n                return this;\r\n            }\r\n\r\n            // Fractions or a number are give\r\n            if (values[0].isFraction || !isNaN(values[0])) {\r\n                this._x = new Fraction(values[0])\r\n            }\r\n            if (values[1].isFraction || !isNaN(values[1])) {\r\n                this._y = new Fraction(values[1])\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    clone = (): Vector => {\r\n        let V = new Vector();\r\n\r\n        if (this._x !== null) {\r\n            V.x = this._x.clone();\r\n        }\r\n        if (this._y !== null) {\r\n            V.y = this._y.clone();\r\n        }\r\n        return V;\r\n    }\r\n\r\n    reset = (): Vector => {\r\n        this._x = null;\r\n        this._y = null;\r\n        return this;\r\n    }\r\n\r\n    zero = (): Vector => {\r\n        this.reset();\r\n        this._x = new Fraction(null);\r\n        this._y = new Fraction(null);\r\n        return this;\r\n    }\r\n\r\n    one = (): Vector => {\r\n        this._x = new Fraction();\r\n        this._y = new Fraction();\r\n        return this;\r\n    }\r\n\r\n    private _parseString = (value: string): Vector => {\r\n        // Split comma, semi colon or single space.\r\n        let components = value.split(/[,;\\s]/g);\r\n\r\n        // Validate the fraction values.\r\n        this.x = new Fraction(components[0] || null);\r\n        this.y = new Fraction(components[1] || null);\r\n        return this;\r\n    };\r\n\r\n    // ------------------------------------------\r\n    // Mathematical operations\r\n    // ------------------------------------------\r\n    opposed = (): Vector => {\r\n        this._x.opposed();\r\n        this._y.opposed();\r\n        return this;\r\n    }\r\n\r\n    add = (V: Vector): Vector => {\r\n        this._x.add(V.x);\r\n        this._y.add(V.y);\r\n\r\n        return this;\r\n    }\r\n\r\n    subtract = (V: Vector): Vector => {\r\n        return this.add(V.clone().opposed());\r\n    }\r\n\r\n    scalarProductWithVector = (V: Vector): Fraction => {\r\n        // TODO: Add the scalar factor !!!!\r\n        return this._x.clone().multiply(V.x).add(this._y.clone().multiply(V.y));\r\n    }\r\n\r\n    static scalarProduct = (v1: Vector, v2: Vector): number => {\r\n        // TODO: Transform to fraction with nthroot.\r\n        return v1.x.value * v2.x.value + v1.y.value * v2.y.value;\r\n    };\r\n\r\n    normal = (): Vector => {\r\n        let x = this.x.clone().opposed(), y = this.y.clone();\r\n        this._x = y;\r\n        this._y = x;\r\n        return this;\r\n    }\r\n\r\n    isNormalTo = (v: Vector): boolean => {\r\n        return this.scalarProductWithVector(v).isZero()\r\n    }\r\n\r\n    multiplyByScalar = (k: any): Vector => {\r\n        let scalar = new Fraction(k);\r\n        this._x.multiply(scalar);\r\n        this._y.multiply(scalar);\r\n        return this;\r\n    }\r\n\r\n    divideByScalar = (k: any): Vector => {\r\n        return this.multiplyByScalar(new Fraction(k).invert());\r\n    }\r\n    // ------------------------------------------\r\n    // Vector functions\r\n    // ------------------------------------------\r\n\r\n    simplify = (): Vector => {\r\n        // Multiply by the lcm of denominators.\r\n        return this.multiplyByScalar(Numeric.lcm(this._x.denominator, this._y.denominator))\r\n            .divideByScalar(Numeric.gcd(this._x.numerator, this._y.numerator));\r\n    }\r\n\r\n    angleWith = (V: Vector, sharp?: Boolean, radian?: Boolean): number => {\r\n        let scalar = this.scalarProductWithVector(V).value,\r\n            toDegree = radian ? 1 : 180 / Math.PI;\r\n        if (sharp) {\r\n            scalar = Math.abs(scalar);\r\n        }\r\n\r\n        return toDegree * Math.acos(scalar / (this.norm * V.norm));\r\n    }\r\n}\r\n","export class Numeric{\r\n    static round(value:number, decimals:number=2):number {\r\n        return Number(Math.round(Number(value+'e'+decimals))+'e-'+decimals);\r\n    }\r\n\r\n    /**\r\n     * Get the list of the nth first prime numbers.\r\n     * @param nb : number of primes to choose from\r\n     */\r\n    static prime(nb?:number):number[]{\r\n        let primes:number[] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973];\r\n        if(nb === undefined){\r\n            return primes;\r\n        }else{\r\n            return primes.slice(0,Math.max(primes.length,nb));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the list of all dividers of a number.\r\n     * @param value\r\n     */\r\n    static dividers(value:number):number[]{\r\n        let D: number[];\r\n        const maxV = Math.sqrt(Math.abs(value));\r\n\r\n        // Initialize the list of dividers.\r\n        D = [];\r\n\r\n        for(let i=1; i<=maxV; i++){\r\n            if(value%i===0){\r\n                D.push(i);\r\n                D.push(value/i);\r\n            }\r\n        }\r\n\r\n        // Order numbers.\r\n        D.sort(function(a, b){return a-b;});\r\n\r\n        // Make sure the array of value is unique.\r\n        return [...new Set(D)];\r\n    }\r\n    /**\r\n     * Great Common Divisor\r\n     * @param values : number values\r\n     */\r\n    static gcd(...values:number[]):number{\r\n        // Define the gcd for two number\r\n        let gcd2 = function(a:number,b:number):number{\r\n            if(b===0){return a;}\r\n            return gcd2(b, a%b);\r\n        };\r\n\r\n        let g:number = 1,\r\n            i:number = 2;\r\n\r\n        // Nothing is given\r\n        if(values.length===0){return 1;}\r\n        // Only one number is given\r\n        if(values.length===1){\r\n            // The first number is zero\r\n            if(values[0]===0){return 1;}\r\n            // Return the number\r\n            return values[0];\r\n        }\r\n\r\n        // We have at least 2 numbers.\r\n        g = gcd2(values[0],values[1]);\r\n\r\n        // The gcd of the two first value is one ? It's already finished.\r\n        if(g===1){return 1;}\r\n\r\n        // The current gcd isn't one. Continue with all next values.\r\n        for(i=2; i<values.length; i++){\r\n            g = gcd2(g, values[i]);\r\n            // Escape if gcd is already one.\r\n            if(g===1){break;}\r\n        }\r\n\r\n        return Math.abs(g);\r\n    }\r\n\r\n    /**\r\n     * Least Common Multiple\r\n     * @param values: list of numbers\r\n     */\r\n    static lcm(...values:number[]):number{\r\n        return values.reduce(function(a,b){\r\n            return Math.abs(a * b / Numeric.gcd(a, b));\r\n        });\r\n    }\r\n}","import {rndPolynom} from \"./rndPolynom\";\r\nimport {rndMonom} from \"./rndMonom\";\r\nimport {rndHelpers} from \"./rndHelpers\";\r\nimport {randomCoefficientConfig, randomMonomConfig, randomPolynomConfig} from \"./rndTypes\";\r\nimport {Monom, Polynom} from \"../algebra\";\r\nimport {Fraction} from \"../coefficients\";\r\nimport {rndFraction} from \"./rndFraction\";\r\n\r\nexport * from \"./rndTypes\"\r\n\r\nexport namespace Random {\r\n    export function polynom(config?: randomPolynomConfig): Polynom {\r\n        return (new rndPolynom(config)).generate()\r\n    }\r\n\r\n    export function monom(config?: randomMonomConfig): Monom {\r\n        return (new rndMonom(config)).generate()\r\n    }\r\n\r\n    export function fraction(config?: randomCoefficientConfig): Fraction {\r\n        return (new rndFraction(config)).generate()\r\n    }\r\n\r\n    export function number(from: number, to: number): number {\r\n        return rndHelpers.randomInt(from, to)\r\n    }\r\n\r\n    export function numberSym(max: number, allowZero?: boolean): number {\r\n        return rndHelpers.randomIntSym(max, allowZero)\r\n    }\r\n\r\n    export function bool(percent?: number): boolean {\r\n        return rndHelpers.randomBool(percent)\r\n    }\r\n\r\n    export function array(arr: any[], number?: number): any[] {\r\n        return rndHelpers.randomArray(arr, number)\r\n    }\r\n\r\n    export function item(arr: any[]): any {\r\n        return rndHelpers.randomItem(arr)\r\n    }\r\n\r\n    export function shuffle(arr: any[]): any {\r\n        rndHelpers.shuffleArray(arr)\r\n    }\r\n}","export class randomCore {\r\n    protected _config: Object\r\n    protected _defaultConfig: Object\r\n    mergeConfig = (config: Object, defaultConfig: Object): Object => {\r\n        if (config !== undefined) {\r\n            return {...defaultConfig, ...config}\r\n        }\r\n        return defaultConfig\r\n    }\r\n\r\n    generate = (): unknown => {\r\n        return undefined\r\n    }\r\n\r\n    config = (config: Object): randomCore => {\r\n        this._config = this.mergeConfig(config, this._defaultConfig)\r\n        return this\r\n    }\r\n}","import {randomCore} from \"./randomCore\";\r\nimport {randomCoefficientConfig, randomMonomConfig, randomPolynomConfig} from \"./rndTypes\";\r\nimport {Fraction} from \"../coefficients\";\r\nimport {Random} from \"./index\";\r\n\r\n/**\r\n * Create a random monom based on a based configuration\r\n */\r\nexport class rndFraction extends randomCore {\r\n    declare protected _config: randomCoefficientConfig\r\n    declare protected _defaultConfig: randomCoefficientConfig\r\n\r\n    constructor(userConfig?: randomCoefficientConfig) {\r\n        super();\r\n\r\n        this._defaultConfig = {\r\n            negative: true,\r\n            max: 10,\r\n            reduced: true,\r\n            zero: true,\r\n            natural: false\r\n        }\r\n\r\n        this._config = this.mergeConfig(userConfig, this._defaultConfig)\r\n    }\r\n\r\n    generate = (): Fraction => {\r\n        let Q = new Fraction()\r\n\r\n        if(this._config.negative){\r\n            Q.numerator = Random.numberSym(this._config.max, this._config.zero)\r\n        }else {\r\n            Q.numerator = Random.number(this._config.zero ? 0 : 1, this._config.max)\r\n        }\r\n        if(this._config.natural){\r\n            Q.denominator = 1\r\n        }else {\r\n            Q.denominator = Random.number(1, this._config.max)\r\n        }\r\n\r\n        return this._config.reduced?Q.reduce():Q\r\n    }\r\n}\r\n","/**\r\n * Random helpers\r\n */\r\nexport class rndHelpers {\r\n\r\n    /**\r\n     * Random boolean with a percent ratio\r\n     * @param percent\r\n     */\r\n    static randomBool(percent:number=0.5):boolean{\r\n        return Math.random()<percent;\r\n    }\r\n\r\n    /**\r\n     * Random integer between two values.\r\n     * @param a (number) : From this value to the second value. If the second is ommited, this value is the max value.\r\n     * @param b (number) : To this value. If this is ommited.\r\n     */\r\n    static randomInt(a:number, b?:number):number{\r\n        if(b===undefined){return this.randomInt(0,a);}\r\n\r\n        return Math.floor(Math.random() * (b - a + 1) + a);\r\n    }\r\n\r\n    /**\r\n     * Random integer between -max and max value.\r\n     * @param max (number) : determine the limits.\r\n     * @param zero (bool) : determine if zero is allowed or not.\r\n     */\r\n    static randomIntSym(max:number, zero?:boolean):number{\r\n        if(zero===false){\r\n            return this.randomBool()?this.randomInt(1,max):-this.randomInt(1,max);\r\n        }else{\r\n            return this.randomInt(-max, max);\r\n        }\r\n    }\r\n\r\n    static randomArray(arr: any[], number?:number):any[]{\r\n        if(number===undefined){number = 1}\r\n\r\n        // Return a clone array\r\n        if(arr.length<=0){return Object.values(arr)}\r\n\r\n        // Randomize the array and return the n first elements.\r\n        return rndHelpers.shuffleArray(arr).slice(0,number);\r\n    }\r\n\r\n    static randomItem(arr: any[]): any{\r\n        if(arr.length===0){return ''}\r\n        return this.randomArray(arr, 1)[0]\r\n    }\r\n\r\n    static shuffleArray(arr: any[]): any[] {\r\n        // The Fisher-Yates algorithm\r\n        let shuffleArray = Object.values(arr)\r\n        for (let i = shuffleArray.length - 1; i > 0; i--) {\r\n            const j = Math.floor(Math.random() * (i + 1));\r\n            const temp = shuffleArray[i];\r\n            shuffleArray[i] = shuffleArray[j];\r\n            shuffleArray[j] = temp;\r\n        }\r\n\r\n        return shuffleArray;\r\n    }\r\n\r\n}","import {randomCore} from \"./randomCore\";\r\nimport {randomMonomConfig} from \"./rndTypes\";\r\nimport {Random} from \"./index\";\r\nimport {Monom} from \"../algebra\";\r\n\r\n/**\r\n * Create a random monom based on a based configuration\r\n */\r\nexport class rndMonom extends randomCore {\r\n    declare protected _config: randomMonomConfig\r\n    declare protected _defaultConfig: randomMonomConfig\r\n\r\n    constructor(userConfig?: randomMonomConfig) {\r\n        super();\r\n\r\n        this._defaultConfig = {\r\n            letters: 'x',\r\n            degree: 2,\r\n            fraction: true,\r\n            zero: false\r\n        }\r\n\r\n        this._config = this.mergeConfig(userConfig, this._defaultConfig)\r\n    }\r\n\r\n    generate = (): Monom => {\r\n        // Create a monom instance\r\n        let M = new Monom()\r\n\r\n        // Generate the coefficient\r\n        if (typeof this._config.fraction === \"boolean\") {\r\n            M.coefficient = Random.fraction({\r\n                zero: this._config.zero,\r\n                reduced: true,\r\n                natural: !this._config.fraction\r\n            })\r\n        } else {\r\n            M.coefficient = Random.fraction(this._config.fraction)\r\n        }\r\n\r\n        // Calculate the degree of the monom\r\n        if (this._config.letters.length > 1) {\r\n            // Initialise each items...\r\n            for (let L of this._config.letters.split('')) {\r\n                M.setLetter(L, 0);\r\n            }\r\n            for (let i = 0; i < this._config.degree; i++) {\r\n                const L = Random.item(this._config.letters.split(\"\"))\r\n                M.setLetter(L, M.degree(L).clone().add(1))\r\n            }\r\n        } else {\r\n            M.setLetter(this._config.letters, this._config.degree)\r\n        }\r\n\r\n        return M\r\n    }\r\n}\r\n","import {randomCore} from \"./randomCore\";\r\nimport {randomPolynomConfig} from \"./rndTypes\";\r\nimport {rndMonom} from \"./rndMonom\";\r\nimport {Random} from \"./index\";\r\nimport {Polynom} from \"../algebra\";\r\nimport {Monom} from \"../algebra\";\r\n\r\n/**\r\n * Random polynoms\r\n */\r\nexport class rndPolynom extends randomCore {\r\n    declare protected _config: randomPolynomConfig\r\n    declare protected _defaultConfig: randomPolynomConfig\r\n\r\n    constructor(userConfig?: randomPolynomConfig) {\r\n        super();\r\n\r\n        // Default config for a random polynom\r\n        this._defaultConfig = {\r\n            letters: 'x',\r\n            degree: 2,\r\n            fraction: false,\r\n            zero: false,\r\n            unit: false,\r\n            factorable: false,\r\n            allowNullMonom: true,\r\n            numberOfMonoms: 0,\r\n            positive: true\r\n        }\r\n\r\n        // Merge config with initialiser\r\n        this._config = this.mergeConfig(userConfig, this._defaultConfig)\r\n    }\r\n\r\n    generate = (): Polynom => {\r\n        if(this._config.factorable && this._config.degree>1){\r\n            return this.factorable()\r\n        }\r\n\r\n        // Create the polynom\r\n        let P = new Polynom().empty(),\r\n            M: Monom\r\n\r\n        for (let i = this._config.degree; i >= 0; i--) {\r\n            // Create monom of corresponding degree.\r\n            M = new rndMonom({\r\n                letters: this._config.letters,\r\n                degree: i,\r\n                fraction: this._config.fraction,\r\n                zero: (i === this._config.degree) ? false : this._config.allowNullMonom\r\n            }).generate()\r\n\r\n            // If degree is the greatest and unit is true, set the monom value to one.\r\n            if (this._config.unit && this._config.degree === i) {\r\n                M.coefficient.one()\r\n            }\r\n\r\n            // Add to the polynom\r\n            P.add(M)\r\n        }\r\n\r\n        // Make sure the first monom is positive.\r\n        if(this._config.positive && P.monomByDegree().coefficient.isNegative()){\r\n            P.monomByDegree().coefficient.opposed()\r\n        }\r\n\r\n        // If the number of monoms is greater than the allowed value, remove some of them... except the first one !\r\n        if (this._config.numberOfMonoms > 0 && this._config.numberOfMonoms < P.length) {\r\n            // Get the greatest degree monom\r\n            let M = P.monomByDegree().clone()\r\n            P.monoms = Random.array(P.monoms.slice(1), this._config.numberOfMonoms-1)\r\n            P.add(M).reorder().reduce()\r\n        }\r\n        return P\r\n    }\r\n\r\n    factorable = (): Polynom => {\r\n        let P = new Polynom().one()\r\n\r\n        let _factorableConfig = {...this._config}\r\n        _factorableConfig.degree = 1\r\n        _factorableConfig.factorable = false\r\n\r\n        for(let i=0; i<this._config.degree;i++){\r\n            P.multiply(Random.polynom(_factorableConfig))\r\n        }\r\n\r\n        return P\r\n    }\r\n}","import {loadHighlighter} from \"typedoc/dist/lib/utils/highlighter\";\r\n\r\ntype tokenType = {\r\n    [key: string]: {\r\n        precedence: number,\r\n        associative: string\r\n    }\r\n}\r\n\r\nexport class Shutingyard {\r\n    private _rpn: { token: string, tokenType: string }[] = [];\r\n    readonly _mode: 'polynom' | 'set';\r\n    private _tokenConfig: tokenType;\r\n    private _uniformize: boolean;\r\n\r\n    constructor(mode?: 'polynom' | 'set') {\r\n        this._mode = typeof mode === 'undefined' ? 'polynom' : mode;\r\n        this.tokenConfigInitialization()\r\n    }\r\n\r\n    /**\r\n     * Determin if the token is a defined operation\r\n     * Defined operations: + - * / ^ sin cos tan\r\n     * @param token\r\n     */\r\n    isOperation(token: string): boolean {\r\n        if (token[0].match(/[+\\-*/^]/g)) {\r\n            return true;\r\n        }\r\n        //\r\n        // if (token.match(/^sin|cos|tan/g)) {\r\n        //     return true;\r\n        // }\r\n\r\n        return false;\r\n    }\r\n\r\n    tokenConfigInitialization(): tokenType {\r\n        if (this._mode === 'set') {\r\n            this._tokenConfig = {\r\n                '&': {precedence: 3, associative: 'left'},\r\n                '|': {precedence: 3, associative: 'left'},\r\n                '!': {precedence: 4, associative: 'right'},\r\n                '-': {precedence: 2, associative: 'left'}\r\n            }\r\n            this._uniformize = false;\r\n        } else {\r\n            this._tokenConfig = {\r\n                '^': {precedence: 4, associative: 'right'},\r\n                '*': {precedence: 3, associative: 'left'},\r\n                '/': {precedence: 3, associative: 'left'},\r\n                '+': {precedence: 2, associative: 'left'},\r\n                '-': {precedence: 2, associative: 'left'},\r\n                '%': {precedence: 3, associative: 'right'},\r\n                'sin': {precedence: 4, associative: 'right'},\r\n                'cos': {precedence: 4, associative: 'right'},\r\n                'tab': {precedence: 4, associative: 'right'},\r\n            }\r\n            this._uniformize = true\r\n        }\r\n        return this._tokenConfig\r\n    }\r\n\r\n    /**\r\n     * Get the next token to analyse.\r\n     * @param expr (string) Expression to analyse\r\n     * @param start (number) CUrrent position in the expr string.\r\n     */\r\n    NextToken2(expr: string, start: number): [string, number, string] {\r\n        let token: string, tokenType: string;\r\n        token = '';\r\n        tokenType = '';\r\n        // Case of parenthesis or comma (generic items)\r\n        if (expr[start] === '(') {\r\n            token = '(';\r\n            tokenType = '(';\r\n        }\r\n        // It's a closing parenthese\r\n        else if (expr[start] === ')') {\r\n            token = ')';\r\n            tokenType = ')';\r\n        }\r\n        // It's an argument separator for a function\r\n        else if (expr[start] === ',') {\r\n            token = ',';\r\n            tokenType = 'function-argument';\r\n        } else{\r\n            // Order token keys by token characters length (descending)\r\n            const keys = Object.keys(this._tokenConfig).sort((a,b)=>b.length-a.length)\r\n\r\n            for(let key of keys){\r\n                if(expr.substr(start, key.length) === key){\r\n                    token += key;\r\n                    tokenType = 'operation'\r\n                    break\r\n                }\r\n            }\r\n\r\n            if(token===''){\r\n                // No function found ! Might be a coefficient !\r\n                if( expr[start].match(/[0-9]/) ) {\r\n                    token = expr.substr(start).match(/^([0-9.,/]+)/)[0]\r\n                    tokenType = 'coefficient'\r\n                }else if (expr[start].match(/[a-zA-Z]/)) {\r\n                    token = expr.substr(start).match(/^([a-zA-Z])/)[0]\r\n                    tokenType = 'variable'\r\n                }else{\r\n                    console.log('Unidentified token', expr[start], expr, start)\r\n                    token = expr[start]\r\n                    tokenType = 'monom'\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n\r\n        // console.log(token, tokenType)\r\n        return [token, start + token.length, tokenType];\r\n    }\r\n\r\n    NextToken(expr: string, start: number): [string, number, string] {\r\n        let tokenMatch: string[], token: string, tokenType: string;\r\n\r\n        this.NextToken2(expr, start)\r\n        // Detect a fraction monoms or return empty array\r\n        tokenMatch = (expr.substr(start).match(/^[0-9/a-zA-Z^]+/g)) || [];\r\n\r\n        if (expr.substr(start, start + 3).match(/^(sin|cos|tan)/g)) {\r\n            token = expr.substr(start, 3)\r\n            tokenType = 'function'\r\n        } else if (tokenMatch.length > 0) {\r\n            token = tokenMatch[0];\r\n            tokenType = 'monom';\r\n        }\r\n        // It's an operation !\r\n        else if (expr[start].match(/[+\\-*/^]/g)) {\r\n            token = expr[start];\r\n            tokenType = 'operation';\r\n        } else if (expr[start].match(/[&|!]/g)) {\r\n            token = expr[start];\r\n            tokenType = 'operation';\r\n        }\r\n        // It's an opening parenthese\r\n        else if (expr[start] === '(') {\r\n            token = '(';\r\n            tokenType = '(';\r\n        }\r\n        // It's a closing parenthese\r\n        else if (expr[start] === ')') {\r\n            token = ')';\r\n            tokenType = ')';\r\n        }\r\n        // It's an argument separator for a function\r\n        else if (expr[start] === ',') {\r\n            token = ',';\r\n            tokenType = 'function-argument';\r\n        }\r\n        // It's a monom.\r\n        else {\r\n            // TODO: Actually, negative exposant aren't supported.\r\n            // token = (expr.substr(start).match(/^[\\da-z\\^]+/g)[0])||'';\r\n            token = tokenMatch[0];\r\n            tokenType = 'monom';\r\n\r\n            if (token === '') {\r\n                token = expr[start];\r\n                tokenType = 'monom';\r\n                console.log('SHUTING YARD - NEXT TOKEN: error at ', start);\r\n            }\r\n        }\r\n\r\n        // console.log(token, start + token.length, tokenType);\r\n        return [token, start + token.length, tokenType];\r\n    }\r\n\r\n    /**\r\n     * Sanitize an expression by adding missing common operation (multiplication between parentheseses)\r\n     * @param expr\r\n     * @constructor\r\n     */\r\n    Uniformizer(expr: string): string {\r\n        // Determiner if need to be uniformized\r\n        if(!this._uniformize){return expr}\r\n\r\n        let expr2;\r\n        // Replace missing multiplication between two parenthese\r\n        expr2 = expr.replace(/\\)\\(/g, ')*(');\r\n\r\n        // Replace missing multiplication between number or setLetter and parenthese.\r\n\r\n        // 3x(x-4) => 3x*(x-4)\r\n        expr2 = expr2.replace(/([\\da-zA-Z])(\\()/g, \"$1*$2\");\r\n\r\n        // (x-4)3x => (x-4)*3x\r\n        expr2 = expr2.replace(/(\\))([\\da-zA-Z])/g, \"$1*$2\");\r\n\r\n        // Add multiplication between number and letters.\r\n        // 3x => 3*x\r\n        expr2 = expr2.replace(/([0-9])([a-zA-Z])/g, \"$1*$2\");\r\n        expr2 = expr2.replace(/([a-zA-Z])([0-9])/g, \"$1*$2\");\r\n\r\n        // Add multiplication between letters ?\r\n        // TODO: More robust solution to handle all letters ?\r\n        expr2 = expr2.replace(/([abcxyz])([abcxyz])/g, \"$1*$2\");\r\n\r\n        // Restore operation auto formating (prevent adding the mutliplcation star)\r\n        // TODO: Accept list of functions\r\n        let fnToken = ['sin', 'cos', 'tan']\r\n        for (let token of fnToken) {\r\n            expr2 = expr2.replace(new RegExp(token + '\\\\*', 'g'), token);\r\n        }\r\n\r\n        return expr2;\r\n    }\r\n\r\n    /**\r\n     * Parse an expression using the shutting yard tree algorithms\r\n     * @param expr (string) Expression to analyse\r\n     * Returns a RPN list of items.\r\n     * @param operators\r\n     */\r\n    parse(expr: string, operators?: string[]): Shutingyard {\r\n        let outQueue: {token:string, tokenType: string}[] = [],    // Output queue\r\n            opStack: {token:string, tokenType: string}[] = [],     // Operation queue\r\n            token: string = '',\r\n            tokenPos: number = 0,\r\n            tokenType: string = '',\r\n            previousOpStatckLength = 0\r\n\r\n        expr = this.Uniformizer(expr);\r\n\r\n        let securityLoopLvl1 = 50,\r\n            securityLoopLvl2_default = 50,\r\n            securityLoopLvl2;\r\n\r\n        while (tokenPos < expr.length) {\r\n            securityLoopLvl1--;\r\n            if (securityLoopLvl1 === 0) {\r\n                console.log('SECURITY LEVEL 1 EXIT');\r\n                break;\r\n            }\r\n\r\n            // Get the next token and the corresponding new (ending) position\r\n            [token, tokenPos, tokenType] = this.NextToken2(expr, tokenPos);\r\n\r\n            switch (tokenType) {\r\n                case 'monom':\r\n                case 'coefficient':\r\n                case 'variable':\r\n                    outQueue.push({\r\n                        token,\r\n                        tokenType\r\n                    });\r\n                    // if(previousOpStatckLength == opStack.length && outQueue.length>=2){\r\n                    //     console.log('opStatckLength', outQueue, opStack.length)\r\n                    //     outQueue.push('*')\r\n                    // }\r\n                    break;\r\n                case 'operation':\r\n                    previousOpStatckLength = opStack.length;\r\n                    //If the token is an operator, o1, then:\r\n                    if (opStack.length > 0) {\r\n                        let opTop = opStack[opStack.length - 1];\r\n\r\n\r\n                        securityLoopLvl2 = +securityLoopLvl2_default;\r\n\r\n                        //while there is an operator token o2, at the top of the operator stack and\r\n                        while (opTop.token in this._tokenConfig && (\r\n                                //either o1 is left-associative and its precedence is less than or equal to that of o2,\r\n                                (this._tokenConfig[token].associative === 'left' && this._tokenConfig[token].precedence <= this._tokenConfig[opTop.token].precedence)\r\n                                ||\r\n                                //or o1 is right associative, and has precedence less than that of o2,\r\n                                (this._tokenConfig[token].associative === 'right' && this._tokenConfig[token].precedence < this._tokenConfig[opTop.token].precedence)\r\n                            )\r\n                            ) {\r\n\r\n                            /* Security exit ! */\r\n                            securityLoopLvl2--;\r\n                            if (securityLoopLvl2 === 0) {\r\n                                console.log('SECURITY LEVEL 2 OPERATION EXIT');\r\n                                break;\r\n                            }\r\n\r\n                            // Add the operation to the queue\r\n                            outQueue.push((opStack.pop()) || {token: '', tokenType: 'operation'});\r\n\r\n                            // Get the next operation on top of the Stack.\r\n                            if(opStack.length===0){break;}\r\n                            opTop = opStack[opStack.length - 1];\r\n                        }\r\n                    }\r\n                    //at the end of iteration push o1 onto the operator stack\r\n                    opStack.push({token,tokenType});\r\n                    break;\r\n                case 'function-argument':\r\n                    // TODO: check if the opStack exist.\r\n                    securityLoopLvl2 = +securityLoopLvl2_default;\r\n                    while (opStack[opStack.length - 1].token !== '(' && opStack.length > 0) {\r\n                        securityLoopLvl2--;\r\n                        if (securityLoopLvl2 === 0) {\r\n                            console.log('SECURITY LEVEL 2 FUNCTION ARGUMENT EXIT');\r\n                            break;\r\n                        }\r\n\r\n                        outQueue.push((opStack.pop()) || {token,tokenType});\r\n                    }\r\n                    break;\r\n                case '(':\r\n                    opStack.push({token,tokenType});\r\n                    // Add an empty value if next element is negative.\r\n                    if (expr[tokenPos] === '-') {\r\n                        outQueue.push({token: '0', tokenType: 'coefficient'});\r\n                    }\r\n                    break;\r\n                case ')':\r\n                    securityLoopLvl2 = +securityLoopLvl2_default;\r\n                    //Until the token at the top of the stack is a left parenthesis, pop operators off the stack onto the output queue.\r\n                    while (opStack[opStack.length - 1].token !== '(' && opStack.length > 1 /*Maybe zero !? */) {\r\n                        securityLoopLvl2--;\r\n                        if (securityLoopLvl2 === 0) {\r\n                            console.log('SECURITY LEVEL 2 CLOSING PARENTHESE EXIT');\r\n                            break;\r\n                        }\r\n\r\n                        outQueue.push((opStack.pop()) || {token,tokenType});\r\n                    }\r\n\r\n                    //Pop the left parenthesis from the stack, but not onto the output queue.\r\n                    opStack.pop();\r\n                    break;\r\n                case 'function':\r\n                    opStack.push({token, tokenType});\r\n                    break;\r\n                default:\r\n                    // In theory, everything should be handled.\r\n                    console.log(`SHUTING YARD: ${tokenType} : ${token} `);\r\n            }\r\n\r\n            // Output\r\n            // console.log(outQueue.concat(opStack.reverse()).join(\" \"));\r\n        }\r\n\r\n        // console.log(outQueue.concat(opStack.reverse()));\r\n        this._rpn = outQueue.concat(opStack.reverse());\r\n\r\n        return this;\r\n    }\r\n\r\n\r\n    // Getter\r\n    get rpn() {\r\n        // console.log(this._rpn)\r\n        return this._rpn;\r\n    }\r\n\r\n\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import {Numeric} from \"./maths/numeric\";\r\nimport {Shutingyard} from \"./maths/shutingyard\";\r\nimport {Random} from \"./maths/random\";\r\nimport {Fraction, Nthroot} from \"./maths/coefficients\";\r\nimport {Monom, Polynom, Equation, LinearSystem, Rational, Logicalset} from \"./maths/algebra\";\r\nimport {Line, Circle, Triangle, Point, Vector} from \"./maths/geometry\";\r\n\r\n// Expose as global\r\n// export let Pi = {\r\n(<any>window).Pi = {\r\n    ShutingYard: Shutingyard,\r\n    Numeric: Numeric,\r\n    Fraction: Fraction,\r\n    Root: Nthroot,\r\n    Monom: Monom,\r\n    Polynom: Polynom,\r\n    Equation: Equation,\r\n    LinearSystem: LinearSystem,\r\n    Rational: Rational,\r\n    Logicalset: Logicalset,\r\n    Random: Random,\r\n    Geometry: {\r\n        Vector: Vector,\r\n        Point: Point,\r\n        Line: Line,\r\n        Triangle: Triangle,\r\n        Circle: Circle\r\n    }\r\n};\r\n"],"names":["Equation","_left","_right","_sign","_polynom","_solutions","_varnothing","_real","constructor","equations","this","Polynom","zero","length","clone","parse","left","right","isEquation","solutions","solution","tex","includes","map","x","join","isReal","undefined","solve","isVarnothing","signAsTex","display","raw","variables","Set","concat","numberOfVars","value","sign","_formatSign","equationString","pStr","strSign","_findSign","split","create","console","log","signStr","_reverseSign","replace","_randomizeDefaults","degree","randomizeDefaults","randomize","opts","moveLeft","subtract","reorder","allLeft","mMove","m","monoms","isZero","simplify","multiply","Numeric","lcm","getDenominators","divide","gcd","getNumerators","isolate","letter","isOne","isMultiVariable","cMove","hasLetter","add","opposed","coefficient","replaceBy","P","F","Fraction","invert","max","letters","_solveDegree1","_solveDegree2","_solveDegree3plus","isGreater","indexOf","isStrictEqual","isAlsoEqual","m1","monomByDegree","m0","v","s","NaN","exact","delta","nthDelta","realX1","realX2","sX1","sX2","aF","bF","cF","denominator","a","b","Math","sqrt","toFixed","Nthroot","reduce","hasRadical","S1","S2","dfrac","sol","LinearSystem","_resolutionSteps","_equations","_letters","equationStrings","isSolvable","V","E","sort","equStr","LS","equArray","equ","L","monomByLetter","push","repeat","_findLetters","setCoefficient","coefficients","i","slice","toString","setLetters","generate","solutionsF","_generateOneEquation","coeff","leftValue","equString","Random","numberSym","_checkIfLinerCombination","_linearReduction","eq1","eq2","c1","c2","mergeEquations","factor1","factor2","eq1multiplied","eq2multiplied","_solveOneLetter","LE","reducedEquations","str","_rawString","_rpn","isLogicalset","Shutingyard","rpn","evaluate","tokenSets","reference","referenceSet","varStack","key","token","tokenType","second","pop","first","filter","has","vennAB","A","B","vennABC","C","Monom","_coefficient","_literal","literal","literalSqrt","isLiteralSquare","literalStr","inputStr","matchAll","clean","Object","keys","isNotZero","isNotEqual","dividers","hasFractionCoefficient","numerator","abs","literals","_getLiteralDividers","monomDividers","N","M","one","arr","tmpList","d","litt","item","currentLetter","displayWithSign","_shutingYardToReducedMonom","copyLiterals","pow","q1","q2","stack","element","setLetter","k","makeSame","isSameAs","multiplyByNumber","nb","root","p","isSquare","compare","isEqual","M1","M2","K","isRational","isEven","values","t","n","r","tmpValues","derivative","dM","primitive","static","coeffN","coeffD","isStrictlyPositive","min","areSameAs","areEquals","_monoms","_factors","_texString","polynomString","factors","texFactors","factorize","f","texString","genDisplay","output","forceSign","wrapParentheses","isNaN","Number","empty","shutingYardToReducedPolynom","test","fractions","m2","tempPolynom","previousToken","isSafeInteger","multiplyByPolynom","multiplyByFraction","multiplyByMonom","multiplyByInteger","xmultiply","euclidian","quotient","reminder","maxMP","degreeP","newM","MaxIteration","geq","isPositive","divideByFraction","divideByInteger","nbF","cP1","cP2","isOpposedAt","isFactorized","match","e","polynomStringNormalized","replaceAll","polynomStringReduced","substr","polyFactors","splice","isDeveloped","j","S","resultPolynom","forEach","monom","dP","integrate","valuesA","valuesB","commonMonom","securityLoop","m1d","m2d","result","dividerPolynom","_factorize2ndDegree","P1","P2","c","x1","x2","factor","xyzPolynom","xFactors","_factorizeByGroups","getZeroes","zeroes","zeroesAsTex","greater","D","z","frac","monomsByDegree","Ms","denominators","numerators","lcmDenominator","gcdDenominator","lcmNumerator","gcdNumerator","_numerator","_denominator","domain","amplify","NumeratorEuclidien","DenominatorEuclidien","R","limits","Infinity","denominatorOrPeriodic","isFraction","floor","infinite","invalid","Q","lesser","g","compareFraction","than","leq","isOpposed","isInverted","isNegativeOne","isNegative","isStrictlyNegative","isInfinity","isFinite","isReduced","isNatural","isOdd","_radical","_nth","_isValid","radical","nth","nthroot","Circle","_center","_squareRadius","_cartesian","_exists","center","exists","squareRadius","radius","cx","cy","y","developed","cartesian","_calculateCartesian","_reset","_parseEquation","_parseCopyCircle","Point","_parseThroughtThreePoints","_parseCenterAndPointThrough","_parseCenterAndRadius","circle","square","pointThrough","Vector","normSquare","y1","y2","T","Triangle","mAB","remarquables","mediators","AB","mAC","AC","intersection","point","relativePosition","distance","distanceTo","lineIntersection","solX","intersectionPoints","equX","lineX","equation","lineY","LinePropriety","Line","_a","_b","_c","_OA","_d","_n","_referencePropriety","_referenceLine","Perpendicular","Parallel","canonical","mxh","slope","OA","height","parametric","pmatrix","normal","director","parseEquation","parseByPointAndVector","parseByPointAndNormal","parseByCoefficient","elem","delete","size","parseByPointAndLine","orientation","isParellelTo","line","simplifyDirection","Pt","isParallel","isSame","hasIntersection","pt","d2","fraction","hitSegment","iPt","getValueAtX","getValueAtY","canonicalAsFloatCoefficient","decimals","_x","_y","_exist","pts","xy","origin","middleOf","texValues","numberOfDigits","_A","_B","_C","_lines","_middles","_remarquables","getSegment","BA","BC","CB","CA","isRectangle","isNormalTo","isEquilateral","isIsocele","lines","intersect","_updateTriangle","_calculateRemarquableLines","getPointByName","ptName","toUpperCase","ptName1","ptName2","_calculateBisectors","medians","heights","bisectors","d1","tlines","b1","norm","b2","_parseString","reset","components","scalarProductWithVector","v1","v2","multiplyByScalar","scalar","divideByScalar","angleWith","sharp","radian","toDegree","PI","acos","round","primes","maxV","gcd2","polynom","config","rndPolynom","rndMonom","rndFraction","number","from","to","rndHelpers","randomInt","allowZero","randomIntSym","bool","percent","randomBool","array","randomArray","randomItem","shuffle","shuffleArray","_config","_defaultConfig","mergeConfig","defaultConfig","randomCore","userConfig","super","negative","reduced","natural","random","temp","unit","factorable","allowNullMonom","numberOfMonoms","positive","_factorableConfig","_mode","_tokenConfig","_uniformize","mode","tokenConfigInitialization","isOperation","precedence","associative","NextToken2","expr","start","NextToken","tokenMatch","Uniformizer","expr2","fnToken","RegExp","operators","outQueue","opStack","tokenPos","previousOpStatckLength","securityLoopLvl2","securityLoopLvl1","opTop","reverse","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","window","Pi","ShutingYard","Root","Rational","Logicalset","Geometry"],"sourceRoot":""}