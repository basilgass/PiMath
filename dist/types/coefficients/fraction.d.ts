import type { compareSign, IExpression, InputValue, IPiMathObject } from "./../pimath.interface";
export type FractionParsingType = number | string | Fraction;
export declare class Fraction implements IPiMathObject<Fraction>, IExpression<Fraction> {
    #private;
    constructor();
    constructor(value: InputValue<Fraction>);
    constructor(numerator: number, denominator: number);
    constructor(decimal: number, periodLength: number);
    parse: (value: InputValue<Fraction>, denominatorOrPeriodic?: number) => Fraction;
    clone: () => Fraction;
    abs: () => this;
    add: (F: InputValue<Fraction>) => Fraction;
    amplify: (k: number) => this;
    areEquals: (...F: Fraction[]) => boolean;
    compare: (F: InputValue<Fraction>, sign?: compareSign) => boolean;
    divide: (F: Fraction | number) => Fraction;
    infinite: () => this;
    invalid: () => this;
    inverse: () => this;
    isApproximative: () => boolean;
    isEqual: (than: Fraction | number) => boolean;
    isEven: () => boolean;
    isExact: () => boolean;
    isFinite: () => boolean;
    isGeq: (than: Fraction | number) => boolean;
    isGreater: (than: Fraction | number) => boolean;
    isInfinity: () => boolean;
    isInverted: (p: Fraction) => boolean;
    isLeq: (than: Fraction | number) => boolean;
    isLesser: (than: Fraction | number) => boolean;
    isNaN: () => boolean;
    isNatural: () => boolean;
    isNegative: () => boolean;
    isNegativeOne: () => boolean;
    isNotEqual: (than: Fraction | number) => boolean;
    isNotZero: () => boolean;
    isOdd: () => boolean;
    isOne: () => boolean;
    isOpposite: (p: Fraction) => boolean;
    isPositive: () => boolean;
    isRational: () => boolean;
    isReduced: () => boolean;
    isRelative: () => boolean;
    isSquare: () => boolean;
    isStrictlyNegative: () => boolean;
    isStrictlyPositive: () => boolean;
    isZero: () => boolean;
    multiply: (F: Fraction | number) => this;
    one: () => this;
    opposite: () => this;
    pow: (p: number | Fraction) => Fraction;
    reduce: () => this;
    root: (p: number) => this;
    sign: () => number;
    sqrt: () => this;
    subtract: (F: Fraction | number) => Fraction;
    zero: () => this;
    static average: (...fractions: (InputValue<Fraction>)[]) => Fraction;
    static max: (...fractions: InputValue<Fraction>[]) => Fraction;
    static min: (...fractions: (InputValue<Fraction>)[]) => Fraction;
    static sort: (fractions: (InputValue<Fraction>)[], reverse?: boolean) => Fraction[];
    static unique: (fractions: (InputValue<Fraction>)[]) => Fraction[];
    static xMultiply: (...values: (InputValue<Fraction>)[]) => Fraction;
    get denominator(): number;
    set denominator(value: number);
    get dfrac(): string;
    get display(): string;
    get frac(): string;
    get numerator(): number;
    set numerator(value: number);
    get tex(): string;
    get texWithSign(): string;
    get tfrac(): string;
    get value(): number;
}
//# sourceMappingURL=fraction.d.ts.map