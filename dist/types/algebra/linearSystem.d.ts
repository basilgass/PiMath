import type { IAlgebra, IEquation, InputValue, IPiMathObject, literalType } from "../pimath.interface";
import { Fraction } from "../coefficients/fraction";
import { Equation } from "./equation";
import { Polynom } from "./polynom";
export declare class LinearSystem implements IPiMathObject<LinearSystem>, IEquation<LinearSystem>, IAlgebra<LinearSystem> {
    #private;
    private _variables;
    constructor(...equations: Equation[]);
    constructor(...equationStrings: string[]);
    parse: (...equations: (string | Equation)[]) => this;
    clone: () => LinearSystem;
    static fromMatrix(matrix: InputValue<Fraction>[][], letters?: string): LinearSystem;
    add(value: InputValue<LinearSystem | Equation | Polynom>, index?: number): this;
    buildTex: (equations: Equation[], operators?: (string[])[]) => string;
    degree(letter?: string | undefined): Fraction;
    get equations(): Equation[];
    set equations(value: Equation[]);
    evaluate(values: InputValue<Fraction> | literalType<number | Fraction>, asNumeric?: boolean | undefined): number | Fraction;
    hasVariable(letter: string): boolean;
    isEqual(value: InputValue<LinearSystem>): boolean;
    get isSolvable(): boolean;
    get matrix(): [Fraction[][], Fraction[]];
    mergeEquations: (eq1: Equation, eq2: Equation, factor1: Fraction, factor2: Fraction) => Equation;
    multiply(value: InputValue<Fraction> | InputValue<Fraction>[], index?: number): LinearSystem;
    reduce(): LinearSystem;
    reorder: () => this;
    solve: (withResolution?: boolean) => this;
    solveMatrix: () => Fraction[];
    stepTex: (letter: string) => string;
    subtract(value: InputValue<LinearSystem | Equation | Polynom>, index?: number): this;
    get tex(): string;
    get display(): string;
    get variables(): string[];
    set variables(value: string | string[]);
    private _findLetters;
    private _linearReduction;
    private _makeMatrix;
    private _solveOneLetter;
}
//# sourceMappingURL=linearSystem.d.ts.map