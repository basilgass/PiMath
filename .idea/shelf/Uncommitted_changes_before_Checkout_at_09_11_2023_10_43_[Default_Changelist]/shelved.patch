Index: tests/algebra/monom.test.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {expect} from 'chai';\r\nimport {Random} from \"../../src/maths/randomization/random\";\r\nimport {describe} from \"mocha\";\r\nimport {Monom, MonomE} from \"../../src/maths/algebra/monom\";\r\n\r\ndescribe('Monom with integer power', () => {\r\n    it('parsing', () => {\r\n        const M0a = new Monom('3');\r\n        expect(M0a.tex).to.be.equal('3')\r\n\r\n        const M0b = new Monom('x');\r\n        expect(M0b.tex).to.be.equal('x')\r\n\r\n        const M0c = new Monom('3x');\r\n        expect(M0c.tex).to.be.equal('3x')\r\n\r\n        const M1 = new Monom('3x^5');\r\n        expect(M1.tex).to.be.equal('3x^{5}')\r\n\r\n        const M2 = new Monom('2/3x^2yz^3y^4')\r\n        expect(M2.display).to.be.equal('2/3x^(2)y^(5)z^(3)')\r\n\r\n        const M3 = new Monom('-3x^(-2)')\r\n        expect(M3.tex).to.be.equal('-3x^{-2}')\r\n\r\n        const M4 = new Monom('3x^(2/3)')\r\n        expect(M4.tex).to.be.equal('3x^{\\\\tfrac{ 2 }{ 3 }}')\r\n\r\n        const M5 = new Monom('-3x^(-2/3)y^(-5)8x^3')\r\n        expect(M5.tex).to.be.equal('-24x^{\\\\tfrac{ 7 }{ 3 }}y^{-5}')\r\n    })\r\n\r\n    it('basic operations', () => {\r\n        const M1 = new Monom('3x'),\r\n            M2 = new Monom('2x')\r\n\r\n        expect(M1.clone().add(M2).isEqual(new Monom('5x'))).to.be.true\r\n        expect(M1.clone().subtract(M2).isEqual(new Monom('x'))).to.be.true\r\n        expect(M1.clone().multiply(M2).isEqual(new Monom('6x^2'))).to.be.true\r\n        expect(M1.clone().divide(M2).isEqual(new Monom('3/2'))).to.be.true\r\n    })\r\n\r\n    it('derivative', () => { // the single test\r\n        const options = new Monom('7x^3'); // this will be your class\r\n\r\n        expect(options.tex).to.be.equal('7x^{3}')\r\n        expect(options.derivative().tex).to.be.equal('21x^{2}');\r\n    });\r\n\r\n    it('integrate', () => { // the single test\r\n        const options = new Monom('7x^3'); // this will be your class\r\n        expect(options.primitive().display).to.be.equal('7/4x^(4)');\r\n    });\r\n\r\n    it('randomize', function () {\r\n        const M = Random.monom({\r\n            letters: 'xyz',\r\n            degree: 5,\r\n            fraction: false,\r\n            zero: false\r\n        });\r\n\r\n        expect(M.coefficient.isZero()).to.be.false\r\n        expect(M.degree().value).to.be.greaterThan(0)\r\n    });\r\n})\r\n\r\ndescribe('Monom with fraction power', () => {\r\n    it('should create a numerical expression', () => {\r\n        const inputStr: string = '-1/5x^(2/3)'\r\n        const M = new Monom(inputStr),\r\n            N = new Monom('7x^(4/5)')\r\n\r\n        M.multiply(N.clone())\r\n\r\n        expect(M.tex).to.be.equal('-\\\\frac{ 7 }{ 5 }x^{\\\\tfrac{ 22 }{ 15 }}')\r\n    })\r\n\r\n    it('should show a monom with sqrt', function () {\r\n        let m = new MonomE('3x^(1/2)')\r\n        m.letters('x', '\\\\sqrt{2}')\r\n\r\n        console.log(m.tex)\r\n    });\r\n})
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/algebra/monom.test.ts b/tests/algebra/monom.test.ts
--- a/tests/algebra/monom.test.ts	
+++ b/tests/algebra/monom.test.ts	
@@ -1,85 +1,9 @@
-import {expect} from 'chai';
-import {Random} from "../../src/maths/randomization/random";
 import {describe} from "mocha";
-import {Monom, MonomE} from "../../src/maths/algebra/monom";
-
-describe('Monom with integer power', () => {
-    it('parsing', () => {
-        const M0a = new Monom('3');
-        expect(M0a.tex).to.be.equal('3')
-
-        const M0b = new Monom('x');
-        expect(M0b.tex).to.be.equal('x')
-
-        const M0c = new Monom('3x');
-        expect(M0c.tex).to.be.equal('3x')
-
-        const M1 = new Monom('3x^5');
-        expect(M1.tex).to.be.equal('3x^{5}')
+import {Monom} from "../../src/maths/algebra/monom";
 
-        const M2 = new Monom('2/3x^2yz^3y^4')
-        expect(M2.display).to.be.equal('2/3x^(2)y^(5)z^(3)')
-
-        const M3 = new Monom('-3x^(-2)')
-        expect(M3.tex).to.be.equal('-3x^{-2}')
-
-        const M4 = new Monom('3x^(2/3)')
-        expect(M4.tex).to.be.equal('3x^{\\tfrac{ 2 }{ 3 }}')
-
-        const M5 = new Monom('-3x^(-2/3)y^(-5)8x^3')
-        expect(M5.tex).to.be.equal('-24x^{\\tfrac{ 7 }{ 3 }}y^{-5}')
+describe('Monom tests', () => {
+    it('Monom can be parsed from a string', () => {
+        let m = new Monom()
     })
 
-    it('basic operations', () => {
-        const M1 = new Monom('3x'),
-            M2 = new Monom('2x')
-
-        expect(M1.clone().add(M2).isEqual(new Monom('5x'))).to.be.true
-        expect(M1.clone().subtract(M2).isEqual(new Monom('x'))).to.be.true
-        expect(M1.clone().multiply(M2).isEqual(new Monom('6x^2'))).to.be.true
-        expect(M1.clone().divide(M2).isEqual(new Monom('3/2'))).to.be.true
-    })
-
-    it('derivative', () => { // the single test
-        const options = new Monom('7x^3'); // this will be your class
-
-        expect(options.tex).to.be.equal('7x^{3}')
-        expect(options.derivative().tex).to.be.equal('21x^{2}');
-    });
-
-    it('integrate', () => { // the single test
-        const options = new Monom('7x^3'); // this will be your class
-        expect(options.primitive().display).to.be.equal('7/4x^(4)');
-    });
-
-    it('randomize', function () {
-        const M = Random.monom({
-            letters: 'xyz',
-            degree: 5,
-            fraction: false,
-            zero: false
-        });
-
-        expect(M.coefficient.isZero()).to.be.false
-        expect(M.degree().value).to.be.greaterThan(0)
-    });
-})
-
-describe('Monom with fraction power', () => {
-    it('should create a numerical expression', () => {
-        const inputStr: string = '-1/5x^(2/3)'
-        const M = new Monom(inputStr),
-            N = new Monom('7x^(4/5)')
-
-        M.multiply(N.clone())
-
-        expect(M.tex).to.be.equal('-\\frac{ 7 }{ 5 }x^{\\tfrac{ 22 }{ 15 }}')
-    })
-
-    it('should show a monom with sqrt', function () {
-        let m = new MonomE('3x^(1/2)')
-        m.letters('x', '\\sqrt{2}')
-
-        console.log(m.tex)
-    });
 })
\ No newline at end of file
Index: src/maths/coefficients/fraction.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {CoefficientCore, FRACTION_FRAC} from \"./coefficientCore\";\r\n\r\n/**\r\n * The fraction class\r\n */\r\n\r\nexport class Fraction extends CoefficientCore<Fraction> {\r\n    constructor(value?: number | string | Fraction, denominator?: number | string) {\r\n        super()\r\n        // Default values.\r\n        this.numerator = 1;\r\n        this.denominator = 1;\r\n\r\n        this.fracType = FRACTION_FRAC.frac\r\n\r\n        if (value !== undefined) {\r\n            if (value instanceof Fraction) return this.parse(value)\r\n            return this.parse(value, denominator)\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    get tex(): string {\r\n        const frac = this.fracTeX\r\n        // restore the frac type to default\r\n        this.fracType = FRACTION_FRAC.frac\r\n\r\n        if (this.isInfinity()) {\r\n            return `${this.signTeX}\\\\infty`\r\n        }\r\n\r\n        if (this.isExact()) {\r\n            if (this.denominator === 1) {\r\n                return `${this.numerator}`;\r\n            } else if (this.numerator < 0) {\r\n                return `-${frac}{ ${-this.numerator} }{ ${this.denominator} }`;\r\n            } else {\r\n                return `${frac}{ ${this.numerator} }{ ${this.denominator} }`;\r\n            }\r\n        } else {\r\n            return this.value.toFixed(3)\r\n        }\r\n    }\r\n\r\n    get display(): string {\r\n        if (this.isInfinity()) {\r\n            return `${this.signTeX}\\\\infty`\r\n        }\r\n\r\n        if (this.isExact()) {\r\n            if (this.denominator === 1) {\r\n                return `${this.numerator}`;\r\n            } else if (this.numerator < 0) {\r\n                return `-${-this.numerator}/${this.denominator}`;\r\n            } else {\r\n                return `${this.numerator}/${this.denominator}`;\r\n            }\r\n        } else {\r\n            return this.value.toFixed(3)\r\n        }\r\n    }\r\n\r\n    createInstance(value?: string | number | Fraction): Fraction {\r\n        return new Fraction(value)\r\n    }\r\n\r\n    clone = (): Fraction => {\r\n        return new Fraction(this.numerator, this.denominator)\r\n    };\r\n\r\n    reduce = (): Fraction => {\r\n        const {N, D} = this.getReducedCoefficient()\r\n        this.numerator = N\r\n        this.denominator = D\r\n        return this;\r\n    };\r\n\r\n    add = (...values: (Fraction | number | string)[]): Fraction => {\r\n        for (let F of values) {\r\n            if (!(F instanceof Fraction)) F = new Fraction(F)\r\n\r\n            let N: number = this.numerator,\r\n                D: number = this.denominator;\r\n\r\n            this.numerator = N * F.denominator + F.numerator * D;\r\n            this.denominator = D * F.denominator;\r\n        }\r\n\r\n        return this.reduce();\r\n    };\r\n\r\n    multiply = (...values: (Fraction | number)[]): Fraction => {\r\n        // Parse the value.\r\n        // If it's a fraction, return a clone of it\r\n        // If it's an integer, return the fraction F/1\r\n        for (let F of values) {\r\n            if (!(F instanceof Fraction)) {\r\n                F = new Fraction(F)\r\n            }\r\n\r\n            this.numerator = this.numerator * F.numerator;\r\n            this.denominator = this.denominator * F.denominator;\r\n        }\r\n\r\n        return this\r\n    };\r\n\r\n    invert = (): Fraction => {\r\n        let n = +this.numerator, d = +this.denominator;\r\n        this.numerator = d;\r\n        this.denominator = n;\r\n\r\n        return this;\r\n    }\r\n\r\n    root = (p: number): Fraction => {\r\n        // TODO: index - root of a fraction => this will return another type of coefficient.\r\n\r\n        // Check if they are perfect roots..\r\n        if (p === 0) {\r\n            return this;\r\n        }\r\n\r\n        // If negative, invert the fraction\r\n        if (p < 0) {\r\n            this.invert()\r\n        }\r\n\r\n        let n = Math.pow(this.numerator, Math.abs(1 / p)),\r\n            d = Math.pow(this.denominator, Math.abs(1 / p));\r\n\r\n        this.numerator = Math.pow(this.numerator, Math.abs(1 / p));\r\n        this.denominator = Math.pow(this.denominator, Math.abs(1 / p));\r\n        return this;\r\n    }\r\n\r\n    static decimalToFraction = (value: string | number | Fraction): [number, number] => {\r\n        // Return the neutral element\r\n        if (value === undefined) return [1, 1]\r\n\r\n        // Return the numerator and denominator if it's already a fraction\r\n        if (value instanceof Fraction) return [value.numerator, value.denominator]\r\n\r\n        // Split the value into unit and decimal part\r\n        let [unit, decimal] = (+value).toString().split('.')\r\n\r\n        // Return the unit if there is no decimal part\r\n        if (decimal === undefined) return [+unit, 1]\r\n\r\n        let decimalLength = decimal.length\r\n\r\n        return [+(unit + decimal), 10 ** decimalLength]\r\n    }\r\n\r\n    static average = (...fractions: (Fraction | number)[]): Fraction => {\r\n        let M = new Fraction().zero()\r\n\r\n        for (let f of fractions) {\r\n            M.add(f)\r\n        }\r\n\r\n        M.divide(fractions.length)\r\n\r\n        return M\r\n    }\r\n\r\n    /**\r\n     * Parse the value to get the numerator and denominator\r\n     * @param value : number or string to parse to get the fraction\r\n     * @param denominatorOrPeriodic (optional|number) : length of the periodic part: 2.333333 => 1 or denominator value\r\n     */\r\n    parse(value: Fraction): Fraction\r\n\r\n    parse(value: string | number): Fraction\r\n\r\n\r\n    // pow = (p: number | Fraction): Fraction => {\r\n    //     // TODO: Fraction.pow with a value different than a safe integer !\r\n    //     if (p instanceof Fraction) {\r\n    //         return this.pow(p.value)\r\n    //     }\r\n    //\r\n    //     this.reduce();\r\n    //     if (p < 0) {\r\n    //         this.invert()\r\n    //     }\r\n    //\r\n    //     // Check if numerator and denominator are roots of...\r\n    //     // othervise, convert to numeric.\r\n    //     let controlNumerator = Math.floor(Math.pow(this.numerator, Math.abs(p))),\r\n    //         controlDenominator = Math.floor(Math.pow(this.denominator, Math.abs(p)))\r\n    //\r\n    //     if (controlNumerator ** Math.abs(p) === this.numerator\r\n    //         &&\r\n    //         controlDenominator ** Math.abs(p) === this.denominator) {\r\n    //\r\n    //         this.numerator = this.numerator ** Math.abs(p);\r\n    //         this.denominator = this.denominator ** Math.abs(p);\r\n    //     } else {\r\n    //         this.numerator = this.numerator ** Math.abs(p);\r\n    //         this.denominator = this.denominator ** Math.abs(p);\r\n    //     }\r\n    //\r\n    //     return this;\r\n    // };\r\n\r\n    parse(value: string | number, denominator: string | number): Fraction\r\n\r\n    parse(value: string | number | Fraction, denominator ?: string | number): Fraction {\r\n        // Default values\r\n        this.numerator = 0;\r\n        this.denominator = 1;\r\n\r\n        // A null value means a zero fraction.\r\n        if (value === null || value === \"\") return this;\r\n\r\n        // No denominator given\r\n        if (denominator === undefined) {\r\n            if (value instanceof Fraction) return value.clone()\r\n\r\n            if (typeof value === \"number\") {\r\n                return new Fraction(value, 1)\r\n            }\r\n\r\n            // a value of type string can be:\r\n            // - an integer number  4\r\n            // - a decimal number   4.12\r\n            // - a fraction         4/5\r\n            // - a decimal fraction 4.12/5.12\r\n            if (typeof value === \"string\") {\r\n                const [N, D] = value.split('/')\r\n                return new Fraction(N, D === undefined ? 1 : D)\r\n            }\r\n        }\r\n\r\n        // Denominator given\r\n        if (+denominator === 0) {\r\n            this.numerator = Infinity\r\n            return this\r\n        }\r\n\r\n        const [N1, D1] = Fraction.decimalToFraction(value)\r\n        const [N2, D2] = Fraction.decimalToFraction(denominator)\r\n\r\n        this.numerator = N1 * D2\r\n        this.denominator = D1 * N2\r\n\r\n        if (D1 > 1 || D2 > 1) this.reduce()\r\n        return this\r\n    }\r\n\r\n    amplify = (k: number): Fraction => {\r\n        if (Number.isSafeInteger(k)) {\r\n            this.numerator *= k;\r\n            this.denominator *= k;\r\n        }\r\n        return this;\r\n    };\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/maths/coefficients/fraction.ts b/src/maths/coefficients/fraction.ts
--- a/src/maths/coefficients/fraction.ts	
+++ b/src/maths/coefficients/fraction.ts	
@@ -13,69 +13,50 @@
 
         this.fracType = FRACTION_FRAC.frac
 
+        this.exact = true
+
         if (value !== undefined) {
-            if (value instanceof Fraction) return this.parse(value)
-            return this.parse(value, denominator)
+            if (value instanceof Fraction) return this._parse(value)
+            return this._parse(value, denominator)
         }
 
         return this;
     }
 
-    get tex(): string {
-        const frac = this.fracTeX
-        // restore the frac type to default
-        this.fracType = FRACTION_FRAC.frac
+    static decimalToFraction = (value: string | number | Fraction): [number, number] => {
+        // Return the neutral element
+        if (value === undefined) return [1, 1]
 
-        if (this.isInfinity()) {
-            return `${this.signTeX}\\infty`
-        }
+        // Return the numerator and denominator if it's already a fraction
+        if (value instanceof Fraction) return [value.numerator, value.denominator]
 
-        if (this.isExact()) {
-            if (this.denominator === 1) {
-                return `${this.numerator}`;
-            } else if (this.numerator < 0) {
-                return `-${frac}{ ${-this.numerator} }{ ${this.denominator} }`;
-            } else {
-                return `${frac}{ ${this.numerator} }{ ${this.denominator} }`;
-            }
-        } else {
-            return this.value.toFixed(3)
-        }
-    }
+        // Split the name into unit and decimal part
+        let [unit, decimal] = (+value).toString().split('.')
 
-    get display(): string {
-        if (this.isInfinity()) {
-            return `${this.signTeX}\\infty`
-        }
+        // Return the unit if there is no decimal part
+        if (decimal === undefined) return [+unit, 1]
+
+        let decimalLength = decimal.length
 
-        if (this.isExact()) {
-            if (this.denominator === 1) {
-                return `${this.numerator}`;
-            } else if (this.numerator < 0) {
-                return `-${-this.numerator}/${this.denominator}`;
-            } else {
-                return `${this.numerator}/${this.denominator}`;
-            }
-        } else {
-            return this.value.toFixed(3)
+        return [+(unit + decimal), 10 ** decimalLength]
+    }
+
+    static average = (...fractions: (Fraction | number)[]): Fraction => {
+        let M = new Fraction().zero()
+
+        for (let f of fractions) {
+            M.add(f)
         }
+
+        M.divide(fractions.length)
+
+        return M
     }
 
     createInstance(value?: string | number | Fraction): Fraction {
         return new Fraction(value)
     }
 
-    clone = (): Fraction => {
-        return new Fraction(this.numerator, this.denominator)
-    };
-
-    reduce = (): Fraction => {
-        const {N, D} = this.getReducedCoefficient()
-        this.numerator = N
-        this.denominator = D
-        return this;
-    };
-
     add = (...values: (Fraction | number | string)[]): Fraction => {
         for (let F of values) {
             if (!(F instanceof Fraction)) F = new Fraction(F)
@@ -91,7 +72,7 @@
     };
 
     multiply = (...values: (Fraction | number)[]): Fraction => {
-        // Parse the value.
+        // Parse the name.
         // If it's a fraction, return a clone of it
         // If it's an integer, return the fraction F/1
         for (let F of values) {
@@ -115,104 +96,98 @@
     }
 
     root = (p: number): Fraction => {
-        // TODO: index - root of a fraction => this will return another type of coefficient.
+        // The indice cannot be negative.
+        if (p < 0) {
+            throw ("cannot make the root with a negative indice.")
+        }
 
-        // Check if they are perfect roots..
+        // Power of zero => return one.
         if (p === 0) {
-            return this;
+            return this.one();
         }
 
-        // If negative, invert the fraction
-        if (p < 0) {
-            this.invert()
+        // Power of one => return this
+        if (p === 1) {
+            return this
         }
-
-        let n = Math.pow(this.numerator, Math.abs(1 / p)),
-            d = Math.pow(this.denominator, Math.abs(1 / p));
 
         this.numerator = Math.pow(this.numerator, Math.abs(1 / p));
         this.denominator = Math.pow(this.denominator, Math.abs(1 / p));
+
+        if (!Number.isSafeInteger(this.numerator) || !Number.isSafeInteger(this.denominator)) {
+            this.exact = false
+            this.numerator = this.numerator / this.denominator
+            this.denominator = 1
+        }
         return this;
     }
 
-    static decimalToFraction = (value: string | number | Fraction): [number, number] => {
-        // Return the neutral element
-        if (value === undefined) return [1, 1]
+    reduce = (): Fraction => {
+        const {N, D} = this.getReducedCoefficient()
+        this.numerator = N
+        this.denominator = D
+        return this;
+    };
 
-        // Return the numerator and denominator if it's already a fraction
-        if (value instanceof Fraction) return [value.numerator, value.denominator]
+    clone = (): Fraction => {
+        return new Fraction(this.numerator, this.denominator)
+    };
 
-        // Split the value into unit and decimal part
-        let [unit, decimal] = (+value).toString().split('.')
+    get tex(): string {
+        const frac = this.fracTeX
+        // restore the frac type to default
+        this.fracType = FRACTION_FRAC.frac
 
-        // Return the unit if there is no decimal part
-        if (decimal === undefined) return [+unit, 1]
+        if (this.isInfinity()) {
+            return `${this.signTeX}\\infty`
+        }
 
-        let decimalLength = decimal.length
-
-        return [+(unit + decimal), 10 ** decimalLength]
+        if (this.isExact()) {
+            if (this.denominator === 1) {
+                return `${this.numerator}`;
+            } else if (this.numerator < 0) {
+                return `-${frac}{ ${-this.numerator} }{ ${this.denominator} }`;
+            } else {
+                return `${frac}{ ${this.numerator} }{ ${this.denominator} }`;
+            }
+        } else {
+            return this.value.toFixed(3)
+        }
     }
 
-    static average = (...fractions: (Fraction | number)[]): Fraction => {
-        let M = new Fraction().zero()
+    get display(): string {
+        if (this.isInfinity()) return `${this.signTeX}oo`
 
-        for (let f of fractions) {
-            M.add(f)
+        if (this.isExact()) {
+            if (this.denominator === 1) {
+                return `${this.numerator}`;
+            } else if (this.numerator < 0) {
+                return `-${-this.numerator}/${this.denominator}`;
+            } else {
+                return `${this.numerator}/${this.denominator}`;
+            }
+        } else {
+            return this.value.toFixed(3)
         }
-
-        M.divide(fractions.length)
-
-        return M
     }
 
     /**
-     * Parse the value to get the numerator and denominator
-     * @param value : number or string to parse to get the fraction
-     * @param denominatorOrPeriodic (optional|number) : length of the periodic part: 2.333333 => 1 or denominator value
+     * Parse the name to get the numerator and denominator
+     * @param value : number or string to _parse to get the fraction
+     * @param denominatorOrPeriodic (optional|number) : length of the periodic part: 2.333333 => 1 or denominator name
      */
-    parse(value: Fraction): Fraction
-
-    parse(value: string | number): Fraction
+    protected _parse(value: Fraction): Fraction
 
+    protected _parse(value: string | number): Fraction
 
-    // pow = (p: number | Fraction): Fraction => {
-    //     // TODO: Fraction.pow with a value different than a safe integer !
-    //     if (p instanceof Fraction) {
-    //         return this.pow(p.value)
-    //     }
-    //
-    //     this.reduce();
-    //     if (p < 0) {
-    //         this.invert()
-    //     }
-    //
-    //     // Check if numerator and denominator are roots of...
-    //     // othervise, convert to numeric.
-    //     let controlNumerator = Math.floor(Math.pow(this.numerator, Math.abs(p))),
-    //         controlDenominator = Math.floor(Math.pow(this.denominator, Math.abs(p)))
-    //
-    //     if (controlNumerator ** Math.abs(p) === this.numerator
-    //         &&
-    //         controlDenominator ** Math.abs(p) === this.denominator) {
-    //
-    //         this.numerator = this.numerator ** Math.abs(p);
-    //         this.denominator = this.denominator ** Math.abs(p);
-    //     } else {
-    //         this.numerator = this.numerator ** Math.abs(p);
-    //         this.denominator = this.denominator ** Math.abs(p);
-    //     }
-    //
-    //     return this;
-    // };
+    protected _parse(value: string | number, denominator: string | number): Fraction
 
-    parse(value: string | number, denominator: string | number): Fraction
-
-    parse(value: string | number | Fraction, denominator ?: string | number): Fraction {
+    protected _parse(value: string | number | Fraction, denominator ?: string | number): Fraction {
         // Default values
         this.numerator = 0;
         this.denominator = 1;
 
-        // A null value means a zero fraction.
+        // A null name means a zero fraction.
         if (value === null || value === "") return this;
 
         // No denominator given
@@ -223,7 +198,7 @@
                 return new Fraction(value, 1)
             }
 
-            // a value of type string can be:
+            // a name of type string can be:
             // - an integer number  4
             // - a decimal number   4.12
             // - a fraction         4/5
@@ -250,12 +225,4 @@
         return this
     }
 
-    amplify = (k: number): Fraction => {
-        if (Number.isSafeInteger(k)) {
-            this.numerator *= k;
-            this.denominator *= k;
-        }
-        return this;
-    };
-
 }
\ No newline at end of file
Index: src/maths/algebra/monom.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/***\r\n * Monom class\r\n * The monom class represents of monom of the form:\r\n * k * x^n * y^m * z^p\r\n * k: Coefficient\r\n * n, m, p: powers as Fraction\r\n * x, y, z: letters as string\r\n */\r\nimport {Numeric} from \"../numeric\";\r\nimport {Shutingyard, ShutingyardType, Token} from \"../shutingyard\";\r\nimport {COMPARESIGNS, literalType} from \"../types\";\r\nimport {RootFraction} from \"../coefficients/rootFraction\";\r\nimport {\r\n    COEFFICIENT_MODE,\r\n    CoefficientCore,\r\n    CoefficientParserTypes,\r\n    CoefficientTypes\r\n} from \"../coefficients/coefficientCore\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\n\r\nexport class Monom {\r\n    private _coefficientMode: COEFFICIENT_MODE\r\n\r\n    /**\r\n     * Create a Monom\r\n     * Defined as \\\\(k \\\\cdot x^{n}\\\\), where \\\\( k,n \\in \\\\mathbb{Q}\\\\).\r\n     * Examples: \\\\(3x^2\\\\) or \\\\(3/5x^2\\\\)\r\n     * @param value (optional) string The value that should be parse. Can be a Monom, a Fraction, a string or a number. If nothing is provided, it will return the trivial monom (0).\r\n     */\r\n    constructor(value?: unknown) {\r\n        this.zero();\r\n\r\n        if (value !== undefined) {\r\n            // A string is given - try to parse the value.\r\n            this.parse(value);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n\r\n    private _coefficient: CoefficientCore<any>;\r\n\r\n    // ------------------------------------------\r\n    /**\r\n     * Get the coefficient \\\\(k\\\\) of the Monom \\\\(k\\\\cdot x^{n}\\\\)\r\n     * @returns {Fraction}\r\n     */\r\n    get coefficient(): CoefficientCore<any> {\r\n        return this._coefficient;\r\n    }\r\n\r\n    /**\r\n     * Set the coefficient \\\\(k\\\\) value of the monom\r\n     * @param {Fraction | number | string} F\r\n     */\r\n    set coefficient(F: CoefficientParserTypes) {\r\n        this._coefficient = this.makeCoefficient(F);\r\n    }\r\n\r\n    private _literal: literalType;\r\n\r\n    /**\r\n     * Get the literal part of \\\\(x^{n_1}y^{n_2}\\\\) as dictionary \\\\[\\\\begin{array}{ll}x&=n_1\\\\\\\\y&=n_2\\\\end{array}\\\\]\r\n     * @returns {literalType}\r\n     */\r\n    get literal(): literalType {\r\n        return this._literal;\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom. Must be a dictionary {x: Fraction, y: Fraction, ...}\r\n     * @param {literalType} L\r\n     */\r\n    set literal(L: literalType) {\r\n        this._literal = L;\r\n    }\r\n\r\n    /**\r\n     * Get the literal square roots of the Monom.\r\n     * TODO: remove this getter ? Is it used and is it correct ?\r\n     * @returns {literalType}\r\n     */\r\n    get literalSqrt(): literalType {\r\n        if (this.isLiteralSquare()) {\r\n            let L: literalType = {}\r\n            for (let key in this._literal) {\r\n                L[key] = this._literal[key].clone().sqrt()\r\n            }\r\n            return L;\r\n        } else {\r\n            return this._literal;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom from a string\r\n     * @param inputStr  String like x^2y^3\r\n     */\r\n    set literalStr(inputStr: string) {\r\n        // TODO : parse using shutingyard tree !\r\n\r\n        // Match all x^n\r\n        for (const v of [...inputStr.matchAll(/([a-z])\\^([+-]?[0-9]+)/g)]) {\r\n            // Create the default letter entry if necessary.\r\n            if (!(v[1] in this._literal)) {\r\n                this._literal[v[1]] = this.makeCoefficient().zero();\r\n            }\r\n\r\n            // Add the new value.\r\n            // TODO: actually, it adds only numeric value\r\n            this._literal[v[1]].add(+v[2]);\r\n        }\r\n\r\n        // Match all x\r\n        for (const v of [...inputStr.matchAll(/([a-z](?!\\^))/g)]) {\r\n            // Match all single letters\r\n            if (!(v[1] in this._literal)) {\r\n                this._literal[v[1]] = this.makeCoefficient().zero();\r\n            }\r\n\r\n            // Add one to the value.\r\n            this._literal[v[1]].add(1)\r\n        }\r\n    }\r\n\r\n    // Getter helpers.\r\n    /**\r\n     * Get the variables letters\r\n     */\r\n    get variables(): string[] {\r\n        let M = this.clone().clean();\r\n        return Object.keys(M.literal)\r\n    }\r\n\r\n    // Display getter\r\n    /**\r\n     * This display getter is to be used in the polynom display getter\r\n     */\r\n    get display(): string {\r\n        let L: string = '',\r\n            letters = Object.keys(this._literal).sort()\r\n        for (let letter of letters) {\r\n            if (!this._literal[letter].isZero()) {\r\n                L += `${letter}`;\r\n                if (!this._literal[letter].isEqualTo(1)) {\r\n                    L += `^(${this._literal[letter].display})`;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.display}`;\r\n            } else {\r\n                return '';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.display}${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    get dividers(): Monom[] {\r\n        // Decompose only if the coefficient is a natural number\r\n        if (!this.coefficient.isRelative()) {\r\n            return [this.clone()]\r\n        }\r\n\r\n\r\n        // Decompose only if the power values are natural numbers.\r\n        if (this.hasFractionCoefficient()) {\r\n            return [this.clone()]\r\n        }\r\n\r\n        // Security : do not do this if isGreaterThan than 10000\r\n        if (this.coefficient.numerator > 1000000) {\r\n            return [this.clone()]\r\n        }\r\n\r\n        const dividers = Numeric.dividers(Math.abs(this.coefficient.numerator))\r\n\r\n        // Decompose the literals parts.\r\n        let literals: literalType[] = [];\r\n        for (let L in this.literal) {\r\n            // L is the letter.\r\n            literals = this._getLiteralDividers(literals, L)\r\n        }\r\n\r\n        const monomDividers: Monom[] = [];\r\n        if (literals.length > 0 && dividers.length > 0) {\r\n            for (let N of dividers) {\r\n                for (let L of literals) {\r\n                    let M = new Monom();\r\n                    M.coefficient = this.makeCoefficient(N)\r\n                    M.literal = L\r\n                    monomDividers.push(M)\r\n                }\r\n            }\r\n        } else if (dividers.length === 0) {\r\n            for (let L of literals) {\r\n                let M = new Monom();\r\n                M.coefficient = this.makeCoefficient().one()\r\n                M.literal = L\r\n                monomDividers.push(M)\r\n            }\r\n        } else {\r\n            for (let N of dividers) {\r\n                let M = new Monom();\r\n                M.coefficient = this.makeCoefficient(N)\r\n                monomDividers.push(M)\r\n            }\r\n        }\r\n\r\n        return monomDividers.length === 0 ? [new Monom().one()] : monomDividers;\r\n    }\r\n\r\n    /**\r\n     * Display the monom, forcing the '+' sign to appear\r\n     */\r\n    get displayWithSign(): string {\r\n        let d: String = this.display;\r\n        return (d[0] !== '-' ? '+' : '') + d;\r\n    }\r\n\r\n    get texWithSign(): string {\r\n        if (this.coefficient.isStrictlyPositive()) {\r\n            return '+' + this.tex\r\n        }\r\n\r\n        return this.tex\r\n    }\r\n\r\n    get plotFunction(): string {\r\n\r\n        let L: string = '',\r\n            letters = Object.keys(this._literal).sort()\r\n\r\n        for (let letter of letters) {\r\n            if (!this._literal[letter].isZero()) {\r\n                L += (L === '' ? \"\" : \"*\") + `${letter}`\r\n                if (!this._literal[letter].isEqualTo(1)) {\r\n                    L += `^(${this._literal[letter].display})`;\r\n                }\r\n            }\r\n        }\r\n\r\n        // No literal part\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.display}`;\r\n            } else {\r\n                return '';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.display}*${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n\r\n    /**\r\n     * Get the tex output of the monom\r\n     */\r\n    get tex(): string {\r\n        // TODO: display with square root !\r\n        let L: string = '',\r\n            letters = Object.keys(this._literal).sort()\r\n\r\n        for (let letter of letters) {\r\n            if (!this._literal[letter].isZero()) {\r\n                L += `${letter}`;\r\n                if (!this._literal[letter].isEqualTo(1)) {\r\n                    L += `^{${this._literal[letter].asTopFraction().tex}}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.tex}`;\r\n            } else {\r\n                return '0';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.tex}${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the least common multiple of monoms\r\n     * @param monoms    Array of monoms\r\n     */\r\n    static lcm = (...monoms: Monom[]): Monom => {\r\n        // All the monoms must be with natural powers...\r\n        for (let m of monoms) {\r\n            if (m.hasFractionCoefficient()) {\r\n                return new Monom().zero()\r\n            }\r\n        }\r\n\r\n\r\n        let M = new Monom(),\r\n            coeffN: number[] = monoms.map(value => value.coefficient.numerator),\r\n            coeffD: number[] = monoms.map(value => value.coefficient.denominator),\r\n            n = Numeric.gcd(...coeffN),\r\n            d = Numeric.lcm(...coeffD);\r\n\r\n        // Get the coefficient.\r\n        M.coefficient = this.makeCoefficient(n, d).reduce();\r\n\r\n        // Set the literal parts - go through each monoms literal parts and get only the lowest degree of each letters.\r\n        for (let m of monoms) {\r\n            // Remove the inexistant letters from the resulting monom\r\n            for (let letter in M.literal) {\r\n                if (!(letter in m.literal)) {\r\n                    M.literal[letter].zero();\r\n                }\r\n            }\r\n            for (let letter in m.literal) {\r\n                if (M.literal[letter] === undefined && m.literal[letter].isStrictlyPositive()) {\r\n                    M.literal[letter] = m.literal[letter].clone();\r\n                } else {\r\n                    M.literal[letter] = this.makeCoefficient(Math.min(m.literal[letter].value, M.literal[letter].value))\r\n                }\r\n            }\r\n        }\r\n\r\n        return M;\r\n    };\r\n\r\n    /**\r\n     * Multiply two monoms and return a NEW monom.\r\n     * @param monoms\r\n     */\r\n    static xmultiply = (...monoms: Monom[]): Monom => {\r\n        let M = new Monom().one();\r\n\r\n        for (let m of monoms) {\r\n            M.multiply(m);\r\n        }\r\n\r\n        return M;\r\n    };\r\n\r\n    makeCoefficient = (...values: CoefficientParserTypes[]): CoefficientTypes => {\r\n        if (this._coefficientMode === COEFFICIENT_MODE.FRACTION) {\r\n            return new Fraction(...values as (Fraction | string | number)[])\r\n        } else if (this._coefficientMode === COEFFICIENT_MODE.ROOT) {\r\n            return new RootFraction(...values as (RootFraction | Fraction | string | number)[])\r\n        }\r\n\r\n        // TODO: add the other modes\r\n        return new Fraction(...values as (Fraction | string | number)[])\r\n    }\r\n\r\n// -----------------------------------------\r\n    /**\r\n     * Parse a string to a monom. The string may include fraction.\r\n     * @param inputStr\r\n     */\r\n    parse = (inputStr: unknown): Monom => {\r\n\r\n        if (typeof inputStr === 'string') {\r\n            this._shutingYardToReducedMonom(inputStr)\r\n        } else if (typeof inputStr === 'number') {\r\n            this._coefficient = this.makeCoefficient(inputStr)\r\n            this._literal = {}\r\n        } else if (inputStr instanceof Fraction) {\r\n            this._coefficient = inputStr.clone()\r\n            this._literal = {}\r\n        } else if (inputStr instanceof RootFraction) {\r\n            this._coefficient = inputStr.clone()\r\n            this._literal = {}\r\n        } else if (inputStr instanceof Monom) {\r\n            this._coefficient = inputStr._coefficient.clone()\r\n            this._literal = this.copyLiterals(inputStr.literal)\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    addToken = (stack: Monom[], element: Token): void => {\r\n\r\n        let q1: Monom, q2: Monom, m: Monom, letter: string, pow: CoefficientCore<any>\r\n\r\n        if (element.tokenType === ShutingyardType.COEFFICIENT) {\r\n            stack.push(new Monom(this.makeCoefficient(element.token)))\r\n\r\n        } else if (element.tokenType === ShutingyardType.VARIABLE) {\r\n            let M = new Monom().one()\r\n            M.setLetter(element.token, 1)\r\n            stack.push(M.clone())\r\n\r\n        } else if (element.tokenType === ShutingyardType.OPERATION) {\r\n            switch (element.token) {\r\n                case '-':\r\n                    // this should only happen for negative powers or for negative coefficient.\r\n                    q2 = (stack.pop()) || new Monom().zero()\r\n                    q1 = (stack.pop()) || new Monom().zero()\r\n\r\n                    stack.push(q1.subtract(q2))\r\n\r\n                    break;\r\n                case '*':\r\n                    // Get the last element in the stack\r\n                    q2 = (stack.pop()) || new Monom().one()\r\n                    q1 = (stack.pop()) || new Monom().one()\r\n\r\n                    stack.push(q1.multiply(q2))\r\n                    break\r\n                case '/':\r\n                    // Get the last element in the stack\r\n                    q2 = (stack.pop()) || new Monom().one()\r\n                    q1 = (stack.pop()) || new Monom().one()\r\n\r\n                    stack.push(q1.divide(q2))\r\n                    break\r\n                case '^':\r\n                    // get the two last elements in the stack\r\n                    pow = (stack.pop().coefficient) || this.makeCoefficient().one()\r\n                    m = (stack.pop()) || new Monom().one()\r\n\r\n                    letter = m.variables[0]\r\n\r\n                    if (letter !== undefined) {\r\n                        m.setLetter(letter, pow)\r\n                    }\r\n\r\n                    stack.push(m)\r\n                    // this.multiply(m.clone())\r\n                    break\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current Monom.\r\n     */\r\n    clone = (): Monom => {\r\n        let F: Monom = new Monom();\r\n\r\n        F.coefficient = this._coefficient.clone();\r\n\r\n        // Copy the literal parts.\r\n        for (let k in this._literal) {\r\n            F.setLetter(k, this._literal[k].clone());\r\n        }\r\n        return F;\r\n    };\r\n\r\n    copyLiterals = (literal: literalType): literalType => {\r\n        let L: literalType = {}\r\n\r\n        for (let k in literal) {\r\n            L[k] = literal[k].clone()\r\n        }\r\n        return L\r\n    }\r\n\r\n    makeSame = (M: Monom): Monom => {\r\n        // Copy the literal parts.\r\n        for (let k in M._literal) {\r\n            this.setLetter(k, M._literal[k].clone());\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Create a zero value monom\r\n     */\r\n    zero = (): Monom => {\r\n        this._coefficient = this.makeCoefficient().zero();\r\n        this._literal = {};\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Create a one value monom\r\n     */\r\n    one = (): Monom => {\r\n        this._coefficient = this.makeCoefficient().one();\r\n        this._literal = {};\r\n        return this;\r\n    };\r\n\r\n// ------------------------------------------\r\n// Mathematical operations\r\n// ------------------------------------------\r\n\r\n    /**\r\n     * Clean the monom by removing each letters with a power of zero.\r\n     */\r\n    clean = (): Monom => {\r\n        for (let letter in this._literal) {\r\n            if (this._literal[letter].isZero()) {\r\n                delete this._literal[letter];\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    reduce = (): Monom => {\r\n        this.clean()\r\n        this.coefficient.reduce()\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Get the opposite\r\n     * Returns a monom.\r\n     */\r\n    opposed = (): Monom => {\r\n        this._coefficient.opposite();\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Add all similar monoms. If they aren't similar, they are simply skipped.\r\n     * @param M (Monom[]) The monoms to add.\r\n     */\r\n    add = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            if (this.isSameAs(m)) {\r\n                if (this.isZero()) {\r\n                    this.makeSame(m)\r\n                }\r\n                this._coefficient.add(m.coefficient);\r\n            } else {\r\n                console.log('Add monom: ' + this.display + ' is not similar with ', m.display);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Subtract multiple monoms\r\n     * @param M (Monom[]) The monoms to subtract\r\n     */\r\n    subtract = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            if (this.isSameAs(m)) {\r\n                if (this.isZero()) {\r\n                    this.makeSame(m)\r\n                }\r\n                this._coefficient.add(m.clone().coefficient.opposite());\r\n            } else {\r\n                console.log('Subtract: Is not similar: ', m.display);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Multiple multiple monoms to the current monom\r\n     * @param M (Monom[]) The monoms to multiply to.\r\n     */\r\n    multiply = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            // Multiply the coefficient.\r\n            this._coefficient.multiply(m.coefficient);\r\n\r\n            // Multiply the literal parts.\r\n            for (let letter in m.literal) {\r\n                if (this._literal[letter] === undefined) {\r\n                    this._literal[letter] = m.literal[letter].clone()\r\n                } else {\r\n                    this._literal[letter].add(m.literal[letter])\r\n                }\r\n\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    multiplyByNumber = (F: Fraction | number): Monom => {\r\n        this._coefficient.multiply(F);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Divide the current monoms by multiple monoms\r\n     * @param M (Monom[])\r\n     */\r\n    divide = (...M: Monom[]): Monom => {\r\n        // Depending on the given value, choose the current item\r\n        for (let v of M) {\r\n            // Divide the coefficient\r\n            this._coefficient.divide(v.coefficient);\r\n\r\n            // Subtract the power values\r\n            for (let letter in v.literal) {\r\n                this._literal[letter] = (this._literal[letter] === undefined) ? v.literal[letter].clone().opposite() : this._literal[letter].subtract(v.literal[letter])\r\n\r\n                // If the power of a particular setLetter is zero, delete it from the literal part..\r\n                if (this._literal[letter].isZero()) {\r\n                    delete this._literal[letter];\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Get the pow of a monom.\r\n     * @param nb (number) : Mathematical pow\r\n     */\r\n    pow = (nb: number | Fraction): Monom => {\r\n        this._coefficient.pow(nb);\r\n        for (let letter in this._literal) {\r\n            this._literal[letter].multiply(nb)\r\n        }\r\n        return this;\r\n    };\r\n\r\n// ------------------------------------------\r\n// Compare functions\r\n\r\n    /**\r\n     * Get the index-root of the monom\r\n     * @param p\r\n     */\r\n    root = (p: number): Monom => {\r\n        // TODO: determiner the index root of a monom\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Return the square root of a monom\r\n     */\r\n    sqrt = (): Monom => {\r\n        if (this.isSquare()) {\r\n            this._coefficient.sqrt();\r\n            for (let letter in this._literal) {\r\n                this._literal[letter].clone().divide(2)\r\n            }\r\n        }\r\n        return this.root(2);\r\n    }\r\n\r\n// ------------------------------------------\r\n    compare = (M: Monom, sign?: COMPARESIGNS): boolean => {\r\n        // TODO: Build the compare systems.\r\n        if (sign === undefined) {\r\n            sign = COMPARESIGNS.EQUALS;\r\n        }\r\n\r\n\r\n        switch (sign) {\r\n            case COMPARESIGNS.EQUALS:\r\n                // To be equal, they must be the isSame\r\n                if (!this.compare(M, COMPARESIGNS.SAME)) {\r\n                    return false;\r\n                }\r\n\r\n                // The literal parts are the isSame. The coefficient must be equal\r\n                return this._coefficient.isEqualTo(M.coefficient);\r\n            case COMPARESIGNS.SAME:\r\n                // Get the list of all variables from both monoms.\r\n                let M1: string[] = this.variables,\r\n                    M2: string[] = M.variables,\r\n                    K: string[] = M1.concat(M2.filter((item) => M1.indexOf(item) < 0));\r\n\r\n                if (M1.length === 0 && M2.length === 0) {\r\n                    return true\r\n                }\r\n                // To compare, both must be different than zero.\r\n                if (!this.isZero() && !M.isZero()) {\r\n                    for (let key of K) {\r\n                        // The setLetter is not available in one of the monom\r\n                        if (this._literal[key] === undefined || M.literal[key] === undefined) {\r\n                            return false;\r\n                        }\r\n                        // The setLetter does not have the isSame power in each monoms.\r\n                        if (!this._literal[key].isEqualTo(M.literal[key])) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // All are positive check - the monoms are the sames.\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is null\r\n     */\r\n    isZero()\r\n        :\r\n        boolean {\r\n        return this._coefficient.value === 0;\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is one\r\n     */\r\n    isOne()\r\n        :\r\n        boolean {\r\n        return this._coefficient.value === 1 && this.variables.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Determine if two monoms are equals\r\n     * @param M\r\n     */\r\n    isEqual = (M: Monom): boolean => {\r\n        return this.compare(M, COMPARESIGNS.EQUALS);\r\n    };\r\n\r\n    /**\r\n     * Determine if two monoms are similar\r\n     * @param M\r\n     */\r\n    isSameAs = (M: Monom): boolean => {\r\n        return this.compare(M, COMPARESIGNS.SAME);\r\n    };\r\n\r\n    isSquare = (): boolean => {\r\n        if (!this.coefficient.isSquare()) {\r\n            return false;\r\n        }\r\n        return this.isLiteralSquare();\r\n    }\r\n// ------------------------------------------\r\n// Misc monoms functions\r\n\r\n    isLiteralSquare = (): boolean => {\r\n        for (let letter in this.literal) {\r\n            // A literal square must have a natural power\r\n            if (this.literal[letter].isRational()) {\r\n                return false\r\n            }\r\n\r\n            // The natural power must be be even\r\n            if (this.literal[letter].isEven()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    hasFractionCoefficient = (): boolean => {\r\n        for (let letter in this._literal) {\r\n            if (this._literal[letter].isRational()) {\r\n                return true\r\n            }\r\n        }\r\n\r\n        return false\r\n    }\r\n\r\n// -------------------------------------\r\n    /**\r\n     * Determine if a monom contains a setLetter in it's literal part\r\n     * @param letter\r\n     */\r\n    hasLetter = (letter?: string): boolean => {\r\n        // The letter was not found\r\n        if (this._literal[letter === undefined ? 'x' : letter] === undefined) {\r\n            return false\r\n        }\r\n\r\n        // The letter is found and is not zero !\r\n        return !this._literal[letter === undefined ? 'x' : letter].isZero();\r\n    };\r\n\r\n    /**\r\n     * Set the power of a particular setLetter\r\n     * @param letter (string) Letter to change\r\n     * @param pow (number) Power of the setLetter (must be positive integer.\r\n     */\r\n    setLetter = (letter: string, pow: CoefficientCore<any> | number): void => {\r\n        if (pow instanceof CoefficientCore) {\r\n            // Set the power of the letter to zero => remove it\r\n            if (this.hasLetter(letter) && pow.isZero()) {\r\n                delete this._literal[letter]\r\n            }\r\n\r\n            this._literal[letter] = pow.clone()\r\n        } else {\r\n            this.setLetter(letter, this.makeCoefficient(pow))\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Get the degree of a monom. If no setLetter is given, the result will be the global degree.\r\n     * @param letter (string) Letter to get to degree (power)\r\n     */\r\n    degree = (letter?: string): CoefficientTypes => {\r\n        if (this.variables.length === 0) {\r\n            return this.makeCoefficient().zero();\r\n        }\r\n        if (letter === undefined) {\r\n            // Not setLetter given -> we get the global monom degree (sum of all the letters).\r\n            return Object.values(this._literal)\r\n                .reduce(\r\n                    (t, n) => t.clone().add(n)\r\n                );\r\n        } else {\r\n            // A setLetter is given -> get the corresponding power.\r\n            return this._literal[letter] === undefined ? this.makeCoefficient().zero() : this._literal[letter].clone();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Evaluate a monom. Each setLetter must be assigned to a Fraction.\r\n     * @param values    Dictionary of <setLetter: Fraction>\r\n     */\r\n    evaluate = (values?: literalType | Fraction | number): CoefficientCore<any> => {\r\n        let r = this.coefficient.clone();\r\n\r\n        if (typeof values === 'number' || values instanceof Fraction) {\r\n            let tmpValues: literalType = {}\r\n            tmpValues[this.variables[0]] = this.makeCoefficient(values)\r\n            return this.evaluate(tmpValues);\r\n        }\r\n\r\n        if (typeof values === 'object') {\r\n            if (this.variables.length === 0) {\r\n                return this.coefficient\r\n            }\r\n            for (let L in this._literal) {\r\n                if (values[L] === undefined) {\r\n                    return this.makeCoefficient().zero();\r\n                }\r\n\r\n                let value = this.makeCoefficient(values[L])\r\n\r\n                r.multiply(value.pow(this._literal[L]))\r\n            }\r\n        }\r\n\r\n        return r;\r\n    };\r\n\r\n    evaluateAsNumeric = (values: { [Key: string]: number } | number): number => {\r\n        let r = this.coefficient.value\r\n\r\n        if (typeof values === 'number') {\r\n            let tmpValues: { [Key: string]: number } = {}\r\n            tmpValues[this.variables[0]] = values\r\n            return this.evaluateAsNumeric(tmpValues);\r\n        }\r\n\r\n        if (typeof values === 'object') {\r\n            if (this.variables.length === 0) {\r\n                return this.coefficient.value\r\n            }\r\n            for (let L in this._literal) {\r\n                if (values[L] === undefined) {\r\n                    return 0;\r\n                }\r\n\r\n                r *= values[L] ** (this._literal[L].value)\r\n            }\r\n        }\r\n\r\n        return r\r\n    }\r\n// ----------------------------------------\r\n// Static functions\r\n// ----------------------------------------\r\n\r\n    /**\r\n     * Derivative the monom\r\n     * @param letter\r\n     */\r\n    derivative = (letter?: string): Monom => {\r\n        // No setLetter given - assume it's the setLetter 'x'\r\n        if (letter === undefined) {\r\n            letter = 'x';\r\n        }\r\n\r\n        if (this.hasLetter(letter)) {\r\n            let d = this._literal[letter].clone(),\r\n                dM = this.clone();\r\n\r\n            // Subtract one to the degree.\r\n            dM._literal[letter].subtract(1)\r\n\r\n            // Multiply the coefficient by the previous degree\r\n            dM._coefficient.multiply(this.makeCoefficient(d.clone()));\r\n            return dM;\r\n        } else {\r\n            return new Monom().zero();\r\n        }\r\n    };\r\n\r\n    primitive = (letter?: string): Monom => {\r\n        // TODO: derivative including the ln value => implies creating different monom system ?\r\n        if (letter === undefined) {\r\n            letter = 'x'\r\n        }\r\n\r\n        // Zero monom\r\n        let M = this.clone(), degree\r\n\r\n        if (M.hasLetter(letter)) {\r\n            degree = M.degree(letter).clone().add(1)\r\n            M.coefficient = M.coefficient.clone().divide(degree)\r\n            M.setLetter(letter, degree)\r\n        } else {\r\n            // There is no letter.\r\n\r\n            // The coefficient might be zero (=> x) or a number a (=> ax)\r\n            if (M.coefficient.isZero()) {\r\n                M.coefficient = this.makeCoefficient().one()\r\n            }\r\n            M.setLetter(letter, 1)\r\n        }\r\n\r\n        return M\r\n    }\r\n\r\n// TODO: The rest of the functions are not used or unnecessary ?\r\n    /**\r\n     * Determine if multiple monoms are similar\r\n     * @param M\r\n     */\r\n    areSameAs = (...M: Monom[]): boolean => {\r\n        let result: boolean = true;\r\n\r\n        // Check all monoms if they are the isSame as the \"this\" one.\r\n        for (let i = 0; i < M.length; i++) {\r\n            if (!this.isSameAs(M[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // All check passed -> all the monoms are similar.\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Determine if multiple monoms are equals\r\n     * @param M\r\n     */\r\n    areEquals = (...M: Monom[]): boolean => {\r\n        // They are not similar.\r\n        if (!this.areSameAs(...M)) {\r\n            return false;\r\n        }\r\n\r\n        // Check all coefficient. They must be equals.\r\n        for (let m of M) {\r\n            if (!this._coefficient.isEqualTo(m.coefficient)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // All checks passed.\r\n        return true;\r\n    };\r\n\r\n    isDivisible = (div: Monom): boolean => {\r\n        // For all variables (letters), the current monom must have a degree higher than the divider\r\n        if (div.degree().isStrictlyPositive()) {\r\n            for (let letter of div.variables) {\r\n                if (!this.degree(letter).isGreaterOrEqualTo(div.degree(letter))) {\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n\r\n        // If the coefficient is rational, we suppose we don't need to check the division by the coefficient.\r\n        if (this.coefficient.isRational() || div.coefficient.isRational()) {\r\n            return true\r\n        }\r\n\r\n        return this.coefficient.clone().divide(div.coefficient).isRelative()\r\n    }\r\n\r\n    isInverted(M\r\n                   :\r\n                   Monom\r\n    ):\r\n        boolean {\r\n        return this.clone().multiply(M).isOne();\r\n    }\r\n\r\n    isNegativeOne()\r\n        :\r\n        boolean {\r\n        return this._coefficient.value === -1 && this.variables.length === 0;\r\n    }\r\n\r\n    isNotEqual(M\r\n                   :\r\n                   Monom\r\n    ):\r\n        boolean {\r\n        return !this.isEqual(M);\r\n    }\r\n\r\n    isNotZero()\r\n        :\r\n        boolean {\r\n        return !this.isZero();\r\n    }\r\n\r\n    isOpposed(M\r\n                  :\r\n                  Monom\r\n    ):\r\n        boolean {\r\n        return this.clone().subtract(M).isZero();\r\n    }\r\n\r\n    isReduced()\r\n        :\r\n        boolean {\r\n        // By construction, it is already reduced (litterals\r\n        return this.coefficient.isReduced();\r\n    }\r\n\r\n    reset()\r\n        :\r\n        any {\r\n        this._coefficient = this.makeCoefficient()\r\n        this._literal = {}\r\n    }\r\n\r\n    _getLiteralDividers(arr: literalType[], letter: string):\r\n        literalType[] {\r\n        let tmpList: { [key: string]: CoefficientTypes }[] = [];\r\n\r\n        // Be default, this.literal[letter] should be a rational number.\r\n        for (let d = 0; d <= this.literal[letter].value; d++) {\r\n            if (arr.length === 0) {\r\n                let litt: literalType = {}\r\n                litt[letter] = this.makeCoefficient(d)\r\n                tmpList.push(litt)\r\n            } else {\r\n                for (let item of arr) {\r\n                    let litt: literalType = {}\r\n                    for (let currentLetter in item) {\r\n                        litt[currentLetter] = item[currentLetter]\r\n                    }\r\n                    litt[letter] = this.makeCoefficient(d)\r\n                    tmpList.push(litt)\r\n                }\r\n            }\r\n        }\r\n        return tmpList;\r\n    }\r\n\r\n    _shutingYardToReducedMonom = (inputStr: string): Monom => {\r\n        // Get the RPN array of the current expression\r\n        const SY: Shutingyard = new Shutingyard().parse(inputStr);\r\n        const rpn: { token: string, tokenType: string }[] = SY.rpn;\r\n\r\n        let stack: Monom[] = []\r\n\r\n        if (rpn.length === 0) {\r\n            this.zero()\r\n            return this\r\n        } else if (rpn.length === 1) {\r\n            const element = rpn[0]\r\n\r\n            this.one()\r\n            if (element.tokenType === 'coefficient') {\r\n                this.coefficient = this.makeCoefficient(element.token)\r\n            } else if (element.tokenType === 'variable') {\r\n                this.setLetter(element.token, 1)\r\n            }\r\n            return this\r\n        } else {\r\n            // Reset the monom\r\n            for (const element of rpn) {\r\n                this.addToken(stack, element)\r\n            }\r\n        }\r\n\r\n        this.one()\r\n        this.multiply(stack[0])\r\n        return this\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/maths/algebra/monom.ts b/src/maths/algebra/monom.ts
--- a/src/maths/algebra/monom.ts	
+++ b/src/maths/algebra/monom.ts	
@@ -1,1113 +1,171 @@
-/***
- * Monom class
- * The monom class represents of monom of the form:
- * k * x^n * y^m * z^p
- * k: Coefficient
- * n, m, p: powers as Fraction
- * x, y, z: letters as string
- */
-import {Numeric} from "../numeric";
-import {Shutingyard, ShutingyardType, Token} from "../shutingyard";
-import {COMPARESIGNS, literalType} from "../types";
-import {RootFraction} from "../coefficients/rootFraction";
 import {
-    COEFFICIENT_MODE,
-    CoefficientCore,
-    CoefficientParserTypes,
-    CoefficientTypes
-} from "../coefficients/coefficientCore";
-import {Fraction} from "../coefficients/fraction";
-
-
-export class Monom {
-    private _coefficientMode: COEFFICIENT_MODE
-
-    /**
-     * Create a Monom
-     * Defined as \\(k \\cdot x^{n}\\), where \\( k,n \in \\mathbb{Q}\\).
-     * Examples: \\(3x^2\\) or \\(3/5x^2\\)
-     * @param value (optional) string The value that should be parse. Can be a Monom, a Fraction, a string or a number. If nothing is provided, it will return the trivial monom (0).
-     */
-    constructor(value?: unknown) {
-        this.zero();
-
-        if (value !== undefined) {
-            // A string is given - try to parse the value.
-            this.parse(value);
-        }
-
-        return this;
-    }
-
-    // ------------------------------------------
-    // Getter and setter
-
-    private _coefficient: CoefficientCore<any>;
-
-    // ------------------------------------------
-    /**
-     * Get the coefficient \\(k\\) of the Monom \\(k\\cdot x^{n}\\)
-     * @returns {Fraction}
-     */
-    get coefficient(): CoefficientCore<any> {
-        return this._coefficient;
-    }
-
-    /**
-     * Set the coefficient \\(k\\) value of the monom
-     * @param {Fraction | number | string} F
-     */
-    set coefficient(F: CoefficientParserTypes) {
-        this._coefficient = this.makeCoefficient(F);
-    }
-
-    private _literal: literalType;
-
-    /**
-     * Get the literal part of \\(x^{n_1}y^{n_2}\\) as dictionary \\[\\begin{array}{ll}x&=n_1\\\\y&=n_2\\end{array}\\]
-     * @returns {literalType}
-     */
-    get literal(): literalType {
-        return this._literal;
-    }
-
-    /**
-     * Set the literal part of the monom. Must be a dictionary {x: Fraction, y: Fraction, ...}
-     * @param {literalType} L
-     */
-    set literal(L: literalType) {
-        this._literal = L;
-    }
+    coreInterface,
+    equalityInterface,
+    expressionElementInterface,
+    expressionInterface,
+    operationInterface
+} from "../types";
+import {Coefficient} from "../coefficients/coefficient";
 
-    /**
-     * Get the literal square roots of the Monom.
-     * TODO: remove this getter ? Is it used and is it correct ?
-     * @returns {literalType}
-     */
-    get literalSqrt(): literalType {
-        if (this.isLiteralSquare()) {
-            let L: literalType = {}
-            for (let key in this._literal) {
-                L[key] = this._literal[key].clone().sqrt()
-            }
-            return L;
-        } else {
-            return this._literal;
-        }
-    }
 
-    /**
-     * Set the literal part of the monom from a string
-     * @param inputStr  String like x^2y^3
-     */
-    set literalStr(inputStr: string) {
-        // TODO : parse using shutingyard tree !
-
-        // Match all x^n
-        for (const v of [...inputStr.matchAll(/([a-z])\^([+-]?[0-9]+)/g)]) {
-            // Create the default letter entry if necessary.
-            if (!(v[1] in this._literal)) {
-                this._literal[v[1]] = this.makeCoefficient().zero();
-            }
+/**
+ * A polynom element is a coefficient with one or more variables and an exponent (which is a power and a root).
+ *
+ */
+export class Monom implements coreInterface, operationInterface, equalityInterface, expressionInterface {
+    constructor(...values: unknown[]) {
 
-            // Add the new value.
-            // TODO: actually, it adds only numeric value
-            this._literal[v[1]].add(+v[2]);
+        if (values.length > 0) {
+            return this.parse(...values)
         }
-
-        // Match all x
-        for (const v of [...inputStr.matchAll(/([a-z](?!\^))/g)]) {
-            // Match all single letters
-            if (!(v[1] in this._literal)) {
-                this._literal[v[1]] = this.makeCoefficient().zero();
-            }
+        return this
+    }
 
-            // Add one to the value.
-            this._literal[v[1]].add(1)
-        }
-    }
+    private _literal: expressionElementInterface = {}
 
-    // Getter helpers.
-    /**
-     * Get the variables letters
-     */
     get variables(): string[] {
-        let M = this.clone().clean();
-        return Object.keys(M.literal)
+        return Object.keys(this._literal).sort()
     }
-
-    // Display getter
-    /**
-     * This display getter is to be used in the polynom display getter
-     */
-    get display(): string {
-        let L: string = '',
-            letters = Object.keys(this._literal).sort()
-        for (let letter of letters) {
-            if (!this._literal[letter].isZero()) {
-                L += `${letter}`;
-                if (!this._literal[letter].isEqualTo(1)) {
-                    L += `^(${this._literal[letter].display})`;
-                }
-            }
-        }
-
-        if (L === '') {
-            // No setLetter - means it's only a number !
-            if (this._coefficient.value != 0) {
-                return `${this._coefficient.display}`;
-            } else {
-                return '';
-            }
-        } else {
-            if (this._coefficient.value === 1) {
-                return L;
-            } else if (this._coefficient.value === -1) {
-                return `-${L}`;
-            } else if (this._coefficient.value === 0) {
-                return '0';
-            } else {
-                return `${this._coefficient.display}${L}`;
-            }
-        }
-    }
-
-    get dividers(): Monom[] {
-        // Decompose only if the coefficient is a natural number
-        if (!this.coefficient.isRelative()) {
-            return [this.clone()]
-        }
-
-
-        // Decompose only if the power values are natural numbers.
-        if (this.hasFractionCoefficient()) {
-            return [this.clone()]
-        }
-
-        // Security : do not do this if isGreaterThan than 10000
-        if (this.coefficient.numerator > 1000000) {
-            return [this.clone()]
-        }
-
-        const dividers = Numeric.dividers(Math.abs(this.coefficient.numerator))
-
-        // Decompose the literals parts.
-        let literals: literalType[] = [];
-        for (let L in this.literal) {
-            // L is the letter.
-            literals = this._getLiteralDividers(literals, L)
-        }
-
-        const monomDividers: Monom[] = [];
-        if (literals.length > 0 && dividers.length > 0) {
-            for (let N of dividers) {
-                for (let L of literals) {
-                    let M = new Monom();
-                    M.coefficient = this.makeCoefficient(N)
-                    M.literal = L
-                    monomDividers.push(M)
-                }
-            }
-        } else if (dividers.length === 0) {
-            for (let L of literals) {
-                let M = new Monom();
-                M.coefficient = this.makeCoefficient().one()
-                M.literal = L
-                monomDividers.push(M)
-            }
-        } else {
-            for (let N of dividers) {
-                let M = new Monom();
-                M.coefficient = this.makeCoefficient(N)
-                monomDividers.push(M)
-            }
-        }
-
-        return monomDividers.length === 0 ? [new Monom().one()] : monomDividers;
-    }
-
-    /**
-     * Display the monom, forcing the '+' sign to appear
-     */
-    get displayWithSign(): string {
-        let d: String = this.display;
-        return (d[0] !== '-' ? '+' : '') + d;
-    }
-
-    get texWithSign(): string {
-        if (this.coefficient.isStrictlyPositive()) {
-            return '+' + this.tex
-        }
-
-        return this.tex
-    }
-
-    get plotFunction(): string {
-
-        let L: string = '',
-            letters = Object.keys(this._literal).sort()
-
-        for (let letter of letters) {
-            if (!this._literal[letter].isZero()) {
-                L += (L === '' ? "" : "*") + `${letter}`
-                if (!this._literal[letter].isEqualTo(1)) {
-                    L += `^(${this._literal[letter].display})`;
-                }
-            }
-        }
-
-        // No literal part
-        if (L === '') {
-            // No setLetter - means it's only a number !
-            if (this._coefficient.value != 0) {
-                return `${this._coefficient.display}`;
-            } else {
-                return '';
-            }
-        } else {
-            if (this._coefficient.value === 1) {
-                return L;
-            } else if (this._coefficient.value === -1) {
-                return `-${L}`;
-            } else if (this._coefficient.value === 0) {
-                return '0';
-            } else {
-                return `${this._coefficient.display}*${L}`;
-            }
-        }
-    }
-
-    // ------------------------------------------
-    // Creation / parsing functions
-
-    /**
-     * Get the tex output of the monom
-     */
-    get tex(): string {
-        // TODO: display with square root !
-        let L: string = '',
-            letters = Object.keys(this._literal).sort()
-
-        for (let letter of letters) {
-            if (!this._literal[letter].isZero()) {
-                L += `${letter}`;
-                if (!this._literal[letter].isEqualTo(1)) {
-                    L += `^{${this._literal[letter].asTopFraction().tex}}`;
-                }
-            }
-        }
-
-        if (L === '') {
-            // No setLetter - means it's only a number !
-            if (this._coefficient.value != 0) {
-                return `${this._coefficient.tex}`;
-            } else {
-                return '0';
-            }
-        } else {
-            if (this._coefficient.value === 1) {
-                return L;
-            } else if (this._coefficient.value === -1) {
-                return `-${L}`;
-            } else if (this._coefficient.value === 0) {
-                return '0';
-            } else {
-                return `${this._coefficient.tex}${L}`;
-            }
-        }
-    }
-
-    /**
-     * Get the least common multiple of monoms
-     * @param monoms    Array of monoms
-     */
-    static lcm = (...monoms: Monom[]): Monom => {
-        // All the monoms must be with natural powers...
-        for (let m of monoms) {
-            if (m.hasFractionCoefficient()) {
-                return new Monom().zero()
-            }
-        }
-
-
-        let M = new Monom(),
-            coeffN: number[] = monoms.map(value => value.coefficient.numerator),
-            coeffD: number[] = monoms.map(value => value.coefficient.denominator),
-            n = Numeric.gcd(...coeffN),
-            d = Numeric.lcm(...coeffD);
-
-        // Get the coefficient.
-        M.coefficient = this.makeCoefficient(n, d).reduce();
-
-        // Set the literal parts - go through each monoms literal parts and get only the lowest degree of each letters.
-        for (let m of monoms) {
-            // Remove the inexistant letters from the resulting monom
-            for (let letter in M.literal) {
-                if (!(letter in m.literal)) {
-                    M.literal[letter].zero();
-                }
-            }
-            for (let letter in m.literal) {
-                if (M.literal[letter] === undefined && m.literal[letter].isStrictlyPositive()) {
-                    M.literal[letter] = m.literal[letter].clone();
-                } else {
-                    M.literal[letter] = this.makeCoefficient(Math.min(m.literal[letter].value, M.literal[letter].value))
-                }
-            }
-        }
-
-        return M;
-    };
-
-    /**
-     * Multiply two monoms and return a NEW monom.
-     * @param monoms
-     */
-    static xmultiply = (...monoms: Monom[]): Monom => {
-        let M = new Monom().one();
-
-        for (let m of monoms) {
-            M.multiply(m);
-        }
 
-        return M;
-    };
-
-    makeCoefficient = (...values: CoefficientParserTypes[]): CoefficientTypes => {
-        if (this._coefficientMode === COEFFICIENT_MODE.FRACTION) {
-            return new Fraction(...values as (Fraction | string | number)[])
-        } else if (this._coefficientMode === COEFFICIENT_MODE.ROOT) {
-            return new RootFraction(...values as (RootFraction | Fraction | string | number)[])
-        }
+    get literal(): expressionElementInterface {
+        return this._literal;
+    }
 
-        // TODO: add the other modes
-        return new Fraction(...values as (Fraction | string | number)[])
+    set literal(value: expressionElementInterface) {
+        this._literal = value;
     }
 
-// -----------------------------------------
-    /**
-     * Parse a string to a monom. The string may include fraction.
-     * @param inputStr
-     */
-    parse = (inputStr: unknown): Monom => {
+    private _coefficient: Coefficient = new Coefficient()
 
-        if (typeof inputStr === 'string') {
-            this._shutingYardToReducedMonom(inputStr)
-        } else if (typeof inputStr === 'number') {
-            this._coefficient = this.makeCoefficient(inputStr)
-            this._literal = {}
-        } else if (inputStr instanceof Fraction) {
-            this._coefficient = inputStr.clone()
-            this._literal = {}
-        } else if (inputStr instanceof RootFraction) {
-            this._coefficient = inputStr.clone()
-            this._literal = {}
-        } else if (inputStr instanceof Monom) {
-            this._coefficient = inputStr._coefficient.clone()
-            this._literal = this.copyLiterals(inputStr.literal)
-        }
+    get coefficient(): Coefficient {
+        return this._coefficient;
+    }
 
-        return this;
-    };
-
-    addToken = (stack: Monom[], element: Token): void => {
-
-        let q1: Monom, q2: Monom, m: Monom, letter: string, pow: CoefficientCore<any>
-
-        if (element.tokenType === ShutingyardType.COEFFICIENT) {
-            stack.push(new Monom(this.makeCoefficient(element.token)))
-
-        } else if (element.tokenType === ShutingyardType.VARIABLE) {
-            let M = new Monom().one()
-            M.setLetter(element.token, 1)
-            stack.push(M.clone())
-
-        } else if (element.tokenType === ShutingyardType.OPERATION) {
-            switch (element.token) {
-                case '-':
-                    // this should only happen for negative powers or for negative coefficient.
-                    q2 = (stack.pop()) || new Monom().zero()
-                    q1 = (stack.pop()) || new Monom().zero()
-
-                    stack.push(q1.subtract(q2))
-
-                    break;
-                case '*':
-                    // Get the last element in the stack
-                    q2 = (stack.pop()) || new Monom().one()
-                    q1 = (stack.pop()) || new Monom().one()
-
-                    stack.push(q1.multiply(q2))
-                    break
-                case '/':
-                    // Get the last element in the stack
-                    q2 = (stack.pop()) || new Monom().one()
-                    q1 = (stack.pop()) || new Monom().one()
-
-                    stack.push(q1.divide(q2))
-                    break
-                case '^':
-                    // get the two last elements in the stack
-                    pow = (stack.pop().coefficient) || this.makeCoefficient().one()
-                    m = (stack.pop()) || new Monom().one()
-
-                    letter = m.variables[0]
-
-                    if (letter !== undefined) {
-                        m.setLetter(letter, pow)
-                    }
-
-                    stack.push(m)
-                    // this.multiply(m.clone())
-                    break
-            }
-        }
+    set coefficient(value: Coefficient) {
+        this._coefficient = value;
     }
 
-    /**
-     * Clone the current Monom.
-     */
-    clone = (): Monom => {
-        let F: Monom = new Monom();
+    add(...values: Monom[]): this {
+        if (values.length === 0) return this
 
-        F.coefficient = this._coefficient.clone();
-
-        // Copy the literal parts.
-        for (let k in this._literal) {
-            F.setLetter(k, this._literal[k].clone());
+        // Check that all the monoms are similar.
+        if (!values.every(x => this.isSimilarTo(x))) {
+            throw new Error('The monoms are not similar.')
         }
-        return F;
-    };
 
-    copyLiterals = (literal: literalType): literalType => {
-        let L: literalType = {}
+        // Add the coefficients.
+        this._coefficient.add(...values.map(x => x.coefficient))
 
-        for (let k in literal) {
-            L[k] = literal[k].clone()
-        }
-        return L
-    }
-
-    makeSame = (M: Monom): Monom => {
-        // Copy the literal parts.
-        for (let k in M._literal) {
-            this.setLetter(k, M._literal[k].clone());
-        }
         return this
     }
 
-    /**
-     * Create a zero value monom
-     */
-    zero = (): Monom => {
-        this._coefficient = this.makeCoefficient().zero();
-        this._literal = {};
-        return this;
-    };
+    subtract(...values: Monom[]): this {
+        return this.add(...values.map(x => x.opposite()))
+    }
+
+    multiply(...values: Monom[]): this {
+        return this
+    }
+
+    divide(value: Monom): this {
+        return this
+    }
 
-    /**
-     * Create a one value monom
-     */
-    one = (): Monom => {
-        this._coefficient = this.makeCoefficient().one();
-        this._literal = {};
-        return this;
-    };
+    opposite(): this {
+        this._coefficient.opposite()
+        return this
+    }
 
-// ------------------------------------------
-// Mathematical operations
-// ------------------------------------------
+    invert(): this {
+        return this
+    }
 
-    /**
-     * Clean the monom by removing each letters with a power of zero.
-     */
-    clean = (): Monom => {
-        for (let letter in this._literal) {
-            if (this._literal[letter].isZero()) {
-                delete this._literal[letter];
-            }
-        }
-        return this;
-    };
+    pow(value: number): this {
+        return this
+    }
+
+    root(value: number): this {
+        return this
+    }
 
-    reduce = (): Monom => {
-        this.clean()
-        this.coefficient.reduce()
+    reduce(): this {
         return this
     }
 
-    /**
-     * Get the opposite
-     * Returns a monom.
-     */
-    opposed = (): Monom => {
-        this._coefficient.opposite();
-        return this;
-    };
-
-    /**
-     * Add all similar monoms. If they aren't similar, they are simply skipped.
-     * @param M (Monom[]) The monoms to add.
-     */
-    add = (...M: Monom[]): Monom => {
-        for (let m of M) {
-            if (this.isSameAs(m)) {
-                if (this.isZero()) {
-                    this.makeSame(m)
-                }
-                this._coefficient.add(m.coefficient);
-            } else {
-                console.log('Add monom: ' + this.display + ' is not similar with ', m.display);
-            }
-        }
-        return this;
-    };
-
-    /**
-     * Subtract multiple monoms
-     * @param M (Monom[]) The monoms to subtract
-     */
-    subtract = (...M: Monom[]): Monom => {
-        for (let m of M) {
-            if (this.isSameAs(m)) {
-                if (this.isZero()) {
-                    this.makeSame(m)
-                }
-                this._coefficient.add(m.clone().coefficient.opposite());
-            } else {
-                console.log('Subtract: Is not similar: ', m.display);
-            }
-        }
-        return this;
-    };
-
-    /**
-     * Multiple multiple monoms to the current monom
-     * @param M (Monom[]) The monoms to multiply to.
-     */
-    multiply = (...M: Monom[]): Monom => {
-        for (let m of M) {
-            // Multiply the coefficient.
-            this._coefficient.multiply(m.coefficient);
-
-            // Multiply the literal parts.
-            for (let letter in m.literal) {
-                if (this._literal[letter] === undefined) {
-                    this._literal[letter] = m.literal[letter].clone()
-                } else {
-                    this._literal[letter].add(m.literal[letter])
-                }
-
-            }
-        }
-        return this;
-    };
-
-    multiplyByNumber = (F: Fraction | number): Monom => {
-        this._coefficient.multiply(F);
-        return this;
-    }
-
-    /**
-     * Divide the current monoms by multiple monoms
-     * @param M (Monom[])
-     */
-    divide = (...M: Monom[]): Monom => {
-        // Depending on the given value, choose the current item
-        for (let v of M) {
-            // Divide the coefficient
-            this._coefficient.divide(v.coefficient);
+    isSimilarTo(value: Monom): boolean {
+        // To be similar, the variables must be similar.
+        // The coefficient can be different.
 
-            // Subtract the power values
-            for (let letter in v.literal) {
-                this._literal[letter] = (this._literal[letter] === undefined) ? v.literal[letter].clone().opposite() : this._literal[letter].subtract(v.literal[letter])
+        // They must have the same number of variables.
+        if (this.variables.length !== (value as Monom).variables.length) return false
 
-                // If the power of a particular setLetter is zero, delete it from the literal part..
-                if (this._literal[letter].isZero()) {
-                    delete this._literal[letter];
-                }
-            }
-        }
-        return this;
-    };
+        // They must have the same variables.
+        if (this.variables.every(x => (value as Monom).variables.includes(x))) return false
 
-    /**
-     * Get the pow of a monom.
-     * @param nb (number) : Mathematical pow
-     */
-    pow = (nb: number | Fraction): Monom => {
-        this._coefficient.pow(nb);
-        for (let letter in this._literal) {
-            this._literal[letter].multiply(nb)
-        }
-        return this;
-    };
-
-// ------------------------------------------
-// Compare functions
-
-    /**
-     * Get the index-root of the monom
-     * @param p
-     */
-    root = (p: number): Monom => {
-        // TODO: determiner the index root of a monom
-        return this;
-    }
-
-    /**
-     * Return the square root of a monom
-     */
-    sqrt = (): Monom => {
-        if (this.isSquare()) {
-            this._coefficient.sqrt();
-            for (let letter in this._literal) {
-                this._literal[letter].clone().divide(2)
-            }
-        }
-        return this.root(2);
-    }
-
-// ------------------------------------------
-    compare = (M: Monom, sign?: COMPARESIGNS): boolean => {
-        // TODO: Build the compare systems.
-        if (sign === undefined) {
-            sign = COMPARESIGNS.EQUALS;
-        }
-
-
-        switch (sign) {
-            case COMPARESIGNS.EQUALS:
-                // To be equal, they must be the isSame
-                if (!this.compare(M, COMPARESIGNS.SAME)) {
-                    return false;
-                }
-
-                // The literal parts are the isSame. The coefficient must be equal
-                return this._coefficient.isEqualTo(M.coefficient);
-            case COMPARESIGNS.SAME:
-                // Get the list of all variables from both monoms.
-                let M1: string[] = this.variables,
-                    M2: string[] = M.variables,
-                    K: string[] = M1.concat(M2.filter((item) => M1.indexOf(item) < 0));
-
-                if (M1.length === 0 && M2.length === 0) {
-                    return true
-                }
-                // To compare, both must be different than zero.
-                if (!this.isZero() && !M.isZero()) {
-                    for (let key of K) {
-                        // The setLetter is not available in one of the monom
-                        if (this._literal[key] === undefined || M.literal[key] === undefined) {
-                            return false;
-                        }
-                        // The setLetter does not have the isSame power in each monoms.
-                        if (!this._literal[key].isEqualTo(M.literal[key])) {
-                            return false;
-                        }
-                    }
-                }
-
-                // All are positive check - the monoms are the sames.
-                return true;
-            default:
-                return false;
-        }
+        return true
     }
-
-    /**
-     * Determine if the monom is null
-     */
-    isZero()
-        :
-        boolean {
-        return this._coefficient.value === 0;
-    }
-
-    /**
-     * Determine if the monom is one
-     */
-    isOne()
-        :
-        boolean {
-        return this._coefficient.value === 1 && this.variables.length === 0;
-    }
-
-    /**
-     * Determine if two monoms are equals
-     * @param M
-     */
-    isEqual = (M: Monom): boolean => {
-        return this.compare(M, COMPARESIGNS.EQUALS);
-    };
 
-    /**
-     * Determine if two monoms are similar
-     * @param M
-     */
-    isSameAs = (M: Monom): boolean => {
-        return this.compare(M, COMPARESIGNS.SAME);
-    };
-
-    isSquare = (): boolean => {
-        if (!this.coefficient.isSquare()) {
-            return false;
-        }
-        return this.isLiteralSquare();
-    }
-// ------------------------------------------
-// Misc monoms functions
-
-    isLiteralSquare = (): boolean => {
-        for (let letter in this.literal) {
-            // A literal square must have a natural power
-            if (this.literal[letter].isRational()) {
-                return false
-            }
+    isEqualTo(value: unknown): boolean {
+        return false
+    }
 
-            // The natural power must be be even
-            if (this.literal[letter].isEven()) {
-                return false;
-            }
-        }
-
-        return true;
-    }
-
-    hasFractionCoefficient = (): boolean => {
-        for (let letter in this._literal) {
-            if (this._literal[letter].isRational()) {
-                return true
-            }
-        }
-
+    isReduced(): boolean {
         return false
     }
 
-// -------------------------------------
-    /**
-     * Determine if a monom contains a setLetter in it's literal part
-     * @param letter
-     */
-    hasLetter = (letter?: string): boolean => {
-        // The letter was not found
-        if (this._literal[letter === undefined ? 'x' : letter] === undefined) {
-            return false
-        }
+    isOne(): boolean {
+        return false
+    }
 
-        // The letter is found and is not zero !
-        return !this._literal[letter === undefined ? 'x' : letter].isZero();
-    };
-
-    /**
-     * Set the power of a particular setLetter
-     * @param letter (string) Letter to change
-     * @param pow (number) Power of the setLetter (must be positive integer.
-     */
-    setLetter = (letter: string, pow: CoefficientCore<any> | number): void => {
-        if (pow instanceof CoefficientCore) {
-            // Set the power of the letter to zero => remove it
-            if (this.hasLetter(letter) && pow.isZero()) {
-                delete this._literal[letter]
-            }
-
-            this._literal[letter] = pow.clone()
-        } else {
-            this.setLetter(letter, this.makeCoefficient(pow))
-        }
-    };
-
-    /**
-     * Get the degree of a monom. If no setLetter is given, the result will be the global degree.
-     * @param letter (string) Letter to get to degree (power)
-     */
-    degree = (letter?: string): CoefficientTypes => {
-        if (this.variables.length === 0) {
-            return this.makeCoefficient().zero();
-        }
-        if (letter === undefined) {
-            // Not setLetter given -> we get the global monom degree (sum of all the letters).
-            return Object.values(this._literal)
-                .reduce(
-                    (t, n) => t.clone().add(n)
-                );
-        } else {
-            // A setLetter is given -> get the corresponding power.
-            return this._literal[letter] === undefined ? this.makeCoefficient().zero() : this._literal[letter].clone();
-        }
-    };
-
-    /**
-     * Evaluate a monom. Each setLetter must be assigned to a Fraction.
-     * @param values    Dictionary of <setLetter: Fraction>
-     */
-    evaluate = (values?: literalType | Fraction | number): CoefficientCore<any> => {
-        let r = this.coefficient.clone();
-
-        if (typeof values === 'number' || values instanceof Fraction) {
-            let tmpValues: literalType = {}
-            tmpValues[this.variables[0]] = this.makeCoefficient(values)
-            return this.evaluate(tmpValues);
-        }
-
-        if (typeof values === 'object') {
-            if (this.variables.length === 0) {
-                return this.coefficient
-            }
-            for (let L in this._literal) {
-                if (values[L] === undefined) {
-                    return this.makeCoefficient().zero();
-                }
-
-                let value = this.makeCoefficient(values[L])
-
-                r.multiply(value.pow(this._literal[L]))
-            }
-        }
-
-        return r;
-    };
-
-    evaluateAsNumeric = (values: { [Key: string]: number } | number): number => {
-        let r = this.coefficient.value
-
-        if (typeof values === 'number') {
-            let tmpValues: { [Key: string]: number } = {}
-            tmpValues[this.variables[0]] = values
-            return this.evaluateAsNumeric(tmpValues);
-        }
-
-        if (typeof values === 'object') {
-            if (this.variables.length === 0) {
-                return this.coefficient.value
-            }
-            for (let L in this._literal) {
-                if (values[L] === undefined) {
-                    return 0;
-                }
-
-                r *= values[L] ** (this._literal[L].value)
-            }
-        }
-
-        return r
-    }
-// ----------------------------------------
-// Static functions
-// ----------------------------------------
-
-    /**
-     * Derivative the monom
-     * @param letter
-     */
-    derivative = (letter?: string): Monom => {
-        // No setLetter given - assume it's the setLetter 'x'
-        if (letter === undefined) {
-            letter = 'x';
-        }
-
-        if (this.hasLetter(letter)) {
-            let d = this._literal[letter].clone(),
-                dM = this.clone();
-
-            // Subtract one to the degree.
-            dM._literal[letter].subtract(1)
-
-            // Multiply the coefficient by the previous degree
-            dM._coefficient.multiply(this.makeCoefficient(d.clone()));
-            return dM;
-        } else {
-            return new Monom().zero();
-        }
-    };
-
-    primitive = (letter?: string): Monom => {
-        // TODO: derivative including the ln value => implies creating different monom system ?
-        if (letter === undefined) {
-            letter = 'x'
-        }
-
-        // Zero monom
-        let M = this.clone(), degree
-
-        if (M.hasLetter(letter)) {
-            degree = M.degree(letter).clone().add(1)
-            M.coefficient = M.coefficient.clone().divide(degree)
-            M.setLetter(letter, degree)
-        } else {
-            // There is no letter.
-
-            // The coefficient might be zero (=> x) or a number a (=> ax)
-            if (M.coefficient.isZero()) {
-                M.coefficient = this.makeCoefficient().one()
-            }
-            M.setLetter(letter, 1)
-        }
-
-        return M
-    }
-
-// TODO: The rest of the functions are not used or unnecessary ?
-    /**
-     * Determine if multiple monoms are similar
-     * @param M
-     */
-    areSameAs = (...M: Monom[]): boolean => {
-        let result: boolean = true;
-
-        // Check all monoms if they are the isSame as the "this" one.
-        for (let i = 0; i < M.length; i++) {
-            if (!this.isSameAs(M[i])) {
-                return false;
-            }
-        }
-
-        // All check passed -> all the monoms are similar.
-        return result;
-    };
-
-    /**
-     * Determine if multiple monoms are equals
-     * @param M
-     */
-    areEquals = (...M: Monom[]): boolean => {
-        // They are not similar.
-        if (!this.areSameAs(...M)) {
-            return false;
-        }
-
-        // Check all coefficient. They must be equals.
-        for (let m of M) {
-            if (!this._coefficient.isEqualTo(m.coefficient)) {
-                return false;
-            }
-        }
-
-        // All checks passed.
-        return true;
-    };
-
-    isDivisible = (div: Monom): boolean => {
-        // For all variables (letters), the current monom must have a degree higher than the divider
-        if (div.degree().isStrictlyPositive()) {
-            for (let letter of div.variables) {
-                if (!this.degree(letter).isGreaterOrEqualTo(div.degree(letter))) {
-                    return false
-                }
-            }
-        }
-
-        // If the coefficient is rational, we suppose we don't need to check the division by the coefficient.
-        if (this.coefficient.isRational() || div.coefficient.isRational()) {
-            return true
-        }
-
-        return this.coefficient.clone().divide(div.coefficient).isRelative()
+    isMinusOne(): boolean {
+        return false
     }
 
-    isInverted(M
-                   :
-                   Monom
-    ):
-        boolean {
-        return this.clone().multiply(M).isOne();
+    isUnit(): boolean {
+        return false
     }
 
-    isNegativeOne()
-        :
-        boolean {
-        return this._coefficient.value === -1 && this.variables.length === 0;
+    isZero(): boolean {
+        return false
     }
 
-    isNotEqual(M
-                   :
-                   Monom
-    ):
-        boolean {
-        return !this.isEqual(M);
-    }
+    clone(): Monom {
 
-    isNotZero()
-        :
-        boolean {
-        return !this.isZero();
-    }
+        const m = new Monom()
 
-    isOpposed(M
-                  :
-                  Monom
-    ):
-        boolean {
-        return this.clone().subtract(M).isZero();
-    }
+        m.coefficient = this.coefficient.clone()
+        for (let v of this.variables) {
+            m.literal[v] = this.literal[v]
+        }
 
-    isReduced()
-        :
-        boolean {
-        // By construction, it is already reduced (litterals
-        return this.coefficient.isReduced();
+        return m
     }
 
-    reset()
-        :
-        any {
-        this._coefficient = this.makeCoefficient()
+    private reset() {
+        this._coefficient = new Coefficient().zero()
         this._literal = {}
     }
 
-    _getLiteralDividers(arr: literalType[], letter: string):
-        literalType[] {
-        let tmpList: { [key: string]: CoefficientTypes }[] = [];
+    private parse(...values: unknown[]): Monom {
+        this.reset()
 
-        // Be default, this.literal[letter] should be a rational number.
-        for (let d = 0; d <= this.literal[letter].value; d++) {
-            if (arr.length === 0) {
-                let litt: literalType = {}
-                litt[letter] = this.makeCoefficient(d)
-                tmpList.push(litt)
-            } else {
-                for (let item of arr) {
-                    let litt: literalType = {}
-                    for (let currentLetter in item) {
-                        litt[currentLetter] = item[currentLetter]
-                    }
-                    litt[letter] = this.makeCoefficient(d)
-                    tmpList.push(litt)
-                }
+        // Parse the values.
+        if (values.length === 1) {
+            if (values[0] instanceof Monom) {
+                return values[0].clone()
             }
-        }
-        return tmpList;
-    }
 
-    _shutingYardToReducedMonom = (inputStr: string): Monom => {
-        // Get the RPN array of the current expression
-        const SY: Shutingyard = new Shutingyard().parse(inputStr);
-        const rpn: { token: string, tokenType: string }[] = SY.rpn;
-
-        let stack: Monom[] = []
-
-        if (rpn.length === 0) {
-            this.zero()
-            return this
-        } else if (rpn.length === 1) {
-            const element = rpn[0]
-
-            this.one()
-            if (element.tokenType === 'coefficient') {
-                this.coefficient = this.makeCoefficient(element.token)
-            } else if (element.tokenType === 'variable') {
-                this.setLetter(element.token, 1)
-            }
-            return this
-        } else {
-            // Reset the monom
-            for (const element of rpn) {
-                this.addToken(stack, element)
+            if (typeof values[0] === "string") {
+                // Parse the string to get the coefficient and the literal.
             }
-        }
 
-        this.one()
-        this.multiply(stack[0])
-        return this
-    }
-}
+            if (typeof values[0] === "number") {
+                // Parse the number to get the coefficient and the literal.
+                this._coefficient = new Coefficient(values[0])
+                return this
+            }
+        }
+
+        return this;
+    }
+}
\ No newline at end of file
Index: tests/coefficients/fraction.test.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {expect} from \"chai\";\r\nimport {Fraction} from \"../../src/maths/coefficients/fraction\";\r\nimport {describe} from \"mocha\";\r\nimport {Random} from \"../../src/maths/randomization/random\";\r\n\r\ndescribe('Fraction tests', () => { // the tests container\r\n    it(\"should parse correctly\", () => {\r\n        const F1 = new Fraction('1/2')\r\n        expect(F1.display).to.be.equal('1/2')\r\n\r\n        const F2 = new Fraction('1.5')\r\n        expect(F2.display).to.be.equal('3/2')\r\n\r\n        const F2n = new Fraction(1.5)\r\n        expect(F2n.display).to.be.equal('3/2')\r\n\r\n        const F3 = new Fraction('-1.5')\r\n        expect(F3.display).to.be.equal('-3/2')\r\n\r\n        const F4 = new Fraction('1.5/2')\r\n        expect(F4.display).to.be.equal('3/4')\r\n\r\n        const F5 = new Fraction('1.5/2.5')\r\n        expect(F5.display).to.be.equal('3/5')\r\n\r\n        const F6 = new Fraction(3, 5)\r\n        expect(F6.display).to.be.equal('3/5')\r\n\r\n        const F7 = new Fraction(0.5, 1.5)\r\n        expect(F7.display).to.be.equal('1/3')\r\n    })\r\n\r\n    it('Tex display', () => { // the single test\r\n        const options = new Fraction(2, 5); // this will be your class\r\n        expect(options.tex).to.be.equal('\\\\frac{ 2 }{ 5 }');\r\n    });\r\n\r\n    it('Compare: equals', () => {\r\n        let F = new Fraction(1, 3),\r\n            Q = new Fraction(2, 6),\r\n            P = new Fraction(2, 5);\r\n        expect(F.isEqualTo(Q)).to.be.true;\r\n        expect(F.isEqualTo(P)).to.be.false;\r\n    })\r\n\r\n    it('Operation: sum of two fraction', () => {\r\n        let F = new Fraction(1, 3),\r\n            Q = new Fraction(2, 7);\r\n\r\n        F.add(Q);\r\n\r\n        expect(F.numerator).to.be.equal(13);\r\n        expect(F.denominator).to.be.equal(21);\r\n    })\r\n\r\n    it('Operation: subtract of two fraction', () => {\r\n        let F = new Fraction(1, 3),\r\n            Q = new Fraction(2, 7);\r\n\r\n        F.subtract(Q);\r\n\r\n        expect(F.numerator).to.be.equal(1);\r\n        expect(F.denominator).to.be.equal(21);\r\n    })\r\n\r\n    it('Reduced', () => {\r\n        let F = new Fraction(2, 5),\r\n            Q = new Fraction(2, 6)\r\n\r\n        expect(F.isReduced()).to.be.true\r\n        expect(Q.isReduced()).to.be.false\r\n    })\r\n\r\n    // TODO: fix this test\r\n    // it('Should parse a number with lots of decimals', () => {\r\n    //     let A = 3.45,\r\n    //         B = 3.3333333333333,\r\n    //         C = 5.314171717171717\r\n    //\r\n    //     let FA = new Fraction(A),\r\n    //         FB = new Fraction(B, 1),\r\n    //         FC = new Fraction(C, 2)\r\n    //\r\n    //     expect(FA.display).to.be.equal('69/20')\r\n    //     expect(FB.display).to.be.equal('10/3')\r\n    //     expect(FC.display).to.be.equal('526103/99000')\r\n    // })\r\n})\r\n\r\ndescribe(\"Fraction static functions\", () => {\r\n    it('should sort fractions', function () {\r\n        let list = [\r\n            new Fraction('3.5'),\r\n            new Fraction('-2.5'),\r\n            new Fraction('3.1'),\r\n            new Fraction('3.54'),\r\n            new Fraction('1.5')\r\n        ]\r\n\r\n        expect(Fraction.sort(list).map(x => x.value)).to.have.all.members([-2.5, 1.5, 3.1, 3.5, 3.54])\r\n    });\r\n\r\n    it('should make a list of fractions unique', function () {\r\n        let list = [\r\n            new Fraction('3.5'),\r\n            new Fraction('-2.5'),\r\n            new Fraction('7/2'),\r\n            new Fraction('3.50'),\r\n            new Fraction('1.5')\r\n        ]\r\n\r\n        expect(Fraction.unique(list, true).map(x => x.value)).to.have.ordered.members([-2.5, 1.5, 3.5])\r\n    });\r\n\r\n    it('should get the average of fractions', function () {\r\n        let list = [\r\n            new Fraction('3.5'),\r\n            new Fraction('-2.5'),\r\n            new Fraction('7/2'),\r\n            new Fraction('3.50'),\r\n            new Fraction('1.5')\r\n        ]\r\n\r\n        expect(Fraction.average(...list).tex).to.be.equal('\\\\frac{ 19 }{ 10 }')\r\n    })\r\n\r\n    it('should multiply and not reduce', function () {\r\n        let list = [\r\n            new Fraction('1/2'),\r\n            new Fraction('4/3'),\r\n            2.5,\r\n            3\r\n        ]\r\n\r\n        expect(new Fraction().multiply(...list).display).to.be.equal(\"60/12\")\r\n    });\r\n\r\n    it('should divide', () => {\r\n        const f1 = new Fraction('1/2'),\r\n            f2 = new Fraction('4/3')\r\n\r\n        expect(f1.divide(f2).display).to.be.equal('3/8')\r\n    })\r\n})\r\n\r\ndescribe(\"Evaluate fraction\", () => {\r\n    it('should evaluate and convert to decimal if not exact', function () {\r\n        let F = new Fraction(Math.sqrt(2))\r\n\r\n        expect(F.isApproximative()).to.be.true\r\n        expect(F.isExact()).to.be.false\r\n\r\n        let G = new Fraction('1/7')\r\n        expect(G.isApproximative()).to.be.false\r\n        expect(G.isExact()).to.be.true\r\n    });\r\n})\r\n\r\ndescribe('Generate a random fraction', () => {\r\n    it('should generate a non natural fraction', function () {\r\n        let F, result = true\r\n\r\n        for (let i = 0; i < 100; i++) {\r\n            F = Random.fraction()\r\n            if (!F.isRelative()) {\r\n                result = false\r\n                break\r\n            }\r\n        }\r\n        expect(F.isNatural()).to.be.false;\r\n    });\r\n})
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/coefficients/fraction.test.ts b/tests/coefficients/fraction.test.ts
--- a/tests/coefficients/fraction.test.ts	
+++ b/tests/coefficients/fraction.test.ts	
@@ -1,7 +1,6 @@
 import {expect} from "chai";
 import {Fraction} from "../../src/maths/coefficients/fraction";
 import {describe} from "mocha";
-import {Random} from "../../src/maths/randomization/random";
 
 describe('Fraction tests', () => { // the tests container
     it("should parse correctly", () => {
@@ -155,18 +154,18 @@
         expect(G.isExact()).to.be.true
     });
 })
-
-describe('Generate a random fraction', () => {
-    it('should generate a non natural fraction', function () {
-        let F, result = true
-
-        for (let i = 0; i < 100; i++) {
-            F = Random.fraction()
-            if (!F.isRelative()) {
-                result = false
-                break
-            }
-        }
-        expect(F.isNatural()).to.be.false;
-    });
-})
\ No newline at end of file
+//
+// describe('Generate a random fraction', () => {
+//     it('should generate a non natural fraction', function () {
+//         let F, result = true
+//
+//         for (let i = 0; i < 100; i++) {
+//             F = Random.fraction()
+//             if (!F.isRelative()) {
+//                 result = false
+//                 break
+//             }
+//         }
+//         expect(F.isNatural()).to.be.false;
+//     });
+// })
\ No newline at end of file
Index: src/maths/coefficients/rootFraction.ts
===================================================================
diff --git a/src/maths/coefficients/rootFraction.ts b/src/maths/coefficients/coefficientElement.ts
rename from src/maths/coefficients/rootFraction.ts
rename to src/maths/coefficients/coefficientElement.ts
--- a/src/maths/coefficients/rootFraction.ts	
+++ b/src/maths/coefficients/coefficientElement.ts	
@@ -1,26 +1,44 @@
 import {Fraction} from "./fraction";
-import {CoefficientCore} from "./coefficientCore";
+import {COEFFICIENT_EXTRA, CoefficientCore, CoefficientParserTypes} from "./coefficientCore";
 
 /**
  * RootFraction is something like "<coefficient>\sqrt[index]{<radical>}
  */
-export class RootFraction extends CoefficientCore<RootFraction> {
-    constructor(value?: number | string | Fraction | RootFraction, radical?: number | string, index?: number | string) {
+
+
+export class CoefficientElement extends CoefficientCore<CoefficientElement> {
+    constructor(value?: CoefficientParserTypes, values?: { radical?: number, index?: number, extra?: string }) {
         super();
 
         // Default values
         this._index = 2;
         this._radical = 1;
+        this._extra = null
 
-        // Parse the value
+        // Parse the name
         if (value !== undefined) {
-            if (value instanceof RootFraction) return this.parse(value)
-            return this.parse(value, radical, index)
+            if (value instanceof CoefficientElement) return this._parse(value)
+            if (values === undefined) return this._parse(value)
+            return this._parse(value,
+                values.radical ?? 1,
+                values.index ?? 2,
+                values.extra ?? null
+            )
         }
 
         return this
     }
 
+    private _extra: COEFFICIENT_EXTRA;
+
+    get extra(): COEFFICIENT_EXTRA {
+        return this._extra;
+    }
+
+    set extra(value: COEFFICIENT_EXTRA) {
+        this._extra = value;
+    }
+
     private _index: number;
 
     get index(): number {
@@ -41,55 +59,56 @@
         this._radical = value;
     }
 
-    get value(): number {
-        return this.numerator * Math.pow(this._radical, 1 / this._index) / this.denominator
+    get fraction(): Fraction {
+        return new Fraction(this.numerator, this.denominator)
     }
 
-    get tex(): string {
-        if (!this._hasRadical()) return this.fraction.tex
-
-        const N = `${this.numerator} \\sqrt${this._index > 2 ? `[${this._index}]` : ''}{ ${this._radical} }`
-
-        if (this.denominator === 1) return N
+    set fraction(value: Fraction) {
+        this.numerator = value.numerator
+        this.denominator = value.denominator
+    }
 
-        return `\\frac{ ${N} }{ ${this.denominator} }`
+    get hasRadical(): boolean {
+        return this._radical !== 1 && this._index > 1
+    }
 
+    get key(): string {
+        return this._index === 2 ? `sqrt(${this._radical})` : `root(${this._index})(${this._radical})`
     }
 
-    get display(): string {
-        if (!this._hasRadical()) return this.fraction.display
-        const N = `${this.numerator}${this._index > 2 ? `root(${this._index})` : 'sqrt'}(${this._radical})`,
-            D = this.denominator > 1 ? `/${this.denominator}` : ''
+    get radicalDisplay(): string {
+        return this.hasRadical ? this.key : ''
+    }
 
-        return `${N}${D}`
+    get radicalTex(): string {
+        return this.hasRadical ? this._index === 2 ? `\\sqrt{ ${this._radical} }` : `\\sqrt[${this._index}]{ ${this._radical} }` : ''
     }
 
-    createInstance(value?: string | number | Fraction | RootFraction): RootFraction {
-        return new RootFraction(value)
+    get extraDisplay(): string {
+        return this._extra === COEFFICIENT_EXTRA.PI ? 'pi' : this._extra === COEFFICIENT_EXTRA.I ? 'i' : ''
     }
 
-    clone = (): RootFraction => {
-        return new RootFraction(this.fraction, this.radical, this.index)
+    get extraTex(): string {
+        return this._extra === COEFFICIENT_EXTRA.PI ? '\\pi' : this._extra === COEFFICIENT_EXTRA.I ? 'i' : ''
     }
 
-    reduce = (): RootFraction => {
-        // Reduce the radical
-        this._extractRadical()
+    static fromList(...values: CoefficientParserTypes[]): CoefficientElement[] {
+        return values.map(x => new CoefficientElement(x))
+    }
 
-        // Reduce the fraction
-        this.fraction = this.fraction.reduce()
-        return this
+    createInstance(value?: CoefficientParserTypes): CoefficientElement {
+        return new CoefficientElement(value)
     }
 
-    one = (): RootFraction => {
+    one = (): CoefficientElement => {
         super.one()
         this._resetRadical()
         return this
     }
 
-    add = (...values: (Fraction | number | string | RootFraction)[]): RootFraction => {
+    add = (...values: CoefficientParserTypes[]): CoefficientElement => {
         // Check that all values are similar
-        const RF_list = values.map(x => new RootFraction(x))
+        const RF_list = CoefficientElement.fromList(...values)
 
         const allAreSimilar = RF_list.every(x => this.isSimilarTo(x))
         if (!allAreSimilar) throw new Error('All values must be similar')
@@ -98,67 +117,120 @@
         return this
     }
 
-    multiply = (...values: (Fraction | number | string | RootFraction)[]): RootFraction => {
-        const RF_list = values.map(x => new RootFraction(x))
+    multiply = (...values: CoefficientParserTypes[]): CoefficientElement => {
+        const RF_list = CoefficientElement.fromList(...values)
+
+        // Multiply the fraction
+        this.fraction = this.fraction.multiply(...RF_list.map(x => x.fraction))
+
+        // Multiply the extra (case of i)
+        const i = [this, ...RF_list].filter(x => x.extra === COEFFICIENT_EXTRA.I).length
+        this.extra = i % 2 === 0 ? null : COEFFICIENT_EXTRA.I
+        this.numerator *= Math.floor(i / 2) % 2 === 0 ? 1 : -1
 
         // Check that all values has the same index
         if (RF_list.every(x => x.index === this.index)) {
-            // Multiply the fraction
-            this.fraction = this.fraction.multiply(...RF_list.map(x => x.fraction))
-
             // Multiply the radical
             this.radical = RF_list.reduce((acc, x) => acc * x.radical, this.radical)
-
-            return this
-        }
-
-        // Check that all values has the same radical
-        if (RF_list.every(x => x.radical === this.radical)) {
-            // Multiply the fraction
-            this.fraction = this.fraction.multiply(...RF_list.map(x => x.fraction))
-
+        } else if (RF_list.every(x => x.radical === this.radical)) {
             // Add the index
             const idx: Fraction = new Fraction(1, this.index)
                 .add(...RF_list.map(x => new Fraction(1, x.index)))
 
             this.radical = Math.pow(this.radical, idx.numerator)
             this.index = idx.denominator
-            return this
+        } else {
+            console.log('SOMETHING WENT WrONG ')
         }
         return this
     }
 
-    invert = (): RootFraction => {
+    invert = (): CoefficientElement => {
         // 3sqrt(2)/7 -> 7/3sqrt(2) -> 7sqrt(2)/(3*2) -> 7sqrt(2)/6
         // 3root(3)(2)/7 -> 7/3root(3)(2) -> 7root(3)(2^2)/(3*2) -> 7root(3)(4)/6
         this.fraction = this.fraction.invert()
         this.denominator = this.denominator * this.radical
         this.radical = this.index - 1 > 1 ? Math.pow(this.radical, this.index - 1) : this.radical
+
         return this
     }
 
-    root(value: number | (Fraction | RootFraction)): RootFraction {
+    root(value: number | (Fraction | CoefficientElement)): CoefficientElement {
         throw new Error("Method not implemented.");
     }
 
-    isSimilarTo = (value: Fraction | number | string | RootFraction): boolean => {
-        let RF = new RootFraction(value).reduce()
+    reduce = (): CoefficientElement => {
+        // Reduce the radical
+        this._extractRadical()
+
+        // Reduce the fraction
+        this.fraction = this.fraction.reduce()
+        return this
+    }
+
+    isSimilarTo = (value: Fraction | number | string | CoefficientElement): boolean => {
+        let RF = new CoefficientElement(value).reduce()
 
         // Check if the index and radical are the same
         return this.index === RF.index && this.radical === RF.radical
     }
 
-    get fraction(): Fraction {
-        return new Fraction(this.numerator, this.denominator)
+    get value(): number {
+        if (this.hasRadical) {
+            return this.numerator * Math.pow(this._radical, 1 / this._index) / this.denominator
+        }
+
+        return this.numerator / this.denominator
+    }
+
+    clone = (): CoefficientElement => {
+        let result = new CoefficientElement(this.fraction, {
+            radical: this._radical,
+            index: this._index,
+            extra: this._extra
+        })
+
+        return result
     }
 
-    set fraction(value: Fraction) {
-        this.numerator = value.numerator
-        this.denominator = value.denominator
+    get tex(): string {
+        if (!this.hasRadical) return this.fraction.tex + this.extraTex
+
+        const N = `${this.numerator} \\sqrt${this._index > 2 ? `[${this._index}]` : ''}{ ${this._radical} }`
+
+        if (this.denominator === 1) return N
+
+        return `\\frac{ ${N} }{ ${this.denominator} }${this.extraTex}`
+
     }
 
-    parse = (value: number | string | Fraction | RootFraction, radical?: number | string, index?: number | string): RootFraction => {
-        if (value instanceof RootFraction) return value.clone()
+    get display(): string {
+        let result = ''
+
+        if (this.isInfinity()) return this.signTeX + 'oo'
+        if (this.isNaN()) return 'NaN'
+
+        let N = [`${this.numerator}`, this.radicalDisplay, this.extraDisplay]
+            .filter(x => x !== '')
+
+        if (N.length > 1) {
+            N = N.map((x, index) => {
+                if (index === 0 && Math.abs(+x) === 1) return +x === -1 ? '-' : ''
+                return x
+            })
+        }
+
+
+        const D = this.denominator > 1 ? `/${this.denominator}` : ''
+
+        return `${N.join('')}${D}`
+    }
+
+    protected _parse = (value: CoefficientParserTypes, radical?: number | string, index?: number | string, extra?: string): CoefficientElement => {
+        if (value instanceof CoefficientElement) return value.clone()
+
+        this.radical = 1
+        this.index = 2
 
         if (value instanceof Fraction) {
             this.numerator = value.numerator
@@ -167,28 +239,53 @@
             this.numerator = value
             this.denominator = 1
         } else if (typeof value === "string") {
-            this.fraction = new Fraction(value)
-            // TODO parse a string with root code....
+            this._extra = value.includes('pi') ? COEFFICIENT_EXTRA.PI : value.includes('i') ? COEFFICIENT_EXTRA.I : null
+            if (this._extra !== null) {
+                value = value.replaceAll('pi', '')
+                    .replaceAll('i', '')
+
+                value = (value === '' ? "1" : value) as string
+                value = (value === '-' ? "-1" : value) as string
+            }
+
+            // Parse the string asqrt(b)/c
+            if (value.includes('sqrt')) {
+                const match = value.match(/^([0-9]+)?sqrt\(([0-9]+)\)?(\/([0-9]+))?/)
+                if (match) {
+                    const [, num, rad, , den] = match
+                    this.numerator = num === undefined ? 1 : +num
+                    this.radical = rad === undefined ? 1 : +rad
+                    this.denominator = den === undefined ? 1 : +den
+                }
+            } else if (value.includes('root')) {
+                const match = value.match(/^([0-9]*)root\(([0-9+])\)\(([0-9]+)\)?(\/([0-9]+))?/)
+                if (match) {
+                    const [, num, index, rad, , den] = match
+                    this.numerator = num === undefined ? 1 : +num
+                    this.radical = rad === undefined ? 1 : +rad
+                    this.index = index === undefined ? 2 : +index
+                    this.denominator = den === undefined ? 1 : +den
+                }
+            } else {
+                this.fraction = new Fraction(value)
+            }
         }
 
         if (radical !== undefined) this.radical = +radical
         if (index !== undefined) this.index = +index
+        if (extra !== undefined) this.extra = extra as COEFFICIENT_EXTRA
 
         return this
     }
 
-    private _resetRadical = (): RootFraction => {
+    private _resetRadical = (): CoefficientElement => {
         this._index = 2
         this._radical = 1
         return this
     }
 
-    private _hasRadical = (): boolean => {
-        return this._radical !== 1 && this._index > 1
-    }
-
     private _extractRadical = (): { extracted: number, radical: number } => {
-        // Maximal value to test for extracting the radical
+        // Maximal name to test for extracting the radical
         let extracted = Math.floor(Math.pow(this._radical, 1 / this._index))
 
         while (extracted > 1) {
Index: src/maths/types.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {Monom} from \"./algebra/monom\";\r\nimport {Polynom} from \"./algebra/polynom\";\r\nimport {Rational} from \"./algebra/rational\";\r\nimport {CoefficientTypes} from \"./coefficients/coefficientCore\";\r\n\r\ninterface coreInterface {\r\n    parse: (...values: unknown[]) => ThisType<this>,\r\n    clone: () => ThisType<this>,\r\n\r\n    readonly tex: string,\r\n    readonly display: string\r\n}\r\n\r\ninterface operationInterface {\r\n    add: (...values: unknown[]) => ThisType<this>,\r\n    subtract: (...values: unknown[]) => ThisType<this>,\r\n    multiply: (...values: unknown[]) => ThisType<this>,\r\n    divide: (value: unknown) => ThisType<this>,\r\n    opposite: () => ThisType<this>,\r\n    invert: () => ThisType<this>,\r\n    pow: (value: unknown) => ThisType<this>,\r\n    root: (value: unknown) => ThisType<this>,\r\n    reduce: () => ThisType<this>,\r\n}\r\n\r\ninterface compareInterface {\r\n    compare: (value: unknown, sign: COMPARESIGNS) => boolean,\r\n    isEqualTo: (value: unknown) => boolean,\r\n    isReduced: () => boolean,\r\n    isOne: () => boolean,\r\n    isMinusOne: () => boolean,\r\n    isUnit: () => boolean,\r\n    isZero: () => boolean,\r\n}\r\n\r\nexport interface coefficientInterface extends coreInterface, operationInterface, compareInterface {\r\n    isGreaterOrEqualTo: (value: unknown) => boolean,\r\n    isGreaterThan: (value: unknown) => boolean,\r\n    isLesserOrEqualTo: (value: unknown) => boolean,\r\n    isLesserThan: (value: unknown) => boolean,\r\n    isNaN: () => boolean,\r\n    isPositive: () => boolean,\r\n    isNegative: () => boolean,\r\n    isStrictlyNegative: () => boolean,\r\n    isStrictlyPositive: () => boolean,\r\n    isOpposedTo: (value: unknown) => boolean,\r\n    isInvertedTo: (value: unknown) => boolean,\r\n    isNatural: () => boolean,\r\n    isRelative: () => boolean,\r\n    isRational: () => boolean,\r\n    isReal: () => boolean,\r\n    isComplex: () => boolean,\r\n    isInfinity: () => boolean,\r\n    isEven: () => boolean,\r\n    isOdd: () => boolean,\r\n    readonly value: number,\r\n}\r\n\r\nexport interface coefficientStaticTypes {\r\n    average: (...values: unknown[]) => coefficientInterface,\r\n    max: (...values: unknown[]) => coefficientInterface,\r\n    min: (...values: unknown[]) => coefficientInterface,\r\n    sort: (...values: unknown[]) => coefficientInterface[],\r\n    unique: (...values: unknown[]) => coefficientInterface[],\r\n}\r\n\r\nexport interface expressionInterface extends coreInterface, operationInterface, compareInterface {\r\n    // variables getter\r\n    readonly variables: string[],\r\n    hasLetter: (letter?: string) => boolean\r\n\r\n    // Evaluate\r\n    evaluate: (value?: evaluateType) => numericType,\r\n\r\n    // Helpers\r\n    isDivisible?: (value: unknown) => boolean,\r\n}\r\n\r\n\r\nexport type literalType = { [Key: string]: CoefficientTypes }\r\nexport type numericType = number | string | CoefficientTypes\r\nexport type expressionType = Monom | Polynom | Rational\r\nexport type evaluateType = numericType | { [key: string]: numericType }\r\n\r\nexport enum COMPARESIGNS {\r\n    \"EQUALS\" = \"=\",\r\n    \"SAME\" = \"same\",\r\n    \"GREATER\" = \">\",\r\n    \"GEQ\" = \">=\",\r\n    \"LESSER\" = \"<\",\r\n    \"LEQ\" = \"<=\",\r\n    \"DIFFERENT\" = \"<>\"\r\n}
===================================================================
diff --git a/src/maths/types.ts b/src/maths/types.ts
--- a/src/maths/types.ts	
+++ b/src/maths/types.ts	
@@ -1,17 +1,14 @@
-import {Monom} from "./algebra/monom";
-import {Polynom} from "./algebra/polynom";
-import {Rational} from "./algebra/rational";
 import {CoefficientTypes} from "./coefficients/coefficientCore";
 
-interface coreInterface {
-    parse: (...values: unknown[]) => ThisType<this>,
+export interface coreInterface {
+    // parse: (...values: unknown[]) => ThisType<this>,
     clone: () => ThisType<this>,
 
     readonly tex: string,
     readonly display: string
 }
 
-interface operationInterface {
+export interface operationInterface {
     add: (...values: unknown[]) => ThisType<this>,
     subtract: (...values: unknown[]) => ThisType<this>,
     multiply: (...values: unknown[]) => ThisType<this>,
@@ -23,8 +20,8 @@
     reduce: () => ThisType<this>,
 }
 
-interface compareInterface {
-    compare: (value: unknown, sign: COMPARESIGNS) => boolean,
+export interface equalityInterface {
+    isSimilarTo: (value: unknown) => boolean,
     isEqualTo: (value: unknown) => boolean,
     isReduced: () => boolean,
     isOne: () => boolean,
@@ -33,7 +30,7 @@
     isZero: () => boolean,
 }
 
-export interface coefficientInterface extends coreInterface, operationInterface, compareInterface {
+export interface compareInterface {
     isGreaterOrEqualTo: (value: unknown) => boolean,
     isGreaterThan: (value: unknown) => boolean,
     isLesserOrEqualTo: (value: unknown) => boolean,
@@ -56,19 +53,29 @@
     readonly value: number,
 }
 
-export interface coefficientStaticTypes {
-    average: (...values: unknown[]) => coefficientInterface,
-    max: (...values: unknown[]) => coefficientInterface,
-    min: (...values: unknown[]) => coefficientInterface,
-    sort: (...values: unknown[]) => coefficientInterface[],
-    unique: (...values: unknown[]) => coefficientInterface[],
+// export interface coefficientStaticTypes {
+//     average: (...values: unknown[]) => coefficientInterface,
+//     max: (...values: unknown[]) => coefficientInterface,
+//     min: (...values: unknown[]) => coefficientInterface,
+//     sort: (...values: unknown[]) => coefficientInterface[],
+//     unique: (...values: unknown[]) => coefficientInterface[],
+// }
+
+export interface expressionElementInterface {
+    [name: string]: {
+        exponent: number,
+        root: number,
+    }
 }
 
-export interface expressionInterface extends coreInterface, operationInterface, compareInterface {
+
+export interface expressionInterface {
     // variables getter
     readonly variables: string[],
+    readonly literal: expressionElementInterface
     hasLetter: (letter?: string) => boolean
 
+
     // Evaluate
     evaluate: (value?: evaluateType) => numericType,
 
@@ -79,7 +86,6 @@
 
 export type literalType = { [Key: string]: CoefficientTypes }
 export type numericType = number | string | CoefficientTypes
-export type expressionType = Monom | Polynom | Rational
 export type evaluateType = numericType | { [key: string]: numericType }
 
 export enum COMPARESIGNS {
Index: src/maths/coefficients/coefficientCore.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {Fraction} from \"./fraction\";\r\nimport {RootFraction} from \"./rootFraction\";\r\nimport {Numeric} from \"../numeric\";\r\n\r\n\r\nexport type CoefficientTypes = Fraction | RootFraction\r\nexport type CoefficientParserTypes = CoefficientTypes | number | string\r\n\r\nexport enum COEFFICIENT_MODE {\r\n    \"FRACTION\",\r\n    \"ROOT\",\r\n    \"RADIAN\",\r\n    \"COMPLEX\"\r\n}\r\n\r\nexport enum FRACTION_FRAC {\r\n    \"frac\",\r\n    \"dfrac\",\r\n    \"tfrac\",\r\n}\r\n\r\nexport abstract class CoefficientCore<T extends CoefficientTypes> {\r\n    private _fracType: FRACTION_FRAC\r\n\r\n    get fracType(): FRACTION_FRAC {\r\n        return this._fracType;\r\n    }\r\n\r\n    set fracType(value: FRACTION_FRAC) {\r\n        this._fracType = value;\r\n    }\r\n\r\n    private _numerator: number\r\n\r\n    get numerator(): number {\r\n        return this._numerator;\r\n    }\r\n\r\n    set numerator(value: number) {\r\n        this._numerator = value;\r\n    }\r\n\r\n    private _denominator: number\r\n\r\n    get denominator(): number {\r\n        return this._denominator;\r\n    }\r\n\r\n    set denominator(value: number) {\r\n        this._denominator = value;\r\n    }\r\n\r\n    get value(): number {\r\n        return this._numerator / this._denominator\r\n    }\r\n\r\n    get sign(): number {\r\n        return (this.numerator * this.denominator >= 0) ? 1 : -1;\r\n    };\r\n\r\n    get signTeX(): string {\r\n        return this.sign === 1 ? '+' : '-'\r\n    }\r\n\r\n    get fracTeX(): string {\r\n        return this._fracType === FRACTION_FRAC.frac ? '\\\\frac' : this._fracType === FRACTION_FRAC.dfrac ? '\\\\dfrac' : '\\\\tfrac'\r\n    }\r\n\r\n    abstract get tex(): string\r\n\r\n    abstract get display(): string\r\n\r\n    static max = <T extends CoefficientTypes>(...values: T[]): T => {\r\n        const [first, ...rest] = values\r\n        return rest.reduce((acc, cur) => acc.isGreaterThan(cur) ? acc : cur, first)\r\n    }\r\n\r\n    static min = <T extends CoefficientTypes>(...values: T[]): T => {\r\n        const [first, ...rest] = values\r\n        return rest.reduce((acc, cur) => acc.isGreaterThan(cur) ? cur : acc, first)\r\n    }\r\n\r\n    static unique = <T extends CoefficientTypes>(values: T[], sort?: boolean): T[] => {\r\n        let uniqueObjects: T[] = [],\r\n            uniqueValues: number[] = []\r\n\r\n        values.forEach((value, index) => {\r\n            if (!uniqueValues.includes(value.value)) {\r\n                uniqueValues.push(value.value)\r\n                uniqueObjects.push(value)\r\n            }\r\n        })\r\n\r\n        if (sort) return CoefficientCore.sort(uniqueObjects)\r\n\r\n        return uniqueObjects\r\n    }\r\n\r\n    static sort = <T extends CoefficientTypes>(values: T[], reverse?: boolean): T[] => {\r\n        let sorted = values.sort((a, b) => a.value - b.value)\r\n\r\n        if (reverse) sorted = sorted.reverse()\r\n\r\n        return sorted\r\n    }\r\n\r\n    abstract createInstance(value?: number | string | T): T\r\n\r\n    abstract clone(): T\r\n\r\n    abstract reduce(): T\r\n\r\n    getReducedCoefficient = (): { N: number, D: number } => {\r\n        if (this.numerator === 1 || this.denominator === 1) return {N: this.numerator, D: this.denominator}\r\n\r\n        let g = Numeric.gcd(this.numerator, this.denominator);\r\n        let [N, D] = [this.numerator, this.denominator]\r\n\r\n        N = N / g;\r\n        D = D / g;\r\n\r\n        if (D < 0) {\r\n            D = -D;\r\n            N = -N;\r\n        }\r\n\r\n        return {N, D}\r\n    };\r\n\r\n    zero = (): T => {\r\n        this.numerator = 0;\r\n        this.denominator = 1;\r\n        return this as unknown as T;\r\n    };\r\n\r\n    one = (): T => {\r\n        this.numerator = 1;\r\n        this.denominator = 1;\r\n        return this as unknown as T;\r\n    };\r\n\r\n    infinite = (): T => {\r\n        this.numerator = Infinity;\r\n        this.denominator = 1;\r\n        return this as unknown as T;\r\n    };\r\n\r\n    invalid = (): T => {\r\n        this.numerator = NaN;\r\n        this.denominator = 1;\r\n        return this as unknown as T\r\n    };\r\n\r\n    abstract add(...coefficients: (T | number | string)[]): T\r\n\r\n    opposite = (): T => {\r\n        this.numerator = -this.numerator;\r\n        return this as unknown as T;\r\n    }\r\n\r\n    subtract = (...coefficients: (T | number | string)[]): T => this.add(...coefficients.map(c => this.createInstance(c).opposite() as T))\r\n\r\n    abstract multiply(...coefficients: (T | number | string)[]): T\r\n\r\n    abstract invert(): T\r\n\r\n    divide = (F: T | number): T => this.multiply(this.createInstance(F).invert() as T);\r\n\r\n    abs = (): T => {\r\n        this.numerator = Math.abs(this.numerator);\r\n        return this as unknown as T;\r\n    }\r\n\r\n    pow = (value: number | CoefficientTypes): T => {\r\n        if (Number.isSafeInteger(value)) {\r\n            const factor = this.clone(),\r\n                abs = Math.abs(value as number)\r\n            for (let i = abs; i <= abs; i++) {\r\n                this.multiply(factor)\r\n            }\r\n\r\n            if ((value as number) < 0) this.invert()\r\n        } else {\r\n            throw new Error('Cannot raise a coefficient to a non-integer power')\r\n        }\r\n        return this as unknown as T\r\n    }\r\n\r\n    abstract root(value: number | CoefficientTypes): T\r\n\r\n    sqrt = (): T => this.root(2)\r\n\r\n    asTopFraction = (): T => {\r\n        this.fracType = FRACTION_FRAC.tfrac\r\n        return this as unknown as T\r\n    }\r\n\r\n    asDisplayFraction = (): T => {\r\n        this.fracType = FRACTION_FRAC.dfrac\r\n        return this as unknown as T\r\n    }\r\n\r\n\r\n    /**\r\n     * All the is* methods without argument\r\n     */\r\n\r\n    isReduced = (): boolean => Math.abs(Numeric.gcd(this._numerator, this._denominator)) === 1\r\n\r\n    isOne = (): boolean => this._numerator === 1 && this._denominator === 1\r\n\r\n    isMinusOne = (): boolean => this._numerator === -1 && this._denominator === 1\r\n\r\n    isUnit = (): boolean => this.isOne() || this.isMinusOne()\r\n\r\n    isZero = (): boolean => this._numerator === 0\r\n\r\n    isFinite = (): boolean => !this.isInfinity() && !this.isNaN()\r\n\r\n    isSquare = (): boolean => Math.sqrt(this._numerator) % 1 === 0 && Math.sqrt(this._denominator) % 1 === 0\r\n\r\n    isNaN = (): boolean => isNaN(this.value)\r\n\r\n    isPositive = (): boolean => this.sign === 1\r\n\r\n    isNegative = (): boolean => this.sign === -1\r\n\r\n    isStrictlyNegative = (): boolean => this.value < 0\r\n\r\n    isStrictlyPositive = (): boolean => this.value > 0\r\n\r\n    isNatural = (): boolean => this.isRelative() && this.isPositive()\r\n\r\n    isRelative = (): boolean => {\r\n        const {N, D} = this.getReducedCoefficient()\r\n        return D === 1\r\n    }\r\n\r\n    isRational = (): boolean => !this.isRelative()\r\n\r\n    isReal = (): boolean => true\r\n\r\n    isComplex = (): boolean => false\r\n\r\n    isInfinity = (): boolean => Math.abs(this.value) === Infinity\r\n\r\n    isEven = (): boolean => this.isRelative() && this.value % 2 === 0\r\n\r\n    isOdd = (): boolean => this.isRelative() && this.value % 2 === 1\r\n\r\n    isApproximative = (): boolean => this._numerator.toString().length >= 15 && this._denominator.toString().length >= 15\r\n\r\n    isExact = (): boolean => !this.isApproximative()\r\n\r\n    isGreaterThan = (than: CoefficientCore<any> | number | string): boolean => this.value > this.createInstance(than as T).value;\r\n\r\n    isSimilarTo = (to: CoefficientCore<any> | number | string): boolean => true;\r\n\r\n    isGreaterOrEqualTo = (than: CoefficientCore<any> | number | string): boolean => this.value >= this.createInstance(than as T).value;\r\n\r\n    isLesserOrEqualTo = (than: CoefficientCore<any> | number | string): boolean => this.value <= this.createInstance(than as T).value;\r\n\r\n    isLesserThan = (than: CoefficientCore<any> | number | string): boolean => this.value < this.createInstance(than as T).value;\r\n\r\n    isEqualTo = (than: CoefficientCore<any> | number | string): boolean => this.value === this.createInstance(than as T).value\r\n\r\n    isOpposedTo = (to: CoefficientCore<any> | number | string): boolean => this.isEqualTo(this.createInstance(to as T).opposite())\r\n\r\n    isInvertedTo = (to: CoefficientCore<any> | number | string): boolean => this.isEqualTo(this.createInstance(to as T).invert())\r\n\r\n}\r\n
===================================================================
diff --git a/src/maths/coefficients/coefficientCore.ts b/src/maths/coefficients/coefficientCore.ts
--- a/src/maths/coefficients/coefficientCore.ts	
+++ b/src/maths/coefficients/coefficientCore.ts	
@@ -1,9 +1,11 @@
 import {Fraction} from "./fraction";
-import {RootFraction} from "./rootFraction";
+import {CoefficientElement} from "./coefficientElement";
 import {Numeric} from "../numeric";
+import {compareInterface, coreInterface, equalityInterface, operationInterface} from "../types";
+import {Coefficient} from "./coefficient";
 
 
-export type CoefficientTypes = Fraction | RootFraction
+export type CoefficientTypes = Fraction | CoefficientElement | Coefficient
 export type CoefficientParserTypes = CoefficientTypes | number | string
 
 export enum COEFFICIENT_MODE {
@@ -13,13 +15,28 @@
     "COMPLEX"
 }
 
+export enum COEFFICIENT_EXTRA {
+    'I' = "i",
+    'PI' = "pi"
+}
+
 export enum FRACTION_FRAC {
     "frac",
     "dfrac",
     "tfrac",
 }
 
-export abstract class CoefficientCore<T extends CoefficientTypes> {
+export abstract class CoefficientCore<T extends CoefficientTypes> implements coreInterface, operationInterface, equalityInterface, compareInterface {
+    private _exact: boolean
+
+    get exact(): boolean {
+        return this._exact;
+    }
+
+    set exact(value: boolean) {
+        this._exact = value;
+    }
+
     private _fracType: FRACTION_FRAC
 
     get fracType(): FRACTION_FRAC {
@@ -50,10 +67,6 @@
         this._denominator = value;
     }
 
-    get value(): number {
-        return this._numerator / this._denominator
-    }
-
     get sign(): number {
         return (this.numerator * this.denominator >= 0) ? 1 : -1;
     };
@@ -66,10 +79,6 @@
         return this._fracType === FRACTION_FRAC.frac ? '\\frac' : this._fracType === FRACTION_FRAC.dfrac ? '\\dfrac' : '\\tfrac'
     }
 
-    abstract get tex(): string
-
-    abstract get display(): string
-
     static max = <T extends CoefficientTypes>(...values: T[]): T => {
         const [first, ...rest] = values
         return rest.reduce((acc, cur) => acc.isGreaterThan(cur) ? acc : cur, first)
@@ -106,9 +115,13 @@
 
     abstract createInstance(value?: number | string | T): T
 
-    abstract clone(): T
-
-    abstract reduce(): T
+    amplify = (k: number): T => {
+        if (Number.isSafeInteger(k)) {
+            this.numerator *= k;
+            this.denominator *= k;
+        }
+        return this as unknown as T;
+    };
 
     getReducedCoefficient = (): { N: number, D: number } => {
         if (this.numerator === 1 || this.denominator === 1) return {N: this.numerator, D: this.denominator}
@@ -153,25 +166,28 @@
 
     abstract add(...coefficients: (T | number | string)[]): T
 
-    opposite = (): T => {
-        this.numerator = -this.numerator;
-        return this as unknown as T;
-    }
-
     subtract = (...coefficients: (T | number | string)[]): T => this.add(...coefficients.map(c => this.createInstance(c).opposite() as T))
 
     abstract multiply(...coefficients: (T | number | string)[]): T
 
-    abstract invert(): T
-
     divide = (F: T | number): T => this.multiply(this.createInstance(F).invert() as T);
 
-    abs = (): T => {
-        this.numerator = Math.abs(this.numerator);
+    opposite = (): T => {
+        this.numerator = -this.numerator;
         return this as unknown as T;
     }
 
-    pow = (value: number | CoefficientTypes): T => {
+    abstract invert(): T
+
+    pow = (value: number | Fraction): T => {
+        // It's a fraction - numerator = power, denoinator = root
+        if (value instanceof Fraction) {
+            this.pow(this.numerator)
+            this.root(this.denominator)
+            return this as unknown as T
+        }
+
+        // It's a number
         if (Number.isSafeInteger(value)) {
             const factor = this.clone(),
                 abs = Math.abs(value as number)
@@ -188,6 +204,13 @@
 
     abstract root(value: number | CoefficientTypes): T
 
+    abstract reduce(): T
+
+    abs = (): T => {
+        this.numerator = Math.abs(this.numerator);
+        return this as unknown as T;
+    }
+
     sqrt = (): T => this.root(2)
 
     asTopFraction = (): T => {
@@ -200,25 +223,24 @@
         return this as unknown as T
     }
 
-
-    /**
-     * All the is* methods without argument
-     */
-
-    isReduced = (): boolean => Math.abs(Numeric.gcd(this._numerator, this._denominator)) === 1
-
-    isOne = (): boolean => this._numerator === 1 && this._denominator === 1
-
-    isMinusOne = (): boolean => this._numerator === -1 && this._denominator === 1
-
-    isUnit = (): boolean => this.isOne() || this.isMinusOne()
-
-    isZero = (): boolean => this._numerator === 0
-
     isFinite = (): boolean => !this.isInfinity() && !this.isNaN()
 
     isSquare = (): boolean => Math.sqrt(this._numerator) % 1 === 0 && Math.sqrt(this._denominator) % 1 === 0
 
+    isApproximative = (): boolean => this._numerator.toString().length >= 15 && this._denominator.toString().length >= 15
+
+    isExact = (): boolean => !this.isApproximative()
+
+    isSimilarTo = (to: CoefficientCore<any> | number | string): boolean => true;
+
+    isGreaterOrEqualTo = (than: CoefficientCore<any> | number | string): boolean => this.value >= this.createInstance(than as T).value;
+
+    isGreaterThan = (than: CoefficientCore<any> | number | string): boolean => this.value > this.createInstance(than as T).value;
+
+    isLesserOrEqualTo = (than: CoefficientCore<any> | number | string): boolean => this.value <= this.createInstance(than as T).value;
+
+    isLesserThan = (than: CoefficientCore<any> | number | string): boolean => this.value < this.createInstance(than as T).value;
+
     isNaN = (): boolean => isNaN(this.value)
 
     isPositive = (): boolean => this.sign === 1
@@ -229,6 +251,10 @@
 
     isStrictlyPositive = (): boolean => this.value > 0
 
+    isOpposedTo = (to: CoefficientCore<any> | number | string): boolean => this.isEqualTo(this.createInstance(to as T).opposite())
+
+    isInvertedTo = (to: CoefficientCore<any> | number | string): boolean => this.isEqualTo(this.createInstance(to as T).invert())
+
     isNatural = (): boolean => this.isRelative() && this.isPositive()
 
     isRelative = (): boolean => {
@@ -248,24 +274,32 @@
 
     isOdd = (): boolean => this.isRelative() && this.value % 2 === 1
 
-    isApproximative = (): boolean => this._numerator.toString().length >= 15 && this._denominator.toString().length >= 15
-
-    isExact = (): boolean => !this.isApproximative()
-
-    isGreaterThan = (than: CoefficientCore<any> | number | string): boolean => this.value > this.createInstance(than as T).value;
-
-    isSimilarTo = (to: CoefficientCore<any> | number | string): boolean => true;
-
-    isGreaterOrEqualTo = (than: CoefficientCore<any> | number | string): boolean => this.value >= this.createInstance(than as T).value;
-
-    isLesserOrEqualTo = (than: CoefficientCore<any> | number | string): boolean => this.value <= this.createInstance(than as T).value;
-
-    isLesserThan = (than: CoefficientCore<any> | number | string): boolean => this.value < this.createInstance(than as T).value;
+    get value(): number {
+        return this._numerator / this._denominator
+    }
 
     isEqualTo = (than: CoefficientCore<any> | number | string): boolean => this.value === this.createInstance(than as T).value
 
-    isOpposedTo = (to: CoefficientCore<any> | number | string): boolean => this.isEqualTo(this.createInstance(to as T).opposite())
+    /**
+     * All the is* methods without argument
+     */
+
+    isReduced = (): boolean => Math.abs(Numeric.gcd(this._numerator, this._denominator)) === 1
+
+    isOne = (): boolean => this._numerator === 1 && this._denominator === 1
+
+    isMinusOne = (): boolean => this._numerator === -1 && this._denominator === 1
+
+    isUnit = (): boolean => this.isOne() || this.isMinusOne()
+
+    isZero = (): boolean => this._numerator === 0
+
+    abstract clone(): T
+
+    abstract get tex(): string
 
-    isInvertedTo = (to: CoefficientCore<any> | number | string): boolean => this.isEqualTo(this.createInstance(to as T).invert())
+    abstract get display(): string
+
+    protected abstract _parse(value: unknown): T
 
 }
Index: tests/geometry/radian.test.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {describe} from \"mocha\";\r\nimport {expect} from \"chai\";\r\nimport {Radian} from \"../../src/maths/geometry/radian\";\r\ndescribe('Random tests', () => {\r\n    it('should create a radian value', () => {\r\n        let r = new Radian('3/2')\r\n\r\n        expect(r.tex).to.be.equal('\\\\frac{ 3\\\\pi }{ 2 }')\r\n        expect(r.display).to.be.equal('3pi/2')\r\n\r\n        let rp = new Radian('3/2', '1/2')\r\n\r\n        expect(rp.tex).to.be.equal('\\\\frac{ 3\\\\pi }{ 2 }+k\\\\frac{ \\\\pi }{ 2 }')\r\n        expect(rp.display).to.be.equal('3pi/2+kpi/2')\r\n    })\r\n})
===================================================================
diff --git a/tests/geometry/radian.test.ts b/tests/geometry/radian.test.ts
--- a/tests/geometry/radian.test.ts	
+++ b/tests/geometry/radian.test.ts	
@@ -1,8 +1,9 @@
 import {describe} from "mocha";
 import {expect} from "chai";
 import {Radian} from "../../src/maths/geometry/radian";
+
 describe('Random tests', () => {
-    it('should create a radian value', () => {
+    it('should create a radian name', () => {
         let r = new Radian('3/2')
 
         expect(r.tex).to.be.equal('\\frac{ 3\\pi }{ 2 }')
