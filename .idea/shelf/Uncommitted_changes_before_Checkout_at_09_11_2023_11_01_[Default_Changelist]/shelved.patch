Index: src/maths/algebra/monom.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/***\r\n * Monom class\r\n * The monom class represents of monom of the form:\r\n * k * x^n * y^m * z^p\r\n * k: Coefficient\r\n * n, m, p: powers as Fraction\r\n * x, y, z: letters as string\r\n */\r\nimport {Numeric} from \"../numeric\";\r\nimport {Shutingyard, ShutingyardType, Token} from \"../shutingyard\";\r\nimport {COMPARESIGNS, literalType} from \"../types\";\r\nimport {RootFraction} from \"../coefficients/rootFraction\";\r\nimport {\r\n    COEFFICIENT_MODE,\r\n    CoefficientCore,\r\n    CoefficientParserTypes,\r\n    CoefficientTypes\r\n} from \"../coefficients/coefficientCore\";\r\nimport {Fraction} from \"../coefficients/fraction\";\r\n\r\n\r\nexport class Monom {\r\n    private _coefficientMode: COEFFICIENT_MODE\r\n\r\n    /**\r\n     * Create a Monom\r\n     * Defined as \\\\(k \\\\cdot x^{n}\\\\), where \\\\( k,n \\in \\\\mathbb{Q}\\\\).\r\n     * Examples: \\\\(3x^2\\\\) or \\\\(3/5x^2\\\\)\r\n     * @param value (optional) string The value that should be parse. Can be a Monom, a Fraction, a string or a number. If nothing is provided, it will return the trivial monom (0).\r\n     */\r\n    constructor(value?: unknown) {\r\n        this.zero();\r\n\r\n        if (value !== undefined) {\r\n            // A string is given - try to parse the value.\r\n            this.parse(value);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Getter and setter\r\n\r\n    private _coefficient: CoefficientCore<any>;\r\n\r\n    // ------------------------------------------\r\n    /**\r\n     * Get the coefficient \\\\(k\\\\) of the Monom \\\\(k\\\\cdot x^{n}\\\\)\r\n     * @returns {Fraction}\r\n     */\r\n    get coefficient(): CoefficientCore<any> {\r\n        return this._coefficient;\r\n    }\r\n\r\n    /**\r\n     * Set the coefficient \\\\(k\\\\) value of the monom\r\n     * @param {Fraction | number | string} F\r\n     */\r\n    set coefficient(F: CoefficientParserTypes) {\r\n        this._coefficient = this.makeCoefficient(F);\r\n    }\r\n\r\n    private _literal: literalType;\r\n\r\n    /**\r\n     * Get the literal part of \\\\(x^{n_1}y^{n_2}\\\\) as dictionary \\\\[\\\\begin{array}{ll}x&=n_1\\\\\\\\y&=n_2\\\\end{array}\\\\]\r\n     * @returns {literalType}\r\n     */\r\n    get literal(): literalType {\r\n        return this._literal;\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom. Must be a dictionary {x: Fraction, y: Fraction, ...}\r\n     * @param {literalType} L\r\n     */\r\n    set literal(L: literalType) {\r\n        this._literal = L;\r\n    }\r\n\r\n    /**\r\n     * Get the literal square roots of the Monom.\r\n     * TODO: remove this getter ? Is it used and is it correct ?\r\n     * @returns {literalType}\r\n     */\r\n    get literalSqrt(): literalType {\r\n        if (this.isLiteralSquare()) {\r\n            let L: literalType = {}\r\n            for (let key in this._literal) {\r\n                L[key] = this._literal[key].clone().sqrt()\r\n            }\r\n            return L;\r\n        } else {\r\n            return this._literal;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the literal part of the monom from a string\r\n     * @param inputStr  String like x^2y^3\r\n     */\r\n    set literalStr(inputStr: string) {\r\n        // TODO : parse using shutingyard tree !\r\n\r\n        // Match all x^n\r\n        for (const v of [...inputStr.matchAll(/([a-z])\\^([+-]?[0-9]+)/g)]) {\r\n            // Create the default letter entry if necessary.\r\n            if (!(v[1] in this._literal)) {\r\n                this._literal[v[1]] = this.makeCoefficient().zero();\r\n            }\r\n\r\n            // Add the new value.\r\n            // TODO: actually, it adds only numeric value\r\n            this._literal[v[1]].add(+v[2]);\r\n        }\r\n\r\n        // Match all x\r\n        for (const v of [...inputStr.matchAll(/([a-z](?!\\^))/g)]) {\r\n            // Match all single letters\r\n            if (!(v[1] in this._literal)) {\r\n                this._literal[v[1]] = this.makeCoefficient().zero();\r\n            }\r\n\r\n            // Add one to the value.\r\n            this._literal[v[1]].add(1)\r\n        }\r\n    }\r\n\r\n    // Getter helpers.\r\n    /**\r\n     * Get the variables letters\r\n     */\r\n    get variables(): string[] {\r\n        let M = this.clone().clean();\r\n        return Object.keys(M.literal)\r\n    }\r\n\r\n    // Display getter\r\n    /**\r\n     * This display getter is to be used in the polynom display getter\r\n     */\r\n    get display(): string {\r\n        let L: string = '',\r\n            letters = Object.keys(this._literal).sort()\r\n        for (let letter of letters) {\r\n            if (!this._literal[letter].isZero()) {\r\n                L += `${letter}`;\r\n                if (!this._literal[letter].isEqualTo(1)) {\r\n                    L += `^(${this._literal[letter].display})`;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.display}`;\r\n            } else {\r\n                return '';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.display}${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    get dividers(): Monom[] {\r\n        // Decompose only if the coefficient is a natural number\r\n        if (!this.coefficient.isRelative()) {\r\n            return [this.clone()]\r\n        }\r\n\r\n\r\n        // Decompose only if the power values are natural numbers.\r\n        if (this.hasFractionCoefficient()) {\r\n            return [this.clone()]\r\n        }\r\n\r\n        // Security : do not do this if isGreaterThan than 10000\r\n        if (this.coefficient.numerator > 1000000) {\r\n            return [this.clone()]\r\n        }\r\n\r\n        const dividers = Numeric.dividers(Math.abs(this.coefficient.numerator))\r\n\r\n        // Decompose the literals parts.\r\n        let literals: literalType[] = [];\r\n        for (let L in this.literal) {\r\n            // L is the letter.\r\n            literals = this._getLiteralDividers(literals, L)\r\n        }\r\n\r\n        const monomDividers: Monom[] = [];\r\n        if (literals.length > 0 && dividers.length > 0) {\r\n            for (let N of dividers) {\r\n                for (let L of literals) {\r\n                    let M = new Monom();\r\n                    M.coefficient = this.makeCoefficient(N)\r\n                    M.literal = L\r\n                    monomDividers.push(M)\r\n                }\r\n            }\r\n        } else if (dividers.length === 0) {\r\n            for (let L of literals) {\r\n                let M = new Monom();\r\n                M.coefficient = this.makeCoefficient().one()\r\n                M.literal = L\r\n                monomDividers.push(M)\r\n            }\r\n        } else {\r\n            for (let N of dividers) {\r\n                let M = new Monom();\r\n                M.coefficient = this.makeCoefficient(N)\r\n                monomDividers.push(M)\r\n            }\r\n        }\r\n\r\n        return monomDividers.length === 0 ? [new Monom().one()] : monomDividers;\r\n    }\r\n\r\n    /**\r\n     * Display the monom, forcing the '+' sign to appear\r\n     */\r\n    get displayWithSign(): string {\r\n        let d: String = this.display;\r\n        return (d[0] !== '-' ? '+' : '') + d;\r\n    }\r\n\r\n    get texWithSign(): string {\r\n        if (this.coefficient.isStrictlyPositive()) {\r\n            return '+' + this.tex\r\n        }\r\n\r\n        return this.tex\r\n    }\r\n\r\n    get plotFunction(): string {\r\n\r\n        let L: string = '',\r\n            letters = Object.keys(this._literal).sort()\r\n\r\n        for (let letter of letters) {\r\n            if (!this._literal[letter].isZero()) {\r\n                L += (L === '' ? \"\" : \"*\") + `${letter}`\r\n                if (!this._literal[letter].isEqualTo(1)) {\r\n                    L += `^(${this._literal[letter].display})`;\r\n                }\r\n            }\r\n        }\r\n\r\n        // No literal part\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.display}`;\r\n            } else {\r\n                return '';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.display}*${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------\r\n    // Creation / parsing functions\r\n\r\n    /**\r\n     * Get the tex output of the monom\r\n     */\r\n    get tex(): string {\r\n        // TODO: display with square root !\r\n        let L: string = '',\r\n            letters = Object.keys(this._literal).sort()\r\n\r\n        for (let letter of letters) {\r\n            if (!this._literal[letter].isZero()) {\r\n                L += `${letter}`;\r\n                if (!this._literal[letter].isEqualTo(1)) {\r\n                    L += `^{${this._literal[letter].asTopFraction().tex}}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (L === '') {\r\n            // No setLetter - means it's only a number !\r\n            if (this._coefficient.value != 0) {\r\n                return `${this._coefficient.tex}`;\r\n            } else {\r\n                return '0';\r\n            }\r\n        } else {\r\n            if (this._coefficient.value === 1) {\r\n                return L;\r\n            } else if (this._coefficient.value === -1) {\r\n                return `-${L}`;\r\n            } else if (this._coefficient.value === 0) {\r\n                return '0';\r\n            } else {\r\n                return `${this._coefficient.tex}${L}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the least common multiple of monoms\r\n     * @param monoms    Array of monoms\r\n     */\r\n    static lcm = (...monoms: Monom[]): Monom => {\r\n        // All the monoms must be with natural powers...\r\n        for (let m of monoms) {\r\n            if (m.hasFractionCoefficient()) {\r\n                return new Monom().zero()\r\n            }\r\n        }\r\n\r\n\r\n        let M = new Monom(),\r\n            coeffN: number[] = monoms.map(value => value.coefficient.numerator),\r\n            coeffD: number[] = monoms.map(value => value.coefficient.denominator),\r\n            n = Numeric.gcd(...coeffN),\r\n            d = Numeric.lcm(...coeffD);\r\n\r\n        // Get the coefficient.\r\n        M.coefficient = this.makeCoefficient(n, d).reduce();\r\n\r\n        // Set the literal parts - go through each monoms literal parts and get only the lowest degree of each letters.\r\n        for (let m of monoms) {\r\n            // Remove the inexistant letters from the resulting monom\r\n            for (let letter in M.literal) {\r\n                if (!(letter in m.literal)) {\r\n                    M.literal[letter].zero();\r\n                }\r\n            }\r\n            for (let letter in m.literal) {\r\n                if (M.literal[letter] === undefined && m.literal[letter].isStrictlyPositive()) {\r\n                    M.literal[letter] = m.literal[letter].clone();\r\n                } else {\r\n                    M.literal[letter] = this.makeCoefficient(Math.min(m.literal[letter].value, M.literal[letter].value))\r\n                }\r\n            }\r\n        }\r\n\r\n        return M;\r\n    };\r\n\r\n    /**\r\n     * Multiply two monoms and return a NEW monom.\r\n     * @param monoms\r\n     */\r\n    static xmultiply = (...monoms: Monom[]): Monom => {\r\n        let M = new Monom().one();\r\n\r\n        for (let m of monoms) {\r\n            M.multiply(m);\r\n        }\r\n\r\n        return M;\r\n    };\r\n\r\n    makeCoefficient = (...values: CoefficientParserTypes[]): CoefficientTypes => {\r\n        if (this._coefficientMode === COEFFICIENT_MODE.FRACTION) {\r\n            return new Fraction(...values as (Fraction | string | number)[])\r\n        } else if (this._coefficientMode === COEFFICIENT_MODE.ROOT) {\r\n            return new RootFraction(...values as (RootFraction | Fraction | string | number)[])\r\n        }\r\n\r\n        // TODO: add the other modes\r\n        return new Fraction(...values as (Fraction | string | number)[])\r\n    }\r\n\r\n// -----------------------------------------\r\n    /**\r\n     * Parse a string to a monom. The string may include fraction.\r\n     * @param inputStr\r\n     */\r\n    parse = (inputStr: unknown): Monom => {\r\n\r\n        if (typeof inputStr === 'string') {\r\n            this._shutingYardToReducedMonom(inputStr)\r\n        } else if (typeof inputStr === 'number') {\r\n            this._coefficient = this.makeCoefficient(inputStr)\r\n            this._literal = {}\r\n        } else if (inputStr instanceof Fraction) {\r\n            this._coefficient = inputStr.clone()\r\n            this._literal = {}\r\n        } else if (inputStr instanceof RootFraction) {\r\n            this._coefficient = inputStr.clone()\r\n            this._literal = {}\r\n        } else if (inputStr instanceof Monom) {\r\n            this._coefficient = inputStr._coefficient.clone()\r\n            this._literal = this.copyLiterals(inputStr.literal)\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    addToken = (stack: Monom[], element: Token): void => {\r\n\r\n        let q1: Monom, q2: Monom, m: Monom, letter: string, pow: CoefficientCore<any>\r\n\r\n        if (element.tokenType === ShutingyardType.COEFFICIENT) {\r\n            stack.push(new Monom(this.makeCoefficient(element.token)))\r\n\r\n        } else if (element.tokenType === ShutingyardType.VARIABLE) {\r\n            let M = new Monom().one()\r\n            M.setLetter(element.token, 1)\r\n            stack.push(M.clone())\r\n\r\n        } else if (element.tokenType === ShutingyardType.OPERATION) {\r\n            switch (element.token) {\r\n                case '-':\r\n                    // this should only happen for negative powers or for negative coefficient.\r\n                    q2 = (stack.pop()) || new Monom().zero()\r\n                    q1 = (stack.pop()) || new Monom().zero()\r\n\r\n                    stack.push(q1.subtract(q2))\r\n\r\n                    break;\r\n                case '*':\r\n                    // Get the last element in the stack\r\n                    q2 = (stack.pop()) || new Monom().one()\r\n                    q1 = (stack.pop()) || new Monom().one()\r\n\r\n                    stack.push(q1.multiply(q2))\r\n                    break\r\n                case '/':\r\n                    // Get the last element in the stack\r\n                    q2 = (stack.pop()) || new Monom().one()\r\n                    q1 = (stack.pop()) || new Monom().one()\r\n\r\n                    stack.push(q1.divide(q2))\r\n                    break\r\n                case '^':\r\n                    // get the two last elements in the stack\r\n                    pow = (stack.pop().coefficient) || this.makeCoefficient().one()\r\n                    m = (stack.pop()) || new Monom().one()\r\n\r\n                    letter = m.variables[0]\r\n\r\n                    if (letter !== undefined) {\r\n                        m.setLetter(letter, pow)\r\n                    }\r\n\r\n                    stack.push(m)\r\n                    // this.multiply(m.clone())\r\n                    break\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current Monom.\r\n     */\r\n    clone = (): Monom => {\r\n        let F: Monom = new Monom();\r\n\r\n        F.coefficient = this._coefficient.clone();\r\n\r\n        // Copy the literal parts.\r\n        for (let k in this._literal) {\r\n            F.setLetter(k, this._literal[k].clone());\r\n        }\r\n        return F;\r\n    };\r\n\r\n    copyLiterals = (literal: literalType): literalType => {\r\n        let L: literalType = {}\r\n\r\n        for (let k in literal) {\r\n            L[k] = literal[k].clone()\r\n        }\r\n        return L\r\n    }\r\n\r\n    makeSame = (M: Monom): Monom => {\r\n        // Copy the literal parts.\r\n        for (let k in M._literal) {\r\n            this.setLetter(k, M._literal[k].clone());\r\n        }\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Create a zero value monom\r\n     */\r\n    zero = (): Monom => {\r\n        this._coefficient = this.makeCoefficient().zero();\r\n        this._literal = {};\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Create a one value monom\r\n     */\r\n    one = (): Monom => {\r\n        this._coefficient = this.makeCoefficient().one();\r\n        this._literal = {};\r\n        return this;\r\n    };\r\n\r\n// ------------------------------------------\r\n// Mathematical operations\r\n// ------------------------------------------\r\n\r\n    /**\r\n     * Clean the monom by removing each letters with a power of zero.\r\n     */\r\n    clean = (): Monom => {\r\n        for (let letter in this._literal) {\r\n            if (this._literal[letter].isZero()) {\r\n                delete this._literal[letter];\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    reduce = (): Monom => {\r\n        this.clean()\r\n        this.coefficient.reduce()\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Get the opposite\r\n     * Returns a monom.\r\n     */\r\n    opposed = (): Monom => {\r\n        this._coefficient.opposite();\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Add all similar monoms. If they aren't similar, they are simply skipped.\r\n     * @param M (Monom[]) The monoms to add.\r\n     */\r\n    add = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            if (this.isSameAs(m)) {\r\n                if (this.isZero()) {\r\n                    this.makeSame(m)\r\n                }\r\n                this._coefficient.add(m.coefficient);\r\n            } else {\r\n                console.log('Add monom: ' + this.display + ' is not similar with ', m.display);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Subtract multiple monoms\r\n     * @param M (Monom[]) The monoms to subtract\r\n     */\r\n    subtract = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            if (this.isSameAs(m)) {\r\n                if (this.isZero()) {\r\n                    this.makeSame(m)\r\n                }\r\n                this._coefficient.add(m.clone().coefficient.opposite());\r\n            } else {\r\n                console.log('Subtract: Is not similar: ', m.display);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Multiple multiple monoms to the current monom\r\n     * @param M (Monom[]) The monoms to multiply to.\r\n     */\r\n    multiply = (...M: Monom[]): Monom => {\r\n        for (let m of M) {\r\n            // Multiply the coefficient.\r\n            this._coefficient.multiply(m.coefficient);\r\n\r\n            // Multiply the literal parts.\r\n            for (let letter in m.literal) {\r\n                if (this._literal[letter] === undefined) {\r\n                    this._literal[letter] = m.literal[letter].clone()\r\n                } else {\r\n                    this._literal[letter].add(m.literal[letter])\r\n                }\r\n\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    multiplyByNumber = (F: Fraction | number): Monom => {\r\n        this._coefficient.multiply(F);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Divide the current monoms by multiple monoms\r\n     * @param M (Monom[])\r\n     */\r\n    divide = (...M: Monom[]): Monom => {\r\n        // Depending on the given value, choose the current item\r\n        for (let v of M) {\r\n            // Divide the coefficient\r\n            this._coefficient.divide(v.coefficient);\r\n\r\n            // Subtract the power values\r\n            for (let letter in v.literal) {\r\n                this._literal[letter] = (this._literal[letter] === undefined) ? v.literal[letter].clone().opposite() : this._literal[letter].subtract(v.literal[letter])\r\n\r\n                // If the power of a particular setLetter is zero, delete it from the literal part..\r\n                if (this._literal[letter].isZero()) {\r\n                    delete this._literal[letter];\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Get the pow of a monom.\r\n     * @param nb (number) : Mathematical pow\r\n     */\r\n    pow = (nb: number | Fraction): Monom => {\r\n        this._coefficient.pow(nb);\r\n        for (let letter in this._literal) {\r\n            this._literal[letter].multiply(nb)\r\n        }\r\n        return this;\r\n    };\r\n\r\n// ------------------------------------------\r\n// Compare functions\r\n\r\n    /**\r\n     * Get the index-root of the monom\r\n     * @param p\r\n     */\r\n    root = (p: number): Monom => {\r\n        // TODO: determiner the index root of a monom\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Return the square root of a monom\r\n     */\r\n    sqrt = (): Monom => {\r\n        if (this.isSquare()) {\r\n            this._coefficient.sqrt();\r\n            for (let letter in this._literal) {\r\n                this._literal[letter].clone().divide(2)\r\n            }\r\n        }\r\n        return this.root(2);\r\n    }\r\n\r\n// ------------------------------------------\r\n    compare = (M: Monom, sign?: COMPARESIGNS): boolean => {\r\n        // TODO: Build the compare systems.\r\n        if (sign === undefined) {\r\n            sign = COMPARESIGNS.EQUALS;\r\n        }\r\n\r\n\r\n        switch (sign) {\r\n            case COMPARESIGNS.EQUALS:\r\n                // To be equal, they must be the isSame\r\n                if (!this.compare(M, COMPARESIGNS.SAME)) {\r\n                    return false;\r\n                }\r\n\r\n                // The literal parts are the isSame. The coefficient must be equal\r\n                return this._coefficient.isEqualTo(M.coefficient);\r\n            case COMPARESIGNS.SAME:\r\n                // Get the list of all variables from both monoms.\r\n                let M1: string[] = this.variables,\r\n                    M2: string[] = M.variables,\r\n                    K: string[] = M1.concat(M2.filter((item) => M1.indexOf(item) < 0));\r\n\r\n                if (M1.length === 0 && M2.length === 0) {\r\n                    return true\r\n                }\r\n                // To compare, both must be different than zero.\r\n                if (!this.isZero() && !M.isZero()) {\r\n                    for (let key of K) {\r\n                        // The setLetter is not available in one of the monom\r\n                        if (this._literal[key] === undefined || M.literal[key] === undefined) {\r\n                            return false;\r\n                        }\r\n                        // The setLetter does not have the isSame power in each monoms.\r\n                        if (!this._literal[key].isEqualTo(M.literal[key])) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // All are positive check - the monoms are the sames.\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is null\r\n     */\r\n    isZero()\r\n        :\r\n        boolean {\r\n        return this._coefficient.value === 0;\r\n    }\r\n\r\n    /**\r\n     * Determine if the monom is one\r\n     */\r\n    isOne()\r\n        :\r\n        boolean {\r\n        return this._coefficient.value === 1 && this.variables.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Determine if two monoms are equals\r\n     * @param M\r\n     */\r\n    isEqual = (M: Monom): boolean => {\r\n        return this.compare(M, COMPARESIGNS.EQUALS);\r\n    };\r\n\r\n    /**\r\n     * Determine if two monoms are similar\r\n     * @param M\r\n     */\r\n    isSameAs = (M: Monom): boolean => {\r\n        return this.compare(M, COMPARESIGNS.SAME);\r\n    };\r\n\r\n    isSquare = (): boolean => {\r\n        if (!this.coefficient.isSquare()) {\r\n            return false;\r\n        }\r\n        return this.isLiteralSquare();\r\n    }\r\n// ------------------------------------------\r\n// Misc monoms functions\r\n\r\n    isLiteralSquare = (): boolean => {\r\n        for (let letter in this.literal) {\r\n            // A literal square must have a natural power\r\n            if (this.literal[letter].isRational()) {\r\n                return false\r\n            }\r\n\r\n            // The natural power must be be even\r\n            if (this.literal[letter].isEven()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    hasFractionCoefficient = (): boolean => {\r\n        for (let letter in this._literal) {\r\n            if (this._literal[letter].isRational()) {\r\n                return true\r\n            }\r\n        }\r\n\r\n        return false\r\n    }\r\n\r\n// -------------------------------------\r\n    /**\r\n     * Determine if a monom contains a setLetter in it's literal part\r\n     * @param letter\r\n     */\r\n    hasLetter = (letter?: string): boolean => {\r\n        // The letter was not found\r\n        if (this._literal[letter === undefined ? 'x' : letter] === undefined) {\r\n            return false\r\n        }\r\n\r\n        // The letter is found and is not zero !\r\n        return !this._literal[letter === undefined ? 'x' : letter].isZero();\r\n    };\r\n\r\n    /**\r\n     * Set the power of a particular setLetter\r\n     * @param letter (string) Letter to change\r\n     * @param pow (number) Power of the setLetter (must be positive integer.\r\n     */\r\n    setLetter = (letter: string, pow: CoefficientCore<any> | number): void => {\r\n        if (pow instanceof CoefficientCore) {\r\n            // Set the power of the letter to zero => remove it\r\n            if (this.hasLetter(letter) && pow.isZero()) {\r\n                delete this._literal[letter]\r\n            }\r\n\r\n            this._literal[letter] = pow.clone()\r\n        } else {\r\n            this.setLetter(letter, this.makeCoefficient(pow))\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Get the degree of a monom. If no setLetter is given, the result will be the global degree.\r\n     * @param letter (string) Letter to get to degree (power)\r\n     */\r\n    degree = (letter?: string): CoefficientTypes => {\r\n        if (this.variables.length === 0) {\r\n            return this.makeCoefficient().zero();\r\n        }\r\n        if (letter === undefined) {\r\n            // Not setLetter given -> we get the global monom degree (sum of all the letters).\r\n            return Object.values(this._literal)\r\n                .reduce(\r\n                    (t, n) => t.clone().add(n)\r\n                );\r\n        } else {\r\n            // A setLetter is given -> get the corresponding power.\r\n            return this._literal[letter] === undefined ? this.makeCoefficient().zero() : this._literal[letter].clone();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Evaluate a monom. Each setLetter must be assigned to a Fraction.\r\n     * @param values    Dictionary of <setLetter: Fraction>\r\n     */\r\n    evaluate = (values?: literalType | Fraction | number): CoefficientCore<any> => {\r\n        let r = this.coefficient.clone();\r\n\r\n        if (typeof values === 'number' || values instanceof Fraction) {\r\n            let tmpValues: literalType = {}\r\n            tmpValues[this.variables[0]] = this.makeCoefficient(values)\r\n            return this.evaluate(tmpValues);\r\n        }\r\n\r\n        if (typeof values === 'object') {\r\n            if (this.variables.length === 0) {\r\n                return this.coefficient\r\n            }\r\n            for (let L in this._literal) {\r\n                if (values[L] === undefined) {\r\n                    return this.makeCoefficient().zero();\r\n                }\r\n\r\n                let value = this.makeCoefficient(values[L])\r\n\r\n                r.multiply(value.pow(this._literal[L]))\r\n            }\r\n        }\r\n\r\n        return r;\r\n    };\r\n\r\n    evaluateAsNumeric = (values: { [Key: string]: number } | number): number => {\r\n        let r = this.coefficient.value\r\n\r\n        if (typeof values === 'number') {\r\n            let tmpValues: { [Key: string]: number } = {}\r\n            tmpValues[this.variables[0]] = values\r\n            return this.evaluateAsNumeric(tmpValues);\r\n        }\r\n\r\n        if (typeof values === 'object') {\r\n            if (this.variables.length === 0) {\r\n                return this.coefficient.value\r\n            }\r\n            for (let L in this._literal) {\r\n                if (values[L] === undefined) {\r\n                    return 0;\r\n                }\r\n\r\n                r *= values[L] ** (this._literal[L].value)\r\n            }\r\n        }\r\n\r\n        return r\r\n    }\r\n// ----------------------------------------\r\n// Static functions\r\n// ----------------------------------------\r\n\r\n    /**\r\n     * Derivative the monom\r\n     * @param letter\r\n     */\r\n    derivative = (letter?: string): Monom => {\r\n        // No setLetter given - assume it's the setLetter 'x'\r\n        if (letter === undefined) {\r\n            letter = 'x';\r\n        }\r\n\r\n        if (this.hasLetter(letter)) {\r\n            let d = this._literal[letter].clone(),\r\n                dM = this.clone();\r\n\r\n            // Subtract one to the degree.\r\n            dM._literal[letter].subtract(1)\r\n\r\n            // Multiply the coefficient by the previous degree\r\n            dM._coefficient.multiply(this.makeCoefficient(d.clone()));\r\n            return dM;\r\n        } else {\r\n            return new Monom().zero();\r\n        }\r\n    };\r\n\r\n    primitive = (letter?: string): Monom => {\r\n        // TODO: derivative including the ln value => implies creating different monom system ?\r\n        if (letter === undefined) {\r\n            letter = 'x'\r\n        }\r\n\r\n        // Zero monom\r\n        let M = this.clone(), degree\r\n\r\n        if (M.hasLetter(letter)) {\r\n            degree = M.degree(letter).clone().add(1)\r\n            M.coefficient = M.coefficient.clone().divide(degree)\r\n            M.setLetter(letter, degree)\r\n        } else {\r\n            // There is no letter.\r\n\r\n            // The coefficient might be zero (=> x) or a number a (=> ax)\r\n            if (M.coefficient.isZero()) {\r\n                M.coefficient = this.makeCoefficient().one()\r\n            }\r\n            M.setLetter(letter, 1)\r\n        }\r\n\r\n        return M\r\n    }\r\n\r\n// TODO: The rest of the functions are not used or unnecessary ?\r\n    /**\r\n     * Determine if multiple monoms are similar\r\n     * @param M\r\n     */\r\n    areSameAs = (...M: Monom[]): boolean => {\r\n        let result: boolean = true;\r\n\r\n        // Check all monoms if they are the isSame as the \"this\" one.\r\n        for (let i = 0; i < M.length; i++) {\r\n            if (!this.isSameAs(M[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // All check passed -> all the monoms are similar.\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Determine if multiple monoms are equals\r\n     * @param M\r\n     */\r\n    areEquals = (...M: Monom[]): boolean => {\r\n        // They are not similar.\r\n        if (!this.areSameAs(...M)) {\r\n            return false;\r\n        }\r\n\r\n        // Check all coefficient. They must be equals.\r\n        for (let m of M) {\r\n            if (!this._coefficient.isEqualTo(m.coefficient)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // All checks passed.\r\n        return true;\r\n    };\r\n\r\n    isDivisible = (div: Monom): boolean => {\r\n        // For all variables (letters), the current monom must have a degree higher than the divider\r\n        if (div.degree().isStrictlyPositive()) {\r\n            for (let letter of div.variables) {\r\n                if (!this.degree(letter).isGreaterOrEqualTo(div.degree(letter))) {\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n\r\n        // If the coefficient is rational, we suppose we don't need to check the division by the coefficient.\r\n        if (this.coefficient.isRational() || div.coefficient.isRational()) {\r\n            return true\r\n        }\r\n\r\n        return this.coefficient.clone().divide(div.coefficient).isRelative()\r\n    }\r\n\r\n    isInverted(M\r\n                   :\r\n                   Monom\r\n    ):\r\n        boolean {\r\n        return this.clone().multiply(M).isOne();\r\n    }\r\n\r\n    isNegativeOne()\r\n        :\r\n        boolean {\r\n        return this._coefficient.value === -1 && this.variables.length === 0;\r\n    }\r\n\r\n    isNotEqual(M\r\n                   :\r\n                   Monom\r\n    ):\r\n        boolean {\r\n        return !this.isEqual(M);\r\n    }\r\n\r\n    isNotZero()\r\n        :\r\n        boolean {\r\n        return !this.isZero();\r\n    }\r\n\r\n    isOpposed(M\r\n                  :\r\n                  Monom\r\n    ):\r\n        boolean {\r\n        return this.clone().subtract(M).isZero();\r\n    }\r\n\r\n    isReduced()\r\n        :\r\n        boolean {\r\n        // By construction, it is already reduced (litterals\r\n        return this.coefficient.isReduced();\r\n    }\r\n\r\n    reset()\r\n        :\r\n        any {\r\n        this._coefficient = this.makeCoefficient()\r\n        this._literal = {}\r\n    }\r\n\r\n    _getLiteralDividers(arr: literalType[], letter: string):\r\n        literalType[] {\r\n        let tmpList: { [key: string]: CoefficientTypes }[] = [];\r\n\r\n        // Be default, this.literal[letter] should be a rational number.\r\n        for (let d = 0; d <= this.literal[letter].value; d++) {\r\n            if (arr.length === 0) {\r\n                let litt: literalType = {}\r\n                litt[letter] = this.makeCoefficient(d)\r\n                tmpList.push(litt)\r\n            } else {\r\n                for (let item of arr) {\r\n                    let litt: literalType = {}\r\n                    for (let currentLetter in item) {\r\n                        litt[currentLetter] = item[currentLetter]\r\n                    }\r\n                    litt[letter] = this.makeCoefficient(d)\r\n                    tmpList.push(litt)\r\n                }\r\n            }\r\n        }\r\n        return tmpList;\r\n    }\r\n\r\n    _shutingYardToReducedMonom = (inputStr: string): Monom => {\r\n        // Get the RPN array of the current expression\r\n        const SY: Shutingyard = new Shutingyard().parse(inputStr);\r\n        const rpn: { token: string, tokenType: string }[] = SY.rpn;\r\n\r\n        let stack: Monom[] = []\r\n\r\n        if (rpn.length === 0) {\r\n            this.zero()\r\n            return this\r\n        } else if (rpn.length === 1) {\r\n            const element = rpn[0]\r\n\r\n            this.one()\r\n            if (element.tokenType === 'coefficient') {\r\n                this.coefficient = this.makeCoefficient(element.token)\r\n            } else if (element.tokenType === 'variable') {\r\n                this.setLetter(element.token, 1)\r\n            }\r\n            return this\r\n        } else {\r\n            // Reset the monom\r\n            for (const element of rpn) {\r\n                this.addToken(stack, element)\r\n            }\r\n        }\r\n\r\n        this.one()\r\n        this.multiply(stack[0])\r\n        return this\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/maths/algebra/monom.ts b/src/maths/algebra/monom.ts
--- a/src/maths/algebra/monom.ts	
+++ b/src/maths/algebra/monom.ts	
@@ -1,1113 +1,203 @@
-/***
- * Monom class
- * The monom class represents of monom of the form:
- * k * x^n * y^m * z^p
- * k: Coefficient
- * n, m, p: powers as Fraction
- * x, y, z: letters as string
- */
-import {Numeric} from "../numeric";
-import {Shutingyard, ShutingyardType, Token} from "../shutingyard";
-import {COMPARESIGNS, literalType} from "../types";
-import {RootFraction} from "../coefficients/rootFraction";
 import {
-    COEFFICIENT_MODE,
-    CoefficientCore,
-    CoefficientParserTypes,
-    CoefficientTypes
-} from "../coefficients/coefficientCore";
-import {Fraction} from "../coefficients/fraction";
-
-
-export class Monom {
-    private _coefficientMode: COEFFICIENT_MODE
-
-    /**
-     * Create a Monom
-     * Defined as \\(k \\cdot x^{n}\\), where \\( k,n \in \\mathbb{Q}\\).
-     * Examples: \\(3x^2\\) or \\(3/5x^2\\)
-     * @param value (optional) string The value that should be parse. Can be a Monom, a Fraction, a string or a number. If nothing is provided, it will return the trivial monom (0).
-     */
-    constructor(value?: unknown) {
-        this.zero();
-
-        if (value !== undefined) {
-            // A string is given - try to parse the value.
-            this.parse(value);
-        }
-
-        return this;
-    }
-
-    // ------------------------------------------
-    // Getter and setter
-
-    private _coefficient: CoefficientCore<any>;
-
-    // ------------------------------------------
-    /**
-     * Get the coefficient \\(k\\) of the Monom \\(k\\cdot x^{n}\\)
-     * @returns {Fraction}
-     */
-    get coefficient(): CoefficientCore<any> {
-        return this._coefficient;
-    }
-
-    /**
-     * Set the coefficient \\(k\\) value of the monom
-     * @param {Fraction | number | string} F
-     */
-    set coefficient(F: CoefficientParserTypes) {
-        this._coefficient = this.makeCoefficient(F);
-    }
-
-    private _literal: literalType;
-
-    /**
-     * Get the literal part of \\(x^{n_1}y^{n_2}\\) as dictionary \\[\\begin{array}{ll}x&=n_1\\\\y&=n_2\\end{array}\\]
-     * @returns {literalType}
-     */
-    get literal(): literalType {
-        return this._literal;
-    }
-
-    /**
-     * Set the literal part of the monom. Must be a dictionary {x: Fraction, y: Fraction, ...}
-     * @param {literalType} L
-     */
-    set literal(L: literalType) {
-        this._literal = L;
-    }
+    coreInterface,
+    equalityInterface,
+    expressionElementInterface,
+    expressionInterface,
+    operationInterface
+} from "../types";
+import {Coefficient} from "../coefficients/coefficient";
 
-    /**
-     * Get the literal square roots of the Monom.
-     * TODO: remove this getter ? Is it used and is it correct ?
-     * @returns {literalType}
-     */
-    get literalSqrt(): literalType {
-        if (this.isLiteralSquare()) {
-            let L: literalType = {}
-            for (let key in this._literal) {
-                L[key] = this._literal[key].clone().sqrt()
-            }
-            return L;
-        } else {
-            return this._literal;
-        }
-    }
 
-    /**
-     * Set the literal part of the monom from a string
-     * @param inputStr  String like x^2y^3
-     */
-    set literalStr(inputStr: string) {
-        // TODO : parse using shutingyard tree !
-
-        // Match all x^n
-        for (const v of [...inputStr.matchAll(/([a-z])\^([+-]?[0-9]+)/g)]) {
-            // Create the default letter entry if necessary.
-            if (!(v[1] in this._literal)) {
-                this._literal[v[1]] = this.makeCoefficient().zero();
-            }
+/**
+ * A polynom element is a coefficient with one or more variables and an exponent (which is a power and a root).
+ *
+ */
+export class Monom implements coreInterface, operationInterface, equalityInterface, expressionInterface {
+    constructor(...values: unknown[]) {
 
-            // Add the new value.
-            // TODO: actually, it adds only numeric value
-            this._literal[v[1]].add(+v[2]);
+        if (values.length > 0) {
+            return this.parse(...values)
         }
-
-        // Match all x
-        for (const v of [...inputStr.matchAll(/([a-z](?!\^))/g)]) {
-            // Match all single letters
-            if (!(v[1] in this._literal)) {
-                this._literal[v[1]] = this.makeCoefficient().zero();
-            }
+        return this
+    }
 
-            // Add one to the value.
-            this._literal[v[1]].add(1)
-        }
-    }
+    private _literal: expressionElementInterface = {}
 
-    // Getter helpers.
-    /**
-     * Get the variables letters
-     */
     get variables(): string[] {
-        let M = this.clone().clean();
-        return Object.keys(M.literal)
+        return Object.keys(this._literal).sort()
     }
-
-    // Display getter
-    /**
-     * This display getter is to be used in the polynom display getter
-     */
-    get display(): string {
-        let L: string = '',
-            letters = Object.keys(this._literal).sort()
-        for (let letter of letters) {
-            if (!this._literal[letter].isZero()) {
-                L += `${letter}`;
-                if (!this._literal[letter].isEqualTo(1)) {
-                    L += `^(${this._literal[letter].display})`;
-                }
-            }
-        }
-
-        if (L === '') {
-            // No setLetter - means it's only a number !
-            if (this._coefficient.value != 0) {
-                return `${this._coefficient.display}`;
-            } else {
-                return '';
-            }
-        } else {
-            if (this._coefficient.value === 1) {
-                return L;
-            } else if (this._coefficient.value === -1) {
-                return `-${L}`;
-            } else if (this._coefficient.value === 0) {
-                return '0';
-            } else {
-                return `${this._coefficient.display}${L}`;
-            }
-        }
-    }
-
-    get dividers(): Monom[] {
-        // Decompose only if the coefficient is a natural number
-        if (!this.coefficient.isRelative()) {
-            return [this.clone()]
-        }
-
-
-        // Decompose only if the power values are natural numbers.
-        if (this.hasFractionCoefficient()) {
-            return [this.clone()]
-        }
-
-        // Security : do not do this if isGreaterThan than 10000
-        if (this.coefficient.numerator > 1000000) {
-            return [this.clone()]
-        }
-
-        const dividers = Numeric.dividers(Math.abs(this.coefficient.numerator))
-
-        // Decompose the literals parts.
-        let literals: literalType[] = [];
-        for (let L in this.literal) {
-            // L is the letter.
-            literals = this._getLiteralDividers(literals, L)
-        }
-
-        const monomDividers: Monom[] = [];
-        if (literals.length > 0 && dividers.length > 0) {
-            for (let N of dividers) {
-                for (let L of literals) {
-                    let M = new Monom();
-                    M.coefficient = this.makeCoefficient(N)
-                    M.literal = L
-                    monomDividers.push(M)
-                }
-            }
-        } else if (dividers.length === 0) {
-            for (let L of literals) {
-                let M = new Monom();
-                M.coefficient = this.makeCoefficient().one()
-                M.literal = L
-                monomDividers.push(M)
-            }
-        } else {
-            for (let N of dividers) {
-                let M = new Monom();
-                M.coefficient = this.makeCoefficient(N)
-                monomDividers.push(M)
-            }
-        }
-
-        return monomDividers.length === 0 ? [new Monom().one()] : monomDividers;
-    }
-
-    /**
-     * Display the monom, forcing the '+' sign to appear
-     */
-    get displayWithSign(): string {
-        let d: String = this.display;
-        return (d[0] !== '-' ? '+' : '') + d;
-    }
-
-    get texWithSign(): string {
-        if (this.coefficient.isStrictlyPositive()) {
-            return '+' + this.tex
-        }
-
-        return this.tex
-    }
-
-    get plotFunction(): string {
-
-        let L: string = '',
-            letters = Object.keys(this._literal).sort()
-
-        for (let letter of letters) {
-            if (!this._literal[letter].isZero()) {
-                L += (L === '' ? "" : "*") + `${letter}`
-                if (!this._literal[letter].isEqualTo(1)) {
-                    L += `^(${this._literal[letter].display})`;
-                }
-            }
-        }
-
-        // No literal part
-        if (L === '') {
-            // No setLetter - means it's only a number !
-            if (this._coefficient.value != 0) {
-                return `${this._coefficient.display}`;
-            } else {
-                return '';
-            }
-        } else {
-            if (this._coefficient.value === 1) {
-                return L;
-            } else if (this._coefficient.value === -1) {
-                return `-${L}`;
-            } else if (this._coefficient.value === 0) {
-                return '0';
-            } else {
-                return `${this._coefficient.display}*${L}`;
-            }
-        }
-    }
-
-    // ------------------------------------------
-    // Creation / parsing functions
-
-    /**
-     * Get the tex output of the monom
-     */
-    get tex(): string {
-        // TODO: display with square root !
-        let L: string = '',
-            letters = Object.keys(this._literal).sort()
-
-        for (let letter of letters) {
-            if (!this._literal[letter].isZero()) {
-                L += `${letter}`;
-                if (!this._literal[letter].isEqualTo(1)) {
-                    L += `^{${this._literal[letter].asTopFraction().tex}}`;
-                }
-            }
-        }
-
-        if (L === '') {
-            // No setLetter - means it's only a number !
-            if (this._coefficient.value != 0) {
-                return `${this._coefficient.tex}`;
-            } else {
-                return '0';
-            }
-        } else {
-            if (this._coefficient.value === 1) {
-                return L;
-            } else if (this._coefficient.value === -1) {
-                return `-${L}`;
-            } else if (this._coefficient.value === 0) {
-                return '0';
-            } else {
-                return `${this._coefficient.tex}${L}`;
-            }
-        }
-    }
-
-    /**
-     * Get the least common multiple of monoms
-     * @param monoms    Array of monoms
-     */
-    static lcm = (...monoms: Monom[]): Monom => {
-        // All the monoms must be with natural powers...
-        for (let m of monoms) {
-            if (m.hasFractionCoefficient()) {
-                return new Monom().zero()
-            }
-        }
-
-
-        let M = new Monom(),
-            coeffN: number[] = monoms.map(value => value.coefficient.numerator),
-            coeffD: number[] = monoms.map(value => value.coefficient.denominator),
-            n = Numeric.gcd(...coeffN),
-            d = Numeric.lcm(...coeffD);
-
-        // Get the coefficient.
-        M.coefficient = this.makeCoefficient(n, d).reduce();
-
-        // Set the literal parts - go through each monoms literal parts and get only the lowest degree of each letters.
-        for (let m of monoms) {
-            // Remove the inexistant letters from the resulting monom
-            for (let letter in M.literal) {
-                if (!(letter in m.literal)) {
-                    M.literal[letter].zero();
-                }
-            }
-            for (let letter in m.literal) {
-                if (M.literal[letter] === undefined && m.literal[letter].isStrictlyPositive()) {
-                    M.literal[letter] = m.literal[letter].clone();
-                } else {
-                    M.literal[letter] = this.makeCoefficient(Math.min(m.literal[letter].value, M.literal[letter].value))
-                }
-            }
-        }
-
-        return M;
-    };
-
-    /**
-     * Multiply two monoms and return a NEW monom.
-     * @param monoms
-     */
-    static xmultiply = (...monoms: Monom[]): Monom => {
-        let M = new Monom().one();
-
-        for (let m of monoms) {
-            M.multiply(m);
-        }
 
-        return M;
-    };
-
-    makeCoefficient = (...values: CoefficientParserTypes[]): CoefficientTypes => {
-        if (this._coefficientMode === COEFFICIENT_MODE.FRACTION) {
-            return new Fraction(...values as (Fraction | string | number)[])
-        } else if (this._coefficientMode === COEFFICIENT_MODE.ROOT) {
-            return new RootFraction(...values as (RootFraction | Fraction | string | number)[])
-        }
+    get literal(): expressionElementInterface {
+        return this._literal;
+    }
 
-        // TODO: add the other modes
-        return new Fraction(...values as (Fraction | string | number)[])
+    set literal(value: expressionElementInterface) {
+        this._literal = value;
     }
 
-// -----------------------------------------
-    /**
-     * Parse a string to a monom. The string may include fraction.
-     * @param inputStr
-     */
-    parse = (inputStr: unknown): Monom => {
+    private _coefficient: Coefficient = new Coefficient()
 
-        if (typeof inputStr === 'string') {
-            this._shutingYardToReducedMonom(inputStr)
-        } else if (typeof inputStr === 'number') {
-            this._coefficient = this.makeCoefficient(inputStr)
-            this._literal = {}
-        } else if (inputStr instanceof Fraction) {
-            this._coefficient = inputStr.clone()
-            this._literal = {}
-        } else if (inputStr instanceof RootFraction) {
-            this._coefficient = inputStr.clone()
-            this._literal = {}
-        } else if (inputStr instanceof Monom) {
-            this._coefficient = inputStr._coefficient.clone()
-            this._literal = this.copyLiterals(inputStr.literal)
-        }
+    get coefficient(): Coefficient {
+        return this._coefficient;
+    }
 
-        return this;
-    };
-
-    addToken = (stack: Monom[], element: Token): void => {
-
-        let q1: Monom, q2: Monom, m: Monom, letter: string, pow: CoefficientCore<any>
-
-        if (element.tokenType === ShutingyardType.COEFFICIENT) {
-            stack.push(new Monom(this.makeCoefficient(element.token)))
-
-        } else if (element.tokenType === ShutingyardType.VARIABLE) {
-            let M = new Monom().one()
-            M.setLetter(element.token, 1)
-            stack.push(M.clone())
-
-        } else if (element.tokenType === ShutingyardType.OPERATION) {
-            switch (element.token) {
-                case '-':
-                    // this should only happen for negative powers or for negative coefficient.
-                    q2 = (stack.pop()) || new Monom().zero()
-                    q1 = (stack.pop()) || new Monom().zero()
-
-                    stack.push(q1.subtract(q2))
-
-                    break;
-                case '*':
-                    // Get the last element in the stack
-                    q2 = (stack.pop()) || new Monom().one()
-                    q1 = (stack.pop()) || new Monom().one()
-
-                    stack.push(q1.multiply(q2))
-                    break
-                case '/':
-                    // Get the last element in the stack
-                    q2 = (stack.pop()) || new Monom().one()
-                    q1 = (stack.pop()) || new Monom().one()
-
-                    stack.push(q1.divide(q2))
-                    break
-                case '^':
-                    // get the two last elements in the stack
-                    pow = (stack.pop().coefficient) || this.makeCoefficient().one()
-                    m = (stack.pop()) || new Monom().one()
-
-                    letter = m.variables[0]
-
-                    if (letter !== undefined) {
-                        m.setLetter(letter, pow)
-                    }
-
-                    stack.push(m)
-                    // this.multiply(m.clone())
-                    break
-            }
-        }
+    set coefficient(value: Coefficient) {
+        this._coefficient = value;
     }
 
-    /**
-     * Clone the current Monom.
-     */
-    clone = (): Monom => {
-        let F: Monom = new Monom();
+    add(...values: Monom[]): this {
+        if (values.length === 0) return this
 
-        F.coefficient = this._coefficient.clone();
-
-        // Copy the literal parts.
-        for (let k in this._literal) {
-            F.setLetter(k, this._literal[k].clone());
+        // Check that all the monoms are similar.
+        if (!values.every(x => this.isSimilarTo(x))) {
+            throw new Error('The monoms are not similar.')
         }
-        return F;
-    };
 
-    copyLiterals = (literal: literalType): literalType => {
-        let L: literalType = {}
+        // Add the coefficients.
+        this._coefficient.add(...values.map(x => x.coefficient))
 
-        for (let k in literal) {
-            L[k] = literal[k].clone()
-        }
-        return L
-    }
-
-    makeSame = (M: Monom): Monom => {
-        // Copy the literal parts.
-        for (let k in M._literal) {
-            this.setLetter(k, M._literal[k].clone());
-        }
         return this
     }
 
-    /**
-     * Create a zero value monom
-     */
-    zero = (): Monom => {
-        this._coefficient = this.makeCoefficient().zero();
-        this._literal = {};
-        return this;
-    };
-
-    /**
-     * Create a one value monom
-     */
-    one = (): Monom => {
-        this._coefficient = this.makeCoefficient().one();
-        this._literal = {};
-        return this;
-    };
-
-// ------------------------------------------
-// Mathematical operations
-// ------------------------------------------
-
-    /**
-     * Clean the monom by removing each letters with a power of zero.
-     */
-    clean = (): Monom => {
-        for (let letter in this._literal) {
-            if (this._literal[letter].isZero()) {
-                delete this._literal[letter];
-            }
-        }
-        return this;
-    };
+    subtract(...values: Monom[]): this {
+        return this.add(...values.map(x => x.opposite()))
+    }
 
-    reduce = (): Monom => {
-        this.clean()
-        this.coefficient.reduce()
+    multiply(...values: Monom[]): this {
         return this
     }
 
-    /**
-     * Get the opposite
-     * Returns a monom.
-     */
-    opposed = (): Monom => {
-        this._coefficient.opposite();
-        return this;
-    };
-
-    /**
-     * Add all similar monoms. If they aren't similar, they are simply skipped.
-     * @param M (Monom[]) The monoms to add.
-     */
-    add = (...M: Monom[]): Monom => {
-        for (let m of M) {
-            if (this.isSameAs(m)) {
-                if (this.isZero()) {
-                    this.makeSame(m)
-                }
-                this._coefficient.add(m.coefficient);
-            } else {
-                console.log('Add monom: ' + this.display + ' is not similar with ', m.display);
-            }
-        }
-        return this;
-    };
+    divide(value: Monom): this {
+        return this
+    }
 
-    /**
-     * Subtract multiple monoms
-     * @param M (Monom[]) The monoms to subtract
-     */
-    subtract = (...M: Monom[]): Monom => {
-        for (let m of M) {
-            if (this.isSameAs(m)) {
-                if (this.isZero()) {
-                    this.makeSame(m)
-                }
-                this._coefficient.add(m.clone().coefficient.opposite());
-            } else {
-                console.log('Subtract: Is not similar: ', m.display);
-            }
-        }
-        return this;
-    };
-
-    /**
-     * Multiple multiple monoms to the current monom
-     * @param M (Monom[]) The monoms to multiply to.
-     */
-    multiply = (...M: Monom[]): Monom => {
-        for (let m of M) {
-            // Multiply the coefficient.
-            this._coefficient.multiply(m.coefficient);
+    opposite(): this {
+        this._coefficient.opposite()
+        return this
+    }
 
-            // Multiply the literal parts.
-            for (let letter in m.literal) {
-                if (this._literal[letter] === undefined) {
-                    this._literal[letter] = m.literal[letter].clone()
-                } else {
-                    this._literal[letter].add(m.literal[letter])
-                }
+    invert(): this {
+        return this
+    }
 
-            }
-        }
-        return this;
-    };
+    pow(value: number): this {
+        return this
+    }
 
-    multiplyByNumber = (F: Fraction | number): Monom => {
-        this._coefficient.multiply(F);
-        return this;
+    root(value: number): this {
+        return this
     }
 
-    /**
-     * Divide the current monoms by multiple monoms
-     * @param M (Monom[])
-     */
-    divide = (...M: Monom[]): Monom => {
-        // Depending on the given value, choose the current item
-        for (let v of M) {
-            // Divide the coefficient
-            this._coefficient.divide(v.coefficient);
-
-            // Subtract the power values
-            for (let letter in v.literal) {
-                this._literal[letter] = (this._literal[letter] === undefined) ? v.literal[letter].clone().opposite() : this._literal[letter].subtract(v.literal[letter])
-
-                // If the power of a particular setLetter is zero, delete it from the literal part..
-                if (this._literal[letter].isZero()) {
-                    delete this._literal[letter];
-                }
-            }
-        }
-        return this;
-    };
+    reduce(): this {
+        return this
+    }
 
-    /**
-     * Get the pow of a monom.
-     * @param nb (number) : Mathematical pow
-     */
-    pow = (nb: number | Fraction): Monom => {
-        this._coefficient.pow(nb);
-        for (let letter in this._literal) {
-            this._literal[letter].multiply(nb)
-        }
-        return this;
-    };
+    isSimilarTo(value: Monom): boolean {
+        // To be similar, the variables must be similar.
+        // The coefficient can be different.
 
-// ------------------------------------------
-// Compare functions
+        // They must have the same number of variables.
+        if (this.variables.length !== (value as Monom).variables.length) return false
 
-    /**
-     * Get the index-root of the monom
-     * @param p
-     */
-    root = (p: number): Monom => {
-        // TODO: determiner the index root of a monom
-        return this;
-    }
-
-    /**
-     * Return the square root of a monom
-     */
-    sqrt = (): Monom => {
-        if (this.isSquare()) {
-            this._coefficient.sqrt();
-            for (let letter in this._literal) {
-                this._literal[letter].clone().divide(2)
-            }
-        }
-        return this.root(2);
-    }
+        // They must have the same variables.
+        if (this.variables.every(x => (value as Monom).variables.includes(x))) return false
 
-// ------------------------------------------
-    compare = (M: Monom, sign?: COMPARESIGNS): boolean => {
-        // TODO: Build the compare systems.
-        if (sign === undefined) {
-            sign = COMPARESIGNS.EQUALS;
-        }
-
-
-        switch (sign) {
-            case COMPARESIGNS.EQUALS:
-                // To be equal, they must be the isSame
-                if (!this.compare(M, COMPARESIGNS.SAME)) {
-                    return false;
-                }
-
-                // The literal parts are the isSame. The coefficient must be equal
-                return this._coefficient.isEqualTo(M.coefficient);
-            case COMPARESIGNS.SAME:
-                // Get the list of all variables from both monoms.
-                let M1: string[] = this.variables,
-                    M2: string[] = M.variables,
-                    K: string[] = M1.concat(M2.filter((item) => M1.indexOf(item) < 0));
-
-                if (M1.length === 0 && M2.length === 0) {
-                    return true
-                }
-                // To compare, both must be different than zero.
-                if (!this.isZero() && !M.isZero()) {
-                    for (let key of K) {
-                        // The setLetter is not available in one of the monom
-                        if (this._literal[key] === undefined || M.literal[key] === undefined) {
-                            return false;
-                        }
-                        // The setLetter does not have the isSame power in each monoms.
-                        if (!this._literal[key].isEqualTo(M.literal[key])) {
-                            return false;
-                        }
-                    }
-                }
-
-                // All are positive check - the monoms are the sames.
-                return true;
-            default:
-                return false;
-        }
+        return true
     }
-
-    /**
-     * Determine if the monom is null
-     */
-    isZero()
-        :
-        boolean {
-        return this._coefficient.value === 0;
-    }
-
-    /**
-     * Determine if the monom is one
-     */
-    isOne()
-        :
-        boolean {
-        return this._coefficient.value === 1 && this.variables.length === 0;
-    }
-
-    /**
-     * Determine if two monoms are equals
-     * @param M
-     */
-    isEqual = (M: Monom): boolean => {
-        return this.compare(M, COMPARESIGNS.EQUALS);
-    };
 
-    /**
-     * Determine if two monoms are similar
-     * @param M
-     */
-    isSameAs = (M: Monom): boolean => {
-        return this.compare(M, COMPARESIGNS.SAME);
-    };
-
-    isSquare = (): boolean => {
-        if (!this.coefficient.isSquare()) {
-            return false;
-        }
-        return this.isLiteralSquare();
-    }
-// ------------------------------------------
-// Misc monoms functions
-
-    isLiteralSquare = (): boolean => {
-        for (let letter in this.literal) {
-            // A literal square must have a natural power
-            if (this.literal[letter].isRational()) {
-                return false
-            }
+    isEqualTo(value: unknown): boolean {
+        return false
+    }
 
-            // The natural power must be be even
-            if (this.literal[letter].isEven()) {
-                return false;
-            }
-        }
-
-        return true;
-    }
-
-    hasFractionCoefficient = (): boolean => {
-        for (let letter in this._literal) {
-            if (this._literal[letter].isRational()) {
-                return true
-            }
-        }
-
+    isReduced(): boolean {
         return false
     }
 
-// -------------------------------------
-    /**
-     * Determine if a monom contains a setLetter in it's literal part
-     * @param letter
-     */
-    hasLetter = (letter?: string): boolean => {
-        // The letter was not found
-        if (this._literal[letter === undefined ? 'x' : letter] === undefined) {
-            return false
-        }
+    isOne(): boolean {
+        return false
+    }
 
-        // The letter is found and is not zero !
-        return !this._literal[letter === undefined ? 'x' : letter].isZero();
-    };
-
-    /**
-     * Set the power of a particular setLetter
-     * @param letter (string) Letter to change
-     * @param pow (number) Power of the setLetter (must be positive integer.
-     */
-    setLetter = (letter: string, pow: CoefficientCore<any> | number): void => {
-        if (pow instanceof CoefficientCore) {
-            // Set the power of the letter to zero => remove it
-            if (this.hasLetter(letter) && pow.isZero()) {
-                delete this._literal[letter]
-            }
-
-            this._literal[letter] = pow.clone()
-        } else {
-            this.setLetter(letter, this.makeCoefficient(pow))
-        }
-    };
-
-    /**
-     * Get the degree of a monom. If no setLetter is given, the result will be the global degree.
-     * @param letter (string) Letter to get to degree (power)
-     */
-    degree = (letter?: string): CoefficientTypes => {
-        if (this.variables.length === 0) {
-            return this.makeCoefficient().zero();
-        }
-        if (letter === undefined) {
-            // Not setLetter given -> we get the global monom degree (sum of all the letters).
-            return Object.values(this._literal)
-                .reduce(
-                    (t, n) => t.clone().add(n)
-                );
-        } else {
-            // A setLetter is given -> get the corresponding power.
-            return this._literal[letter] === undefined ? this.makeCoefficient().zero() : this._literal[letter].clone();
-        }
-    };
-
-    /**
-     * Evaluate a monom. Each setLetter must be assigned to a Fraction.
-     * @param values    Dictionary of <setLetter: Fraction>
-     */
-    evaluate = (values?: literalType | Fraction | number): CoefficientCore<any> => {
-        let r = this.coefficient.clone();
-
-        if (typeof values === 'number' || values instanceof Fraction) {
-            let tmpValues: literalType = {}
-            tmpValues[this.variables[0]] = this.makeCoefficient(values)
-            return this.evaluate(tmpValues);
-        }
-
-        if (typeof values === 'object') {
-            if (this.variables.length === 0) {
-                return this.coefficient
-            }
-            for (let L in this._literal) {
-                if (values[L] === undefined) {
-                    return this.makeCoefficient().zero();
-                }
-
-                let value = this.makeCoefficient(values[L])
-
-                r.multiply(value.pow(this._literal[L]))
-            }
-        }
-
-        return r;
-    };
-
-    evaluateAsNumeric = (values: { [Key: string]: number } | number): number => {
-        let r = this.coefficient.value
-
-        if (typeof values === 'number') {
-            let tmpValues: { [Key: string]: number } = {}
-            tmpValues[this.variables[0]] = values
-            return this.evaluateAsNumeric(tmpValues);
-        }
-
-        if (typeof values === 'object') {
-            if (this.variables.length === 0) {
-                return this.coefficient.value
-            }
-            for (let L in this._literal) {
-                if (values[L] === undefined) {
-                    return 0;
-                }
-
-                r *= values[L] ** (this._literal[L].value)
-            }
-        }
-
-        return r
-    }
-// ----------------------------------------
-// Static functions
-// ----------------------------------------
-
-    /**
-     * Derivative the monom
-     * @param letter
-     */
-    derivative = (letter?: string): Monom => {
-        // No setLetter given - assume it's the setLetter 'x'
-        if (letter === undefined) {
-            letter = 'x';
-        }
-
-        if (this.hasLetter(letter)) {
-            let d = this._literal[letter].clone(),
-                dM = this.clone();
-
-            // Subtract one to the degree.
-            dM._literal[letter].subtract(1)
-
-            // Multiply the coefficient by the previous degree
-            dM._coefficient.multiply(this.makeCoefficient(d.clone()));
-            return dM;
-        } else {
-            return new Monom().zero();
-        }
-    };
-
-    primitive = (letter?: string): Monom => {
-        // TODO: derivative including the ln value => implies creating different monom system ?
-        if (letter === undefined) {
-            letter = 'x'
-        }
-
-        // Zero monom
-        let M = this.clone(), degree
-
-        if (M.hasLetter(letter)) {
-            degree = M.degree(letter).clone().add(1)
-            M.coefficient = M.coefficient.clone().divide(degree)
-            M.setLetter(letter, degree)
-        } else {
-            // There is no letter.
-
-            // The coefficient might be zero (=> x) or a number a (=> ax)
-            if (M.coefficient.isZero()) {
-                M.coefficient = this.makeCoefficient().one()
-            }
-            M.setLetter(letter, 1)
-        }
-
-        return M
-    }
-
-// TODO: The rest of the functions are not used or unnecessary ?
-    /**
-     * Determine if multiple monoms are similar
-     * @param M
-     */
-    areSameAs = (...M: Monom[]): boolean => {
-        let result: boolean = true;
-
-        // Check all monoms if they are the isSame as the "this" one.
-        for (let i = 0; i < M.length; i++) {
-            if (!this.isSameAs(M[i])) {
-                return false;
-            }
-        }
-
-        // All check passed -> all the monoms are similar.
-        return result;
-    };
-
-    /**
-     * Determine if multiple monoms are equals
-     * @param M
-     */
-    areEquals = (...M: Monom[]): boolean => {
-        // They are not similar.
-        if (!this.areSameAs(...M)) {
-            return false;
-        }
-
-        // Check all coefficient. They must be equals.
-        for (let m of M) {
-            if (!this._coefficient.isEqualTo(m.coefficient)) {
-                return false;
-            }
-        }
-
-        // All checks passed.
-        return true;
-    };
-
-    isDivisible = (div: Monom): boolean => {
-        // For all variables (letters), the current monom must have a degree higher than the divider
-        if (div.degree().isStrictlyPositive()) {
-            for (let letter of div.variables) {
-                if (!this.degree(letter).isGreaterOrEqualTo(div.degree(letter))) {
-                    return false
-                }
-            }
-        }
-
-        // If the coefficient is rational, we suppose we don't need to check the division by the coefficient.
-        if (this.coefficient.isRational() || div.coefficient.isRational()) {
-            return true
-        }
-
-        return this.coefficient.clone().divide(div.coefficient).isRelative()
+    isMinusOne(): boolean {
+        return false
     }
-
-    isInverted(M
-                   :
-                   Monom
-    ):
-        boolean {
-        return this.clone().multiply(M).isOne();
-    }
-
-    isNegativeOne()
-        :
-        boolean {
-        return this._coefficient.value === -1 && this.variables.length === 0;
-    }
 
-    isNotEqual(M
-                   :
-                   Monom
-    ):
-        boolean {
-        return !this.isEqual(M);
+    isUnit(): boolean {
+        return false
     }
 
-    isNotZero()
-        :
-        boolean {
-        return !this.isZero();
+    isZero(): boolean {
+        return false
     }
 
-    isOpposed(M
-                  :
-                  Monom
-    ):
-        boolean {
-        return this.clone().subtract(M).isZero();
-    }
-
-    isReduced()
-        :
-        boolean {
-        // By construction, it is already reduced (litterals
-        return this.coefficient.isReduced();
-    }
-
-    reset()
-        :
-        any {
-        this._coefficient = this.makeCoefficient()
+    private reset() {
+        this._coefficient = new Coefficient().zero()
         this._literal = {}
     }
 
-    _getLiteralDividers(arr: literalType[], letter: string):
-        literalType[] {
-        let tmpList: { [key: string]: CoefficientTypes }[] = [];
+    private parse(...values: unknown[]): Monom {
+        this.reset()
+
+        // Parse the values.
+        if (values.length === 1) {
+            if (values[0] instanceof Monom) {
+                return values[0].clone()
+            }
+
+            if (typeof values[0] === "string") {
+                // Parse the string to get the coefficient and the literal.
+            }
+
+            if (typeof values[0] === "number") {
+                // Parse the number to get the coefficient and the literal.
+                this._coefficient = new Coefficient(values[0])
+                return this
+            }
+        }
+
+        return this;
+    }
+
+    clone(): Monom {
+
+        const m = new Monom()
 
-        // Be default, this.literal[letter] should be a rational number.
-        for (let d = 0; d <= this.literal[letter].value; d++) {
-            if (arr.length === 0) {
-                let litt: literalType = {}
-                litt[letter] = this.makeCoefficient(d)
-                tmpList.push(litt)
+        m.coefficient = this.coefficient.clone()
+        for (let v of this.variables) {
+            m.literal[v] = this.literal[v]
+        }
+
+        return m
+    }
+
+    get tex(): string {
+        if (this.coefficient.length === 0) return "0"
+
+        let result = this.coefficient.length > 1 ? `\\left(${this.coefficient.tex}\\right)` : `${this.coefficient.tex}`
+
+        // TODO: handle negative exponent and root.
+        for (let v of this.variables) {
+            if (this.literal[v].exponent === 1) {
+                result += v
             } else {
-                for (let item of arr) {
-                    let litt: literalType = {}
-                    for (let currentLetter in item) {
-                        litt[currentLetter] = item[currentLetter]
-                    }
-                    litt[letter] = this.makeCoefficient(d)
-                    tmpList.push(litt)
-                }
+                result += `${v}^{ ${this.literal[v].exponent} }`
             }
         }
-        return tmpList;
+        return result
     }
 
-    _shutingYardToReducedMonom = (inputStr: string): Monom => {
-        // Get the RPN array of the current expression
-        const SY: Shutingyard = new Shutingyard().parse(inputStr);
-        const rpn: { token: string, tokenType: string }[] = SY.rpn;
-
-        let stack: Monom[] = []
+    get display(): string {
+        if (this.coefficient.length === 0) return "0"
 
-        if (rpn.length === 0) {
-            this.zero()
-            return this
-        } else if (rpn.length === 1) {
-            const element = rpn[0]
+        let result = this.coefficient.length > 1 ? `(${this.coefficient.display})` : `${this.coefficient.display}`
 
-            this.one()
-            if (element.tokenType === 'coefficient') {
-                this.coefficient = this.makeCoefficient(element.token)
-            } else if (element.tokenType === 'variable') {
-                this.setLetter(element.token, 1)
-            }
-            return this
-        } else {
-            // Reset the monom
-            for (const element of rpn) {
-                this.addToken(stack, element)
+        // TODO: handle negative exponent and root.
+        for (let v of this.variables) {
+            if (this.literal[v].exponent === 1) {
+                result += v
+            } else {
+                result += `${v}^{${this.literal[v].exponent}}`
             }
         }
-
-        this.one()
-        this.multiply(stack[0])
-        return this
+        return result
     }
-}
+}
\ No newline at end of file
Index: src/maths/coefficients/coefficientCore.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {Fraction} from \"./fraction\";\r\nimport {RootFraction} from \"./rootFraction\";\r\nimport {Numeric} from \"../numeric\";\r\n\r\n\r\nexport type CoefficientTypes = Fraction | RootFraction\r\nexport type CoefficientParserTypes = CoefficientTypes | number | string\r\n\r\nexport enum COEFFICIENT_MODE {\r\n    \"FRACTION\",\r\n    \"ROOT\",\r\n    \"RADIAN\",\r\n    \"COMPLEX\"\r\n}\r\n\r\nexport enum FRACTION_FRAC {\r\n    \"frac\",\r\n    \"dfrac\",\r\n    \"tfrac\",\r\n}\r\n\r\nexport abstract class CoefficientCore<T extends CoefficientTypes> {\r\n    private _fracType: FRACTION_FRAC\r\n\r\n    get fracType(): FRACTION_FRAC {\r\n        return this._fracType;\r\n    }\r\n\r\n    set fracType(value: FRACTION_FRAC) {\r\n        this._fracType = value;\r\n    }\r\n\r\n    private _numerator: number\r\n\r\n    get numerator(): number {\r\n        return this._numerator;\r\n    }\r\n\r\n    set numerator(value: number) {\r\n        this._numerator = value;\r\n    }\r\n\r\n    private _denominator: number\r\n\r\n    get denominator(): number {\r\n        return this._denominator;\r\n    }\r\n\r\n    set denominator(value: number) {\r\n        this._denominator = value;\r\n    }\r\n\r\n    get value(): number {\r\n        return this._numerator / this._denominator\r\n    }\r\n\r\n    get sign(): number {\r\n        return (this.numerator * this.denominator >= 0) ? 1 : -1;\r\n    };\r\n\r\n    get signTeX(): string {\r\n        return this.sign === 1 ? '+' : '-'\r\n    }\r\n\r\n    get fracTeX(): string {\r\n        return this._fracType === FRACTION_FRAC.frac ? '\\\\frac' : this._fracType === FRACTION_FRAC.dfrac ? '\\\\dfrac' : '\\\\tfrac'\r\n    }\r\n\r\n    abstract get tex(): string\r\n\r\n    abstract get display(): string\r\n\r\n    static max = <T extends CoefficientTypes>(...values: T[]): T => {\r\n        const [first, ...rest] = values\r\n        return rest.reduce((acc, cur) => acc.isGreaterThan(cur) ? acc : cur, first)\r\n    }\r\n\r\n    static min = <T extends CoefficientTypes>(...values: T[]): T => {\r\n        const [first, ...rest] = values\r\n        return rest.reduce((acc, cur) => acc.isGreaterThan(cur) ? cur : acc, first)\r\n    }\r\n\r\n    static unique = <T extends CoefficientTypes>(values: T[], sort?: boolean): T[] => {\r\n        let uniqueObjects: T[] = [],\r\n            uniqueValues: number[] = []\r\n\r\n        values.forEach((value, index) => {\r\n            if (!uniqueValues.includes(value.value)) {\r\n                uniqueValues.push(value.value)\r\n                uniqueObjects.push(value)\r\n            }\r\n        })\r\n\r\n        if (sort) return CoefficientCore.sort(uniqueObjects)\r\n\r\n        return uniqueObjects\r\n    }\r\n\r\n    static sort = <T extends CoefficientTypes>(values: T[], reverse?: boolean): T[] => {\r\n        let sorted = values.sort((a, b) => a.value - b.value)\r\n\r\n        if (reverse) sorted = sorted.reverse()\r\n\r\n        return sorted\r\n    }\r\n\r\n    abstract createInstance(value?: number | string | T): T\r\n\r\n    abstract clone(): T\r\n\r\n    abstract reduce(): T\r\n\r\n    getReducedCoefficient = (): { N: number, D: number } => {\r\n        if (this.numerator === 1 || this.denominator === 1) return {N: this.numerator, D: this.denominator}\r\n\r\n        let g = Numeric.gcd(this.numerator, this.denominator);\r\n        let [N, D] = [this.numerator, this.denominator]\r\n\r\n        N = N / g;\r\n        D = D / g;\r\n\r\n        if (D < 0) {\r\n            D = -D;\r\n            N = -N;\r\n        }\r\n\r\n        return {N, D}\r\n    };\r\n\r\n    zero = (): T => {\r\n        this.numerator = 0;\r\n        this.denominator = 1;\r\n        return this as unknown as T;\r\n    };\r\n\r\n    one = (): T => {\r\n        this.numerator = 1;\r\n        this.denominator = 1;\r\n        return this as unknown as T;\r\n    };\r\n\r\n    infinite = (): T => {\r\n        this.numerator = Infinity;\r\n        this.denominator = 1;\r\n        return this as unknown as T;\r\n    };\r\n\r\n    invalid = (): T => {\r\n        this.numerator = NaN;\r\n        this.denominator = 1;\r\n        return this as unknown as T\r\n    };\r\n\r\n    abstract add(...coefficients: (T | number | string)[]): T\r\n\r\n    opposite = (): T => {\r\n        this.numerator = -this.numerator;\r\n        return this as unknown as T;\r\n    }\r\n\r\n    subtract = (...coefficients: (T | number | string)[]): T => this.add(...coefficients.map(c => this.createInstance(c).opposite() as T))\r\n\r\n    abstract multiply(...coefficients: (T | number | string)[]): T\r\n\r\n    abstract invert(): T\r\n\r\n    divide = (F: T | number): T => this.multiply(this.createInstance(F).invert() as T);\r\n\r\n    abs = (): T => {\r\n        this.numerator = Math.abs(this.numerator);\r\n        return this as unknown as T;\r\n    }\r\n\r\n    pow = (value: number | CoefficientTypes): T => {\r\n        if (Number.isSafeInteger(value)) {\r\n            const factor = this.clone(),\r\n                abs = Math.abs(value as number)\r\n            for (let i = abs; i <= abs; i++) {\r\n                this.multiply(factor)\r\n            }\r\n\r\n            if ((value as number) < 0) this.invert()\r\n        } else {\r\n            throw new Error('Cannot raise a coefficient to a non-integer power')\r\n        }\r\n        return this as unknown as T\r\n    }\r\n\r\n    abstract root(value: number | CoefficientTypes): T\r\n\r\n    sqrt = (): T => this.root(2)\r\n\r\n    asTopFraction = (): T => {\r\n        this.fracType = FRACTION_FRAC.tfrac\r\n        return this as unknown as T\r\n    }\r\n\r\n    asDisplayFraction = (): T => {\r\n        this.fracType = FRACTION_FRAC.dfrac\r\n        return this as unknown as T\r\n    }\r\n\r\n\r\n    /**\r\n     * All the is* methods without argument\r\n     */\r\n\r\n    isReduced = (): boolean => Math.abs(Numeric.gcd(this._numerator, this._denominator)) === 1\r\n\r\n    isOne = (): boolean => this._numerator === 1 && this._denominator === 1\r\n\r\n    isMinusOne = (): boolean => this._numerator === -1 && this._denominator === 1\r\n\r\n    isUnit = (): boolean => this.isOne() || this.isMinusOne()\r\n\r\n    isZero = (): boolean => this._numerator === 0\r\n\r\n    isFinite = (): boolean => !this.isInfinity() && !this.isNaN()\r\n\r\n    isSquare = (): boolean => Math.sqrt(this._numerator) % 1 === 0 && Math.sqrt(this._denominator) % 1 === 0\r\n\r\n    isNaN = (): boolean => isNaN(this.value)\r\n\r\n    isPositive = (): boolean => this.sign === 1\r\n\r\n    isNegative = (): boolean => this.sign === -1\r\n\r\n    isStrictlyNegative = (): boolean => this.value < 0\r\n\r\n    isStrictlyPositive = (): boolean => this.value > 0\r\n\r\n    isNatural = (): boolean => this.isRelative() && this.isPositive()\r\n\r\n    isRelative = (): boolean => {\r\n        const {N, D} = this.getReducedCoefficient()\r\n        return D === 1\r\n    }\r\n\r\n    isRational = (): boolean => !this.isRelative()\r\n\r\n    isReal = (): boolean => true\r\n\r\n    isComplex = (): boolean => false\r\n\r\n    isInfinity = (): boolean => Math.abs(this.value) === Infinity\r\n\r\n    isEven = (): boolean => this.isRelative() && this.value % 2 === 0\r\n\r\n    isOdd = (): boolean => this.isRelative() && this.value % 2 === 1\r\n\r\n    isApproximative = (): boolean => this._numerator.toString().length >= 15 && this._denominator.toString().length >= 15\r\n\r\n    isExact = (): boolean => !this.isApproximative()\r\n\r\n    isGreaterThan = (than: CoefficientCore<any> | number | string): boolean => this.value > this.createInstance(than as T).value;\r\n\r\n    isSimilarTo = (to: CoefficientCore<any> | number | string): boolean => true;\r\n\r\n    isGreaterOrEqualTo = (than: CoefficientCore<any> | number | string): boolean => this.value >= this.createInstance(than as T).value;\r\n\r\n    isLesserOrEqualTo = (than: CoefficientCore<any> | number | string): boolean => this.value <= this.createInstance(than as T).value;\r\n\r\n    isLesserThan = (than: CoefficientCore<any> | number | string): boolean => this.value < this.createInstance(than as T).value;\r\n\r\n    isEqualTo = (than: CoefficientCore<any> | number | string): boolean => this.value === this.createInstance(than as T).value\r\n\r\n    isOpposedTo = (to: CoefficientCore<any> | number | string): boolean => this.isEqualTo(this.createInstance(to as T).opposite())\r\n\r\n    isInvertedTo = (to: CoefficientCore<any> | number | string): boolean => this.isEqualTo(this.createInstance(to as T).invert())\r\n\r\n}\r\n
===================================================================
diff --git a/src/maths/coefficients/coefficientCore.ts b/src/maths/coefficients/coefficientCore.ts
--- a/src/maths/coefficients/coefficientCore.ts	
+++ b/src/maths/coefficients/coefficientCore.ts	
@@ -1,9 +1,10 @@
 import {Fraction} from "./fraction";
 import {RootFraction} from "./rootFraction";
 import {Numeric} from "../numeric";
+import {Coefficient} from "./coefficient";
 
 
-export type CoefficientTypes = Fraction | RootFraction
+export type CoefficientTypes = Coefficient | Fraction | RootFraction
 export type CoefficientParserTypes = CoefficientTypes | number | string
 
 export enum COEFFICIENT_MODE {
Index: src/maths/types.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {Monom} from \"./algebra/monom\";\r\nimport {Polynom} from \"./algebra/polynom\";\r\nimport {Rational} from \"./algebra/rational\";\r\nimport {CoefficientTypes} from \"./coefficients/coefficientCore\";\r\n\r\ninterface coreInterface {\r\n    parse: (...values: unknown[]) => ThisType<this>,\r\n    clone: () => ThisType<this>,\r\n\r\n    readonly tex: string,\r\n    readonly display: string\r\n}\r\n\r\ninterface operationInterface {\r\n    add: (...values: unknown[]) => ThisType<this>,\r\n    subtract: (...values: unknown[]) => ThisType<this>,\r\n    multiply: (...values: unknown[]) => ThisType<this>,\r\n    divide: (value: unknown) => ThisType<this>,\r\n    opposite: () => ThisType<this>,\r\n    invert: () => ThisType<this>,\r\n    pow: (value: unknown) => ThisType<this>,\r\n    root: (value: unknown) => ThisType<this>,\r\n    reduce: () => ThisType<this>,\r\n}\r\n\r\ninterface compareInterface {\r\n    compare: (value: unknown, sign: COMPARESIGNS) => boolean,\r\n    isEqualTo: (value: unknown) => boolean,\r\n    isReduced: () => boolean,\r\n    isOne: () => boolean,\r\n    isMinusOne: () => boolean,\r\n    isUnit: () => boolean,\r\n    isZero: () => boolean,\r\n}\r\n\r\nexport interface coefficientInterface extends coreInterface, operationInterface, compareInterface {\r\n    isGreaterOrEqualTo: (value: unknown) => boolean,\r\n    isGreaterThan: (value: unknown) => boolean,\r\n    isLesserOrEqualTo: (value: unknown) => boolean,\r\n    isLesserThan: (value: unknown) => boolean,\r\n    isNaN: () => boolean,\r\n    isPositive: () => boolean,\r\n    isNegative: () => boolean,\r\n    isStrictlyNegative: () => boolean,\r\n    isStrictlyPositive: () => boolean,\r\n    isOpposedTo: (value: unknown) => boolean,\r\n    isInvertedTo: (value: unknown) => boolean,\r\n    isNatural: () => boolean,\r\n    isRelative: () => boolean,\r\n    isRational: () => boolean,\r\n    isReal: () => boolean,\r\n    isComplex: () => boolean,\r\n    isInfinity: () => boolean,\r\n    isEven: () => boolean,\r\n    isOdd: () => boolean,\r\n    readonly value: number,\r\n}\r\n\r\nexport interface coefficientStaticTypes {\r\n    average: (...values: unknown[]) => coefficientInterface,\r\n    max: (...values: unknown[]) => coefficientInterface,\r\n    min: (...values: unknown[]) => coefficientInterface,\r\n    sort: (...values: unknown[]) => coefficientInterface[],\r\n    unique: (...values: unknown[]) => coefficientInterface[],\r\n}\r\n\r\nexport interface expressionInterface extends coreInterface, operationInterface, compareInterface {\r\n    // variables getter\r\n    readonly variables: string[],\r\n    hasLetter: (letter?: string) => boolean\r\n\r\n    // Evaluate\r\n    evaluate: (value?: evaluateType) => numericType,\r\n\r\n    // Helpers\r\n    isDivisible?: (value: unknown) => boolean,\r\n}\r\n\r\n\r\nexport type literalType = { [Key: string]: CoefficientTypes }\r\nexport type numericType = number | string | CoefficientTypes\r\nexport type expressionType = Monom | Polynom | Rational\r\nexport type evaluateType = numericType | { [key: string]: numericType }\r\n\r\nexport enum COMPARESIGNS {\r\n    \"EQUALS\" = \"=\",\r\n    \"SAME\" = \"same\",\r\n    \"GREATER\" = \">\",\r\n    \"GEQ\" = \">=\",\r\n    \"LESSER\" = \"<\",\r\n    \"LEQ\" = \"<=\",\r\n    \"DIFFERENT\" = \"<>\"\r\n}
===================================================================
diff --git a/src/maths/types.ts b/src/maths/types.ts
--- a/src/maths/types.ts	
+++ b/src/maths/types.ts	
@@ -1,9 +1,6 @@
-import {Monom} from "./algebra/monom";
-import {Polynom} from "./algebra/polynom";
-import {Rational} from "./algebra/rational";
 import {CoefficientTypes} from "./coefficients/coefficientCore";
 
-interface coreInterface {
+export interface coreInterface {
     parse: (...values: unknown[]) => ThisType<this>,
     clone: () => ThisType<this>,
 
@@ -11,7 +8,7 @@
     readonly display: string
 }
 
-interface operationInterface {
+export interface operationInterface {
     add: (...values: unknown[]) => ThisType<this>,
     subtract: (...values: unknown[]) => ThisType<this>,
     multiply: (...values: unknown[]) => ThisType<this>,
@@ -23,7 +20,7 @@
     reduce: () => ThisType<this>,
 }
 
-interface compareInterface {
+export interface equalityInterface {
     compare: (value: unknown, sign: COMPARESIGNS) => boolean,
     isEqualTo: (value: unknown) => boolean,
     isReduced: () => boolean,
@@ -33,7 +30,7 @@
     isZero: () => boolean,
 }
 
-export interface coefficientInterface extends coreInterface, operationInterface, compareInterface {
+export interface compareInterface {
     isGreaterOrEqualTo: (value: unknown) => boolean,
     isGreaterThan: (value: unknown) => boolean,
     isLesserOrEqualTo: (value: unknown) => boolean,
@@ -56,17 +53,17 @@
     readonly value: number,
 }
 
-export interface coefficientStaticTypes {
-    average: (...values: unknown[]) => coefficientInterface,
-    max: (...values: unknown[]) => coefficientInterface,
-    min: (...values: unknown[]) => coefficientInterface,
-    sort: (...values: unknown[]) => coefficientInterface[],
-    unique: (...values: unknown[]) => coefficientInterface[],
+export interface expressionElementInterface {
+    [name: string]: {
+        exponent: number,
+        root: number,
+    }
 }
 
-export interface expressionInterface extends coreInterface, operationInterface, compareInterface {
+export interface expressionInterface {
     // variables getter
     readonly variables: string[],
+    readonly literal: expressionElementInterface,
     hasLetter: (letter?: string) => boolean
 
     // Evaluate
@@ -79,7 +76,6 @@
 
 export type literalType = { [Key: string]: CoefficientTypes }
 export type numericType = number | string | CoefficientTypes
-export type expressionType = Monom | Polynom | Rational
 export type evaluateType = numericType | { [key: string]: numericType }
 
 export enum COMPARESIGNS {
