import { InputValue, IPiMathObject } from '../pimath.interface';
import { Fraction } from '../coefficients/fraction';

export declare class Vector implements IPiMathObject<Vector> {
    #private;
    constructor(...values: Vector[] | InputValue<Fraction>[]);
    get array(): Fraction[];
    set array(value: Fraction[]);
    get x(): Fraction;
    set x(value: Fraction | number | string);
    get y(): Fraction;
    set y(value: Fraction | number | string);
    get z(): Fraction;
    set z(value: Fraction | number | string);
    get asPoint(): boolean;
    set asPoint(value: boolean);
    get normSquare(): Fraction;
    get norm(): number;
    get tex(): string;
    get display(): string;
    setDimension(value?: number): this;
    get dimension(): number;
    get isNull(): boolean;
    static asTex(...values: string[]): string;
    static asDisplay(...values: string[]): string;
    defineAsPoint(value?: boolean): this;
    parse(...values: Vector[] | InputValue<Fraction>[]): this;
    clone(): Vector;
    copy(): Fraction[];
    zero: () => this;
    one: () => this;
    opposite: () => this;
    add: (V: Vector) => this;
    subtract: (V: Vector) => this;
    unit: () => this;
    middleOf(V1: Vector, V2: Vector): this;
    translate(...values: Fraction[]): this;
    dot: (V: Vector) => Fraction;
    cross(value: Vector): Vector;
    normal: () => this;
    isZero(): boolean;
    isOne(): boolean;
    isEqual: (v: Vector) => boolean;
    isColinearTo: (v: Vector) => boolean;
    isNormalTo: (v: Vector) => boolean;
    multiplyByScalar: (k: InputValue<Fraction>) => this;
    divideByScalar: (k: InputValue<Fraction>) => this;
    simplify: () => this;
    angle: (V: Vector, sharp?: boolean, radian?: boolean) => number;
    fromString: (value: string) => this;
    distanceTo(item: Vector): {
        value: number;
        fraction: Fraction;
        tex: string;
    };
}
