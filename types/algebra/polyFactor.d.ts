import { IAlgebra, IExpression, InputAlgebra, InputValue, IPiMathObject, literalType } from '../pimath.interface';
import { Fraction } from '../coefficients/fraction';
import { Factor } from './factor';
import { Polynom } from './polynom';

export declare class PolyFactor implements IPiMathObject<PolyFactor>, IExpression<PolyFactor>, IAlgebra<PolyFactor> {
    #private;
    constructor(...values: (Factor | InputAlgebra<Polynom> | PolyFactor)[]);
    parse(...values: (Factor | InputAlgebra<Polynom> | PolyFactor)[]): this;
    fromPolynom(polynom: InputAlgebra<Polynom>, letter?: string): this;
    clone(): PolyFactor;
    add(...values: PolyFactor[]): this;
    degree(letter?: string): Fraction;
    derivative(): this;
    develop(): Polynom;
    divide(value: PolyFactor): this;
    evaluate(values: InputValue<Fraction> | literalType<number | Fraction>, asNumeric?: boolean): number | Fraction;
    hasVariable(letter: string): boolean;
    inverse(): this;
    isEqual(value: PolyFactor): boolean;
    isOne(): boolean;
    isZero(): boolean;
    multiply(...values: PolyFactor[]): this;
    one(): this;
    opposite(): this;
    pow(value: number | Fraction): this;
    primitive(): PolyFactor;
    reduce(): this;
    root(value: number): this;
    sort(): this;
    sqrt(): this;
    subtract(...values: PolyFactor[]): this;
    zero(): this;
    static gcd(...values: PolyFactor[]): PolyFactor;
    get factors(): Factor[];
    set factors(value: Factor[]);
    get variables(): string[];
    get asRoot(): this;
    get asPower(): this;
    get numerator(): Factor[];
    get denominator(): Factor[];
    get display(): string;
    get tex(): string;
}
